(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));

  // vendor/topbar.js
  var require_topbar = __commonJS({
    "vendor/topbar.js"(exports, module) {
      (function(window2, document2) {
        "use strict";
        (function() {
          var lastTime = 0;
          var vendors = ["ms", "moz", "webkit", "o"];
          for (var x = 0; x < vendors.length && !window2.requestAnimationFrame; ++x) {
            window2.requestAnimationFrame = window2[vendors[x] + "RequestAnimationFrame"];
            window2.cancelAnimationFrame = window2[vendors[x] + "CancelAnimationFrame"] || window2[vendors[x] + "CancelRequestAnimationFrame"];
          }
          if (!window2.requestAnimationFrame)
            window2.requestAnimationFrame = function(callback, element) {
              var currTime = new Date().getTime();
              var timeToCall = Math.max(0, 16 - (currTime - lastTime));
              var id = window2.setTimeout(function() {
                callback(currTime + timeToCall);
              }, timeToCall);
              lastTime = currTime + timeToCall;
              return id;
            };
          if (!window2.cancelAnimationFrame)
            window2.cancelAnimationFrame = function(id) {
              clearTimeout(id);
            };
        })();
        var canvas, progressTimerId, fadeTimerId, currentProgress, showing, addEvent = function(elem, type, handler) {
          if (elem.addEventListener)
            elem.addEventListener(type, handler, false);
          else if (elem.attachEvent)
            elem.attachEvent("on" + type, handler);
          else
            elem["on" + type] = handler;
        }, options = {
          autoRun: true,
          barThickness: 3,
          barColors: {
            0: "rgba(26,  188, 156, .9)",
            ".25": "rgba(52,  152, 219, .9)",
            ".50": "rgba(241, 196, 15,  .9)",
            ".75": "rgba(230, 126, 34,  .9)",
            "1.0": "rgba(211, 84,  0,   .9)"
          },
          shadowBlur: 10,
          shadowColor: "rgba(0,   0,   0,   .6)",
          className: null
        }, repaint = function() {
          canvas.width = window2.innerWidth;
          canvas.height = options.barThickness * 5;
          var ctx = canvas.getContext("2d");
          ctx.shadowBlur = options.shadowBlur;
          ctx.shadowColor = options.shadowColor;
          var lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          for (var stop in options.barColors)
            lineGradient.addColorStop(stop, options.barColors[stop]);
          ctx.lineWidth = options.barThickness;
          ctx.beginPath();
          ctx.moveTo(0, options.barThickness / 2);
          ctx.lineTo(Math.ceil(currentProgress * canvas.width), options.barThickness / 2);
          ctx.strokeStyle = lineGradient;
          ctx.stroke();
        }, createCanvas = function() {
          canvas = document2.createElement("canvas");
          var style = canvas.style;
          style.position = "fixed";
          style.top = style.left = style.right = style.margin = style.padding = 0;
          style.zIndex = 100001;
          style.display = "none";
          if (options.className)
            canvas.classList.add(options.className);
          document2.body.appendChild(canvas);
          addEvent(window2, "resize", repaint);
        }, topbar2 = {
          config: function(opts) {
            for (var key in opts)
              if (options.hasOwnProperty(key))
                options[key] = opts[key];
          },
          show: function() {
            if (showing)
              return;
            showing = true;
            if (fadeTimerId !== null)
              window2.cancelAnimationFrame(fadeTimerId);
            if (!canvas)
              createCanvas();
            canvas.style.opacity = 1;
            canvas.style.display = "block";
            topbar2.progress(0);
            if (options.autoRun) {
              (function loop() {
                progressTimerId = window2.requestAnimationFrame(loop);
                topbar2.progress("+" + 0.05 * Math.pow(1 - Math.sqrt(currentProgress), 2));
              })();
            }
          },
          progress: function(to) {
            if (typeof to === "undefined")
              return currentProgress;
            if (typeof to === "string") {
              to = (to.indexOf("+") >= 0 || to.indexOf("-") >= 0 ? currentProgress : 0) + parseFloat(to);
            }
            currentProgress = to > 1 ? 1 : to;
            repaint();
            return currentProgress;
          },
          hide: function() {
            if (!showing)
              return;
            showing = false;
            if (progressTimerId != null) {
              window2.cancelAnimationFrame(progressTimerId);
              progressTimerId = null;
            }
            (function loop() {
              if (topbar2.progress("+.1") >= 1) {
                canvas.style.opacity -= 0.05;
                if (canvas.style.opacity <= 0.05) {
                  canvas.style.display = "none";
                  fadeTimerId = null;
                  return;
                }
              }
              fadeTimerId = window2.requestAnimationFrame(loop);
            })();
          }
        };
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = topbar2;
        } else if (typeof define === "function" && define.amd) {
          define(function() {
            return topbar2;
          });
        } else {
          this.topbar = topbar2;
        }
      }).call(exports, window, document);
    }
  });

  // ../deps/phoenix_html/priv/static/phoenix_html.js
  (function() {
    var PolyfillEvent = eventConstructor();
    function eventConstructor() {
      if (typeof window.CustomEvent === "function")
        return window.CustomEvent;
      function CustomEvent2(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: void 0 };
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      }
      CustomEvent2.prototype = window.Event.prototype;
      return CustomEvent2;
    }
    function buildHiddenInput(name, value) {
      var input = document.createElement("input");
      input.type = "hidden";
      input.name = name;
      input.value = value;
      return input;
    }
    function handleClick(element, targetModifierKey) {
      var to = element.getAttribute("data-to"), method = buildHiddenInput("_method", element.getAttribute("data-method")), csrf = buildHiddenInput("_csrf_token", element.getAttribute("data-csrf")), form = document.createElement("form"), target = element.getAttribute("target");
      form.method = element.getAttribute("data-method") === "get" ? "get" : "post";
      form.action = to;
      form.style.display = "hidden";
      if (target)
        form.target = target;
      else if (targetModifierKey)
        form.target = "_blank";
      form.appendChild(csrf);
      form.appendChild(method);
      document.body.appendChild(form);
      form.submit();
    }
    window.addEventListener("click", function(e) {
      var element = e.target;
      if (e.defaultPrevented)
        return;
      while (element && element.getAttribute) {
        var phoenixLinkEvent = new PolyfillEvent("phoenix.link.click", {
          "bubbles": true,
          "cancelable": true
        });
        if (!element.dispatchEvent(phoenixLinkEvent)) {
          e.preventDefault();
          e.stopImmediatePropagation();
          return false;
        }
        if (element.getAttribute("data-method")) {
          handleClick(element, e.metaKey || e.shiftKey);
          e.preventDefault();
          return false;
        } else {
          element = element.parentNode;
        }
      }
    }, false);
    window.addEventListener("phoenix.link.click", function(e) {
      var message = e.target.getAttribute("data-confirm");
      if (message && !window.confirm(message)) {
        e.preventDefault();
      }
    }, false);
  })();

  // ../deps/phoenix/priv/static/phoenix.mjs
  var closure = (value) => {
    if (typeof value === "function") {
      return value;
    } else {
      let closure22 = function() {
        return value;
      };
      return closure22;
    }
  };
  var globalSelf = typeof self !== "undefined" ? self : null;
  var phxWindow = typeof window !== "undefined" ? window : null;
  var global = globalSelf || phxWindow || global;
  var DEFAULT_VSN = "2.0.0";
  var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
  var DEFAULT_TIMEOUT = 1e4;
  var WS_CLOSE_NORMAL = 1e3;
  var CHANNEL_STATES = {
    closed: "closed",
    errored: "errored",
    joined: "joined",
    joining: "joining",
    leaving: "leaving"
  };
  var CHANNEL_EVENTS = {
    close: "phx_close",
    error: "phx_error",
    join: "phx_join",
    reply: "phx_reply",
    leave: "phx_leave"
  };
  var TRANSPORTS = {
    longpoll: "longpoll",
    websocket: "websocket"
  };
  var XHR_STATES = {
    complete: 4
  };
  var Push = class {
    constructor(channel, event, payload, timeout) {
      this.channel = channel;
      this.event = event;
      this.payload = payload || function() {
        return {};
      };
      this.receivedResp = null;
      this.timeout = timeout;
      this.timeoutTimer = null;
      this.recHooks = [];
      this.sent = false;
    }
    resend(timeout) {
      this.timeout = timeout;
      this.reset();
      this.send();
    }
    send() {
      if (this.hasReceived("timeout")) {
        return;
      }
      this.startTimeout();
      this.sent = true;
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload(),
        ref: this.ref,
        join_ref: this.channel.joinRef()
      });
    }
    receive(status, callback) {
      if (this.hasReceived(status)) {
        callback(this.receivedResp.response);
      }
      this.recHooks.push({ status, callback });
      return this;
    }
    reset() {
      this.cancelRefEvent();
      this.ref = null;
      this.refEvent = null;
      this.receivedResp = null;
      this.sent = false;
    }
    matchReceive({ status, response, _ref }) {
      this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
    }
    cancelRefEvent() {
      if (!this.refEvent) {
        return;
      }
      this.channel.off(this.refEvent);
    }
    cancelTimeout() {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
    startTimeout() {
      if (this.timeoutTimer) {
        this.cancelTimeout();
      }
      this.ref = this.channel.socket.makeRef();
      this.refEvent = this.channel.replyEventName(this.ref);
      this.channel.on(this.refEvent, (payload) => {
        this.cancelRefEvent();
        this.cancelTimeout();
        this.receivedResp = payload;
        this.matchReceive(payload);
      });
      this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout);
    }
    hasReceived(status) {
      return this.receivedResp && this.receivedResp.status === status;
    }
    trigger(status, response) {
      this.channel.trigger(this.refEvent, { status, response });
    }
  };
  var Timer = class {
    constructor(callback, timerCalc) {
      this.callback = callback;
      this.timerCalc = timerCalc;
      this.timer = null;
      this.tries = 0;
    }
    reset() {
      this.tries = 0;
      clearTimeout(this.timer);
    }
    scheduleTimeout() {
      clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.tries = this.tries + 1;
        this.callback();
      }, this.timerCalc(this.tries + 1));
    }
  };
  var Channel = class {
    constructor(topic, params, socket) {
      this.state = CHANNEL_STATES.closed;
      this.topic = topic;
      this.params = closure(params || {});
      this.socket = socket;
      this.bindings = [];
      this.bindingRef = 0;
      this.timeout = this.socket.timeout;
      this.joinedOnce = false;
      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
      this.pushBuffer = [];
      this.stateChangeRefs = [];
      this.rejoinTimer = new Timer(() => {
        if (this.socket.isConnected()) {
          this.rejoin();
        }
      }, this.socket.rejoinAfterMs);
      this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
      this.stateChangeRefs.push(this.socket.onOpen(() => {
        this.rejoinTimer.reset();
        if (this.isErrored()) {
          this.rejoin();
        }
      }));
      this.joinPush.receive("ok", () => {
        this.state = CHANNEL_STATES.joined;
        this.rejoinTimer.reset();
        this.pushBuffer.forEach((pushEvent) => pushEvent.send());
        this.pushBuffer = [];
      });
      this.joinPush.receive("error", () => {
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.onClose(() => {
        this.rejoinTimer.reset();
        if (this.socket.hasLogger())
          this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
        this.state = CHANNEL_STATES.closed;
        this.socket.remove(this);
      });
      this.onError((reason) => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `error ${this.topic}`, reason);
        if (this.isJoining()) {
          this.joinPush.reset();
        }
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.joinPush.receive("timeout", () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
        leavePush.send();
        this.state = CHANNEL_STATES.errored;
        this.joinPush.reset();
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
        this.trigger(this.replyEventName(ref), payload);
      });
    }
    join(timeout = this.timeout) {
      if (this.joinedOnce) {
        throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
      } else {
        this.timeout = timeout;
        this.joinedOnce = true;
        this.rejoin();
        return this.joinPush;
      }
    }
    onClose(callback) {
      this.on(CHANNEL_EVENTS.close, callback);
    }
    onError(callback) {
      return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));
    }
    on(event, callback) {
      let ref = this.bindingRef++;
      this.bindings.push({ event, ref, callback });
      return ref;
    }
    off(event, ref) {
      this.bindings = this.bindings.filter((bind) => {
        return !(bind.event === event && (typeof ref === "undefined" || ref === bind.ref));
      });
    }
    canPush() {
      return this.socket.isConnected() && this.isJoined();
    }
    push(event, payload, timeout = this.timeout) {
      payload = payload || {};
      if (!this.joinedOnce) {
        throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
      }
      let pushEvent = new Push(this, event, function() {
        return payload;
      }, timeout);
      if (this.canPush()) {
        pushEvent.send();
      } else {
        pushEvent.startTimeout();
        this.pushBuffer.push(pushEvent);
      }
      return pushEvent;
    }
    leave(timeout = this.timeout) {
      this.rejoinTimer.reset();
      this.joinPush.cancelTimeout();
      this.state = CHANNEL_STATES.leaving;
      let onClose = () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `leave ${this.topic}`);
        this.trigger(CHANNEL_EVENTS.close, "leave");
      };
      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
      leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
      leavePush.send();
      if (!this.canPush()) {
        leavePush.trigger("ok", {});
      }
      return leavePush;
    }
    onMessage(_event, payload, _ref) {
      return payload;
    }
    isMember(topic, event, payload, joinRef) {
      if (this.topic !== topic) {
        return false;
      }
      if (joinRef && joinRef !== this.joinRef()) {
        if (this.socket.hasLogger())
          this.socket.log("channel", "dropping outdated message", { topic, event, payload, joinRef });
        return false;
      } else {
        return true;
      }
    }
    joinRef() {
      return this.joinPush.ref;
    }
    rejoin(timeout = this.timeout) {
      if (this.isLeaving()) {
        return;
      }
      this.socket.leaveOpenTopic(this.topic);
      this.state = CHANNEL_STATES.joining;
      this.joinPush.resend(timeout);
    }
    trigger(event, payload, ref, joinRef) {
      let handledPayload = this.onMessage(event, payload, ref, joinRef);
      if (payload && !handledPayload) {
        throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
      }
      let eventBindings = this.bindings.filter((bind) => bind.event === event);
      for (let i = 0; i < eventBindings.length; i++) {
        let bind = eventBindings[i];
        bind.callback(handledPayload, ref, joinRef || this.joinRef());
      }
    }
    replyEventName(ref) {
      return `chan_reply_${ref}`;
    }
    isClosed() {
      return this.state === CHANNEL_STATES.closed;
    }
    isErrored() {
      return this.state === CHANNEL_STATES.errored;
    }
    isJoined() {
      return this.state === CHANNEL_STATES.joined;
    }
    isJoining() {
      return this.state === CHANNEL_STATES.joining;
    }
    isLeaving() {
      return this.state === CHANNEL_STATES.leaving;
    }
  };
  var Ajax = class {
    static request(method, endPoint, accept, body, timeout, ontimeout, callback) {
      if (global.XDomainRequest) {
        let req = new global.XDomainRequest();
        return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);
      } else {
        let req = new global.XMLHttpRequest();
        return this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);
      }
    }
    static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {
      req.timeout = timeout;
      req.open(method, endPoint);
      req.onload = () => {
        let response = this.parseJSON(req.responseText);
        callback && callback(response);
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.onprogress = () => {
      };
      req.send(body);
      return req;
    }
    static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {
      req.open(method, endPoint, true);
      req.timeout = timeout;
      req.setRequestHeader("Content-Type", accept);
      req.onerror = () => callback && callback(null);
      req.onreadystatechange = () => {
        if (req.readyState === XHR_STATES.complete && callback) {
          let response = this.parseJSON(req.responseText);
          callback(response);
        }
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.send(body);
      return req;
    }
    static parseJSON(resp) {
      if (!resp || resp === "") {
        return null;
      }
      try {
        return JSON.parse(resp);
      } catch (e) {
        console && console.log("failed to parse JSON response", resp);
        return null;
      }
    }
    static serialize(obj, parentKey) {
      let queryStr = [];
      for (var key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
          continue;
        }
        let paramKey = parentKey ? `${parentKey}[${key}]` : key;
        let paramVal = obj[key];
        if (typeof paramVal === "object") {
          queryStr.push(this.serialize(paramVal, paramKey));
        } else {
          queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
        }
      }
      return queryStr.join("&");
    }
    static appendParams(url, params) {
      if (Object.keys(params).length === 0) {
        return url;
      }
      let prefix = url.match(/\?/) ? "&" : "?";
      return `${url}${prefix}${this.serialize(params)}`;
    }
  };
  var LongPoll = class {
    constructor(endPoint) {
      this.endPoint = null;
      this.token = null;
      this.skipHeartbeat = true;
      this.reqs = /* @__PURE__ */ new Set();
      this.onopen = function() {
      };
      this.onerror = function() {
      };
      this.onmessage = function() {
      };
      this.onclose = function() {
      };
      this.pollEndpoint = this.normalizeEndpoint(endPoint);
      this.readyState = SOCKET_STATES.connecting;
      this.poll();
    }
    normalizeEndpoint(endPoint) {
      return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
    }
    endpointURL() {
      return Ajax.appendParams(this.pollEndpoint, { token: this.token });
    }
    closeAndRetry(code, reason, wasClean) {
      this.close(code, reason, wasClean);
      this.readyState = SOCKET_STATES.connecting;
    }
    ontimeout() {
      this.onerror("timeout");
      this.closeAndRetry(1005, "timeout", false);
    }
    isActive() {
      return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;
    }
    poll() {
      this.ajax("GET", null, () => this.ontimeout(), (resp) => {
        if (resp) {
          var { status, token, messages } = resp;
          this.token = token;
        } else {
          status = 0;
        }
        switch (status) {
          case 200:
            messages.forEach((msg) => {
              setTimeout(() => this.onmessage({ data: msg }), 0);
            });
            this.poll();
            break;
          case 204:
            this.poll();
            break;
          case 410:
            this.readyState = SOCKET_STATES.open;
            this.onopen({});
            this.poll();
            break;
          case 403:
            this.onerror(403);
            this.close(1008, "forbidden", false);
            break;
          case 0:
          case 500:
            this.onerror(500);
            this.closeAndRetry(1011, "internal server error", 500);
            break;
          default:
            throw new Error(`unhandled poll status ${status}`);
        }
      });
    }
    send(body) {
      this.ajax("POST", body, () => this.onerror("timeout"), (resp) => {
        if (!resp || resp.status !== 200) {
          this.onerror(resp && resp.status);
          this.closeAndRetry(1011, "internal server error", false);
        }
      });
    }
    close(code, reason, wasClean) {
      for (let req of this.reqs) {
        req.abort();
      }
      this.readyState = SOCKET_STATES.closed;
      let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });
      if (typeof CloseEvent !== "undefined") {
        this.onclose(new CloseEvent("close", opts));
      } else {
        this.onclose(opts);
      }
    }
    ajax(method, body, onCallerTimeout, callback) {
      let req;
      let ontimeout = () => {
        this.reqs.delete(req);
        onCallerTimeout();
      };
      req = Ajax.request(method, this.endpointURL(), "application/json", body, this.timeout, ontimeout, (resp) => {
        this.reqs.delete(req);
        if (this.isActive()) {
          callback(resp);
        }
      });
      this.reqs.add(req);
    }
  };
  var serializer_default = {
    HEADER_LENGTH: 1,
    META_LENGTH: 4,
    KINDS: { push: 0, reply: 1, broadcast: 2 },
    encode(msg, callback) {
      if (msg.payload.constructor === ArrayBuffer) {
        return callback(this.binaryEncode(msg));
      } else {
        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
        return callback(JSON.stringify(payload));
      }
    },
    decode(rawPayload, callback) {
      if (rawPayload.constructor === ArrayBuffer) {
        return callback(this.binaryDecode(rawPayload));
      } else {
        let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);
        return callback({ join_ref, ref, topic, event, payload });
      }
    },
    binaryEncode(message) {
      let { join_ref, ref, event, topic, payload } = message;
      let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;
      let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
      let view = new DataView(header);
      let offset = 0;
      view.setUint8(offset++, this.KINDS.push);
      view.setUint8(offset++, join_ref.length);
      view.setUint8(offset++, ref.length);
      view.setUint8(offset++, topic.length);
      view.setUint8(offset++, event.length);
      Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      var combined = new Uint8Array(header.byteLength + payload.byteLength);
      combined.set(new Uint8Array(header), 0);
      combined.set(new Uint8Array(payload), header.byteLength);
      return combined.buffer;
    },
    binaryDecode(buffer) {
      let view = new DataView(buffer);
      let kind = view.getUint8(0);
      let decoder = new TextDecoder();
      switch (kind) {
        case this.KINDS.push:
          return this.decodePush(buffer, view, decoder);
        case this.KINDS.reply:
          return this.decodeReply(buffer, view, decoder);
        case this.KINDS.broadcast:
          return this.decodeBroadcast(buffer, view, decoder);
      }
    },
    decodePush(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let topicSize = view.getUint8(2);
      let eventSize = view.getUint8(3);
      let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: joinRef, ref: null, topic, event, payload: data };
    },
    decodeReply(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let refSize = view.getUint8(2);
      let topicSize = view.getUint8(3);
      let eventSize = view.getUint8(4);
      let offset = this.HEADER_LENGTH + this.META_LENGTH;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let ref = decoder.decode(buffer.slice(offset, offset + refSize));
      offset = offset + refSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      let payload = { status: event, response: data };
      return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
    },
    decodeBroadcast(buffer, view, decoder) {
      let topicSize = view.getUint8(1);
      let eventSize = view.getUint8(2);
      let offset = this.HEADER_LENGTH + 2;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: null, ref: null, topic, event, payload: data };
    }
  };
  var Socket = class {
    constructor(endPoint, opts = {}) {
      this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
      this.channels = [];
      this.sendBuffer = [];
      this.ref = 0;
      this.timeout = opts.timeout || DEFAULT_TIMEOUT;
      this.transport = opts.transport || global.WebSocket || LongPoll;
      this.establishedConnections = 0;
      this.defaultEncoder = serializer_default.encode.bind(serializer_default);
      this.defaultDecoder = serializer_default.decode.bind(serializer_default);
      this.closeWasClean = false;
      this.binaryType = opts.binaryType || "arraybuffer";
      this.connectClock = 1;
      if (this.transport !== LongPoll) {
        this.encode = opts.encode || this.defaultEncoder;
        this.decode = opts.decode || this.defaultDecoder;
      } else {
        this.encode = this.defaultEncoder;
        this.decode = this.defaultDecoder;
      }
      let awaitingConnectionOnPageShow = null;
      if (phxWindow && phxWindow.addEventListener) {
        phxWindow.addEventListener("pagehide", (_e) => {
          if (this.conn) {
            this.disconnect();
            awaitingConnectionOnPageShow = this.connectClock;
          }
        });
        phxWindow.addEventListener("pageshow", (_e) => {
          if (awaitingConnectionOnPageShow === this.connectClock) {
            awaitingConnectionOnPageShow = null;
            this.connect();
          }
        });
      }
      this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
      this.rejoinAfterMs = (tries) => {
        if (opts.rejoinAfterMs) {
          return opts.rejoinAfterMs(tries);
        } else {
          return [1e3, 2e3, 5e3][tries - 1] || 1e4;
        }
      };
      this.reconnectAfterMs = (tries) => {
        if (opts.reconnectAfterMs) {
          return opts.reconnectAfterMs(tries);
        } else {
          return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
        }
      };
      this.logger = opts.logger || null;
      this.longpollerTimeout = opts.longpollerTimeout || 2e4;
      this.params = closure(opts.params || {});
      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
      this.vsn = opts.vsn || DEFAULT_VSN;
      this.heartbeatTimer = null;
      this.pendingHeartbeatRef = null;
      this.reconnectTimer = new Timer(() => {
        this.teardown(() => this.connect());
      }, this.reconnectAfterMs);
    }
    getLongPollTransport() {
      return LongPoll;
    }
    replaceTransport(newTransport) {
      this.connectClock++;
      this.closeWasClean = true;
      this.reconnectTimer.reset();
      this.sendBuffer = [];
      if (this.conn) {
        this.conn.close();
        this.conn = null;
      }
      this.transport = newTransport;
    }
    protocol() {
      return location.protocol.match(/^https/) ? "wss" : "ws";
    }
    endPointURL() {
      let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), { vsn: this.vsn });
      if (uri.charAt(0) !== "/") {
        return uri;
      }
      if (uri.charAt(1) === "/") {
        return `${this.protocol()}:${uri}`;
      }
      return `${this.protocol()}://${location.host}${uri}`;
    }
    disconnect(callback, code, reason) {
      this.connectClock++;
      this.closeWasClean = true;
      this.reconnectTimer.reset();
      this.teardown(callback, code, reason);
    }
    connect(params) {
      if (params) {
        console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
        this.params = closure(params);
      }
      if (this.conn) {
        return;
      }
      this.connectClock++;
      this.closeWasClean = false;
      this.conn = new this.transport(this.endPointURL());
      this.conn.binaryType = this.binaryType;
      this.conn.timeout = this.longpollerTimeout;
      this.conn.onopen = () => this.onConnOpen();
      this.conn.onerror = (error) => this.onConnError(error);
      this.conn.onmessage = (event) => this.onConnMessage(event);
      this.conn.onclose = (event) => this.onConnClose(event);
    }
    log(kind, msg, data) {
      this.logger(kind, msg, data);
    }
    hasLogger() {
      return this.logger !== null;
    }
    onOpen(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.open.push([ref, callback]);
      return ref;
    }
    onClose(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.close.push([ref, callback]);
      return ref;
    }
    onError(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.error.push([ref, callback]);
      return ref;
    }
    onMessage(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.message.push([ref, callback]);
      return ref;
    }
    ping(callback) {
      if (!this.isConnected()) {
        return false;
      }
      let ref = this.makeRef();
      let startTime = Date.now();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref });
      let onMsgRef = this.onMessage((msg) => {
        if (msg.ref === ref) {
          this.off([onMsgRef]);
          callback(Date.now() - startTime);
        }
      });
      return true;
    }
    onConnOpen() {
      if (this.hasLogger())
        this.log("transport", `connected to ${this.endPointURL()}`);
      this.closeWasClean = false;
      this.establishedConnections++;
      this.flushSendBuffer();
      this.reconnectTimer.reset();
      this.resetHeartbeat();
      this.stateChangeCallbacks.open.forEach(([, callback]) => callback());
    }
    heartbeatTimeout() {
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        if (this.hasLogger()) {
          this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
        }
        this.abnormalClose("heartbeat timeout");
      }
    }
    resetHeartbeat() {
      if (this.conn && this.conn.skipHeartbeat) {
        return;
      }
      this.pendingHeartbeatRef = null;
      clearTimeout(this.heartbeatTimer);
      setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    }
    teardown(callback, code, reason) {
      if (!this.conn) {
        return callback && callback();
      }
      this.waitForBufferDone(() => {
        if (this.conn) {
          if (code) {
            this.conn.close(code, reason || "");
          } else {
            this.conn.close();
          }
        }
        this.waitForSocketClosed(() => {
          if (this.conn) {
            this.conn.onclose = function() {
            };
            this.conn = null;
          }
          callback && callback();
        });
      });
    }
    waitForBufferDone(callback, tries = 1) {
      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
        callback();
        return;
      }
      setTimeout(() => {
        this.waitForBufferDone(callback, tries + 1);
      }, 150 * tries);
    }
    waitForSocketClosed(callback, tries = 1) {
      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
        callback();
        return;
      }
      setTimeout(() => {
        this.waitForSocketClosed(callback, tries + 1);
      }, 150 * tries);
    }
    onConnClose(event) {
      let closeCode = event && event.code;
      if (this.hasLogger())
        this.log("transport", "close", event);
      this.triggerChanError();
      clearTimeout(this.heartbeatTimer);
      if (!this.closeWasClean && closeCode !== 1e3) {
        this.reconnectTimer.scheduleTimeout();
      }
      this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));
    }
    onConnError(error) {
      if (this.hasLogger())
        this.log("transport", error);
      let transportBefore = this.transport;
      let establishedBefore = this.establishedConnections;
      this.stateChangeCallbacks.error.forEach(([, callback]) => {
        callback(error, transportBefore, establishedBefore);
      });
      if (transportBefore === this.transport || establishedBefore > 0) {
        this.triggerChanError();
      }
    }
    triggerChanError() {
      this.channels.forEach((channel) => {
        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
          channel.trigger(CHANNEL_EVENTS.error);
        }
      });
    }
    connectionState() {
      switch (this.conn && this.conn.readyState) {
        case SOCKET_STATES.connecting:
          return "connecting";
        case SOCKET_STATES.open:
          return "open";
        case SOCKET_STATES.closing:
          return "closing";
        default:
          return "closed";
      }
    }
    isConnected() {
      return this.connectionState() === "open";
    }
    remove(channel) {
      this.off(channel.stateChangeRefs);
      this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());
    }
    off(refs) {
      for (let key in this.stateChangeCallbacks) {
        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {
          return refs.indexOf(ref) === -1;
        });
      }
    }
    channel(topic, chanParams = {}) {
      let chan = new Channel(topic, chanParams, this);
      this.channels.push(chan);
      return chan;
    }
    push(data) {
      if (this.hasLogger()) {
        let { topic, event, payload, ref, join_ref } = data;
        this.log("push", `${topic} ${event} (${join_ref}, ${ref})`, payload);
      }
      if (this.isConnected()) {
        this.encode(data, (result) => this.conn.send(result));
      } else {
        this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));
      }
    }
    makeRef() {
      let newRef = this.ref + 1;
      if (newRef === this.ref) {
        this.ref = 0;
      } else {
        this.ref = newRef;
      }
      return this.ref.toString();
    }
    sendHeartbeat() {
      if (this.pendingHeartbeatRef && !this.isConnected()) {
        return;
      }
      this.pendingHeartbeatRef = this.makeRef();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
      this.heartbeatTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
    }
    abnormalClose(reason) {
      this.closeWasClean = false;
      if (this.isConnected()) {
        this.conn.close(WS_CLOSE_NORMAL, reason);
      }
    }
    flushSendBuffer() {
      if (this.isConnected() && this.sendBuffer.length > 0) {
        this.sendBuffer.forEach((callback) => callback());
        this.sendBuffer = [];
      }
    }
    onConnMessage(rawMessage) {
      this.decode(rawMessage.data, (msg) => {
        let { topic, event, payload, ref, join_ref } = msg;
        if (ref && ref === this.pendingHeartbeatRef) {
          clearTimeout(this.heartbeatTimer);
          this.pendingHeartbeatRef = null;
          setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
        }
        if (this.hasLogger())
          this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
        for (let i = 0; i < this.channels.length; i++) {
          const channel = this.channels[i];
          if (!channel.isMember(topic, event, payload, join_ref)) {
            continue;
          }
          channel.trigger(event, payload, ref, join_ref);
        }
        for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {
          let [, callback] = this.stateChangeCallbacks.message[i];
          callback(msg);
        }
      });
    }
    leaveOpenTopic(topic) {
      let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));
      if (dupChannel) {
        if (this.hasLogger())
          this.log("transport", `leaving duplicate topic "${topic}"`);
        dupChannel.leave();
      }
    }
  };

  // ../deps/phoenix_live_view/priv/static/phoenix_live_view.esm.js
  var CONSECUTIVE_RELOADS = "consecutive-reloads";
  var MAX_RELOADS = 10;
  var RELOAD_JITTER_MIN = 5e3;
  var RELOAD_JITTER_MAX = 1e4;
  var FAILSAFE_JITTER = 3e4;
  var PHX_EVENT_CLASSES = [
    "phx-click-loading",
    "phx-change-loading",
    "phx-submit-loading",
    "phx-keydown-loading",
    "phx-keyup-loading",
    "phx-blur-loading",
    "phx-focus-loading"
  ];
  var PHX_COMPONENT = "data-phx-component";
  var PHX_LIVE_LINK = "data-phx-link";
  var PHX_TRACK_STATIC = "track-static";
  var PHX_LINK_STATE = "data-phx-link-state";
  var PHX_REF = "data-phx-ref";
  var PHX_REF_SRC = "data-phx-ref-src";
  var PHX_TRACK_UPLOADS = "track-uploads";
  var PHX_UPLOAD_REF = "data-phx-upload-ref";
  var PHX_PREFLIGHTED_REFS = "data-phx-preflighted-refs";
  var PHX_DONE_REFS = "data-phx-done-refs";
  var PHX_DROP_TARGET = "drop-target";
  var PHX_ACTIVE_ENTRY_REFS = "data-phx-active-refs";
  var PHX_LIVE_FILE_UPDATED = "phx:live-file:updated";
  var PHX_SKIP = "data-phx-skip";
  var PHX_PRUNE = "data-phx-prune";
  var PHX_PAGE_LOADING = "page-loading";
  var PHX_CONNECTED_CLASS = "phx-connected";
  var PHX_DISCONNECTED_CLASS = "phx-loading";
  var PHX_NO_FEEDBACK_CLASS = "phx-no-feedback";
  var PHX_ERROR_CLASS = "phx-error";
  var PHX_PARENT_ID = "data-phx-parent-id";
  var PHX_MAIN = "data-phx-main";
  var PHX_ROOT_ID = "data-phx-root-id";
  var PHX_TRIGGER_ACTION = "trigger-action";
  var PHX_FEEDBACK_FOR = "feedback-for";
  var PHX_HAS_FOCUSED = "phx-has-focused";
  var FOCUSABLE_INPUTS = ["text", "textarea", "number", "email", "password", "search", "tel", "url", "date", "time", "datetime-local", "color", "range"];
  var CHECKABLE_INPUTS = ["checkbox", "radio"];
  var PHX_HAS_SUBMITTED = "phx-has-submitted";
  var PHX_SESSION = "data-phx-session";
  var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;
  var PHX_STICKY = "data-phx-sticky";
  var PHX_STATIC = "data-phx-static";
  var PHX_READONLY = "data-phx-readonly";
  var PHX_DISABLED = "data-phx-disabled";
  var PHX_DISABLE_WITH = "disable-with";
  var PHX_DISABLE_WITH_RESTORE = "data-phx-disable-with-restore";
  var PHX_HOOK = "hook";
  var PHX_DEBOUNCE = "debounce";
  var PHX_THROTTLE = "throttle";
  var PHX_UPDATE = "update";
  var PHX_KEY = "key";
  var PHX_PRIVATE = "phxPrivate";
  var PHX_AUTO_RECOVER = "auto-recover";
  var PHX_LV_DEBUG = "phx:live-socket:debug";
  var PHX_LV_PROFILE = "phx:live-socket:profiling";
  var PHX_LV_LATENCY_SIM = "phx:live-socket:latency-sim";
  var PHX_PROGRESS = "progress";
  var LOADER_TIMEOUT = 1;
  var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;
  var BINDING_PREFIX = "phx-";
  var PUSH_TIMEOUT = 3e4;
  var DEBOUNCE_TRIGGER = "debounce-trigger";
  var THROTTLED = "throttled";
  var DEBOUNCE_PREV_KEY = "debounce-prev-key";
  var DEFAULTS = {
    debounce: 300,
    throttle: 300
  };
  var DYNAMICS = "d";
  var STATIC = "s";
  var COMPONENTS = "c";
  var EVENTS = "e";
  var REPLY = "r";
  var TITLE = "t";
  var TEMPLATES = "p";
  var EntryUploader = class {
    constructor(entry, chunkSize, liveSocket2) {
      this.liveSocket = liveSocket2;
      this.entry = entry;
      this.offset = 0;
      this.chunkSize = chunkSize;
      this.chunkTimer = null;
      this.uploadChannel = liveSocket2.channel(`lvu:${entry.ref}`, { token: entry.metadata() });
    }
    error(reason) {
      clearTimeout(this.chunkTimer);
      this.uploadChannel.leave();
      this.entry.error(reason);
    }
    upload() {
      this.uploadChannel.onError((reason) => this.error(reason));
      this.uploadChannel.join().receive("ok", (_data) => this.readNextChunk()).receive("error", (reason) => this.error(reason));
    }
    isDone() {
      return this.offset >= this.entry.file.size;
    }
    readNextChunk() {
      let reader = new window.FileReader();
      let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);
      reader.onload = (e) => {
        if (e.target.error === null) {
          this.offset += e.target.result.byteLength;
          this.pushChunk(e.target.result);
        } else {
          return logError("Read error: " + e.target.error);
        }
      };
      reader.readAsArrayBuffer(blob);
    }
    pushChunk(chunk) {
      if (!this.uploadChannel.isJoined()) {
        return;
      }
      this.uploadChannel.push("chunk", chunk).receive("ok", () => {
        this.entry.progress(this.offset / this.entry.file.size * 100);
        if (!this.isDone()) {
          this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);
        }
      });
    }
  };
  var logError = (msg, obj) => console.error && console.error(msg, obj);
  var isCid = (cid) => {
    let type = typeof cid;
    return type === "number" || type === "string" && /^(0|[1-9]\d*)$/.test(cid);
  };
  function detectDuplicateIds() {
    let ids = /* @__PURE__ */ new Set();
    let elems = document.querySelectorAll("*[id]");
    for (let i = 0, len = elems.length; i < len; i++) {
      if (ids.has(elems[i].id)) {
        console.error(`Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`);
      } else {
        ids.add(elems[i].id);
      }
    }
  }
  var debug = (view, kind, msg, obj) => {
    if (view.liveSocket.isDebugEnabled()) {
      console.log(`${view.id} ${kind}: ${msg} - `, obj);
    }
  };
  var closure2 = (val) => typeof val === "function" ? val : function() {
    return val;
  };
  var clone = (obj) => {
    return JSON.parse(JSON.stringify(obj));
  };
  var closestPhxBinding = (el, binding, borderEl) => {
    do {
      if (el.matches(`[${binding}]`)) {
        return el;
      }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));
    return null;
  };
  var isObject = (obj) => {
    return obj !== null && typeof obj === "object" && !(obj instanceof Array);
  };
  var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);
  var isEmpty = (obj) => {
    for (let x in obj) {
      return false;
    }
    return true;
  };
  var maybe = (el, callback) => el && callback(el);
  var channelUploader = function(entries, onError, resp, liveSocket2) {
    entries.forEach((entry) => {
      let entryUploader = new EntryUploader(entry, resp.config.chunk_size, liveSocket2);
      entryUploader.upload();
    });
  };
  var Browser = {
    canPushState() {
      return typeof history.pushState !== "undefined";
    },
    dropLocal(localStorage, namespace, subkey) {
      return localStorage.removeItem(this.localKey(namespace, subkey));
    },
    updateLocal(localStorage, namespace, subkey, initial, func) {
      let current = this.getLocal(localStorage, namespace, subkey);
      let key = this.localKey(namespace, subkey);
      let newVal = current === null ? initial : func(current);
      localStorage.setItem(key, JSON.stringify(newVal));
      return newVal;
    },
    getLocal(localStorage, namespace, subkey) {
      return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));
    },
    updateCurrentState(callback) {
      if (!this.canPushState()) {
        return;
      }
      history.replaceState(callback(history.state || {}), "", window.location.href);
    },
    pushState(kind, meta, to) {
      if (this.canPushState()) {
        if (to !== window.location.href) {
          if (meta.type == "redirect" && meta.scroll) {
            let currentState = history.state || {};
            currentState.scroll = meta.scroll;
            history.replaceState(currentState, "", window.location.href);
          }
          delete meta.scroll;
          history[kind + "State"](meta, "", to || null);
          let hashEl = this.getHashTargetEl(window.location.hash);
          if (hashEl) {
            hashEl.scrollIntoView();
          } else if (meta.type === "redirect") {
            window.scroll(0, 0);
          }
        }
      } else {
        this.redirect(to);
      }
    },
    setCookie(name, value) {
      document.cookie = `${name}=${value}`;
    },
    getCookie(name) {
      return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), "$1");
    },
    redirect(toURL, flash) {
      if (flash) {
        Browser.setCookie("__phoenix_flash__", flash + "; max-age=60000; path=/");
      }
      window.location = toURL;
    },
    localKey(namespace, subkey) {
      return `${namespace}-${subkey}`;
    },
    getHashTargetEl(maybeHash) {
      let hash = maybeHash.toString().substring(1);
      if (hash === "") {
        return;
      }
      return document.getElementById(hash) || document.querySelector(`a[name="${hash}"]`);
    }
  };
  var browser_default = Browser;
  var DOM = {
    byId(id) {
      return document.getElementById(id) || logError(`no id found for ${id}`);
    },
    removeClass(el, className) {
      el.classList.remove(className);
      if (el.classList.length === 0) {
        el.removeAttribute("class");
      }
    },
    all(node, query2, callback) {
      if (!node) {
        return [];
      }
      let array = Array.from(node.querySelectorAll(query2));
      return callback ? array.forEach(callback) : array;
    },
    childNodeLength(html) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return template.content.childElementCount;
    },
    isUploadInput(el) {
      return el.type === "file" && el.getAttribute(PHX_UPLOAD_REF) !== null;
    },
    findUploadInputs(node) {
      return this.all(node, `input[type="file"][${PHX_UPLOAD_REF}]`);
    },
    findComponentNodeList(node, cid) {
      return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}="${cid}"]`), node);
    },
    isPhxDestroyed(node) {
      return node.id && DOM.private(node, "destroyed") ? true : false;
    },
    markPhxChildDestroyed(el) {
      if (this.isPhxChild(el)) {
        el.setAttribute(PHX_SESSION, "");
      }
      this.putPrivate(el, "destroyed", true);
    },
    findPhxChildrenInFragment(html, parentId) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return this.findPhxChildren(template.content, parentId);
    },
    isIgnored(el, phxUpdate) {
      return (el.getAttribute(phxUpdate) || el.getAttribute("data-phx-update")) === "ignore";
    },
    isPhxUpdate(el, phxUpdate, updateTypes) {
      return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;
    },
    findPhxSticky(el) {
      return this.all(el, `[${PHX_STICKY}]`);
    },
    findPhxChildren(el, parentId) {
      return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}="${parentId}"]`);
    },
    findParentCIDs(node, cids) {
      let initial = new Set(cids);
      return cids.reduce((acc, cid) => {
        let selector = `[${PHX_COMPONENT}="${cid}"] [${PHX_COMPONENT}]`;
        this.filterWithinSameLiveView(this.all(node, selector), node).map((el) => parseInt(el.getAttribute(PHX_COMPONENT))).forEach((childCID) => acc.delete(childCID));
        return acc;
      }, initial);
    },
    filterWithinSameLiveView(nodes, parent) {
      if (parent.querySelector(PHX_VIEW_SELECTOR)) {
        return nodes.filter((el) => this.withinSameLiveView(el, parent));
      } else {
        return nodes;
      }
    },
    withinSameLiveView(node, parent) {
      while (node = node.parentNode) {
        if (node.isSameNode(parent)) {
          return true;
        }
        if (node.getAttribute(PHX_SESSION) !== null) {
          return false;
        }
      }
    },
    private(el, key) {
      return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];
    },
    deletePrivate(el, key) {
      el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];
    },
    putPrivate(el, key, value) {
      if (!el[PHX_PRIVATE]) {
        el[PHX_PRIVATE] = {};
      }
      el[PHX_PRIVATE][key] = value;
    },
    updatePrivate(el, key, defaultVal, updateFunc) {
      let existing = this.private(el, key);
      if (existing === void 0) {
        this.putPrivate(el, key, updateFunc(defaultVal));
      } else {
        this.putPrivate(el, key, updateFunc(existing));
      }
    },
    copyPrivates(target, source) {
      if (source[PHX_PRIVATE]) {
        target[PHX_PRIVATE] = source[PHX_PRIVATE];
      }
    },
    putTitle(str) {
      let titleEl = document.querySelector("title");
      let { prefix, suffix } = titleEl.dataset;
      document.title = `${prefix || ""}${str}${suffix || ""}`;
    },
    debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, callback) {
      let debounce = el.getAttribute(phxDebounce);
      let throttle = el.getAttribute(phxThrottle);
      if (debounce === "") {
        debounce = defaultDebounce;
      }
      if (throttle === "") {
        throttle = defaultThrottle;
      }
      let value = debounce || throttle;
      switch (value) {
        case null:
          return callback();
        case "blur":
          if (this.once(el, "debounce-blur")) {
            el.addEventListener("blur", () => callback());
          }
          return;
        default:
          let timeout = parseInt(value);
          let trigger = () => throttle ? this.deletePrivate(el, THROTTLED) : callback();
          let currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);
          if (isNaN(timeout)) {
            return logError(`invalid throttle/debounce value: ${value}`);
          }
          if (throttle) {
            let newKeyDown = false;
            if (event.type === "keydown") {
              let prevKey = this.private(el, DEBOUNCE_PREV_KEY);
              this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);
              newKeyDown = prevKey !== event.key;
            }
            if (!newKeyDown && this.private(el, THROTTLED)) {
              return false;
            } else {
              callback();
              this.putPrivate(el, THROTTLED, true);
              setTimeout(() => {
                if (asyncFilter()) {
                  this.triggerCycle(el, DEBOUNCE_TRIGGER);
                }
              }, timeout);
            }
          } else {
            setTimeout(() => {
              if (asyncFilter()) {
                this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle);
              }
            }, timeout);
          }
          let form = el.form;
          if (form && this.once(form, "bind-debounce")) {
            form.addEventListener("submit", () => {
              Array.from(new FormData(form).entries(), ([name]) => {
                let input = form.querySelector(`[name="${name}"]`);
                this.incCycle(input, DEBOUNCE_TRIGGER);
                this.deletePrivate(input, THROTTLED);
              });
            });
          }
          if (this.once(el, "bind-debounce")) {
            el.addEventListener("blur", () => this.triggerCycle(el, DEBOUNCE_TRIGGER));
          }
      }
    },
    triggerCycle(el, key, currentCycle) {
      let [cycle, trigger] = this.private(el, key);
      if (!currentCycle) {
        currentCycle = cycle;
      }
      if (currentCycle === cycle) {
        this.incCycle(el, key);
        trigger();
      }
    },
    once(el, key) {
      if (this.private(el, key) === true) {
        return false;
      }
      this.putPrivate(el, key, true);
      return true;
    },
    incCycle(el, key, trigger = function() {
    }) {
      let [currentCycle] = this.private(el, key) || [0, trigger];
      currentCycle++;
      this.putPrivate(el, key, [currentCycle, trigger]);
      return currentCycle;
    },
    discardError(container, el, phxFeedbackFor) {
      let field = el.getAttribute && el.getAttribute(phxFeedbackFor);
      let input = field && container.querySelector(`[id="${field}"], [name="${field}"]`);
      if (!input) {
        return;
      }
      if (!(this.private(input, PHX_HAS_FOCUSED) || this.private(input.form, PHX_HAS_SUBMITTED))) {
        el.classList.add(PHX_NO_FEEDBACK_CLASS);
      }
    },
    showError(inputEl, phxFeedbackFor) {
      if (inputEl.id || inputEl.name) {
        this.all(inputEl.form, `[${phxFeedbackFor}="${inputEl.id}"], [${phxFeedbackFor}="${inputEl.name}"]`, (el) => {
          this.removeClass(el, PHX_NO_FEEDBACK_CLASS);
        });
      }
    },
    isPhxChild(node) {
      return node.getAttribute && node.getAttribute(PHX_PARENT_ID);
    },
    isPhxSticky(node) {
      return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;
    },
    firstPhxChild(el) {
      return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];
    },
    dispatchEvent(target, name, opts = {}) {
      let bubbles = opts.bubbles === void 0 ? true : !!opts.bubbles;
      let eventOpts = { bubbles, cancelable: true, detail: opts.detail || {} };
      let event = name === "click" ? new MouseEvent("click", eventOpts) : new CustomEvent(name, eventOpts);
      target.dispatchEvent(event);
    },
    cloneNode(node, html) {
      if (typeof html === "undefined") {
        return node.cloneNode(true);
      } else {
        let cloned = node.cloneNode(false);
        cloned.innerHTML = html;
        return cloned;
      }
    },
    mergeAttrs(target, source, opts = {}) {
      let exclude = opts.exclude || [];
      let isIgnored = opts.isIgnored;
      let sourceAttrs = source.attributes;
      for (let i = sourceAttrs.length - 1; i >= 0; i--) {
        let name = sourceAttrs[i].name;
        if (exclude.indexOf(name) < 0) {
          target.setAttribute(name, source.getAttribute(name));
        }
      }
      let targetAttrs = target.attributes;
      for (let i = targetAttrs.length - 1; i >= 0; i--) {
        let name = targetAttrs[i].name;
        if (isIgnored) {
          if (name.startsWith("data-") && !source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        } else {
          if (!source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        }
      }
    },
    mergeFocusedInput(target, source) {
      if (!(target instanceof HTMLSelectElement)) {
        DOM.mergeAttrs(target, source, { exclude: ["value"] });
      }
      if (source.readOnly) {
        target.setAttribute("readonly", true);
      } else {
        target.removeAttribute("readonly");
      }
    },
    hasSelectionRange(el) {
      return el.setSelectionRange && (el.type === "text" || el.type === "textarea");
    },
    restoreFocus(focused, selectionStart, selectionEnd) {
      if (!DOM.isTextualInput(focused)) {
        return;
      }
      let wasFocused = focused.matches(":focus");
      if (focused.readOnly) {
        focused.blur();
      }
      if (!wasFocused) {
        focused.focus();
      }
      if (this.hasSelectionRange(focused)) {
        focused.setSelectionRange(selectionStart, selectionEnd);
      }
    },
    isFormInput(el) {
      return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== "button";
    },
    syncAttrsToProps(el) {
      if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {
        el.checked = el.getAttribute("checked") !== null;
      }
    },
    isTextualInput(el) {
      return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;
    },
    isNowTriggerFormExternal(el, phxTriggerExternal) {
      return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null;
    },
    syncPendingRef(fromEl, toEl, disableWith) {
      let ref = fromEl.getAttribute(PHX_REF);
      if (ref === null) {
        return true;
      }
      let refSrc = fromEl.getAttribute(PHX_REF_SRC);
      if (DOM.isFormInput(fromEl) || fromEl.getAttribute(disableWith) !== null) {
        if (DOM.isUploadInput(fromEl)) {
          DOM.mergeAttrs(fromEl, toEl, { isIgnored: true });
        }
        DOM.putPrivate(fromEl, PHX_REF, toEl);
        return false;
      } else {
        PHX_EVENT_CLASSES.forEach((className) => {
          fromEl.classList.contains(className) && toEl.classList.add(className);
        });
        toEl.setAttribute(PHX_REF, ref);
        toEl.setAttribute(PHX_REF_SRC, refSrc);
        return true;
      }
    },
    cleanChildNodes(container, phxUpdate) {
      if (DOM.isPhxUpdate(container, phxUpdate, ["append", "prepend"])) {
        let toRemove = [];
        container.childNodes.forEach((childNode) => {
          if (!childNode.id) {
            let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === "";
            if (!isEmptyTextNode) {
              logError(`only HTML element tags with an id are allowed inside containers with phx-update.

removing illegal node: "${(childNode.outerHTML || childNode.nodeValue).trim()}"

`);
            }
            toRemove.push(childNode);
          }
        });
        toRemove.forEach((childNode) => childNode.remove());
      }
    },
    replaceRootContainer(container, tagName, attrs) {
      let retainedAttrs = /* @__PURE__ */ new Set(["id", PHX_SESSION, PHX_STATIC, PHX_MAIN, PHX_ROOT_ID]);
      if (container.tagName.toLowerCase() === tagName.toLowerCase()) {
        Array.from(container.attributes).filter((attr) => !retainedAttrs.has(attr.name.toLowerCase())).forEach((attr) => container.removeAttribute(attr.name));
        Object.keys(attrs).filter((name) => !retainedAttrs.has(name.toLowerCase())).forEach((attr) => container.setAttribute(attr, attrs[attr]));
        return container;
      } else {
        let newContainer = document.createElement(tagName);
        Object.keys(attrs).forEach((attr) => newContainer.setAttribute(attr, attrs[attr]));
        retainedAttrs.forEach((attr) => newContainer.setAttribute(attr, container.getAttribute(attr)));
        newContainer.innerHTML = container.innerHTML;
        container.replaceWith(newContainer);
        return newContainer;
      }
    },
    getSticky(el, name, defaultVal) {
      let op = (DOM.private(el, "sticky") || []).find(([existingName]) => name === existingName);
      if (op) {
        let [_name, _op, stashedResult] = op;
        return stashedResult;
      } else {
        return typeof defaultVal === "function" ? defaultVal() : defaultVal;
      }
    },
    deleteSticky(el, name) {
      this.updatePrivate(el, "sticky", [], (ops) => {
        return ops.filter(([existingName, _2]) => existingName !== name);
      });
    },
    putSticky(el, name, op) {
      let stashedResult = op(el);
      this.updatePrivate(el, "sticky", [], (ops) => {
        let existingIndex = ops.findIndex(([existingName]) => name === existingName);
        if (existingIndex >= 0) {
          ops[existingIndex] = [name, op, stashedResult];
        } else {
          ops.push([name, op, stashedResult]);
        }
        return ops;
      });
    },
    applyStickyOperations(el) {
      let ops = DOM.private(el, "sticky");
      if (!ops) {
        return;
      }
      ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));
    }
  };
  var dom_default = DOM;
  var UploadEntry = class {
    static isActive(fileEl, file) {
      let isNew = file._phxRef === void 0;
      let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return file.size > 0 && (isNew || isActive);
    }
    static isPreflighted(fileEl, file) {
      let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(",");
      let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return isPreflighted && this.isActive(fileEl, file);
    }
    constructor(fileEl, file, view) {
      this.ref = LiveUploader.genFileRef(file);
      this.fileEl = fileEl;
      this.file = file;
      this.view = view;
      this.meta = null;
      this._isCancelled = false;
      this._isDone = false;
      this._progress = 0;
      this._lastProgressSent = -1;
      this._onDone = function() {
      };
      this._onElUpdated = this.onElUpdated.bind(this);
      this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
    }
    metadata() {
      return this.meta;
    }
    progress(progress) {
      this._progress = Math.floor(progress);
      if (this._progress > this._lastProgressSent) {
        if (this._progress >= 100) {
          this._progress = 100;
          this._lastProgressSent = 100;
          this._isDone = true;
          this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {
            LiveUploader.untrackFile(this.fileEl, this.file);
            this._onDone();
          });
        } else {
          this._lastProgressSent = this._progress;
          this.view.pushFileProgress(this.fileEl, this.ref, this._progress);
        }
      }
    }
    cancel() {
      this._isCancelled = true;
      this._isDone = true;
      this._onDone();
    }
    isDone() {
      return this._isDone;
    }
    error(reason = "failed") {
      this.view.pushFileProgress(this.fileEl, this.ref, { error: reason });
      LiveUploader.clearFiles(this.fileEl);
    }
    onDone(callback) {
      this._onDone = () => {
        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
        callback();
      };
    }
    onElUpdated() {
      let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      if (activeRefs.indexOf(this.ref) === -1) {
        this.cancel();
      }
    }
    toPreflightPayload() {
      return {
        last_modified: this.file.lastModified,
        name: this.file.name,
        size: this.file.size,
        type: this.file.type,
        ref: this.ref
      };
    }
    uploader(uploaders) {
      if (this.meta.uploader) {
        let callback = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);
        return { name: this.meta.uploader, callback };
      } else {
        return { name: "channel", callback: channelUploader };
      }
    }
    zipPostFlight(resp) {
      this.meta = resp.entries[this.ref];
      if (!this.meta) {
        logError(`no preflight upload response returned with ref ${this.ref}`, { input: this.fileEl, response: resp });
      }
    }
  };
  var liveUploaderFileRef = 0;
  var LiveUploader = class {
    static genFileRef(file) {
      let ref = file._phxRef;
      if (ref !== void 0) {
        return ref;
      } else {
        file._phxRef = (liveUploaderFileRef++).toString();
        return file._phxRef;
      }
    }
    static getEntryDataURL(inputEl, ref, callback) {
      let file = this.activeFiles(inputEl).find((file2) => this.genFileRef(file2) === ref);
      callback(URL.createObjectURL(file));
    }
    static hasUploadsInProgress(formEl) {
      let active = 0;
      dom_default.findUploadInputs(formEl).forEach((input) => {
        if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {
          active++;
        }
      });
      return active > 0;
    }
    static serializeUploads(inputEl) {
      let files = this.activeFiles(inputEl);
      let fileData = {};
      files.forEach((file) => {
        let entry = { path: inputEl.name };
        let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);
        fileData[uploadRef] = fileData[uploadRef] || [];
        entry.ref = this.genFileRef(file);
        entry.name = file.name || entry.ref;
        entry.type = file.type;
        entry.size = file.size;
        fileData[uploadRef].push(entry);
      });
      return fileData;
    }
    static clearFiles(inputEl) {
      inputEl.value = null;
      inputEl.removeAttribute(PHX_UPLOAD_REF);
      dom_default.putPrivate(inputEl, "files", []);
    }
    static untrackFile(inputEl, file) {
      dom_default.putPrivate(inputEl, "files", dom_default.private(inputEl, "files").filter((f) => !Object.is(f, file)));
    }
    static trackFiles(inputEl, files) {
      if (inputEl.getAttribute("multiple") !== null) {
        let newFiles = files.filter((file) => !this.activeFiles(inputEl).find((f) => Object.is(f, file)));
        dom_default.putPrivate(inputEl, "files", this.activeFiles(inputEl).concat(newFiles));
        inputEl.value = null;
      } else {
        dom_default.putPrivate(inputEl, "files", files);
      }
    }
    static activeFileInputs(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((el) => el.files && this.activeFiles(el).length > 0);
    }
    static activeFiles(input) {
      return (dom_default.private(input, "files") || []).filter((f) => UploadEntry.isActive(input, f));
    }
    static inputsAwaitingPreflight(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((input) => this.filesAwaitingPreflight(input).length > 0);
    }
    static filesAwaitingPreflight(input) {
      return this.activeFiles(input).filter((f) => !UploadEntry.isPreflighted(input, f));
    }
    constructor(inputEl, view, onComplete) {
      this.view = view;
      this.onComplete = onComplete;
      this._entries = Array.from(LiveUploader.filesAwaitingPreflight(inputEl) || []).map((file) => new UploadEntry(inputEl, file, view));
      this.numEntriesInProgress = this._entries.length;
    }
    entries() {
      return this._entries;
    }
    initAdapterUpload(resp, onError, liveSocket2) {
      this._entries = this._entries.map((entry) => {
        entry.zipPostFlight(resp);
        entry.onDone(() => {
          this.numEntriesInProgress--;
          if (this.numEntriesInProgress === 0) {
            this.onComplete();
          }
        });
        return entry;
      });
      let groupedEntries = this._entries.reduce((acc, entry) => {
        let { name, callback } = entry.uploader(liveSocket2.uploaders);
        acc[name] = acc[name] || { callback, entries: [] };
        acc[name].entries.push(entry);
        return acc;
      }, {});
      for (let name in groupedEntries) {
        let { callback, entries } = groupedEntries[name];
        callback(entries, onError, resp, liveSocket2);
      }
    }
  };
  var Hooks = {
    LiveFileUpload: {
      activeRefs() {
        return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);
      },
      preflightedRefs() {
        return this.el.getAttribute(PHX_PREFLIGHTED_REFS);
      },
      mounted() {
        this.preflightedWas = this.preflightedRefs();
      },
      updated() {
        let newPreflights = this.preflightedRefs();
        if (this.preflightedWas !== newPreflights) {
          this.preflightedWas = newPreflights;
          if (newPreflights === "") {
            this.__view.cancelSubmit(this.el.form);
          }
        }
        if (this.activeRefs() === "") {
          this.el.value = null;
        }
        this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));
      }
    },
    LiveImgPreview: {
      mounted() {
        this.ref = this.el.getAttribute("data-phx-entry-ref");
        this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));
        LiveUploader.getEntryDataURL(this.inputEl, this.ref, (url) => {
          this.url = url;
          this.el.src = url;
        });
      },
      destroyed() {
        URL.revokeObjectURL(this.url);
      }
    }
  };
  var hooks_default = Hooks;
  var DOMPostMorphRestorer = class {
    constructor(containerBefore, containerAfter, updateType) {
      let idsBefore = /* @__PURE__ */ new Set();
      let idsAfter = new Set([...containerAfter.children].map((child) => child.id));
      let elementsToModify = [];
      Array.from(containerBefore.children).forEach((child) => {
        if (child.id) {
          idsBefore.add(child.id);
          if (idsAfter.has(child.id)) {
            let previousElementId = child.previousElementSibling && child.previousElementSibling.id;
            elementsToModify.push({ elementId: child.id, previousElementId });
          }
        }
      });
      this.containerId = containerAfter.id;
      this.updateType = updateType;
      this.elementsToModify = elementsToModify;
      this.elementIdsToAdd = [...idsAfter].filter((id) => !idsBefore.has(id));
    }
    perform() {
      let container = dom_default.byId(this.containerId);
      this.elementsToModify.forEach((elementToModify) => {
        if (elementToModify.previousElementId) {
          maybe(document.getElementById(elementToModify.previousElementId), (previousElem) => {
            maybe(document.getElementById(elementToModify.elementId), (elem) => {
              let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;
              if (!isInRightPlace) {
                previousElem.insertAdjacentElement("afterend", elem);
              }
            });
          });
        } else {
          maybe(document.getElementById(elementToModify.elementId), (elem) => {
            let isInRightPlace = elem.previousElementSibling == null;
            if (!isInRightPlace) {
              container.insertAdjacentElement("afterbegin", elem);
            }
          });
        }
      });
      if (this.updateType == "prepend") {
        this.elementIdsToAdd.reverse().forEach((elemId) => {
          maybe(document.getElementById(elemId), (elem) => container.insertAdjacentElement("afterbegin", elem));
        });
      }
    }
  };
  var DOCUMENT_FRAGMENT_NODE = 11;
  function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
      attr = toNodeAttrs[i];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      attrValue = attr.value;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attr.prefix === "xmlns") {
            attrName = attr.name;
          }
          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = fromNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          fromNode.setAttribute(attrName, attrValue);
        }
      }
    }
    var fromNodeAttrs = fromNode.attributes;
    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
      attr = fromNodeAttrs[d];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          fromNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!toNode.hasAttribute(attrName)) {
          fromNode.removeAttribute(attrName);
        }
      }
    }
  }
  var range;
  var NS_XHTML = "http://www.w3.org/1999/xhtml";
  var doc = typeof document === "undefined" ? void 0 : document;
  var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
  function createFragmentFromTemplate(str) {
    var template = doc.createElement("template");
    template.innerHTML = str;
    return template.content.childNodes[0];
  }
  function createFragmentFromRange(str) {
    if (!range) {
      range = doc.createRange();
      range.selectNode(doc.body);
    }
    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
  }
  function createFragmentFromWrap(str) {
    var fragment = doc.createElement("body");
    fragment.innerHTML = str;
    return fragment.childNodes[0];
  }
  function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }
    return createFragmentFromWrap(str);
  }
  function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;
    if (fromNodeName === toNodeName) {
      return true;
    }
    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);
    if (fromCodeStart <= 90 && toCodeStart >= 97) {
      return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {
      return toNodeName === fromNodeName.toUpperCase();
    } else {
      return false;
    }
  }
  function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);
  }
  function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
      var nextChild = curChild.nextSibling;
      toEl.appendChild(curChild);
      curChild = nextChild;
    }
    return toEl;
  }
  function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
      fromEl[name] = toEl[name];
      if (fromEl[name]) {
        fromEl.setAttribute(name, "");
      } else {
        fromEl.removeAttribute(name);
      }
    }
  }
  var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
      var parentNode = fromEl.parentNode;
      if (parentNode) {
        var parentName = parentNode.nodeName.toUpperCase();
        if (parentName === "OPTGROUP") {
          parentNode = parentNode.parentNode;
          parentName = parentNode && parentNode.nodeName.toUpperCase();
        }
        if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
          if (fromEl.hasAttribute("selected") && !toEl.selected) {
            fromEl.setAttribute("selected", "selected");
            fromEl.removeAttribute("selected");
          }
          parentNode.selectedIndex = -1;
        }
      }
      syncBooleanAttrProp(fromEl, toEl, "selected");
    },
    INPUT: function(fromEl, toEl) {
      syncBooleanAttrProp(fromEl, toEl, "checked");
      syncBooleanAttrProp(fromEl, toEl, "disabled");
      if (fromEl.value !== toEl.value) {
        fromEl.value = toEl.value;
      }
      if (!toEl.hasAttribute("value")) {
        fromEl.removeAttribute("value");
      }
    },
    TEXTAREA: function(fromEl, toEl) {
      var newValue = toEl.value;
      if (fromEl.value !== newValue) {
        fromEl.value = newValue;
      }
      var firstChild = fromEl.firstChild;
      if (firstChild) {
        var oldValue = firstChild.nodeValue;
        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
          return;
        }
        firstChild.nodeValue = newValue;
      }
    },
    SELECT: function(fromEl, toEl) {
      if (!toEl.hasAttribute("multiple")) {
        var selectedIndex = -1;
        var i = 0;
        var curChild = fromEl.firstChild;
        var optgroup;
        var nodeName;
        while (curChild) {
          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
          if (nodeName === "OPTGROUP") {
            optgroup = curChild;
            curChild = optgroup.firstChild;
          } else {
            if (nodeName === "OPTION") {
              if (curChild.hasAttribute("selected")) {
                selectedIndex = i;
                break;
              }
              i++;
            }
            curChild = curChild.nextSibling;
            if (!curChild && optgroup) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          }
        }
        fromEl.selectedIndex = selectedIndex;
      }
    }
  };
  var ELEMENT_NODE = 1;
  var DOCUMENT_FRAGMENT_NODE$1 = 11;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  function noop() {
  }
  function defaultGetNodeKey(node) {
    if (node) {
      return node.getAttribute && node.getAttribute("id") || node.id;
    }
  }
  function morphdomFactory(morphAttrs2) {
    return function morphdom2(fromNode, toNode, options) {
      if (!options) {
        options = {};
      }
      if (typeof toNode === "string") {
        if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML" || fromNode.nodeName === "BODY") {
          var toNodeHtml = toNode;
          toNode = doc.createElement("html");
          toNode.innerHTML = toNodeHtml;
        } else {
          toNode = toElement(toNode);
        }
      }
      var getNodeKey = options.getNodeKey || defaultGetNodeKey;
      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
      var onNodeAdded = options.onNodeAdded || noop;
      var onBeforeElUpdated = options.onBeforeElUpdated || noop;
      var onElUpdated = options.onElUpdated || noop;
      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
      var onNodeDiscarded = options.onNodeDiscarded || noop;
      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
      var childrenOnly = options.childrenOnly === true;
      var fromNodesLookup = /* @__PURE__ */ Object.create(null);
      var keyedRemovalList = [];
      function addKeyedRemoval(key) {
        keyedRemovalList.push(key);
      }
      function walkDiscardedChildNodes(node, skipKeyedNodes) {
        if (node.nodeType === ELEMENT_NODE) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = void 0;
            if (skipKeyedNodes && (key = getNodeKey(curChild))) {
              addKeyedRemoval(key);
            } else {
              onNodeDiscarded(curChild);
              if (curChild.firstChild) {
                walkDiscardedChildNodes(curChild, skipKeyedNodes);
              }
            }
            curChild = curChild.nextSibling;
          }
        }
      }
      function removeNode(node, parentNode, skipKeyedNodes) {
        if (onBeforeNodeDiscarded(node) === false) {
          return;
        }
        if (parentNode) {
          parentNode.removeChild(node);
        }
        onNodeDiscarded(node);
        walkDiscardedChildNodes(node, skipKeyedNodes);
      }
      function indexTree(node) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = getNodeKey(curChild);
            if (key) {
              fromNodesLookup[key] = curChild;
            }
            indexTree(curChild);
            curChild = curChild.nextSibling;
          }
        }
      }
      indexTree(fromNode);
      function handleNodeAdded(el) {
        onNodeAdded(el);
        var curChild = el.firstChild;
        while (curChild) {
          var nextSibling = curChild.nextSibling;
          var key = getNodeKey(curChild);
          if (key) {
            var unmatchedFromEl = fromNodesLookup[key];
            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
              morphEl(unmatchedFromEl, curChild);
            } else {
              handleNodeAdded(curChild);
            }
          } else {
            handleNodeAdded(curChild);
          }
          curChild = nextSibling;
        }
      }
      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
        while (curFromNodeChild) {
          var fromNextSibling = curFromNodeChild.nextSibling;
          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
            addKeyedRemoval(curFromNodeKey);
          } else {
            removeNode(curFromNodeChild, fromEl, true);
          }
          curFromNodeChild = fromNextSibling;
        }
      }
      function morphEl(fromEl, toEl, childrenOnly2) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
          delete fromNodesLookup[toElKey];
        }
        if (!childrenOnly2) {
          if (onBeforeElUpdated(fromEl, toEl) === false) {
            return;
          }
          morphAttrs2(fromEl, toEl);
          onElUpdated(fromEl);
          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
            return;
          }
        }
        if (fromEl.nodeName !== "TEXTAREA") {
          morphChildren(fromEl, toEl);
        } else {
          specialElHandlers.TEXTAREA(fromEl, toEl);
        }
      }
      function morphChildren(fromEl, toEl) {
        var curToNodeChild = toEl.firstChild;
        var curFromNodeChild = fromEl.firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        outer:
          while (curToNodeChild) {
            toNextSibling = curToNodeChild.nextSibling;
            curToNodeKey = getNodeKey(curToNodeChild);
            while (curFromNodeChild) {
              fromNextSibling = curFromNodeChild.nextSibling;
              if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              curFromNodeKey = getNodeKey(curFromNodeChild);
              var curFromNodeType = curFromNodeChild.nodeType;
              var isCompatible = void 0;
              if (curFromNodeType === curToNodeChild.nodeType) {
                if (curFromNodeType === ELEMENT_NODE) {
                  if (curToNodeKey) {
                    if (curToNodeKey !== curFromNodeKey) {
                      if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                        if (fromNextSibling === matchingFromEl) {
                          isCompatible = false;
                        } else {
                          fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                          if (curFromNodeKey) {
                            addKeyedRemoval(curFromNodeKey);
                          } else {
                            removeNode(curFromNodeChild, fromEl, true);
                          }
                          curFromNodeChild = matchingFromEl;
                        }
                      } else {
                        isCompatible = false;
                      }
                    }
                  } else if (curFromNodeKey) {
                    isCompatible = false;
                  }
                  isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                  if (isCompatible) {
                    morphEl(curFromNodeChild, curToNodeChild);
                  }
                } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                  isCompatible = true;
                  if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                  }
                }
              }
              if (isCompatible) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              if (curFromNodeKey) {
                addKeyedRemoval(curFromNodeKey);
              } else {
                removeNode(curFromNodeChild, fromEl, true);
              }
              curFromNodeChild = fromNextSibling;
            }
            if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
              fromEl.appendChild(matchingFromEl);
              morphEl(matchingFromEl, curToNodeChild);
            } else {
              var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
              if (onBeforeNodeAddedResult !== false) {
                if (onBeforeNodeAddedResult) {
                  curToNodeChild = onBeforeNodeAddedResult;
                }
                if (curToNodeChild.actualize) {
                  curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                }
                fromEl.appendChild(curToNodeChild);
                handleNodeAdded(curToNodeChild);
              }
            }
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
          }
        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
        var specialElHandler = specialElHandlers[fromEl.nodeName];
        if (specialElHandler) {
          specialElHandler(fromEl, toEl);
        }
      }
      var morphedNode = fromNode;
      var morphedNodeType = morphedNode.nodeType;
      var toNodeType = toNode.nodeType;
      if (!childrenOnly) {
        if (morphedNodeType === ELEMENT_NODE) {
          if (toNodeType === ELEMENT_NODE) {
            if (!compareNodeNames(fromNode, toNode)) {
              onNodeDiscarded(fromNode);
              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
            }
          } else {
            morphedNode = toNode;
          }
        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
          if (toNodeType === morphedNodeType) {
            if (morphedNode.nodeValue !== toNode.nodeValue) {
              morphedNode.nodeValue = toNode.nodeValue;
            }
            return morphedNode;
          } else {
            morphedNode = toNode;
          }
        }
      }
      if (morphedNode === toNode) {
        onNodeDiscarded(fromNode);
      } else {
        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
          return;
        }
        morphEl(morphedNode, toNode, childrenOnly);
        if (keyedRemovalList) {
          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {
            var elToRemove = fromNodesLookup[keyedRemovalList[i]];
            if (elToRemove) {
              removeNode(elToRemove, elToRemove.parentNode, false);
            }
          }
        }
      }
      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        if (morphedNode.actualize) {
          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
        }
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
      }
      return morphedNode;
    };
  }
  var morphdom = morphdomFactory(morphAttrs);
  var morphdom_esm_default = morphdom;
  var DOMPatch = class {
    static patchEl(fromEl, toEl, activeElement) {
      morphdom_esm_default(fromEl, toEl, {
        childrenOnly: false,
        onBeforeElUpdated: (fromEl2, toEl2) => {
          if (activeElement && activeElement.isSameNode(fromEl2) && dom_default.isFormInput(fromEl2)) {
            dom_default.mergeFocusedInput(fromEl2, toEl2);
            return false;
          }
        }
      });
    }
    constructor(view, container, id, html, targetCID) {
      this.view = view;
      this.liveSocket = view.liveSocket;
      this.container = container;
      this.id = id;
      this.rootID = view.root.id;
      this.html = html;
      this.targetCID = targetCID;
      this.cidPatch = isCid(this.targetCID);
      this.callbacks = {
        beforeadded: [],
        beforeupdated: [],
        beforephxChildAdded: [],
        afteradded: [],
        afterupdated: [],
        afterdiscarded: [],
        afterphxChildAdded: [],
        aftertransitionsDiscarded: []
      };
    }
    before(kind, callback) {
      this.callbacks[`before${kind}`].push(callback);
    }
    after(kind, callback) {
      this.callbacks[`after${kind}`].push(callback);
    }
    trackBefore(kind, ...args) {
      this.callbacks[`before${kind}`].forEach((callback) => callback(...args));
    }
    trackAfter(kind, ...args) {
      this.callbacks[`after${kind}`].forEach((callback) => callback(...args));
    }
    markPrunableContentForRemoval() {
      dom_default.all(this.container, "[phx-update=append] > *, [phx-update=prepend] > *", (el) => {
        el.setAttribute(PHX_PRUNE, "");
      });
    }
    perform() {
      let { view, liveSocket: liveSocket2, container, html } = this;
      let targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;
      if (this.isCIDPatch() && !targetContainer) {
        return;
      }
      let focused = liveSocket2.getActiveElement();
      let { selectionStart, selectionEnd } = focused && dom_default.hasSelectionRange(focused) ? focused : {};
      let phxUpdate = liveSocket2.binding(PHX_UPDATE);
      let phxFeedbackFor = liveSocket2.binding(PHX_FEEDBACK_FOR);
      let disableWith = liveSocket2.binding(PHX_DISABLE_WITH);
      let phxTriggerExternal = liveSocket2.binding(PHX_TRIGGER_ACTION);
      let phxRemove = liveSocket2.binding("remove");
      let added = [];
      let updates = [];
      let appendPrependUpdates = [];
      let pendingRemoves = [];
      let externalFormTriggered = null;
      let diffHTML = liveSocket2.time("premorph container prep", () => {
        return this.buildDiffHTML(container, html, phxUpdate, targetContainer);
      });
      this.trackBefore("added", container);
      this.trackBefore("updated", container, container);
      liveSocket2.time("morphdom", () => {
        morphdom_esm_default(targetContainer, diffHTML, {
          childrenOnly: targetContainer.getAttribute(PHX_COMPONENT) === null,
          getNodeKey: (node) => {
            return dom_default.isPhxDestroyed(node) ? null : node.id;
          },
          onBeforeNodeAdded: (el) => {
            this.trackBefore("added", el);
            return el;
          },
          onNodeAdded: (el) => {
            if (el instanceof HTMLImageElement && el.srcset) {
              el.srcset = el.srcset;
            } else if (el instanceof HTMLVideoElement && el.autoplay) {
              el.play();
            }
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            dom_default.discardError(targetContainer, el, phxFeedbackFor);
            if (dom_default.isPhxChild(el) && view.ownsElement(el) || dom_default.isPhxSticky(el) && view.ownsElement(el.parentNode)) {
              this.trackAfter("phxChildAdded", el);
            }
            added.push(el);
          },
          onNodeDiscarded: (el) => {
            if (dom_default.isPhxChild(el) || dom_default.isPhxSticky(el)) {
              liveSocket2.destroyViewByEl(el);
            }
            this.trackAfter("discarded", el);
          },
          onBeforeNodeDiscarded: (el) => {
            if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {
              return true;
            }
            if (el.parentNode !== null && dom_default.isPhxUpdate(el.parentNode, phxUpdate, ["append", "prepend"]) && el.id) {
              return false;
            }
            if (el.getAttribute && el.getAttribute(phxRemove)) {
              pendingRemoves.push(el);
              return false;
            }
            if (this.skipCIDSibling(el)) {
              return false;
            }
            return true;
          },
          onElUpdated: (el) => {
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            updates.push(el);
          },
          onBeforeElUpdated: (fromEl, toEl) => {
            dom_default.cleanChildNodes(toEl, phxUpdate);
            if (this.skipCIDSibling(toEl)) {
              return false;
            }
            if (dom_default.isPhxSticky(fromEl)) {
              return false;
            }
            if (dom_default.isIgnored(fromEl, phxUpdate)) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeAttrs(fromEl, toEl, { isIgnored: true });
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (fromEl.type === "number" && (fromEl.validity && fromEl.validity.badInput)) {
              return false;
            }
            if (!dom_default.syncPendingRef(fromEl, toEl, disableWith)) {
              if (dom_default.isUploadInput(fromEl)) {
                this.trackBefore("updated", fromEl, toEl);
                updates.push(fromEl);
              }
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (dom_default.isPhxChild(toEl)) {
              let prevSession = fromEl.getAttribute(PHX_SESSION);
              dom_default.mergeAttrs(fromEl, toEl, { exclude: [PHX_STATIC] });
              if (prevSession !== "") {
                fromEl.setAttribute(PHX_SESSION, prevSession);
              }
              fromEl.setAttribute(PHX_ROOT_ID, this.rootID);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            dom_default.copyPrivates(toEl, fromEl);
            dom_default.discardError(targetContainer, toEl, phxFeedbackFor);
            let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);
            if (isFocusedFormEl) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeFocusedInput(fromEl, toEl);
              dom_default.syncAttrsToProps(fromEl);
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            } else {
              if (dom_default.isPhxUpdate(toEl, phxUpdate, ["append", "prepend"])) {
                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));
              }
              dom_default.syncAttrsToProps(toEl);
              dom_default.applyStickyOperations(toEl);
              this.trackBefore("updated", fromEl, toEl);
              return true;
            }
          }
        });
      });
      if (liveSocket2.isDebugEnabled()) {
        detectDuplicateIds();
      }
      if (appendPrependUpdates.length > 0) {
        liveSocket2.time("post-morph append/prepend restoration", () => {
          appendPrependUpdates.forEach((update) => update.perform());
        });
      }
      liveSocket2.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));
      dom_default.dispatchEvent(document, "phx:update");
      added.forEach((el) => this.trackAfter("added", el));
      updates.forEach((el) => this.trackAfter("updated", el));
      if (pendingRemoves.length > 0) {
        liveSocket2.transitionRemoves(pendingRemoves);
        liveSocket2.requestDOMUpdate(() => {
          pendingRemoves.forEach((el) => {
            let child = dom_default.firstPhxChild(el);
            if (child) {
              liveSocket2.destroyViewByEl(child);
            }
            el.remove();
          });
          this.trackAfter("transitionsDiscarded", pendingRemoves);
        });
      }
      if (externalFormTriggered) {
        liveSocket2.disconnect();
        externalFormTriggered.submit();
      }
      return true;
    }
    isCIDPatch() {
      return this.cidPatch;
    }
    skipCIDSibling(el) {
      return el.nodeType === Node.ELEMENT_NODE && el.getAttribute(PHX_SKIP) !== null;
    }
    targetCIDContainer(html) {
      if (!this.isCIDPatch()) {
        return;
      }
      let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);
      if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {
        return first;
      } else {
        return first && first.parentNode;
      }
    }
    buildDiffHTML(container, html, phxUpdate, targetContainer) {
      let isCIDPatch = this.isCIDPatch();
      let isCIDWithSingleRoot = isCIDPatch && targetContainer.getAttribute(PHX_COMPONENT) === this.targetCID.toString();
      if (!isCIDPatch || isCIDWithSingleRoot) {
        return html;
      } else {
        let diffContainer = null;
        let template = document.createElement("template");
        diffContainer = dom_default.cloneNode(targetContainer);
        let [firstComponent, ...rest] = dom_default.findComponentNodeList(diffContainer, this.targetCID);
        template.innerHTML = html;
        rest.forEach((el) => el.remove());
        Array.from(diffContainer.childNodes).forEach((child) => {
          if (child.id && child.nodeType === Node.ELEMENT_NODE && child.getAttribute(PHX_COMPONENT) !== this.targetCID.toString()) {
            child.setAttribute(PHX_SKIP, "");
            child.innerHTML = "";
          }
        });
        Array.from(template.content.childNodes).forEach((el) => diffContainer.insertBefore(el, firstComponent));
        firstComponent.remove();
        return diffContainer.outerHTML;
      }
    }
  };
  var Rendered = class {
    static extract(diff) {
      let { [REPLY]: reply, [EVENTS]: events, [TITLE]: title } = diff;
      delete diff[REPLY];
      delete diff[EVENTS];
      delete diff[TITLE];
      return { diff, title, reply: reply || null, events: events || [] };
    }
    constructor(viewId, rendered) {
      this.viewId = viewId;
      this.rendered = {};
      this.mergeDiff(rendered);
    }
    parentViewId() {
      return this.viewId;
    }
    toString(onlyCids) {
      return this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids);
    }
    recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids) {
      onlyCids = onlyCids ? new Set(onlyCids) : null;
      let output = { buffer: "", components, onlyCids };
      this.toOutputBuffer(rendered, null, output);
      return output.buffer;
    }
    componentCIDs(diff) {
      return Object.keys(diff[COMPONENTS] || {}).map((i) => parseInt(i));
    }
    isComponentOnlyDiff(diff) {
      if (!diff[COMPONENTS]) {
        return false;
      }
      return Object.keys(diff).length === 1;
    }
    getComponent(diff, cid) {
      return diff[COMPONENTS][cid];
    }
    mergeDiff(diff) {
      let newc = diff[COMPONENTS];
      let cache = {};
      delete diff[COMPONENTS];
      this.rendered = this.mutableMerge(this.rendered, diff);
      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};
      if (newc) {
        let oldc = this.rendered[COMPONENTS];
        for (let cid in newc) {
          newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);
        }
        for (let cid in newc) {
          oldc[cid] = newc[cid];
        }
        diff[COMPONENTS] = newc;
      }
    }
    cachedFindComponent(cid, cdiff, oldc, newc, cache) {
      if (cache[cid]) {
        return cache[cid];
      } else {
        let ndiff, stat, scid = cdiff[STATIC];
        if (isCid(scid)) {
          let tdiff;
          if (scid > 0) {
            tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);
          } else {
            tdiff = oldc[-scid];
          }
          stat = tdiff[STATIC];
          ndiff = this.cloneMerge(tdiff, cdiff);
          ndiff[STATIC] = stat;
        } else {
          ndiff = cdiff[STATIC] !== void 0 ? cdiff : this.cloneMerge(oldc[cid] || {}, cdiff);
        }
        cache[cid] = ndiff;
        return ndiff;
      }
    }
    mutableMerge(target, source) {
      if (source[STATIC] !== void 0) {
        return source;
      } else {
        this.doMutableMerge(target, source);
        return target;
      }
    }
    doMutableMerge(target, source) {
      for (let key in source) {
        let val = source[key];
        let targetVal = target[key];
        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {
          this.doMutableMerge(targetVal, val);
        } else {
          target[key] = val;
        }
      }
    }
    cloneMerge(target, source) {
      let merged = __spreadValues(__spreadValues({}, target), source);
      for (let key in merged) {
        let val = source[key];
        let targetVal = target[key];
        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {
          merged[key] = this.cloneMerge(targetVal, val);
        }
      }
      return merged;
    }
    componentToString(cid) {
      return this.recursiveCIDToString(this.rendered[COMPONENTS], cid);
    }
    pruneCIDs(cids) {
      cids.forEach((cid) => delete this.rendered[COMPONENTS][cid]);
    }
    get() {
      return this.rendered;
    }
    isNewFingerprint(diff = {}) {
      return !!diff[STATIC];
    }
    templateStatic(part, templates) {
      if (typeof part === "number") {
        return templates[part];
      } else {
        return part;
      }
    }
    toOutputBuffer(rendered, templates, output) {
      if (rendered[DYNAMICS]) {
        return this.comprehensionToBuffer(rendered, templates, output);
      }
      let { [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      output.buffer += statics[0];
      for (let i = 1; i < statics.length; i++) {
        this.dynamicToBuffer(rendered[i - 1], templates, output);
        output.buffer += statics[i];
      }
    }
    comprehensionToBuffer(rendered, templates, output) {
      let { [DYNAMICS]: dynamics, [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      let compTemplates = templates || rendered[TEMPLATES];
      for (let d = 0; d < dynamics.length; d++) {
        let dynamic = dynamics[d];
        output.buffer += statics[0];
        for (let i = 1; i < statics.length; i++) {
          this.dynamicToBuffer(dynamic[i - 1], compTemplates, output);
          output.buffer += statics[i];
        }
      }
    }
    dynamicToBuffer(rendered, templates, output) {
      if (typeof rendered === "number") {
        output.buffer += this.recursiveCIDToString(output.components, rendered, output.onlyCids);
      } else if (isObject(rendered)) {
        this.toOutputBuffer(rendered, templates, output);
      } else {
        output.buffer += rendered;
      }
    }
    recursiveCIDToString(components, cid, onlyCids) {
      let component = components[cid] || logError(`no component for CID ${cid}`, components);
      let template = document.createElement("template");
      template.innerHTML = this.recursiveToString(component, components, onlyCids);
      let container = template.content;
      let skip = onlyCids && !onlyCids.has(cid);
      let [hasChildNodes, hasChildComponents] = Array.from(container.childNodes).reduce(([hasNodes, hasComponents], child, i) => {
        if (child.nodeType === Node.ELEMENT_NODE) {
          if (child.getAttribute(PHX_COMPONENT)) {
            return [hasNodes, true];
          }
          child.setAttribute(PHX_COMPONENT, cid);
          if (!child.id) {
            child.id = `${this.parentViewId()}-${cid}-${i}`;
          }
          if (skip) {
            child.setAttribute(PHX_SKIP, "");
            child.innerHTML = "";
          }
          return [true, hasComponents];
        } else {
          if (child.nodeValue.trim() !== "") {
            logError(`only HTML element tags are allowed at the root of components.

got: "${child.nodeValue.trim()}"

within:
`, template.innerHTML.trim());
            child.replaceWith(this.createSpan(child.nodeValue, cid));
            return [true, hasComponents];
          } else {
            child.remove();
            return [hasNodes, hasComponents];
          }
        }
      }, [false, false]);
      if (!hasChildNodes && !hasChildComponents) {
        logError("expected at least one HTML element tag inside a component, but the component is empty:\n", template.innerHTML.trim());
        return this.createSpan("", cid).outerHTML;
      } else if (!hasChildNodes && hasChildComponents) {
        logError("expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.", template.innerHTML.trim());
        return template.innerHTML;
      } else {
        return template.innerHTML;
      }
    }
    createSpan(text, cid) {
      let span = document.createElement("span");
      span.innerText = text;
      span.setAttribute(PHX_COMPONENT, cid);
      return span;
    }
  };
  var viewHookID = 1;
  var ViewHook = class {
    static makeID() {
      return viewHookID++;
    }
    static elementID(el) {
      return el.phxHookId;
    }
    constructor(view, el, callbacks) {
      this.__view = view;
      this.liveSocket = view.liveSocket;
      this.__callbacks = callbacks;
      this.__listeners = /* @__PURE__ */ new Set();
      this.__isDisconnected = false;
      this.el = el;
      this.el.phxHookId = this.constructor.makeID();
      for (let key in this.__callbacks) {
        this[key] = this.__callbacks[key];
      }
    }
    __mounted() {
      this.mounted && this.mounted();
    }
    __updated() {
      this.updated && this.updated();
    }
    __beforeUpdate() {
      this.beforeUpdate && this.beforeUpdate();
    }
    __destroyed() {
      this.destroyed && this.destroyed();
    }
    __reconnected() {
      if (this.__isDisconnected) {
        this.__isDisconnected = false;
        this.reconnected && this.reconnected();
      }
    }
    __disconnected() {
      this.__isDisconnected = true;
      this.disconnected && this.disconnected();
    }
    pushEvent(event, payload = {}, onReply = function() {
    }) {
      return this.__view.pushHookEvent(null, event, payload, onReply);
    }
    pushEventTo(phxTarget, event, payload = {}, onReply = function() {
    }) {
      return this.__view.withinTargets(phxTarget, (view, targetCtx) => {
        return view.pushHookEvent(targetCtx, event, payload, onReply);
      });
    }
    handleEvent(event, callback) {
      let callbackRef = (customEvent, bypass) => bypass ? event : callback(customEvent.detail);
      window.addEventListener(`phx:${event}`, callbackRef);
      this.__listeners.add(callbackRef);
      return callbackRef;
    }
    removeHandleEvent(callbackRef) {
      let event = callbackRef(null, true);
      window.removeEventListener(`phx:${event}`, callbackRef);
      this.__listeners.delete(callbackRef);
    }
    upload(name, files) {
      return this.__view.dispatchUploads(name, files);
    }
    uploadTo(phxTarget, name, files) {
      return this.__view.withinTargets(phxTarget, (view) => view.dispatchUploads(name, files));
    }
    __cleanup__() {
      this.__listeners.forEach((callbackRef) => this.removeHandleEvent(callbackRef));
    }
  };
  var JS = {
    exec(eventType, phxEvent, view, sourceEl, defaults) {
      let [defaultKind, defaultArgs] = defaults || [null, {}];
      let commands = phxEvent.charAt(0) === "[" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];
      commands.forEach(([kind, args]) => {
        if (kind === defaultKind && defaultArgs.data) {
          args.data = Object.assign(args.data || {}, defaultArgs.data);
        }
        this.filterToEls(sourceEl, args).forEach((el) => {
          this[`exec_${kind}`](eventType, phxEvent, view, sourceEl, el, args);
        });
      });
    },
    isVisible(el) {
      return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length > 0);
    },
    exec_dispatch(eventType, phxEvent, view, sourceEl, el, { to, event, detail, bubbles }) {
      detail = detail || {};
      detail.dispatcher = sourceEl;
      dom_default.dispatchEvent(el, event, { detail, bubbles });
    },
    exec_push(eventType, phxEvent, view, sourceEl, el, args) {
      if (!view.isConnected()) {
        return;
      }
      let { event, data, target, page_loading, loading, value, dispatcher } = args;
      let pushOpts = { loading, value, target, page_loading: !!page_loading };
      let targetSrc = eventType === "change" && dispatcher ? dispatcher : sourceEl;
      let phxTarget = target || targetSrc.getAttribute(view.binding("target")) || targetSrc;
      view.withinTargets(phxTarget, (targetView, targetCtx) => {
        if (eventType === "change") {
          let { newCid, _target, callback } = args;
          _target = _target || (sourceEl instanceof HTMLInputElement ? sourceEl.name : void 0);
          if (_target) {
            pushOpts._target = _target;
          }
          targetView.pushInput(sourceEl, targetCtx, newCid, event || phxEvent, pushOpts, callback);
        } else if (eventType === "submit") {
          targetView.submitForm(sourceEl, targetCtx, event || phxEvent, pushOpts);
        } else {
          targetView.pushEvent(eventType, sourceEl, targetCtx, event || phxEvent, data, pushOpts);
        }
      });
    },
    exec_add_class(eventType, phxEvent, view, sourceEl, el, { names, transition, time }) {
      this.addOrRemoveClasses(el, names, [], transition, time, view);
    },
    exec_remove_class(eventType, phxEvent, view, sourceEl, el, { names, transition, time }) {
      this.addOrRemoveClasses(el, [], names, transition, time, view);
    },
    exec_transition(eventType, phxEvent, view, sourceEl, el, { time, transition }) {
      let [transition_start, running, transition_end] = transition;
      let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(running), []);
      let onDone = () => this.addOrRemoveClasses(el, transition_end, transition_start.concat(running));
      view.transition(time, onStart, onDone);
    },
    exec_toggle(eventType, phxEvent, view, sourceEl, el, { display, ins, outs, time }) {
      this.toggle(eventType, view, el, display, ins, outs, time);
    },
    exec_show(eventType, phxEvent, view, sourceEl, el, { display, transition, time }) {
      this.show(eventType, view, el, display, transition, time);
    },
    exec_hide(eventType, phxEvent, view, sourceEl, el, { display, transition, time }) {
      this.hide(eventType, view, el, display, transition, time);
    },
    exec_set_attr(eventType, phxEvent, view, sourceEl, el, { attr: [attr, val] }) {
      this.setOrRemoveAttrs(el, [[attr, val]], []);
    },
    exec_remove_attr(eventType, phxEvent, view, sourceEl, el, { attr }) {
      this.setOrRemoveAttrs(el, [], [attr]);
    },
    show(eventType, view, el, display, transition, time) {
      if (!this.isVisible(el)) {
        this.toggle(eventType, view, el, display, transition, null, time);
      }
    },
    hide(eventType, view, el, display, transition, time) {
      if (this.isVisible(el)) {
        this.toggle(eventType, view, el, display, null, transition, time);
      }
    },
    toggle(eventType, view, el, display, ins, outs, time) {
      let [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];
      let [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];
      if (inClasses.length > 0 || outClasses.length > 0) {
        if (this.isVisible(el)) {
          let onStart = () => {
            this.addOrRemoveClasses(el, outStartClasses, inClasses.concat(inStartClasses).concat(inEndClasses));
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, outClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, outEndClasses, outStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:hide-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          if (eventType === "remove") {
            return;
          }
          let onStart = () => {
            this.addOrRemoveClasses(el, inStartClasses, outClasses.concat(outStartClasses).concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = display || "block");
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, inClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, inEndClasses, inStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:show-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      } else {
        if (this.isVisible(el)) {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:hide-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:show-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = display || "block");
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      }
    },
    addOrRemoveClasses(el, adds, removes, transition, time, view) {
      let [transition_run, transition_start, transition_end] = transition || [[], [], []];
      if (transition_run.length > 0) {
        let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(transition_run), []);
        let onDone = () => this.addOrRemoveClasses(el, adds.concat(transition_end), removes.concat(transition_run).concat(transition_start));
        return view.transition(time, onStart, onDone);
      }
      window.requestAnimationFrame(() => {
        let [prevAdds, prevRemoves] = dom_default.getSticky(el, "classes", [[], []]);
        let keepAdds = adds.filter((name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));
        let keepRemoves = removes.filter((name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));
        let newAdds = prevAdds.filter((name) => removes.indexOf(name) < 0).concat(keepAdds);
        let newRemoves = prevRemoves.filter((name) => adds.indexOf(name) < 0).concat(keepRemoves);
        dom_default.putSticky(el, "classes", (currentEl) => {
          currentEl.classList.remove(...newRemoves);
          currentEl.classList.add(...newAdds);
          return [newAdds, newRemoves];
        });
      });
    },
    setOrRemoveAttrs(el, sets, removes) {
      let [prevSets, prevRemoves] = dom_default.getSticky(el, "attrs", [[], []]);
      let alteredAttrs = sets.map(([attr, _val]) => attr).concat(removes);
      let newSets = prevSets.filter(([attr, _val]) => !alteredAttrs.includes(attr)).concat(sets);
      let newRemoves = prevRemoves.filter((attr) => !alteredAttrs.includes(attr)).concat(removes);
      dom_default.putSticky(el, "attrs", (currentEl) => {
        newRemoves.forEach((attr) => currentEl.removeAttribute(attr));
        newSets.forEach(([attr, val]) => currentEl.setAttribute(attr, val));
        return [newSets, newRemoves];
      });
    },
    hasAllClasses(el, classes) {
      return classes.every((name) => el.classList.contains(name));
    },
    isToggledOut(el, outClasses) {
      return !this.isVisible(el) || this.hasAllClasses(el, outClasses);
    },
    filterToEls(sourceEl, { to }) {
      return to ? dom_default.all(document, to) : [sourceEl];
    }
  };
  var js_default = JS;
  var serializeForm = (form, meta, onlyNames = []) => {
    let formData = new FormData(form);
    let toRemove = [];
    formData.forEach((val, key, _index) => {
      if (val instanceof File) {
        toRemove.push(key);
      }
    });
    toRemove.forEach((key) => formData.delete(key));
    let params = new URLSearchParams();
    for (let [key, val] of formData.entries()) {
      if (onlyNames.length === 0 || onlyNames.indexOf(key) >= 0) {
        params.append(key, val);
      }
    }
    for (let metaKey in meta) {
      params.append(metaKey, meta[metaKey]);
    }
    return params.toString();
  };
  var View = class {
    constructor(el, liveSocket2, parentView, flash) {
      this.liveSocket = liveSocket2;
      this.flash = flash;
      this.parent = parentView;
      this.root = parentView ? parentView.root : this;
      this.el = el;
      this.id = this.el.id;
      this.ref = 0;
      this.childJoins = 0;
      this.loaderTimer = null;
      this.pendingDiffs = [];
      this.pruningCIDs = [];
      this.redirect = false;
      this.href = null;
      this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;
      this.joinPending = true;
      this.destroyed = false;
      this.joinCallback = function(onDone) {
        onDone && onDone();
      };
      this.stopCallback = function() {
      };
      this.pendingJoinOps = this.parent ? null : [];
      this.viewHooks = {};
      this.uploaders = {};
      this.formSubmits = [];
      this.children = this.parent ? null : {};
      this.root.children[this.id] = {};
      this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {
        return {
          redirect: this.redirect ? this.href : void 0,
          url: this.redirect ? void 0 : this.href || void 0,
          params: this.connectParams(),
          session: this.getSession(),
          static: this.getStatic(),
          flash: this.flash
        };
      });
      this.showLoader(this.liveSocket.loaderTimeout);
      this.bindChannel();
    }
    setHref(href) {
      this.href = href;
    }
    setRedirect(href) {
      this.redirect = true;
      this.href = href;
    }
    isMain() {
      return this.el.getAttribute(PHX_MAIN) !== null;
    }
    connectParams() {
      let params = this.liveSocket.params(this.el);
      let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map((node) => node.src || node.href).filter((url) => typeof url === "string");
      if (manifest.length > 0) {
        params["_track_static"] = manifest;
      }
      params["_mounts"] = this.joinCount;
      return params;
    }
    isConnected() {
      return this.channel.canPush();
    }
    getSession() {
      return this.el.getAttribute(PHX_SESSION);
    }
    getStatic() {
      let val = this.el.getAttribute(PHX_STATIC);
      return val === "" ? null : val;
    }
    destroy(callback = function() {
    }) {
      this.destroyAllChildren();
      this.destroyed = true;
      delete this.root.children[this.id];
      if (this.parent) {
        delete this.root.children[this.parent.id][this.id];
      }
      clearTimeout(this.loaderTimer);
      let onFinished = () => {
        callback();
        for (let id in this.viewHooks) {
          this.destroyHook(this.viewHooks[id]);
        }
      };
      dom_default.markPhxChildDestroyed(this.el);
      this.log("destroyed", () => ["the child has been removed from the parent"]);
      this.channel.leave().receive("ok", onFinished).receive("error", onFinished).receive("timeout", onFinished);
    }
    setContainerClasses(...classes) {
      this.el.classList.remove(PHX_CONNECTED_CLASS, PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);
      this.el.classList.add(...classes);
    }
    showLoader(timeout) {
      clearTimeout(this.loaderTimer);
      if (timeout) {
        this.loaderTimer = setTimeout(() => this.showLoader(), timeout);
      } else {
        for (let id in this.viewHooks) {
          this.viewHooks[id].__disconnected();
        }
        this.setContainerClasses(PHX_DISCONNECTED_CLASS);
      }
    }
    hideLoader() {
      clearTimeout(this.loaderTimer);
      this.setContainerClasses(PHX_CONNECTED_CLASS);
    }
    triggerReconnected() {
      for (let id in this.viewHooks) {
        this.viewHooks[id].__reconnected();
      }
    }
    log(kind, msgCallback) {
      this.liveSocket.log(this, kind, msgCallback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.liveSocket.transition(time, onStart, onDone);
    }
    withinTargets(phxTarget, callback) {
      if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {
        return this.liveSocket.owner(phxTarget, (view) => callback(view, phxTarget));
      }
      if (isCid(phxTarget)) {
        let targets = dom_default.findComponentNodeList(this.el, phxTarget);
        if (targets.length === 0) {
          logError(`no component found matching phx-target of ${phxTarget}`);
        } else {
          callback(this, parseInt(phxTarget));
        }
      } else {
        let targets = Array.from(document.querySelectorAll(phxTarget));
        if (targets.length === 0) {
          logError(`nothing found matching the phx-target selector "${phxTarget}"`);
        }
        targets.forEach((target) => this.liveSocket.owner(target, (view) => callback(view, target)));
      }
    }
    applyDiff(type, rawDiff, callback) {
      this.log(type, () => ["", clone(rawDiff)]);
      let { diff, reply, events, title } = Rendered.extract(rawDiff);
      if (title) {
        dom_default.putTitle(title);
      }
      callback({ diff, reply, events });
      return reply;
    }
    onJoin(resp) {
      let { rendered, container } = resp;
      if (container) {
        let [tag, attrs] = container;
        this.el = dom_default.replaceRootContainer(this.el, tag, attrs);
      }
      this.childJoins = 0;
      this.joinPending = true;
      this.flash = null;
      browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);
      this.applyDiff("mount", rendered, ({ diff, events }) => {
        this.rendered = new Rendered(this.id, diff);
        let html = this.renderContainer(null, "join");
        this.dropPendingRefs();
        let forms = this.formsForRecovery(html);
        this.joinCount++;
        if (forms.length > 0) {
          forms.forEach(([form, newForm, newCid], i) => {
            this.pushFormRecovery(form, newCid, (resp2) => {
              if (i === forms.length - 1) {
                this.onJoinComplete(resp2, html, events);
              }
            });
          });
        } else {
          this.onJoinComplete(resp, html, events);
        }
      });
    }
    dropPendingRefs() {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}]`, (el) => {
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
      });
    }
    onJoinComplete({ live_patch }, html, events) {
      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {
        return this.applyJoinPatch(live_patch, html, events);
      }
      let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter((toEl) => {
        let fromEl = toEl.id && this.el.querySelector(`[id="${toEl.id}"]`);
        let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);
        if (phxStatic) {
          toEl.setAttribute(PHX_STATIC, phxStatic);
        }
        return this.joinChild(toEl);
      });
      if (newChildren.length === 0) {
        if (this.parent) {
          this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
          this.applyJoinPatch(live_patch, html, events);
        }
      } else {
        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);
      }
    }
    attachTrueDocEl() {
      this.el = dom_default.byId(this.id);
      this.el.setAttribute(PHX_ROOT_ID, this.root.id);
    }
    applyJoinPatch(live_patch, html, events) {
      this.attachTrueDocEl();
      let patch = new DOMPatch(this, this.el, this.id, html, null);
      patch.markPrunableContentForRemoval();
      this.performPatch(patch, false);
      this.joinNewChildren();
      dom_default.all(this.el, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, (hookEl) => {
        let hook = this.addHook(hookEl);
        if (hook) {
          hook.__mounted();
        }
      });
      this.joinPending = false;
      this.liveSocket.dispatchEvents(events);
      this.applyPendingUpdates();
      if (live_patch) {
        let { kind, to } = live_patch;
        this.liveSocket.historyPatch(to, kind);
      }
      this.hideLoader();
      if (this.joinCount > 1) {
        this.triggerReconnected();
      }
      this.stopCallback();
    }
    triggerBeforeUpdateHook(fromEl, toEl) {
      this.liveSocket.triggerDOM("onBeforeElUpdated", [fromEl, toEl]);
      let hook = this.getHook(fromEl);
      let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));
      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {
        hook.__beforeUpdate();
        return hook;
      }
    }
    performPatch(patch, pruneCids) {
      let removedEls = [];
      let phxChildrenAdded = false;
      let updatedHookIds = /* @__PURE__ */ new Set();
      patch.after("added", (el) => {
        this.liveSocket.triggerDOM("onNodeAdded", [el]);
        let newHook = this.addHook(el);
        if (newHook) {
          newHook.__mounted();
        }
      });
      patch.after("phxChildAdded", (el) => {
        if (dom_default.isPhxSticky(el)) {
          this.liveSocket.joinRootViews();
        } else {
          phxChildrenAdded = true;
        }
      });
      patch.before("updated", (fromEl, toEl) => {
        let hook = this.triggerBeforeUpdateHook(fromEl, toEl);
        if (hook) {
          updatedHookIds.add(fromEl.id);
        }
      });
      patch.after("updated", (el) => {
        if (updatedHookIds.has(el.id)) {
          this.getHook(el).__updated();
        }
      });
      patch.after("discarded", (el) => {
        if (el.nodeType === Node.ELEMENT_NODE) {
          removedEls.push(el);
        }
      });
      patch.after("transitionsDiscarded", (els) => this.afterElementsRemoved(els, pruneCids));
      patch.perform();
      this.afterElementsRemoved(removedEls, pruneCids);
      return phxChildrenAdded;
    }
    afterElementsRemoved(elements, pruneCids) {
      let destroyedCIDs = [];
      elements.forEach((parent) => {
        let components = dom_default.all(parent, `[${PHX_COMPONENT}]`);
        let hooks = dom_default.all(parent, `[${this.binding(PHX_HOOK)}]`);
        components.concat(parent).forEach((el) => {
          let cid = this.componentID(el);
          if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {
            destroyedCIDs.push(cid);
          }
        });
        hooks.concat(parent).forEach((hookEl) => {
          let hook = this.getHook(hookEl);
          hook && this.destroyHook(hook);
        });
      });
      if (pruneCids) {
        this.maybePushComponentsDestroyed(destroyedCIDs);
      }
    }
    joinNewChildren() {
      dom_default.findPhxChildren(this.el, this.id).forEach((el) => this.joinChild(el));
    }
    getChildById(id) {
      return this.root.children[this.id][id];
    }
    getDescendentByEl(el) {
      if (el.id === this.id) {
        return this;
      } else {
        return this.children[el.getAttribute(PHX_PARENT_ID)][el.id];
      }
    }
    destroyDescendent(id) {
      for (let parentId in this.root.children) {
        for (let childId in this.root.children[parentId]) {
          if (childId === id) {
            return this.root.children[parentId][childId].destroy();
          }
        }
      }
    }
    joinChild(el) {
      let child = this.getChildById(el.id);
      if (!child) {
        let view = new View(el, this.liveSocket, this);
        this.root.children[this.id][view.id] = view;
        view.join();
        this.childJoins++;
        return true;
      }
    }
    isJoinPending() {
      return this.joinPending;
    }
    ackJoin(_child) {
      this.childJoins--;
      if (this.childJoins === 0) {
        if (this.parent) {
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
        }
      }
    }
    onAllChildJoinsComplete() {
      this.joinCallback(() => {
        this.pendingJoinOps.forEach(([view, op]) => {
          if (!view.isDestroyed()) {
            op();
          }
        });
        this.pendingJoinOps = [];
      });
    }
    update(diff, events) {
      if (this.isJoinPending() || this.liveSocket.hasPendingLink() && !dom_default.isPhxSticky(this.el)) {
        return this.pendingDiffs.push({ diff, events });
      }
      this.rendered.mergeDiff(diff);
      let phxChildrenAdded = false;
      if (this.rendered.isComponentOnlyDiff(diff)) {
        this.liveSocket.time("component patch complete", () => {
          let parentCids = dom_default.findParentCIDs(this.el, this.rendered.componentCIDs(diff));
          parentCids.forEach((parentCID) => {
            if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {
              phxChildrenAdded = true;
            }
          });
        });
      } else if (!isEmpty(diff)) {
        this.liveSocket.time("full patch complete", () => {
          let html = this.renderContainer(diff, "update");
          let patch = new DOMPatch(this, this.el, this.id, html, null);
          phxChildrenAdded = this.performPatch(patch, true);
        });
      }
      this.liveSocket.dispatchEvents(events);
      if (phxChildrenAdded) {
        this.joinNewChildren();
      }
    }
    renderContainer(diff, kind) {
      return this.liveSocket.time(`toString diff (${kind})`, () => {
        let tag = this.el.tagName;
        let cids = diff ? this.rendered.componentCIDs(diff).concat(this.pruningCIDs) : null;
        let html = this.rendered.toString(cids);
        return `<${tag}>${html}</${tag}>`;
      });
    }
    componentPatch(diff, cid) {
      if (isEmpty(diff))
        return false;
      let html = this.rendered.componentToString(cid);
      let patch = new DOMPatch(this, this.el, this.id, html, cid);
      let childrenAdded = this.performPatch(patch, true);
      return childrenAdded;
    }
    getHook(el) {
      return this.viewHooks[ViewHook.elementID(el)];
    }
    addHook(el) {
      if (ViewHook.elementID(el) || !el.getAttribute) {
        return;
      }
      let hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));
      if (hookName && !this.ownsElement(el)) {
        return;
      }
      let callbacks = this.liveSocket.getHookCallbacks(hookName);
      if (callbacks) {
        if (!el.id) {
          logError(`no DOM ID for hook "${hookName}". Hooks require a unique ID on each element.`, el);
        }
        let hook = new ViewHook(this, el, callbacks);
        this.viewHooks[ViewHook.elementID(hook.el)] = hook;
        return hook;
      } else if (hookName !== null) {
        logError(`unknown hook found for "${hookName}"`, el);
      }
    }
    destroyHook(hook) {
      hook.__destroyed();
      hook.__cleanup__();
      delete this.viewHooks[ViewHook.elementID(hook.el)];
    }
    applyPendingUpdates() {
      this.pendingDiffs.forEach(({ diff, events }) => this.update(diff, events));
      this.pendingDiffs = [];
    }
    onChannel(event, cb) {
      this.liveSocket.onChannel(this.channel, event, (resp) => {
        if (this.isJoinPending()) {
          this.root.pendingJoinOps.push([this, () => cb(resp)]);
        } else {
          this.liveSocket.requestDOMUpdate(() => cb(resp));
        }
      });
    }
    bindChannel() {
      this.liveSocket.onChannel(this.channel, "diff", (rawDiff) => {
        this.liveSocket.requestDOMUpdate(() => {
          this.applyDiff("update", rawDiff, ({ diff, events }) => this.update(diff, events));
        });
      });
      this.onChannel("redirect", ({ to, flash }) => this.onRedirect({ to, flash }));
      this.onChannel("live_patch", (redir) => this.onLivePatch(redir));
      this.onChannel("live_redirect", (redir) => this.onLiveRedirect(redir));
      this.channel.onError((reason) => this.onError(reason));
      this.channel.onClose((reason) => this.onClose(reason));
    }
    destroyAllChildren() {
      for (let id in this.root.children[this.id]) {
        this.getChildById(id).destroy();
      }
    }
    onLiveRedirect(redir) {
      let { to, kind, flash } = redir;
      let url = this.expandURL(to);
      this.liveSocket.historyRedirect(url, kind, flash);
    }
    onLivePatch(redir) {
      let { to, kind } = redir;
      this.href = this.expandURL(to);
      this.liveSocket.historyPatch(to, kind);
    }
    expandURL(to) {
      return to.startsWith("/") ? `${window.location.protocol}//${window.location.host}${to}` : to;
    }
    onRedirect({ to, flash }) {
      this.liveSocket.redirect(to, flash);
    }
    isDestroyed() {
      return this.destroyed;
    }
    join(callback) {
      if (this.isMain()) {
        this.stopCallback = this.liveSocket.withPageLoading({ to: this.href, kind: "initial" });
      }
      this.joinCallback = (onDone) => {
        onDone = onDone || function() {
        };
        callback ? callback(this.joinCount, onDone) : onDone();
      };
      this.liveSocket.wrapPush(this, { timeout: false }, () => {
        return this.channel.join().receive("ok", (data) => {
          if (!this.isDestroyed()) {
            this.liveSocket.requestDOMUpdate(() => this.onJoin(data));
          }
        }).receive("error", (resp) => !this.isDestroyed() && this.onJoinError(resp)).receive("timeout", () => !this.isDestroyed() && this.onJoinError({ reason: "timeout" }));
      });
    }
    onJoinError(resp) {
      if (resp.reason === "unauthorized" || resp.reason === "stale") {
        this.log("error", () => ["unauthorized live_redirect. Falling back to page request", resp]);
        return this.onRedirect({ to: this.href });
      }
      if (resp.redirect || resp.live_redirect) {
        this.joinPending = false;
        this.channel.leave();
      }
      if (resp.redirect) {
        return this.onRedirect(resp.redirect);
      }
      if (resp.live_redirect) {
        return this.onLiveRedirect(resp.live_redirect);
      }
      this.log("error", () => ["unable to join", resp]);
      if (this.liveSocket.isConnected()) {
        this.liveSocket.reloadWithJitter(this);
      }
    }
    onClose(reason) {
      if (this.isDestroyed()) {
        return;
      }
      if (this.liveSocket.hasPendingLink() && reason !== "leave") {
        return this.liveSocket.reloadWithJitter(this);
      }
      this.destroyAllChildren();
      this.liveSocket.dropActiveElement(this);
      if (document.activeElement) {
        document.activeElement.blur();
      }
      if (this.liveSocket.isUnloaded()) {
        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);
      }
    }
    onError(reason) {
      this.onClose(reason);
      if (this.liveSocket.isConnected()) {
        this.log("error", () => ["view crashed", reason]);
      }
      if (!this.liveSocket.isUnloaded()) {
        this.displayError();
      }
    }
    displayError() {
      if (this.isMain()) {
        dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: { to: this.href, kind: "error" } });
      }
      this.showLoader();
      this.setContainerClasses(PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);
    }
    pushWithReply(refGenerator, event, payload, onReply = function() {
    }) {
      if (!this.isConnected()) {
        return;
      }
      let [ref, [el], opts] = refGenerator ? refGenerator() : [null, [], {}];
      let onLoadingDone = function() {
      };
      if (opts.page_loading || el && el.getAttribute(this.binding(PHX_PAGE_LOADING)) !== null) {
        onLoadingDone = this.liveSocket.withPageLoading({ kind: "element", target: el });
      }
      if (typeof payload.cid !== "number") {
        delete payload.cid;
      }
      return this.liveSocket.wrapPush(this, { timeout: true }, () => {
        return this.channel.push(event, payload, PUSH_TIMEOUT).receive("ok", (resp) => {
          if (ref !== null) {
            this.undoRefs(ref);
          }
          let finish = (hookReply) => {
            if (resp.redirect) {
              this.onRedirect(resp.redirect);
            }
            if (resp.live_patch) {
              this.onLivePatch(resp.live_patch);
            }
            if (resp.live_redirect) {
              this.onLiveRedirect(resp.live_redirect);
            }
            onLoadingDone();
            onReply(resp, hookReply);
          };
          if (resp.diff) {
            this.liveSocket.requestDOMUpdate(() => {
              let hookReply = this.applyDiff("update", resp.diff, ({ diff, events }) => {
                this.update(diff, events);
              });
              finish(hookReply);
            });
          } else {
            finish(null);
          }
        });
      });
    }
    undoRefs(ref) {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}="${ref}"]`, (el) => {
        let disabledVal = el.getAttribute(PHX_DISABLED);
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
        if (el.getAttribute(PHX_READONLY) !== null) {
          el.readOnly = false;
          el.removeAttribute(PHX_READONLY);
        }
        if (disabledVal !== null) {
          el.disabled = disabledVal === "true" ? true : false;
          el.removeAttribute(PHX_DISABLED);
        }
        PHX_EVENT_CLASSES.forEach((className) => dom_default.removeClass(el, className));
        let disableRestore = el.getAttribute(PHX_DISABLE_WITH_RESTORE);
        if (disableRestore !== null) {
          el.innerText = disableRestore;
          el.removeAttribute(PHX_DISABLE_WITH_RESTORE);
        }
        let toEl = dom_default.private(el, PHX_REF);
        if (toEl) {
          let hook = this.triggerBeforeUpdateHook(el, toEl);
          DOMPatch.patchEl(el, toEl, this.liveSocket.getActiveElement());
          if (hook) {
            hook.__updated();
          }
          dom_default.deletePrivate(el, PHX_REF);
        }
      });
    }
    putRef(elements, event, opts = {}) {
      let newRef = this.ref++;
      let disableWith = this.binding(PHX_DISABLE_WITH);
      if (opts.loading) {
        elements = elements.concat(dom_default.all(document, opts.loading));
      }
      elements.forEach((el) => {
        el.classList.add(`phx-${event}-loading`);
        el.setAttribute(PHX_REF, newRef);
        el.setAttribute(PHX_REF_SRC, this.el.id);
        let disableText = el.getAttribute(disableWith);
        if (disableText !== null) {
          if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {
            el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);
          }
          if (disableText !== "") {
            el.innerText = disableText;
          }
          el.setAttribute("disabled", "");
        }
      });
      return [newRef, elements, opts];
    }
    componentID(el) {
      let cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);
      return cid ? parseInt(cid) : null;
    }
    targetComponentID(target, targetCtx, opts = {}) {
      if (isCid(targetCtx)) {
        return targetCtx;
      }
      let cidOrSelector = target.getAttribute(this.binding("target"));
      if (isCid(cidOrSelector)) {
        return parseInt(cidOrSelector);
      } else if (targetCtx && (cidOrSelector !== null || opts.target)) {
        return this.closestComponentID(targetCtx);
      } else {
        return null;
      }
    }
    closestComponentID(targetCtx) {
      if (isCid(targetCtx)) {
        return targetCtx;
      } else if (targetCtx) {
        return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), (el) => this.ownsElement(el) && this.componentID(el));
      } else {
        return null;
      }
    }
    pushHookEvent(targetCtx, event, payload, onReply) {
      if (!this.isConnected()) {
        this.log("hook", () => ["unable to push hook event. LiveView not connected", event, payload]);
        return false;
      }
      let [ref, els, opts] = this.putRef([], "hook");
      this.pushWithReply(() => [ref, els, opts], "event", {
        type: "hook",
        event,
        value: payload,
        cid: this.closestComponentID(targetCtx)
      }, (resp, reply) => onReply(reply, ref));
      return ref;
    }
    extractMeta(el, meta, value) {
      let prefix = this.binding("value-");
      for (let i = 0; i < el.attributes.length; i++) {
        if (!meta) {
          meta = {};
        }
        let name = el.attributes[i].name;
        if (name.startsWith(prefix)) {
          meta[name.replace(prefix, "")] = el.getAttribute(name);
        }
      }
      if (el.value !== void 0) {
        if (!meta) {
          meta = {};
        }
        meta.value = el.value;
        if (el.tagName === "INPUT" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {
          delete meta.value;
        }
      }
      if (value) {
        if (!meta) {
          meta = {};
        }
        for (let key in value) {
          meta[key] = value[key];
        }
      }
      return meta;
    }
    pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}) {
      this.pushWithReply(() => this.putRef([el], type, opts), "event", {
        type,
        event: phxEvent,
        value: this.extractMeta(el, meta, opts.value),
        cid: this.targetComponentID(el, targetCtx, opts)
      });
    }
    pushFileProgress(fileEl, entryRef, progress, onReply = function() {
    }) {
      this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {
        view.pushWithReply(null, "progress", {
          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),
          ref: fileEl.getAttribute(PHX_UPLOAD_REF),
          entry_ref: entryRef,
          progress,
          cid: view.targetComponentID(fileEl.form, targetCtx)
        }, onReply);
      });
    }
    pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback) {
      let uploads;
      let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx);
      let refGenerator = () => this.putRef([inputEl, inputEl.form], "change", opts);
      let formData;
      if (inputEl.getAttribute(this.binding("change"))) {
        formData = serializeForm(inputEl.form, { _target: opts._target }, [inputEl.name]);
      } else {
        formData = serializeForm(inputEl.form, { _target: opts._target });
      }
      if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {
        LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));
      }
      uploads = LiveUploader.serializeUploads(inputEl);
      let event = {
        type: "form",
        event: phxEvent,
        value: formData,
        uploads,
        cid
      };
      this.pushWithReply(refGenerator, "event", event, (resp) => {
        dom_default.showError(inputEl, this.liveSocket.binding(PHX_FEEDBACK_FOR));
        if (dom_default.isUploadInput(inputEl) && inputEl.getAttribute("data-phx-auto-upload") !== null) {
          if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {
            let [ref, _els] = refGenerator();
            this.uploadFiles(inputEl.form, targetCtx, ref, cid, (_uploads) => {
              callback && callback(resp);
              this.triggerAwaitingSubmit(inputEl.form);
            });
          }
        } else {
          callback && callback(resp);
        }
      });
    }
    triggerAwaitingSubmit(formEl) {
      let awaitingSubmit = this.getScheduledSubmit(formEl);
      if (awaitingSubmit) {
        let [_el, _ref, _opts, callback] = awaitingSubmit;
        this.cancelSubmit(formEl);
        callback();
      }
    }
    getScheduledSubmit(formEl) {
      return this.formSubmits.find(([el, _ref, _opts, _callback]) => el.isSameNode(formEl));
    }
    scheduleSubmit(formEl, ref, opts, callback) {
      if (this.getScheduledSubmit(formEl)) {
        return true;
      }
      this.formSubmits.push([formEl, ref, opts, callback]);
    }
    cancelSubmit(formEl) {
      this.formSubmits = this.formSubmits.filter(([el, ref, _callback]) => {
        if (el.isSameNode(formEl)) {
          this.undoRefs(ref);
          return false;
        } else {
          return true;
        }
      });
    }
    pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply) {
      let filterIgnored = (el) => {
        let userIgnored = closestPhxBinding(el, `${this.binding(PHX_UPDATE)}=ignore`, el.form);
        return !(userIgnored || closestPhxBinding(el, "data-phx-update=ignore", el.form));
      };
      let filterDisables = (el) => {
        return el.hasAttribute(this.binding(PHX_DISABLE_WITH));
      };
      let filterButton = (el) => el.tagName == "BUTTON";
      let filterInput = (el) => ["INPUT", "TEXTAREA", "SELECT"].includes(el.tagName);
      let refGenerator = () => {
        let formElements = Array.from(formEl.elements);
        let disables = formElements.filter(filterDisables);
        let buttons = formElements.filter(filterButton).filter(filterIgnored);
        let inputs = formElements.filter(filterInput).filter(filterIgnored);
        buttons.forEach((button) => {
          button.setAttribute(PHX_DISABLED, button.disabled);
          button.disabled = true;
        });
        inputs.forEach((input) => {
          input.setAttribute(PHX_READONLY, input.readOnly);
          input.readOnly = true;
          if (input.files) {
            input.setAttribute(PHX_DISABLED, input.disabled);
            input.disabled = true;
          }
        });
        formEl.setAttribute(this.binding(PHX_PAGE_LOADING), "");
        return this.putRef([formEl].concat(disables).concat(buttons).concat(inputs), "submit", opts);
      };
      let cid = this.targetComponentID(formEl, targetCtx);
      if (LiveUploader.hasUploadsInProgress(formEl)) {
        let [ref, _els] = refGenerator();
        let push = () => this.pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply);
        return this.scheduleSubmit(formEl, ref, opts, push);
      } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
        let [ref, els] = refGenerator();
        let proxyRefGen = () => [ref, els, opts];
        this.uploadFiles(formEl, targetCtx, ref, cid, (_uploads) => {
          let formData = serializeForm(formEl, {});
          this.pushWithReply(proxyRefGen, "event", {
            type: "form",
            event: phxEvent,
            value: formData,
            cid
          }, onReply);
        });
      } else {
        let formData = serializeForm(formEl, {});
        this.pushWithReply(refGenerator, "event", {
          type: "form",
          event: phxEvent,
          value: formData,
          cid
        }, onReply);
      }
    }
    uploadFiles(formEl, targetCtx, ref, cid, onComplete) {
      let joinCountAtUpload = this.joinCount;
      let inputEls = LiveUploader.activeFileInputs(formEl);
      let numFileInputsInProgress = inputEls.length;
      inputEls.forEach((inputEl) => {
        let uploader = new LiveUploader(inputEl, this, () => {
          numFileInputsInProgress--;
          if (numFileInputsInProgress === 0) {
            onComplete();
          }
        });
        this.uploaders[inputEl] = uploader;
        let entries = uploader.entries().map((entry) => entry.toPreflightPayload());
        let payload = {
          ref: inputEl.getAttribute(PHX_UPLOAD_REF),
          entries,
          cid: this.targetComponentID(inputEl.form, targetCtx)
        };
        this.log("upload", () => ["sending preflight request", payload]);
        this.pushWithReply(null, "allow_upload", payload, (resp) => {
          this.log("upload", () => ["got preflight response", resp]);
          if (resp.error) {
            this.undoRefs(ref);
            let [entry_ref, reason] = resp.error;
            this.log("upload", () => [`error for entry ${entry_ref}`, reason]);
          } else {
            let onError = (callback) => {
              this.channel.onError(() => {
                if (this.joinCount === joinCountAtUpload) {
                  callback();
                }
              });
            };
            uploader.initAdapterUpload(resp, onError, this.liveSocket);
          }
        });
      });
    }
    dispatchUploads(name, filesOrBlobs) {
      let inputs = dom_default.findUploadInputs(this.el).filter((el) => el.name === name);
      if (inputs.length === 0) {
        logError(`no live file inputs found matching the name "${name}"`);
      } else if (inputs.length > 1) {
        logError(`duplicate live file inputs found matching the name "${name}"`);
      } else {
        dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, { detail: { files: filesOrBlobs } });
      }
    }
    pushFormRecovery(form, newCid, callback) {
      this.liveSocket.withinOwners(form, (view, targetCtx) => {
        let input = form.elements[0];
        let phxEvent = form.getAttribute(this.binding(PHX_AUTO_RECOVER)) || form.getAttribute(this.binding("change"));
        js_default.exec("change", phxEvent, view, input, ["push", { _target: input.name, newCid, callback }]);
      });
    }
    pushLinkPatch(href, targetEl, callback) {
      let linkRef = this.liveSocket.setPendingLink(href);
      let refGen = targetEl ? () => this.putRef([targetEl], "click") : null;
      let fallback = () => this.liveSocket.redirect(window.location.href);
      let push = this.pushWithReply(refGen, "live_patch", { url: href }, (resp) => {
        this.liveSocket.requestDOMUpdate(() => {
          if (resp.link_redirect) {
            this.liveSocket.replaceMain(href, null, callback, linkRef);
          } else {
            if (this.liveSocket.commitPendingLink(linkRef)) {
              this.href = href;
            }
            this.applyPendingUpdates();
            callback && callback(linkRef);
          }
        });
      });
      if (push) {
        push.receive("timeout", fallback);
      } else {
        fallback();
      }
    }
    formsForRecovery(html) {
      if (this.joinCount === 0) {
        return [];
      }
      let phxChange = this.binding("change");
      let template = document.createElement("template");
      template.innerHTML = html;
      return dom_default.all(this.el, `form[${phxChange}]`).filter((form) => form.id && this.ownsElement(form)).filter((form) => form.elements.length > 0).filter((form) => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== "ignore").map((form) => {
        let newForm = template.content.querySelector(`form[id="${form.id}"][${phxChange}="${form.getAttribute(phxChange)}"]`);
        if (newForm) {
          return [form, newForm, this.targetComponentID(newForm)];
        } else {
          return [form, null, null];
        }
      }).filter(([form, newForm, newCid]) => newForm);
    }
    maybePushComponentsDestroyed(destroyedCIDs) {
      let willDestroyCIDs = destroyedCIDs.filter((cid) => {
        return dom_default.findComponentNodeList(this.el, cid).length === 0;
      });
      if (willDestroyCIDs.length > 0) {
        this.pruningCIDs.push(...willDestroyCIDs);
        this.pushWithReply(null, "cids_will_destroy", { cids: willDestroyCIDs }, () => {
          this.pruningCIDs = this.pruningCIDs.filter((cid) => willDestroyCIDs.indexOf(cid) !== -1);
          let completelyDestroyCIDs = willDestroyCIDs.filter((cid) => {
            return dom_default.findComponentNodeList(this.el, cid).length === 0;
          });
          if (completelyDestroyCIDs.length > 0) {
            this.pushWithReply(null, "cids_destroyed", { cids: completelyDestroyCIDs }, (resp) => {
              this.rendered.pruneCIDs(resp.cids);
            });
          }
        });
      }
    }
    ownsElement(el) {
      return el.getAttribute(PHX_PARENT_ID) === this.id || maybe(el.closest(PHX_VIEW_SELECTOR), (node) => node.id) === this.id;
    }
    submitForm(form, targetCtx, phxEvent, opts = {}) {
      dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);
      let phxFeedback = this.liveSocket.binding(PHX_FEEDBACK_FOR);
      let inputs = Array.from(form.elements);
      this.liveSocket.blurActiveElement(this);
      this.pushFormSubmit(form, targetCtx, phxEvent, opts, () => {
        inputs.forEach((input) => dom_default.showError(input, phxFeedback));
        this.liveSocket.restorePreviouslyActiveFocus();
      });
    }
    binding(kind) {
      return this.liveSocket.binding(kind);
    }
  };
  var LiveSocket = class {
    constructor(url, phxSocket, opts = {}) {
      this.unloaded = false;
      if (!phxSocket || phxSocket.constructor.name === "Object") {
        throw new Error(`
      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:

          import {Socket} from "phoenix"
          import {LiveSocket} from "phoenix_live_view"
          let liveSocket = new LiveSocket("/live", Socket, {...})
      `);
      }
      this.socket = new phxSocket(url, opts);
      this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;
      this.opts = opts;
      this.params = closure2(opts.params || {});
      this.viewLogger = opts.viewLogger;
      this.metadataCallbacks = opts.metadata || {};
      this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});
      this.activeElement = null;
      this.prevActive = null;
      this.silenced = false;
      this.main = null;
      this.outgoingMainEl = null;
      this.clickStartedAtTarget = null;
      this.linkRef = 1;
      this.roots = {};
      this.href = window.location.href;
      this.pendingLink = null;
      this.currentLocation = clone(window.location);
      this.hooks = opts.hooks || {};
      this.uploaders = opts.uploaders || {};
      this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;
      this.reloadWithJitterTimer = null;
      this.maxReloads = opts.maxReloads || MAX_RELOADS;
      this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;
      this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;
      this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;
      this.localStorage = opts.localStorage || window.localStorage;
      this.sessionStorage = opts.sessionStorage || window.sessionStorage;
      this.boundTopLevelEvents = false;
      this.domCallbacks = Object.assign({ onNodeAdded: closure2(), onBeforeElUpdated: closure2() }, opts.dom || {});
      this.transitions = new TransitionSet();
      window.addEventListener("pagehide", (_e) => {
        this.unloaded = true;
      });
      this.socket.onOpen(() => {
        if (this.isUnloaded()) {
          window.location.reload();
        }
      });
    }
    isProfileEnabled() {
      return this.sessionStorage.getItem(PHX_LV_PROFILE) === "true";
    }
    isDebugEnabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "true";
    }
    isDebugDisabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "false";
    }
    enableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "true");
    }
    enableProfiling() {
      this.sessionStorage.setItem(PHX_LV_PROFILE, "true");
    }
    disableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "false");
    }
    disableProfiling() {
      this.sessionStorage.removeItem(PHX_LV_PROFILE);
    }
    enableLatencySim(upperBoundMs) {
      this.enableDebug();
      console.log("latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable");
      this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);
    }
    disableLatencySim() {
      this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);
    }
    getLatencySim() {
      let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);
      return str ? parseInt(str) : null;
    }
    getSocket() {
      return this.socket;
    }
    connect() {
      if (window.location.hostname === "localhost" && !this.isDebugDisabled()) {
        this.enableDebug();
      }
      let doConnect = () => {
        if (this.joinRootViews()) {
          this.bindTopLevelEvents();
          this.socket.connect();
        } else if (this.main) {
          this.socket.connect();
        }
      };
      if (["complete", "loaded", "interactive"].indexOf(document.readyState) >= 0) {
        doConnect();
      } else {
        document.addEventListener("DOMContentLoaded", () => doConnect());
      }
    }
    disconnect(callback) {
      clearTimeout(this.reloadWithJitterTimer);
      this.socket.disconnect(callback);
    }
    replaceTransport(transport) {
      clearTimeout(this.reloadWithJitterTimer);
      this.socket.replaceTransport(transport);
      this.connect();
    }
    execJS(el, encodedJS, eventType = null) {
      this.owner(el, (view) => js_default.exec(eventType, encodedJS, view, el));
    }
    triggerDOM(kind, args) {
      this.domCallbacks[kind](...args);
    }
    time(name, func) {
      if (!this.isProfileEnabled() || !console.time) {
        return func();
      }
      console.time(name);
      let result = func();
      console.timeEnd(name);
      return result;
    }
    log(view, kind, msgCallback) {
      if (this.viewLogger) {
        let [msg, obj] = msgCallback();
        this.viewLogger(view, kind, msg, obj);
      } else if (this.isDebugEnabled()) {
        let [msg, obj] = msgCallback();
        debug(view, kind, msg, obj);
      }
    }
    requestDOMUpdate(callback) {
      this.transitions.after(callback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.transitions.addTransition(time, onStart, onDone);
    }
    onChannel(channel, event, cb) {
      channel.on(event, (data) => {
        let latency = this.getLatencySim();
        if (!latency) {
          cb(data);
        } else {
          console.log(`simulating ${latency}ms of latency from server to client`);
          setTimeout(() => cb(data), latency);
        }
      });
    }
    wrapPush(view, opts, push) {
      let latency = this.getLatencySim();
      let oldJoinCount = view.joinCount;
      if (!latency) {
        if (this.isConnected() && opts.timeout) {
          return push().receive("timeout", () => {
            if (view.joinCount === oldJoinCount && !view.isDestroyed()) {
              this.reloadWithJitter(view, () => {
                this.log(view, "timeout", () => ["received timeout while communicating with server. Falling back to hard refresh for recovery"]);
              });
            }
          });
        } else {
          return push();
        }
      }
      console.log(`simulating ${latency}ms of latency from client to server`);
      let fakePush = {
        receives: [],
        receive(kind, cb) {
          this.receives.push([kind, cb]);
        }
      };
      setTimeout(() => {
        if (view.isDestroyed()) {
          return;
        }
        fakePush.receives.reduce((acc, [kind, cb]) => acc.receive(kind, cb), push());
      }, latency);
      return fakePush;
    }
    reloadWithJitter(view, log) {
      clearTimeout(this.reloadWithJitterTimer);
      this.disconnect();
      let minMs = this.reloadJitterMin;
      let maxMs = this.reloadJitterMax;
      let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
      let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, (count) => count + 1);
      if (tries > this.maxReloads) {
        afterMs = this.failsafeJitter;
      }
      this.reloadWithJitterTimer = setTimeout(() => {
        if (view.isDestroyed() || view.isConnected()) {
          return;
        }
        view.destroy();
        log ? log() : this.log(view, "join", () => [`encountered ${tries} consecutive reloads`]);
        if (tries > this.maxReloads) {
          this.log(view, "join", () => [`exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`]);
        }
        if (this.hasPendingLink()) {
          window.location = this.pendingLink;
        } else {
          window.location.reload();
        }
      }, afterMs);
    }
    getHookCallbacks(name) {
      return name && name.startsWith("Phoenix.") ? hooks_default[name.split(".")[1]] : this.hooks[name];
    }
    isUnloaded() {
      return this.unloaded;
    }
    isConnected() {
      return this.socket.isConnected();
    }
    getBindingPrefix() {
      return this.bindingPrefix;
    }
    binding(kind) {
      return `${this.getBindingPrefix()}${kind}`;
    }
    channel(topic, params) {
      return this.socket.channel(topic, params);
    }
    joinRootViews() {
      let rootsFound = false;
      dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, (rootEl) => {
        if (!this.getRootById(rootEl.id)) {
          let view = this.newRootView(rootEl);
          view.setHref(this.getHref());
          view.join();
          if (rootEl.getAttribute(PHX_MAIN)) {
            this.main = view;
          }
        }
        rootsFound = true;
      });
      return rootsFound;
    }
    redirect(to, flash) {
      this.disconnect();
      browser_default.redirect(to, flash);
    }
    replaceMain(href, flash, callback = null, linkRef = this.setPendingLink(href)) {
      this.outgoingMainEl = this.outgoingMainEl || this.main.el;
      let newMainEl = dom_default.cloneNode(this.outgoingMainEl, "");
      this.main.showLoader(this.loaderTimeout);
      this.main.destroy();
      this.main = this.newRootView(newMainEl, flash);
      this.main.setRedirect(href);
      this.transitionRemoves();
      this.main.join((joinCount, onDone) => {
        if (joinCount === 1 && this.commitPendingLink(linkRef)) {
          this.requestDOMUpdate(() => {
            dom_default.findPhxSticky(document).forEach((el) => newMainEl.appendChild(el));
            this.outgoingMainEl.replaceWith(newMainEl);
            this.outgoingMainEl = null;
            callback && requestAnimationFrame(callback);
            onDone();
          });
        }
      });
    }
    transitionRemoves(elements) {
      let removeAttr = this.binding("remove");
      elements = elements || dom_default.all(document, `[${removeAttr}]`);
      elements.forEach((el) => {
        if (document.body.contains(el)) {
          this.execJS(el, el.getAttribute(removeAttr), "remove");
        }
      });
    }
    isPhxView(el) {
      return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;
    }
    newRootView(el, flash) {
      let view = new View(el, this, null, flash);
      this.roots[view.id] = view;
      return view;
    }
    owner(childEl, callback) {
      let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), (el) => this.getViewByEl(el)) || this.main;
      if (view) {
        callback(view);
      }
    }
    withinOwners(childEl, callback) {
      this.owner(childEl, (view) => callback(view, childEl));
    }
    getViewByEl(el) {
      let rootId = el.getAttribute(PHX_ROOT_ID);
      return maybe(this.getRootById(rootId), (root) => root.getDescendentByEl(el));
    }
    getRootById(id) {
      return this.roots[id];
    }
    destroyAllViews() {
      for (let id in this.roots) {
        this.roots[id].destroy();
        delete this.roots[id];
      }
      this.main = null;
    }
    destroyViewByEl(el) {
      let root = this.getRootById(el.getAttribute(PHX_ROOT_ID));
      if (root && root.id === el.id) {
        root.destroy();
        delete this.roots[root.id];
      } else if (root) {
        root.destroyDescendent(el.id);
      }
    }
    setActiveElement(target) {
      if (this.activeElement === target) {
        return;
      }
      this.activeElement = target;
      let cancel = () => {
        if (target === this.activeElement) {
          this.activeElement = null;
        }
        target.removeEventListener("mouseup", this);
        target.removeEventListener("touchend", this);
      };
      target.addEventListener("mouseup", cancel);
      target.addEventListener("touchend", cancel);
    }
    getActiveElement() {
      if (document.activeElement === document.body) {
        return this.activeElement || document.activeElement;
      } else {
        return document.activeElement || document.body;
      }
    }
    dropActiveElement(view) {
      if (this.prevActive && view.ownsElement(this.prevActive)) {
        this.prevActive = null;
      }
    }
    restorePreviouslyActiveFocus() {
      if (this.prevActive && this.prevActive !== document.body) {
        this.prevActive.focus();
      }
    }
    blurActiveElement() {
      this.prevActive = this.getActiveElement();
      if (this.prevActive !== document.body) {
        this.prevActive.blur();
      }
    }
    bindTopLevelEvents() {
      if (this.boundTopLevelEvents) {
        return;
      }
      this.boundTopLevelEvents = true;
      this.socket.onClose((event) => {
        if (event && event.code === 1e3 && this.main) {
          this.reloadWithJitter(this.main);
        }
      });
      document.body.addEventListener("click", function() {
      });
      window.addEventListener("pageshow", (e) => {
        if (e.persisted) {
          this.getSocket().disconnect();
          this.withPageLoading({ to: window.location.href, kind: "redirect" });
          window.location.reload();
        }
      }, true);
      this.bindNav();
      this.bindClicks();
      this.bindForms();
      this.bind({ keyup: "keyup", keydown: "keydown" }, (e, type, view, targetEl, phxEvent, eventTarget) => {
        let matchKey = targetEl.getAttribute(this.binding(PHX_KEY));
        let pressedKey = e.key && e.key.toLowerCase();
        if (matchKey && matchKey.toLowerCase() !== pressedKey) {
          return;
        }
        let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
        js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
      });
      this.bind({ blur: "focusout", focus: "focusin" }, (e, type, view, targetEl, phxEvent, eventTarget) => {
        if (!eventTarget) {
          let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      this.bind({ blur: "blur", focus: "focus" }, (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) => {
        if (phxTarget === "window") {
          let data = this.eventMeta(type, e, targetEl);
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      window.addEventListener("dragover", (e) => e.preventDefault());
      window.addEventListener("drop", (e) => {
        e.preventDefault();
        let dropTargetId = maybe(closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)), (trueTarget) => {
          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));
        });
        let dropTarget = dropTargetId && document.getElementById(dropTargetId);
        let files = Array.from(e.dataTransfer.files || []);
        if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {
          return;
        }
        LiveUploader.trackFiles(dropTarget, files);
        dropTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
      this.on(PHX_TRACK_UPLOADS, (e) => {
        let uploadTarget = e.target;
        if (!dom_default.isUploadInput(uploadTarget)) {
          return;
        }
        let files = Array.from(e.detail.files || []).filter((f) => f instanceof File || f instanceof Blob);
        LiveUploader.trackFiles(uploadTarget, files);
        uploadTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
    }
    eventMeta(eventName, e, targetEl) {
      let callback = this.metadataCallbacks[eventName];
      return callback ? callback(e, targetEl) : {};
    }
    setPendingLink(href) {
      this.linkRef++;
      this.pendingLink = href;
      return this.linkRef;
    }
    commitPendingLink(linkRef) {
      if (this.linkRef !== linkRef) {
        return false;
      } else {
        this.href = this.pendingLink;
        this.pendingLink = null;
        return true;
      }
    }
    getHref() {
      return this.href;
    }
    hasPendingLink() {
      return !!this.pendingLink;
    }
    bind(events, callback) {
      for (let event in events) {
        let browserEventName = events[event];
        this.on(browserEventName, (e) => {
          let binding = this.binding(event);
          let windowBinding = this.binding(`window-${event}`);
          let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);
          if (targetPhxEvent) {
            this.debounce(e.target, e, browserEventName, () => {
              this.withinOwners(e.target, (view) => {
                callback(e, event, view, e.target, targetPhxEvent, null);
              });
            });
          } else {
            dom_default.all(document, `[${windowBinding}]`, (el) => {
              let phxEvent = el.getAttribute(windowBinding);
              this.debounce(el, e, browserEventName, () => {
                this.withinOwners(el, (view) => {
                  callback(e, event, view, el, phxEvent, "window");
                });
              });
            });
          }
        });
      }
    }
    bindClicks() {
      window.addEventListener("mousedown", (e) => this.clickStartedAtTarget = e.target);
      this.bindClick("click", "click", false);
      this.bindClick("mousedown", "capture-click", true);
    }
    bindClick(eventName, bindingName, capture) {
      let click = this.binding(bindingName);
      window.addEventListener(eventName, (e) => {
        let target = null;
        if (capture) {
          target = e.target.matches(`[${click}]`) ? e.target : e.target.querySelector(`[${click}]`);
        } else {
          let clickStartedAtTarget = this.clickStartedAtTarget || e.target;
          target = closestPhxBinding(clickStartedAtTarget, click);
          this.dispatchClickAway(e, clickStartedAtTarget);
          this.clickStartedAtTarget = null;
        }
        let phxEvent = target && target.getAttribute(click);
        if (!phxEvent) {
          return;
        }
        if (target.getAttribute("href") === "#") {
          e.preventDefault();
        }
        this.debounce(target, e, "click", () => {
          this.withinOwners(target, (view) => {
            js_default.exec("click", phxEvent, view, target, ["push", { data: this.eventMeta("click", e, target) }]);
          });
        });
      }, capture);
    }
    dispatchClickAway(e, clickStartedAt) {
      let phxClickAway = this.binding("click-away");
      dom_default.all(document, `[${phxClickAway}]`, (el) => {
        if (!(el.isSameNode(clickStartedAt) || el.contains(clickStartedAt))) {
          this.withinOwners(e.target, (view) => {
            let phxEvent = el.getAttribute(phxClickAway);
            if (js_default.isVisible(el)) {
              js_default.exec("click", phxEvent, view, el, ["push", { data: this.eventMeta("click", e, e.target) }]);
            }
          });
        }
      });
    }
    bindNav() {
      if (!browser_default.canPushState()) {
        return;
      }
      if (history.scrollRestoration) {
        history.scrollRestoration = "manual";
      }
      let scrollTimer = null;
      window.addEventListener("scroll", (_e) => {
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => {
          browser_default.updateCurrentState((state) => Object.assign(state, { scroll: window.scrollY }));
        }, 100);
      });
      window.addEventListener("popstate", (event) => {
        if (!this.registerNewLocation(window.location)) {
          return;
        }
        let { type, id, root, scroll: scroll2 } = event.state || {};
        let href = window.location.href;
        this.requestDOMUpdate(() => {
          if (this.main.isConnected() && (type === "patch" && id === this.main.id)) {
            this.main.pushLinkPatch(href, null);
          } else {
            this.replaceMain(href, null, () => {
              if (root) {
                this.replaceRootHistory();
              }
              if (typeof scroll2 === "number") {
                setTimeout(() => {
                  window.scrollTo(0, scroll2);
                }, 0);
              }
            });
          }
        });
      }, false);
      window.addEventListener("click", (e) => {
        let target = closestPhxBinding(e.target, PHX_LIVE_LINK);
        let type = target && target.getAttribute(PHX_LIVE_LINK);
        let wantsNewTab = e.metaKey || e.ctrlKey || e.button === 1;
        if (!type || !this.isConnected() || !this.main || wantsNewTab) {
          return;
        }
        let href = target.href;
        let linkState = target.getAttribute(PHX_LINK_STATE);
        e.preventDefault();
        e.stopImmediatePropagation();
        if (this.pendingLink === href) {
          return;
        }
        this.requestDOMUpdate(() => {
          if (type === "patch") {
            this.pushHistoryPatch(href, linkState, target);
          } else if (type === "redirect") {
            this.historyRedirect(href, linkState);
          } else {
            throw new Error(`expected ${PHX_LIVE_LINK} to be "patch" or "redirect", got: ${type}`);
          }
        });
      }, false);
    }
    dispatchEvent(event, payload = {}) {
      dom_default.dispatchEvent(window, `phx:${event}`, { detail: payload });
    }
    dispatchEvents(events) {
      events.forEach(([event, payload]) => this.dispatchEvent(event, payload));
    }
    withPageLoading(info, callback) {
      dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: info });
      let done = () => dom_default.dispatchEvent(window, "phx:page-loading-stop", { detail: info });
      return callback ? callback(done) : done;
    }
    pushHistoryPatch(href, linkState, targetEl) {
      this.withPageLoading({ to: href, kind: "patch" }, (done) => {
        this.main.pushLinkPatch(href, targetEl, (linkRef) => {
          this.historyPatch(href, linkState, linkRef);
          done();
        });
      });
    }
    historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {
      if (!this.commitPendingLink(linkRef)) {
        return;
      }
      browser_default.pushState(linkState, { type: "patch", id: this.main.id }, href);
      this.registerNewLocation(window.location);
    }
    historyRedirect(href, linkState, flash) {
      let scroll2 = window.scrollY;
      this.withPageLoading({ to: href, kind: "redirect" }, (done) => {
        this.replaceMain(href, flash, () => {
          browser_default.pushState(linkState, { type: "redirect", id: this.main.id, scroll: scroll2 }, href);
          this.registerNewLocation(window.location);
          done();
        });
      });
    }
    replaceRootHistory() {
      browser_default.pushState("replace", { root: true, type: "patch", id: this.main.id });
    }
    registerNewLocation(newLocation) {
      let { pathname, search } = this.currentLocation;
      if (pathname + search === newLocation.pathname + newLocation.search) {
        return false;
      } else {
        this.currentLocation = clone(newLocation);
        return true;
      }
    }
    bindForms() {
      let iterations = 0;
      this.on("submit", (e) => {
        let phxEvent = e.target.getAttribute(this.binding("submit"));
        if (!phxEvent) {
          return;
        }
        e.preventDefault();
        e.target.disabled = true;
        this.withinOwners(e.target, (view) => {
          js_default.exec("submit", phxEvent, view, e.target, ["push", {}]);
        });
      }, false);
      for (let type of ["change", "input"]) {
        this.on(type, (e) => {
          let phxChange = this.binding("change");
          let input = e.target;
          let inputEvent = input.getAttribute(phxChange);
          let formEvent = input.form && input.form.getAttribute(phxChange);
          let phxEvent = inputEvent || formEvent;
          if (!phxEvent) {
            return;
          }
          if (input.type === "number" && input.validity && input.validity.badInput) {
            return;
          }
          let dispatcher = inputEvent ? input : input.form;
          let currentIterations = iterations;
          iterations++;
          let { at, type: lastType } = dom_default.private(input, "prev-iteration") || {};
          if (at === currentIterations - 1 && type !== lastType) {
            return;
          }
          dom_default.putPrivate(input, "prev-iteration", { at: currentIterations, type });
          this.debounce(input, e, type, () => {
            this.withinOwners(dispatcher, (view) => {
              dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);
              if (!dom_default.isTextualInput(input)) {
                this.setActiveElement(input);
              }
              js_default.exec("change", phxEvent, view, input, ["push", { _target: e.target.name, dispatcher }]);
            });
          });
        }, false);
      }
    }
    debounce(el, event, eventType, callback) {
      if (eventType === "blur" || eventType === "focusout") {
        return callback();
      }
      let phxDebounce = this.binding(PHX_DEBOUNCE);
      let phxThrottle = this.binding(PHX_THROTTLE);
      let defaultDebounce = this.defaults.debounce.toString();
      let defaultThrottle = this.defaults.throttle.toString();
      this.withinOwners(el, (view) => {
        let asyncFilter = () => !view.isDestroyed() && document.body.contains(el);
        dom_default.debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, () => {
          callback();
        });
      });
    }
    silenceEvents(callback) {
      this.silenced = true;
      callback();
      this.silenced = false;
    }
    on(event, callback) {
      window.addEventListener(event, (e) => {
        if (!this.silenced) {
          callback(e);
        }
      });
    }
  };
  var TransitionSet = class {
    constructor() {
      this.transitions = /* @__PURE__ */ new Set();
      this.pendingOps = [];
      this.reset();
    }
    reset() {
      this.transitions.forEach((timer) => {
        cancelTimeout(timer);
        this.transitions.delete(timer);
      });
      this.flushPendingOps();
    }
    after(callback) {
      if (this.size() === 0) {
        callback();
      } else {
        this.pushPendingOp(callback);
      }
    }
    addTransition(time, onStart, onDone) {
      onStart();
      let timer = setTimeout(() => {
        this.transitions.delete(timer);
        onDone();
        if (this.size() === 0) {
          this.flushPendingOps();
        }
      }, time);
      this.transitions.add(timer);
    }
    pushPendingOp(op) {
      this.pendingOps.push(op);
    }
    size() {
      return this.transitions.size;
    }
    flushPendingOps() {
      this.pendingOps.forEach((op) => op());
      this.pendingOps = [];
    }
  };

  // js/app.js
  var import_topbar = __toESM(require_topbar());

  // node_modules/uplot/dist/uPlot.esm.js
  var FEAT_TIME = true;
  var pre = "u-";
  var UPLOT = "uplot";
  var ORI_HZ = pre + "hz";
  var ORI_VT = pre + "vt";
  var TITLE2 = pre + "title";
  var WRAP = pre + "wrap";
  var UNDER = pre + "under";
  var OVER = pre + "over";
  var AXIS = pre + "axis";
  var OFF = pre + "off";
  var SELECT = pre + "select";
  var CURSOR_X = pre + "cursor-x";
  var CURSOR_Y = pre + "cursor-y";
  var CURSOR_PT = pre + "cursor-pt";
  var LEGEND = pre + "legend";
  var LEGEND_LIVE = pre + "live";
  var LEGEND_INLINE = pre + "inline";
  var LEGEND_THEAD = pre + "thead";
  var LEGEND_SERIES = pre + "series";
  var LEGEND_MARKER = pre + "marker";
  var LEGEND_LABEL = pre + "label";
  var LEGEND_VALUE = pre + "value";
  var WIDTH = "width";
  var HEIGHT = "height";
  var TOP = "top";
  var BOTTOM = "bottom";
  var LEFT = "left";
  var RIGHT = "right";
  var hexBlack = "#000";
  var transparent = hexBlack + "0";
  var mousemove = "mousemove";
  var mousedown = "mousedown";
  var mouseup = "mouseup";
  var mouseenter = "mouseenter";
  var mouseleave = "mouseleave";
  var dblclick = "dblclick";
  var resize = "resize";
  var scroll = "scroll";
  var change = "change";
  var dppxchange = "dppxchange";
  var domEnv = typeof window != "undefined";
  var doc2 = domEnv ? document : null;
  var win = domEnv ? window : null;
  var nav = domEnv ? navigator : null;
  var pxRatio;
  var query;
  function setPxRatio() {
    let _pxRatio = devicePixelRatio;
    if (pxRatio != _pxRatio) {
      pxRatio = _pxRatio;
      query && off(change, query, setPxRatio);
      query = matchMedia(`(min-resolution: ${pxRatio - 1e-3}dppx) and (max-resolution: ${pxRatio + 1e-3}dppx)`);
      on(change, query, setPxRatio);
      win.dispatchEvent(new CustomEvent(dppxchange));
    }
  }
  function addClass(el, c) {
    if (c != null) {
      let cl = el.classList;
      !cl.contains(c) && cl.add(c);
    }
  }
  function remClass(el, c) {
    let cl = el.classList;
    cl.contains(c) && cl.remove(c);
  }
  function setStylePx(el, name, value) {
    el.style[name] = value + "px";
  }
  function placeTag(tag, cls, targ, refEl) {
    let el = doc2.createElement(tag);
    if (cls != null)
      addClass(el, cls);
    if (targ != null)
      targ.insertBefore(el, refEl);
    return el;
  }
  function placeDiv(cls, targ) {
    return placeTag("div", cls, targ);
  }
  var xformCache = /* @__PURE__ */ new WeakMap();
  function elTrans(el, xPos, yPos, xMax, yMax) {
    let xform = "translate(" + xPos + "px," + yPos + "px)";
    let xformOld = xformCache.get(el);
    if (xform != xformOld) {
      el.style.transform = xform;
      xformCache.set(el, xform);
      if (xPos < 0 || yPos < 0 || xPos > xMax || yPos > yMax)
        addClass(el, OFF);
      else
        remClass(el, OFF);
    }
  }
  var colorCache = /* @__PURE__ */ new WeakMap();
  function elColor(el, background, borderColor) {
    let newColor = background + borderColor;
    let oldColor = colorCache.get(el);
    if (newColor != oldColor) {
      colorCache.set(el, newColor);
      el.style.background = background;
      el.style.borderColor = borderColor;
    }
  }
  var sizeCache = /* @__PURE__ */ new WeakMap();
  function elSize(el, newWid, newHgt, centered) {
    let newSize = newWid + "" + newHgt;
    let oldSize = sizeCache.get(el);
    if (newSize != oldSize) {
      sizeCache.set(el, newSize);
      el.style.height = newHgt + "px";
      el.style.width = newWid + "px";
      el.style.marginLeft = centered ? -newWid / 2 + "px" : 0;
      el.style.marginTop = centered ? -newHgt / 2 + "px" : 0;
    }
  }
  var evOpts = { passive: true };
  var evOpts2 = __spreadProps(__spreadValues({}, evOpts), { capture: true });
  function on(ev, el, cb, capt) {
    el.addEventListener(ev, cb, capt ? evOpts2 : evOpts);
  }
  function off(ev, el, cb, capt) {
    el.removeEventListener(ev, cb, capt ? evOpts2 : evOpts);
  }
  domEnv && setPxRatio();
  function closestIdx(num, arr, lo, hi) {
    let mid;
    lo = lo || 0;
    hi = hi || arr.length - 1;
    let bitwise = hi <= 2147483647;
    while (hi - lo > 1) {
      mid = bitwise ? lo + hi >> 1 : floor((lo + hi) / 2);
      if (arr[mid] < num)
        lo = mid;
      else
        hi = mid;
    }
    if (num - arr[lo] <= arr[hi] - num)
      return lo;
    return hi;
  }
  function nonNullIdx(data, _i0, _i1, dir) {
    for (let i = dir == 1 ? _i0 : _i1; i >= _i0 && i <= _i1; i += dir) {
      if (data[i] != null)
        return i;
    }
    return -1;
  }
  function getMinMax(data, _i0, _i1, sorted) {
    let _min = inf;
    let _max = -inf;
    if (sorted == 1) {
      _min = data[_i0];
      _max = data[_i1];
    } else if (sorted == -1) {
      _min = data[_i1];
      _max = data[_i0];
    } else {
      for (let i = _i0; i <= _i1; i++) {
        if (data[i] != null) {
          _min = min(_min, data[i]);
          _max = max(_max, data[i]);
        }
      }
    }
    return [_min, _max];
  }
  function getMinMaxLog(data, _i0, _i1) {
    let _min = inf;
    let _max = -inf;
    for (let i = _i0; i <= _i1; i++) {
      if (data[i] > 0) {
        _min = min(_min, data[i]);
        _max = max(_max, data[i]);
      }
    }
    return [
      _min == inf ? 1 : _min,
      _max == -inf ? 10 : _max
    ];
  }
  var _fixedTuple = [0, 0];
  function fixIncr(minIncr, maxIncr, minExp, maxExp) {
    _fixedTuple[0] = minExp < 0 ? roundDec(minIncr, -minExp) : minIncr;
    _fixedTuple[1] = maxExp < 0 ? roundDec(maxIncr, -maxExp) : maxIncr;
    return _fixedTuple;
  }
  function rangeLog(min2, max2, base, fullMags) {
    let minSign = sign(min2);
    let logFn = base == 10 ? log10 : log2;
    if (min2 == max2) {
      if (minSign == -1) {
        min2 *= base;
        max2 /= base;
      } else {
        min2 /= base;
        max2 *= base;
      }
    }
    let minExp, maxExp, minMaxIncrs;
    if (fullMags) {
      minExp = floor(logFn(min2));
      maxExp = ceil(logFn(max2));
      minMaxIncrs = fixIncr(pow(base, minExp), pow(base, maxExp), minExp, maxExp);
      min2 = minMaxIncrs[0];
      max2 = minMaxIncrs[1];
    } else {
      minExp = floor(logFn(abs(min2)));
      maxExp = floor(logFn(abs(max2)));
      minMaxIncrs = fixIncr(pow(base, minExp), pow(base, maxExp), minExp, maxExp);
      min2 = incrRoundDn(min2, minMaxIncrs[0]);
      max2 = incrRoundUp(max2, minMaxIncrs[1]);
    }
    return [min2, max2];
  }
  function rangeAsinh(min2, max2, base, fullMags) {
    let minMax = rangeLog(min2, max2, base, fullMags);
    if (min2 == 0)
      minMax[0] = 0;
    if (max2 == 0)
      minMax[1] = 0;
    return minMax;
  }
  var rangePad = 0.1;
  var autoRangePart = {
    mode: 3,
    pad: rangePad
  };
  var _eqRangePart = {
    pad: 0,
    soft: null,
    mode: 0
  };
  var _eqRange = {
    min: _eqRangePart,
    max: _eqRangePart
  };
  function rangeNum(_min, _max, mult, extra) {
    if (isObj(mult))
      return _rangeNum(_min, _max, mult);
    _eqRangePart.pad = mult;
    _eqRangePart.soft = extra ? 0 : null;
    _eqRangePart.mode = extra ? 3 : 0;
    return _rangeNum(_min, _max, _eqRange);
  }
  function ifNull(lh, rh) {
    return lh == null ? rh : lh;
  }
  function hasData(data, idx0, idx1) {
    idx0 = ifNull(idx0, 0);
    idx1 = ifNull(idx1, data.length - 1);
    while (idx0 <= idx1) {
      if (data[idx0] != null)
        return true;
      idx0++;
    }
    return false;
  }
  function _rangeNum(_min, _max, cfg) {
    let cmin = cfg.min;
    let cmax = cfg.max;
    let padMin = ifNull(cmin.pad, 0);
    let padMax = ifNull(cmax.pad, 0);
    let hardMin = ifNull(cmin.hard, -inf);
    let hardMax = ifNull(cmax.hard, inf);
    let softMin = ifNull(cmin.soft, inf);
    let softMax = ifNull(cmax.soft, -inf);
    let softMinMode = ifNull(cmin.mode, 0);
    let softMaxMode = ifNull(cmax.mode, 0);
    let delta = _max - _min;
    if (delta < 1e-9) {
      delta = 0;
      if (_min == 0 || _max == 0) {
        delta = 1e-9;
        if (softMinMode == 2 && softMin != inf)
          padMin = 0;
        if (softMaxMode == 2 && softMax != -inf)
          padMax = 0;
      }
    }
    let nonZeroDelta = delta || abs(_max) || 1e3;
    let mag = log10(nonZeroDelta);
    let base = pow(10, floor(mag));
    let _padMin = nonZeroDelta * (delta == 0 ? _min == 0 ? 0.1 : 1 : padMin);
    let _newMin = roundDec(incrRoundDn(_min - _padMin, base / 10), 9);
    let _softMin = _min >= softMin && (softMinMode == 1 || softMinMode == 3 && _newMin <= softMin || softMinMode == 2 && _newMin >= softMin) ? softMin : inf;
    let minLim = max(hardMin, _newMin < _softMin && _min >= _softMin ? _softMin : min(_softMin, _newMin));
    let _padMax = nonZeroDelta * (delta == 0 ? _max == 0 ? 0.1 : 1 : padMax);
    let _newMax = roundDec(incrRoundUp(_max + _padMax, base / 10), 9);
    let _softMax = _max <= softMax && (softMaxMode == 1 || softMaxMode == 3 && _newMax >= softMax || softMaxMode == 2 && _newMax <= softMax) ? softMax : -inf;
    let maxLim = min(hardMax, _newMax > _softMax && _max <= _softMax ? _softMax : max(_softMax, _newMax));
    if (minLim == maxLim && minLim == 0)
      maxLim = 100;
    return [minLim, maxLim];
  }
  var numFormatter = new Intl.NumberFormat(domEnv ? nav.language : "en-US");
  var fmtNum = (val) => numFormatter.format(val);
  var M = Math;
  var PI = M.PI;
  var abs = M.abs;
  var floor = M.floor;
  var round = M.round;
  var ceil = M.ceil;
  var min = M.min;
  var max = M.max;
  var pow = M.pow;
  var sign = M.sign;
  var log10 = M.log10;
  var log2 = M.log2;
  var sinh = (v, linthresh = 1) => M.sinh(v) * linthresh;
  var asinh = (v, linthresh = 1) => M.asinh(v / linthresh);
  var inf = Infinity;
  function numIntDigits(x) {
    return (log10((x ^ x >> 31) - (x >> 31)) | 0) + 1;
  }
  function incrRound(num, incr) {
    return round(num / incr) * incr;
  }
  function clamp(num, _min, _max) {
    return min(max(num, _min), _max);
  }
  function fnOrSelf(v) {
    return typeof v == "function" ? v : () => v;
  }
  var retArg0 = (_0) => _0;
  var retArg1 = (_0, _1) => _1;
  var retNull = (_2) => null;
  var retTrue = (_2) => true;
  var retEq = (a, b) => a == b;
  function incrRoundUp(num, incr) {
    return ceil(num / incr) * incr;
  }
  function incrRoundDn(num, incr) {
    return floor(num / incr) * incr;
  }
  function roundDec(val, dec) {
    return round(val * (dec = 10 ** dec)) / dec;
  }
  var fixedDec = /* @__PURE__ */ new Map();
  function guessDec(num) {
    return (("" + num).split(".")[1] || "").length;
  }
  function genIncrs(base, minExp, maxExp, mults) {
    let incrs = [];
    let multDec = mults.map(guessDec);
    for (let exp = minExp; exp < maxExp; exp++) {
      let expa = abs(exp);
      let mag = roundDec(pow(base, exp), expa);
      for (let i = 0; i < mults.length; i++) {
        let _incr = mults[i] * mag;
        let dec = (_incr >= 0 && exp >= 0 ? 0 : expa) + (exp >= multDec[i] ? 0 : multDec[i]);
        let incr = roundDec(_incr, dec);
        incrs.push(incr);
        fixedDec.set(incr, dec);
      }
    }
    return incrs;
  }
  var EMPTY_OBJ = {};
  var EMPTY_ARR = [];
  var nullNullTuple = [null, null];
  var isArr = Array.isArray;
  function isStr(v) {
    return typeof v == "string";
  }
  function isObj(v) {
    let is = false;
    if (v != null) {
      let c = v.constructor;
      is = c == null || c == Object;
    }
    return is;
  }
  function fastIsObj(v) {
    return v != null && typeof v == "object";
  }
  var TypedArray = Object.getPrototypeOf(Uint8Array);
  function copy(o, _isObj = isObj) {
    let out;
    if (isArr(o)) {
      let val = o.find((v) => v != null);
      if (isArr(val) || _isObj(val)) {
        out = Array(o.length);
        for (let i = 0; i < o.length; i++)
          out[i] = copy(o[i], _isObj);
      } else
        out = o.slice();
    } else if (o instanceof TypedArray)
      out = o.slice();
    else if (_isObj(o)) {
      out = {};
      for (let k in o)
        out[k] = copy(o[k], _isObj);
    } else
      out = o;
    return out;
  }
  function assign(targ) {
    let args = arguments;
    for (let i = 1; i < args.length; i++) {
      let src = args[i];
      for (let key in src) {
        if (isObj(targ[key]))
          assign(targ[key], copy(src[key]));
        else
          targ[key] = copy(src[key]);
      }
    }
    return targ;
  }
  var NULL_REMOVE = 0;
  var NULL_RETAIN = 1;
  var NULL_EXPAND = 2;
  function nullExpand(yVals, nullIdxs, alignedLen) {
    for (let i = 0, xi, lastNullIdx = -1; i < nullIdxs.length; i++) {
      let nullIdx = nullIdxs[i];
      if (nullIdx > lastNullIdx) {
        xi = nullIdx - 1;
        while (xi >= 0 && yVals[xi] == null)
          yVals[xi--] = null;
        xi = nullIdx + 1;
        while (xi < alignedLen && yVals[xi] == null)
          yVals[lastNullIdx = xi++] = null;
      }
    }
  }
  function join(tables, nullModes) {
    let xVals = /* @__PURE__ */ new Set();
    for (let ti = 0; ti < tables.length; ti++) {
      let t = tables[ti];
      let xs = t[0];
      let len = xs.length;
      for (let i = 0; i < len; i++)
        xVals.add(xs[i]);
    }
    let data = [Array.from(xVals).sort((a, b) => a - b)];
    let alignedLen = data[0].length;
    let xIdxs = /* @__PURE__ */ new Map();
    for (let i = 0; i < alignedLen; i++)
      xIdxs.set(data[0][i], i);
    for (let ti = 0; ti < tables.length; ti++) {
      let t = tables[ti];
      let xs = t[0];
      for (let si = 1; si < t.length; si++) {
        let ys = t[si];
        let yVals = Array(alignedLen).fill(void 0);
        let nullMode = nullModes ? nullModes[ti][si] : NULL_RETAIN;
        let nullIdxs = [];
        for (let i = 0; i < ys.length; i++) {
          let yVal = ys[i];
          let alignedIdx = xIdxs.get(xs[i]);
          if (yVal === null) {
            if (nullMode != NULL_REMOVE) {
              yVals[alignedIdx] = yVal;
              if (nullMode == NULL_EXPAND)
                nullIdxs.push(alignedIdx);
            }
          } else
            yVals[alignedIdx] = yVal;
        }
        nullExpand(yVals, nullIdxs, alignedLen);
        data.push(yVals);
      }
    }
    return data;
  }
  var microTask = typeof queueMicrotask == "undefined" ? (fn) => Promise.resolve().then(fn) : queueMicrotask;
  var months = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];
  var days = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ];
  function slice3(str) {
    return str.slice(0, 3);
  }
  var days3 = days.map(slice3);
  var months3 = months.map(slice3);
  var engNames = {
    MMMM: months,
    MMM: months3,
    WWWW: days,
    WWW: days3
  };
  function zeroPad2(int) {
    return (int < 10 ? "0" : "") + int;
  }
  function zeroPad3(int) {
    return (int < 10 ? "00" : int < 100 ? "0" : "") + int;
  }
  var subs = {
    YYYY: (d) => d.getFullYear(),
    YY: (d) => (d.getFullYear() + "").slice(2),
    MMMM: (d, names) => names.MMMM[d.getMonth()],
    MMM: (d, names) => names.MMM[d.getMonth()],
    MM: (d) => zeroPad2(d.getMonth() + 1),
    M: (d) => d.getMonth() + 1,
    DD: (d) => zeroPad2(d.getDate()),
    D: (d) => d.getDate(),
    WWWW: (d, names) => names.WWWW[d.getDay()],
    WWW: (d, names) => names.WWW[d.getDay()],
    HH: (d) => zeroPad2(d.getHours()),
    H: (d) => d.getHours(),
    h: (d) => {
      let h = d.getHours();
      return h == 0 ? 12 : h > 12 ? h - 12 : h;
    },
    AA: (d) => d.getHours() >= 12 ? "PM" : "AM",
    aa: (d) => d.getHours() >= 12 ? "pm" : "am",
    a: (d) => d.getHours() >= 12 ? "p" : "a",
    mm: (d) => zeroPad2(d.getMinutes()),
    m: (d) => d.getMinutes(),
    ss: (d) => zeroPad2(d.getSeconds()),
    s: (d) => d.getSeconds(),
    fff: (d) => zeroPad3(d.getMilliseconds())
  };
  function fmtDate(tpl, names) {
    names = names || engNames;
    let parts = [];
    let R = /\{([a-z]+)\}|[^{]+/gi, m;
    while (m = R.exec(tpl))
      parts.push(m[0][0] == "{" ? subs[m[1]] : m[0]);
    return (d) => {
      let out = "";
      for (let i = 0; i < parts.length; i++)
        out += typeof parts[i] == "string" ? parts[i] : parts[i](d, names);
      return out;
    };
  }
  var localTz = new Intl.DateTimeFormat().resolvedOptions().timeZone;
  function tzDate(date, tz) {
    let date2;
    if (tz == "UTC" || tz == "Etc/UTC")
      date2 = new Date(+date + date.getTimezoneOffset() * 6e4);
    else if (tz == localTz)
      date2 = date;
    else {
      date2 = new Date(date.toLocaleString("en-US", { timeZone: tz }));
      date2.setMilliseconds(date.getMilliseconds());
    }
    return date2;
  }
  var onlyWhole = (v) => v % 1 == 0;
  var allMults = [1, 2, 2.5, 5];
  var decIncrs = genIncrs(10, -16, 0, allMults);
  var oneIncrs = genIncrs(10, 0, 16, allMults);
  var wholeIncrs = oneIncrs.filter(onlyWhole);
  var numIncrs = decIncrs.concat(oneIncrs);
  var NL = "\n";
  var yyyy = "{YYYY}";
  var NLyyyy = NL + yyyy;
  var md = "{M}/{D}";
  var NLmd = NL + md;
  var NLmdyy = NLmd + "/{YY}";
  var aa = "{aa}";
  var hmm = "{h}:{mm}";
  var hmmaa = hmm + aa;
  var NLhmmaa = NL + hmmaa;
  var ss = ":{ss}";
  var _ = null;
  function genTimeStuffs(ms) {
    let s = ms * 1e3, m = s * 60, h = m * 60, d = h * 24, mo = d * 30, y = d * 365;
    let subSecIncrs = ms == 1 ? genIncrs(10, 0, 3, allMults).filter(onlyWhole) : genIncrs(10, -3, 0, allMults);
    let timeIncrs = subSecIncrs.concat([
      s,
      s * 5,
      s * 10,
      s * 15,
      s * 30,
      m,
      m * 5,
      m * 10,
      m * 15,
      m * 30,
      h,
      h * 2,
      h * 3,
      h * 4,
      h * 6,
      h * 8,
      h * 12,
      d,
      d * 2,
      d * 3,
      d * 4,
      d * 5,
      d * 6,
      d * 7,
      d * 8,
      d * 9,
      d * 10,
      d * 15,
      mo,
      mo * 2,
      mo * 3,
      mo * 4,
      mo * 6,
      y,
      y * 2,
      y * 5,
      y * 10,
      y * 25,
      y * 50,
      y * 100
    ]);
    const _timeAxisStamps = [
      [y, yyyy, _, _, _, _, _, _, 1],
      [d * 28, "{MMM}", NLyyyy, _, _, _, _, _, 1],
      [d, md, NLyyyy, _, _, _, _, _, 1],
      [h, "{h}" + aa, NLmdyy, _, NLmd, _, _, _, 1],
      [m, hmmaa, NLmdyy, _, NLmd, _, _, _, 1],
      [s, ss, NLmdyy + " " + hmmaa, _, NLmd + " " + hmmaa, _, NLhmmaa, _, 1],
      [ms, ss + ".{fff}", NLmdyy + " " + hmmaa, _, NLmd + " " + hmmaa, _, NLhmmaa, _, 1]
    ];
    function timeAxisSplits(tzDate2) {
      return (self2, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace) => {
        let splits = [];
        let isYr = foundIncr >= y;
        let isMo = foundIncr >= mo && foundIncr < y;
        let minDate = tzDate2(scaleMin);
        let minDateTs = roundDec(minDate * ms, 3);
        let minMin = mkDate(minDate.getFullYear(), isYr ? 0 : minDate.getMonth(), isMo || isYr ? 1 : minDate.getDate());
        let minMinTs = roundDec(minMin * ms, 3);
        if (isMo || isYr) {
          let moIncr = isMo ? foundIncr / mo : 0;
          let yrIncr = isYr ? foundIncr / y : 0;
          let split = minDateTs == minMinTs ? minDateTs : roundDec(mkDate(minMin.getFullYear() + yrIncr, minMin.getMonth() + moIncr, 1) * ms, 3);
          let splitDate = new Date(round(split / ms));
          let baseYear = splitDate.getFullYear();
          let baseMonth = splitDate.getMonth();
          for (let i = 0; split <= scaleMax; i++) {
            let next = mkDate(baseYear + yrIncr * i, baseMonth + moIncr * i, 1);
            let offs = next - tzDate2(roundDec(next * ms, 3));
            split = roundDec((+next + offs) * ms, 3);
            if (split <= scaleMax)
              splits.push(split);
          }
        } else {
          let incr0 = foundIncr >= d ? d : foundIncr;
          let tzOffset = floor(scaleMin) - floor(minDateTs);
          let split = minMinTs + tzOffset + incrRoundUp(minDateTs - minMinTs, incr0);
          splits.push(split);
          let date0 = tzDate2(split);
          let prevHour = date0.getHours() + date0.getMinutes() / m + date0.getSeconds() / h;
          let incrHours = foundIncr / h;
          let minSpace = self2.axes[axisIdx]._space;
          let pctSpace = foundSpace / minSpace;
          while (1) {
            split = roundDec(split + foundIncr, ms == 1 ? 0 : 3);
            if (split > scaleMax)
              break;
            if (incrHours > 1) {
              let expectedHour = floor(roundDec(prevHour + incrHours, 6)) % 24;
              let splitDate = tzDate2(split);
              let actualHour = splitDate.getHours();
              let dstShift = actualHour - expectedHour;
              if (dstShift > 1)
                dstShift = -1;
              split -= dstShift * h;
              prevHour = (prevHour + incrHours) % 24;
              let prevSplit = splits[splits.length - 1];
              let pctIncr = roundDec((split - prevSplit) / foundIncr, 3);
              if (pctIncr * pctSpace >= 0.7)
                splits.push(split);
            } else
              splits.push(split);
          }
        }
        return splits;
      };
    }
    return [
      timeIncrs,
      _timeAxisStamps,
      timeAxisSplits
    ];
  }
  var [timeIncrsMs, _timeAxisStampsMs, timeAxisSplitsMs] = genTimeStuffs(1);
  var [timeIncrsS, _timeAxisStampsS, timeAxisSplitsS] = genTimeStuffs(1e-3);
  genIncrs(2, -53, 53, [1]);
  function timeAxisStamps(stampCfg, fmtDate2) {
    return stampCfg.map((s) => s.map((v, i) => i == 0 || i == 8 || v == null ? v : fmtDate2(i == 1 || s[8] == 0 ? v : s[1] + v)));
  }
  function timeAxisVals(tzDate2, stamps) {
    return (self2, splits, axisIdx, foundSpace, foundIncr) => {
      let s = stamps.find((s2) => foundIncr >= s2[0]) || stamps[stamps.length - 1];
      let prevYear;
      let prevMnth;
      let prevDate;
      let prevHour;
      let prevMins;
      let prevSecs;
      return splits.map((split) => {
        let date = tzDate2(split);
        let newYear = date.getFullYear();
        let newMnth = date.getMonth();
        let newDate = date.getDate();
        let newHour = date.getHours();
        let newMins = date.getMinutes();
        let newSecs = date.getSeconds();
        let stamp = newYear != prevYear && s[2] || newMnth != prevMnth && s[3] || newDate != prevDate && s[4] || newHour != prevHour && s[5] || newMins != prevMins && s[6] || newSecs != prevSecs && s[7] || s[1];
        prevYear = newYear;
        prevMnth = newMnth;
        prevDate = newDate;
        prevHour = newHour;
        prevMins = newMins;
        prevSecs = newSecs;
        return stamp(date);
      });
    };
  }
  function timeAxisVal(tzDate2, dateTpl) {
    let stamp = fmtDate(dateTpl);
    return (self2, splits, axisIdx, foundSpace, foundIncr) => splits.map((split) => stamp(tzDate2(split)));
  }
  function mkDate(y, m, d) {
    return new Date(y, m, d);
  }
  function timeSeriesStamp(stampCfg, fmtDate2) {
    return fmtDate2(stampCfg);
  }
  var _timeSeriesStamp = "{YYYY}-{MM}-{DD} {h}:{mm}{aa}";
  function timeSeriesVal(tzDate2, stamp) {
    return (self2, val) => stamp(tzDate2(val));
  }
  function legendStroke(self2, seriesIdx) {
    let s = self2.series[seriesIdx];
    return s.width ? s.stroke(self2, seriesIdx) : s.points.width ? s.points.stroke(self2, seriesIdx) : null;
  }
  function legendFill(self2, seriesIdx) {
    return self2.series[seriesIdx].fill(self2, seriesIdx);
  }
  var legendOpts = {
    show: true,
    live: true,
    isolate: false,
    markers: {
      show: true,
      width: 2,
      stroke: legendStroke,
      fill: legendFill,
      dash: "solid"
    },
    idx: null,
    idxs: null,
    values: []
  };
  function cursorPointShow(self2, si) {
    let o = self2.cursor.points;
    let pt = placeDiv();
    let size = o.size(self2, si);
    setStylePx(pt, WIDTH, size);
    setStylePx(pt, HEIGHT, size);
    let mar = size / -2;
    setStylePx(pt, "marginLeft", mar);
    setStylePx(pt, "marginTop", mar);
    let width = o.width(self2, si, size);
    width && setStylePx(pt, "borderWidth", width);
    return pt;
  }
  function cursorPointFill(self2, si) {
    let sp = self2.series[si].points;
    return sp._fill || sp._stroke;
  }
  function cursorPointStroke(self2, si) {
    let sp = self2.series[si].points;
    return sp._stroke || sp._fill;
  }
  function cursorPointSize(self2, si) {
    let sp = self2.series[si].points;
    return ptDia(sp.width, 1);
  }
  function dataIdx(self2, seriesIdx, cursorIdx) {
    return cursorIdx;
  }
  var moveTuple = [0, 0];
  function cursorMove(self2, mouseLeft1, mouseTop1) {
    moveTuple[0] = mouseLeft1;
    moveTuple[1] = mouseTop1;
    return moveTuple;
  }
  function filtBtn0(self2, targ, handle) {
    return (e) => {
      e.button == 0 && handle(e);
    };
  }
  function passThru(self2, targ, handle) {
    return handle;
  }
  var cursorOpts = {
    show: true,
    x: true,
    y: true,
    lock: false,
    move: cursorMove,
    points: {
      show: cursorPointShow,
      size: cursorPointSize,
      width: 0,
      stroke: cursorPointStroke,
      fill: cursorPointFill
    },
    bind: {
      mousedown: filtBtn0,
      mouseup: filtBtn0,
      click: filtBtn0,
      dblclick: filtBtn0,
      mousemove: passThru,
      mouseleave: passThru,
      mouseenter: passThru
    },
    drag: {
      setScale: true,
      x: true,
      y: false,
      dist: 0,
      uni: null,
      _x: false,
      _y: false
    },
    focus: {
      prox: -1
    },
    left: -10,
    top: -10,
    idx: null,
    dataIdx,
    idxs: null
  };
  var axisLines = {
    show: true,
    stroke: "rgba(0,0,0,0.07)",
    width: 2
  };
  var grid = assign({}, axisLines, {
    filter: retArg1
  });
  var ticks = assign({}, grid, {
    size: 10
  });
  var border = assign({}, axisLines, {
    show: false
  });
  var font = '12px system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"';
  var labelFont = "bold " + font;
  var lineMult = 1.5;
  var xAxisOpts = {
    show: true,
    scale: "x",
    stroke: hexBlack,
    space: 50,
    gap: 5,
    size: 50,
    labelGap: 0,
    labelSize: 30,
    labelFont,
    side: 2,
    grid,
    ticks,
    border,
    font,
    rotate: 0
  };
  var numSeriesLabel = "Value";
  var timeSeriesLabel = "Time";
  var xSeriesOpts = {
    show: true,
    scale: "x",
    auto: false,
    sorted: 1,
    min: inf,
    max: -inf,
    idxs: []
  };
  function numAxisVals(self2, splits, axisIdx, foundSpace, foundIncr) {
    return splits.map((v) => v == null ? "" : fmtNum(v));
  }
  function numAxisSplits(self2, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {
    let splits = [];
    let numDec = fixedDec.get(foundIncr) || 0;
    scaleMin = forceMin ? scaleMin : roundDec(incrRoundUp(scaleMin, foundIncr), numDec);
    for (let val = scaleMin; val <= scaleMax; val = roundDec(val + foundIncr, numDec))
      splits.push(Object.is(val, -0) ? 0 : val);
    return splits;
  }
  function logAxisSplits(self2, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {
    const splits = [];
    const logBase = self2.scales[self2.axes[axisIdx].scale].log;
    const logFn = logBase == 10 ? log10 : log2;
    const exp = floor(logFn(scaleMin));
    foundIncr = pow(logBase, exp);
    if (exp < 0)
      foundIncr = roundDec(foundIncr, -exp);
    let split = scaleMin;
    do {
      splits.push(split);
      split = roundDec(split + foundIncr, fixedDec.get(foundIncr));
      if (split >= foundIncr * logBase)
        foundIncr = split;
    } while (split <= scaleMax);
    return splits;
  }
  function asinhAxisSplits(self2, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {
    let sc = self2.scales[self2.axes[axisIdx].scale];
    let linthresh = sc.asinh;
    let posSplits = scaleMax > linthresh ? logAxisSplits(self2, axisIdx, max(linthresh, scaleMin), scaleMax, foundIncr) : [linthresh];
    let zero = scaleMax >= 0 && scaleMin <= 0 ? [0] : [];
    let negSplits = scaleMin < -linthresh ? logAxisSplits(self2, axisIdx, max(linthresh, -scaleMax), -scaleMin, foundIncr) : [linthresh];
    return negSplits.reverse().map((v) => -v).concat(zero, posSplits);
  }
  var RE_ALL = /./;
  var RE_12357 = /[12357]/;
  var RE_125 = /[125]/;
  var RE_1 = /1/;
  function logAxisValsFilt(self2, splits, axisIdx, foundSpace, foundIncr) {
    let axis = self2.axes[axisIdx];
    let scaleKey = axis.scale;
    let sc = self2.scales[scaleKey];
    if (sc.distr == 3 && sc.log == 2)
      return splits;
    let valToPos = self2.valToPos;
    let minSpace = axis._space;
    let _10 = valToPos(10, scaleKey);
    let re = valToPos(9, scaleKey) - _10 >= minSpace ? RE_ALL : valToPos(7, scaleKey) - _10 >= minSpace ? RE_12357 : valToPos(5, scaleKey) - _10 >= minSpace ? RE_125 : RE_1;
    return splits.map((v) => sc.distr == 4 && v == 0 || re.test(v) ? v : null);
  }
  function numSeriesVal(self2, val) {
    return val == null ? "" : fmtNum(val);
  }
  var yAxisOpts = {
    show: true,
    scale: "y",
    stroke: hexBlack,
    space: 30,
    gap: 5,
    size: 50,
    labelGap: 0,
    labelSize: 30,
    labelFont,
    side: 3,
    grid,
    ticks,
    border,
    font,
    rotate: 0
  };
  function ptDia(width, mult) {
    let dia = 3 + (width || 1) * 2;
    return roundDec(dia * mult, 3);
  }
  function seriesPointsShow(self2, si) {
    let { scale, idxs } = self2.series[0];
    let xData = self2._data[0];
    let p0 = self2.valToPos(xData[idxs[0]], scale, true);
    let p1 = self2.valToPos(xData[idxs[1]], scale, true);
    let dim = abs(p1 - p0);
    let s = self2.series[si];
    let maxPts = dim / (s.points.space * pxRatio);
    return idxs[1] - idxs[0] <= maxPts;
  }
  var facet = {
    scale: null,
    auto: true,
    sorted: 0,
    min: inf,
    max: -inf
  };
  var xySeriesOpts = {
    show: true,
    auto: true,
    sorted: 0,
    alpha: 1,
    facets: [
      assign({}, facet, { scale: "x" }),
      assign({}, facet, { scale: "y" })
    ]
  };
  var ySeriesOpts = {
    scale: "y",
    auto: true,
    sorted: 0,
    show: true,
    spanGaps: false,
    gaps: (self2, seriesIdx, idx0, idx1, nullGaps) => nullGaps,
    alpha: 1,
    points: {
      show: seriesPointsShow,
      filter: null
    },
    values: null,
    min: inf,
    max: -inf,
    idxs: [],
    path: null,
    clip: null
  };
  function clampScale(self2, val, scaleMin, scaleMax, scaleKey) {
    return scaleMin / 10;
  }
  var xScaleOpts = {
    time: FEAT_TIME,
    auto: true,
    distr: 1,
    log: 10,
    asinh: 1,
    min: null,
    max: null,
    dir: 1,
    ori: 0
  };
  var yScaleOpts = assign({}, xScaleOpts, {
    time: false,
    ori: 1
  });
  var syncs = {};
  function _sync(key, opts) {
    let s = syncs[key];
    if (!s) {
      s = {
        key,
        plots: [],
        sub(plot) {
          s.plots.push(plot);
        },
        unsub(plot) {
          s.plots = s.plots.filter((c) => c != plot);
        },
        pub(type, self2, x, y, w, h, i) {
          for (let j = 0; j < s.plots.length; j++)
            s.plots[j] != self2 && s.plots[j].pub(type, self2, x, y, w, h, i);
        }
      };
      if (key != null)
        syncs[key] = s;
    }
    return s;
  }
  var BAND_CLIP_FILL = 1 << 0;
  var BAND_CLIP_STROKE = 1 << 1;
  function orient(u, seriesIdx, cb) {
    const series = u.series[seriesIdx];
    const scales = u.scales;
    const bbox = u.bbox;
    const scaleX = u.mode == 2 ? scales[series.facets[0].scale] : scales[u.series[0].scale];
    let dx = u._data[0], dy = u._data[seriesIdx], sx = scaleX, sy = u.mode == 2 ? scales[series.facets[1].scale] : scales[series.scale], l = bbox.left, t = bbox.top, w = bbox.width, h = bbox.height, H = u.valToPosH, V = u.valToPosV;
    return sx.ori == 0 ? cb(series, dx, dy, sx, sy, H, V, l, t, w, h, moveToH, lineToH, rectH, arcH, bezierCurveToH) : cb(series, dx, dy, sx, sy, V, H, t, l, h, w, moveToV, lineToV, rectV, arcV, bezierCurveToV);
  }
  function bandFillClipDirs(self2, seriesIdx) {
    let fillDir = 0;
    let clipDirs = 0;
    let bands = ifNull(self2.bands, EMPTY_ARR);
    for (let i = 0; i < bands.length; i++) {
      let b = bands[i];
      if (b.series[0] == seriesIdx)
        fillDir = b.dir;
      else if (b.series[1] == seriesIdx) {
        if (b.dir == 1)
          clipDirs |= 1;
        else
          clipDirs |= 2;
      }
    }
    return [
      fillDir,
      clipDirs == 1 ? -1 : clipDirs == 2 ? 1 : clipDirs == 3 ? 2 : 0
    ];
  }
  function seriesFillTo(self2, seriesIdx, dataMin, dataMax, bandFillDir) {
    let scale = self2.scales[self2.series[seriesIdx].scale];
    return bandFillDir == -1 ? scale.min : bandFillDir == 1 ? scale.max : scale.distr == 3 ? scale.dir == 1 ? scale.min : scale.max : 0;
  }
  function clipBandLine(self2, seriesIdx, idx0, idx1, strokePath, clipDir) {
    return orient(self2, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
      let pxRound = series.pxRound;
      const dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);
      const lineTo = scaleX.ori == 0 ? lineToH : lineToV;
      let frIdx, toIdx;
      if (dir == 1) {
        frIdx = idx0;
        toIdx = idx1;
      } else {
        frIdx = idx1;
        toIdx = idx0;
      }
      let x0 = pxRound(valToPosX(dataX[frIdx], scaleX, xDim, xOff));
      let y0 = pxRound(valToPosY(dataY[frIdx], scaleY, yDim, yOff));
      let x1 = pxRound(valToPosX(dataX[toIdx], scaleX, xDim, xOff));
      let yLimit = pxRound(valToPosY(clipDir == 1 ? scaleY.max : scaleY.min, scaleY, yDim, yOff));
      let clip = new Path2D(strokePath);
      lineTo(clip, x1, yLimit);
      lineTo(clip, x0, yLimit);
      lineTo(clip, x0, y0);
      return clip;
    });
  }
  function clipGaps(gaps, ori, plotLft, plotTop, plotWid, plotHgt) {
    let clip = null;
    if (gaps.length > 0) {
      clip = new Path2D();
      const rect2 = ori == 0 ? rectH : rectV;
      let prevGapEnd = plotLft;
      for (let i = 0; i < gaps.length; i++) {
        let g = gaps[i];
        if (g[1] > g[0]) {
          let w2 = g[0] - prevGapEnd;
          w2 > 0 && rect2(clip, prevGapEnd, plotTop, w2, plotTop + plotHgt);
          prevGapEnd = g[1];
        }
      }
      let w = plotLft + plotWid - prevGapEnd;
      w > 0 && rect2(clip, prevGapEnd, plotTop, w, plotTop + plotHgt);
    }
    return clip;
  }
  function addGap(gaps, fromX, toX) {
    let prevGap = gaps[gaps.length - 1];
    if (prevGap && prevGap[0] == fromX)
      prevGap[1] = toX;
    else
      gaps.push([fromX, toX]);
  }
  function findGaps(xs, ys, idx0, idx1, dir, pixelForX, align) {
    let gaps = [];
    for (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {
      let yVal = ys[i];
      if (yVal === null) {
        let fr = i, to = i;
        if (dir == 1) {
          while (++i <= idx1 && ys[i] === null)
            to = i;
        } else {
          while (--i >= idx0 && ys[i] === null)
            to = i;
        }
        let frPx = pixelForX(xs[fr]);
        let toPx = to == fr ? frPx : pixelForX(xs[to]);
        let frPx2 = align <= 0 ? pixelForX(xs[fr - dir]) : frPx;
        frPx = frPx2;
        let toPx2 = align >= 0 ? pixelForX(xs[to + dir]) : toPx;
        toPx = toPx2;
        if (toPx >= frPx)
          gaps.push([frPx, toPx]);
      }
    }
    return gaps;
  }
  function pxRoundGen(pxAlign) {
    return pxAlign == 0 ? retArg0 : pxAlign == 1 ? round : (v) => incrRound(v, pxAlign);
  }
  function rect(ori) {
    let moveTo = ori == 0 ? moveToH : moveToV;
    let arcTo = ori == 0 ? (p, x1, y1, x2, y2, r) => {
      p.arcTo(x1, y1, x2, y2, r);
    } : (p, y1, x1, y2, x2, r) => {
      p.arcTo(x1, y1, x2, y2, r);
    };
    let rect2 = ori == 0 ? (p, x, y, w, h) => {
      p.rect(x, y, w, h);
    } : (p, y, x, h, w) => {
      p.rect(x, y, w, h);
    };
    return (p, x, y, w, h, r = 0) => {
      if (r == 0)
        rect2(p, x, y, w, h);
      else {
        r = min(r, w / 2, h / 2);
        moveTo(p, x + r, y);
        arcTo(p, x + w, y, x + w, y + h, r);
        arcTo(p, x + w, y + h, x, y + h, r);
        arcTo(p, x, y + h, x, y, r);
        arcTo(p, x, y, x + w, y, r);
        p.closePath();
      }
    };
  }
  var moveToH = (p, x, y) => {
    p.moveTo(x, y);
  };
  var moveToV = (p, y, x) => {
    p.moveTo(x, y);
  };
  var lineToH = (p, x, y) => {
    p.lineTo(x, y);
  };
  var lineToV = (p, y, x) => {
    p.lineTo(x, y);
  };
  var rectH = rect(0);
  var rectV = rect(1);
  var arcH = (p, x, y, r, startAngle, endAngle) => {
    p.arc(x, y, r, startAngle, endAngle);
  };
  var arcV = (p, y, x, r, startAngle, endAngle) => {
    p.arc(x, y, r, startAngle, endAngle);
  };
  var bezierCurveToH = (p, bp1x, bp1y, bp2x, bp2y, p2x, p2y) => {
    p.bezierCurveTo(bp1x, bp1y, bp2x, bp2y, p2x, p2y);
  };
  var bezierCurveToV = (p, bp1y, bp1x, bp2y, bp2x, p2y, p2x) => {
    p.bezierCurveTo(bp1x, bp1y, bp2x, bp2y, p2x, p2y);
  };
  function points(opts) {
    return (u, seriesIdx, idx0, idx1, filtIdxs) => {
      return orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
        let { pxRound, points: points2 } = series;
        let moveTo, arc;
        if (scaleX.ori == 0) {
          moveTo = moveToH;
          arc = arcH;
        } else {
          moveTo = moveToV;
          arc = arcV;
        }
        const width = roundDec(points2.width * pxRatio, 3);
        let rad = (points2.size - points2.width) / 2 * pxRatio;
        let dia = roundDec(rad * 2, 3);
        let fill = new Path2D();
        let clip = new Path2D();
        let { left: lft, top, width: wid, height: hgt } = u.bbox;
        rectH(clip, lft - dia, top - dia, wid + dia * 2, hgt + dia * 2);
        const drawPoint = (pi) => {
          if (dataY[pi] != null) {
            let x = pxRound(valToPosX(dataX[pi], scaleX, xDim, xOff));
            let y = pxRound(valToPosY(dataY[pi], scaleY, yDim, yOff));
            moveTo(fill, x + rad, y);
            arc(fill, x, y, rad, 0, PI * 2);
          }
        };
        if (filtIdxs)
          filtIdxs.forEach(drawPoint);
        else {
          for (let pi = idx0; pi <= idx1; pi++)
            drawPoint(pi);
        }
        return {
          stroke: width > 0 ? fill : null,
          fill,
          clip,
          flags: BAND_CLIP_FILL | BAND_CLIP_STROKE
        };
      });
    };
  }
  function _drawAcc(lineTo) {
    return (stroke, accX, minY, maxY, inY, outY) => {
      if (minY != maxY) {
        if (inY != minY && outY != minY)
          lineTo(stroke, accX, minY);
        if (inY != maxY && outY != maxY)
          lineTo(stroke, accX, maxY);
        lineTo(stroke, accX, outY);
      }
    };
  }
  var drawAccH = _drawAcc(lineToH);
  var drawAccV = _drawAcc(lineToV);
  function linear(opts) {
    const alignGaps = ifNull(opts == null ? void 0 : opts.alignGaps, 0);
    return (u, seriesIdx, idx0, idx1) => {
      return orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
        let pxRound = series.pxRound;
        let pixelForX = (val) => pxRound(valToPosX(val, scaleX, xDim, xOff));
        let pixelForY = (val) => pxRound(valToPosY(val, scaleY, yDim, yOff));
        let lineTo, drawAcc;
        if (scaleX.ori == 0) {
          lineTo = lineToH;
          drawAcc = drawAccH;
        } else {
          lineTo = lineToV;
          drawAcc = drawAccV;
        }
        const dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);
        const _paths = { stroke: new Path2D(), fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL };
        const stroke = _paths.stroke;
        let minY = inf, maxY = -inf, inY, outY, drawnAtX;
        let accX = pixelForX(dataX[dir == 1 ? idx0 : idx1]);
        let lftIdx = nonNullIdx(dataY, idx0, idx1, 1 * dir);
        let rgtIdx = nonNullIdx(dataY, idx0, idx1, -1 * dir);
        let lftX = pixelForX(dataX[lftIdx]);
        let rgtX = pixelForX(dataX[rgtIdx]);
        for (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {
          let x = pixelForX(dataX[i]);
          if (x == accX) {
            if (dataY[i] != null) {
              outY = pixelForY(dataY[i]);
              if (minY == inf) {
                lineTo(stroke, x, outY);
                inY = outY;
              }
              minY = min(outY, minY);
              maxY = max(outY, maxY);
            }
          } else {
            if (minY != inf) {
              drawAcc(stroke, accX, minY, maxY, inY, outY);
              drawnAtX = accX;
            }
            if (dataY[i] != null) {
              outY = pixelForY(dataY[i]);
              lineTo(stroke, x, outY);
              minY = maxY = inY = outY;
            } else {
              minY = inf;
              maxY = -inf;
            }
            accX = x;
          }
        }
        if (minY != inf && minY != maxY && drawnAtX != accX)
          drawAcc(stroke, accX, minY, maxY, inY, outY);
        let [bandFillDir, bandClipDir] = bandFillClipDirs(u, seriesIdx);
        if (series.fill != null || bandFillDir != 0) {
          let fill = _paths.fill = new Path2D(stroke);
          let fillToVal = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);
          let fillToY = pixelForY(fillToVal);
          lineTo(fill, rgtX, fillToY);
          lineTo(fill, lftX, fillToY);
        }
        if (!series.spanGaps) {
          let gaps = [];
          gaps.push(...findGaps(dataX, dataY, idx0, idx1, dir, pixelForX, alignGaps));
          _paths.gaps = gaps = series.gaps(u, seriesIdx, idx0, idx1, gaps);
          _paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);
        }
        if (bandClipDir != 0) {
          _paths.band = bandClipDir == 2 ? [
            clipBandLine(u, seriesIdx, idx0, idx1, stroke, -1),
            clipBandLine(u, seriesIdx, idx0, idx1, stroke, 1)
          ] : clipBandLine(u, seriesIdx, idx0, idx1, stroke, bandClipDir);
        }
        return _paths;
      });
    };
  }
  function stepped(opts) {
    const align = ifNull(opts.align, 1);
    const ascDesc = ifNull(opts.ascDesc, false);
    const alignGaps = ifNull(opts.alignGaps, 0);
    return (u, seriesIdx, idx0, idx1) => {
      return orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
        let pxRound = series.pxRound;
        let pixelForX = (val) => pxRound(valToPosX(val, scaleX, xDim, xOff));
        let pixelForY = (val) => pxRound(valToPosY(val, scaleY, yDim, yOff));
        let lineTo = scaleX.ori == 0 ? lineToH : lineToV;
        const _paths = { stroke: new Path2D(), fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL };
        const stroke = _paths.stroke;
        const dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);
        idx0 = nonNullIdx(dataY, idx0, idx1, 1);
        idx1 = nonNullIdx(dataY, idx0, idx1, -1);
        let prevYPos = pixelForY(dataY[dir == 1 ? idx0 : idx1]);
        let firstXPos = pixelForX(dataX[dir == 1 ? idx0 : idx1]);
        let prevXPos = firstXPos;
        lineTo(stroke, firstXPos, prevYPos);
        for (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {
          let yVal1 = dataY[i];
          if (yVal1 == null)
            continue;
          let x1 = pixelForX(dataX[i]);
          let y1 = pixelForY(yVal1);
          if (align == 1)
            lineTo(stroke, x1, prevYPos);
          else
            lineTo(stroke, prevXPos, y1);
          lineTo(stroke, x1, y1);
          prevYPos = y1;
          prevXPos = x1;
        }
        let [bandFillDir, bandClipDir] = bandFillClipDirs(u, seriesIdx);
        if (series.fill != null || bandFillDir != 0) {
          let fill = _paths.fill = new Path2D(stroke);
          let fillTo = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);
          let fillToY = pixelForY(fillTo);
          lineTo(fill, prevXPos, fillToY);
          lineTo(fill, firstXPos, fillToY);
        }
        if (!series.spanGaps) {
          let gaps = [];
          gaps.push(...findGaps(dataX, dataY, idx0, idx1, dir, pixelForX, alignGaps));
          let halfStroke = series.width * pxRatio / 2;
          let startsOffset = ascDesc || align == 1 ? halfStroke : -halfStroke;
          let endsOffset = ascDesc || align == -1 ? -halfStroke : halfStroke;
          gaps.forEach((g) => {
            g[0] += startsOffset;
            g[1] += endsOffset;
          });
          _paths.gaps = gaps = series.gaps(u, seriesIdx, idx0, idx1, gaps);
          _paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);
        }
        if (bandClipDir != 0) {
          _paths.band = bandClipDir == 2 ? [
            clipBandLine(u, seriesIdx, idx0, idx1, stroke, -1),
            clipBandLine(u, seriesIdx, idx0, idx1, stroke, 1)
          ] : clipBandLine(u, seriesIdx, idx0, idx1, stroke, bandClipDir);
        }
        return _paths;
      });
    };
  }
  function bars(opts) {
    opts = opts || EMPTY_OBJ;
    const size = ifNull(opts.size, [0.6, inf, 1]);
    const align = opts.align || 0;
    const extraGap = (opts.gap || 0) * pxRatio;
    const radius = ifNull(opts.radius, 0);
    const gapFactor = 1 - size[0];
    const maxWidth = ifNull(size[1], inf) * pxRatio;
    const minWidth = ifNull(size[2], 1) * pxRatio;
    const disp = ifNull(opts.disp, EMPTY_OBJ);
    const _each = ifNull(opts.each, (_2) => {
    });
    const { fill: dispFills, stroke: dispStrokes } = disp;
    return (u, seriesIdx, idx0, idx1) => {
      return orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
        let pxRound = series.pxRound;
        const _dirX = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);
        const _dirY = scaleY.dir * (scaleY.ori == 1 ? 1 : -1);
        let rect2 = scaleX.ori == 0 ? rectH : rectV;
        let each = scaleX.ori == 0 ? _each : (u2, seriesIdx2, i, top, lft, hgt, wid) => {
          _each(u2, seriesIdx2, i, lft, top, wid, hgt);
        };
        let [bandFillDir, bandClipDir] = bandFillClipDirs(u, seriesIdx);
        let fillToY = scaleY.distr == 3 ? bandFillDir == 1 ? scaleY.max : scaleY.min : 0;
        let y0Pos = valToPosY(fillToY, scaleY, yDim, yOff);
        let xShift, barWid;
        let strokeWidth = pxRound(series.width * pxRatio);
        let multiPath = false;
        let fillColors = null;
        let fillPaths = null;
        let strokeColors = null;
        let strokePaths = null;
        if (dispFills != null && (strokeWidth == 0 || dispStrokes != null)) {
          multiPath = true;
          fillColors = dispFills.values(u, seriesIdx, idx0, idx1);
          fillPaths = /* @__PURE__ */ new Map();
          new Set(fillColors).forEach((color) => {
            if (color != null)
              fillPaths.set(color, new Path2D());
          });
          if (strokeWidth > 0) {
            strokeColors = dispStrokes.values(u, seriesIdx, idx0, idx1);
            strokePaths = /* @__PURE__ */ new Map();
            new Set(strokeColors).forEach((color) => {
              if (color != null)
                strokePaths.set(color, new Path2D());
            });
          }
        }
        let { x0, size: size2 } = disp;
        if (x0 != null && size2 != null) {
          dataX = x0.values(u, seriesIdx, idx0, idx1);
          if (x0.unit == 2)
            dataX = dataX.map((pct) => u.posToVal(xOff + pct * xDim, scaleX.key, true));
          let sizes = size2.values(u, seriesIdx, idx0, idx1);
          if (size2.unit == 2)
            barWid = sizes[0] * xDim;
          else
            barWid = valToPosX(sizes[0], scaleX, xDim, xOff) - valToPosX(0, scaleX, xDim, xOff);
          barWid = pxRound(barWid - strokeWidth);
          xShift = _dirX == 1 ? -strokeWidth / 2 : barWid + strokeWidth / 2;
        } else {
          let colWid = xDim;
          if (dataX.length > 1) {
            let prevIdx = null;
            for (let i = 0, minDelta = Infinity; i < dataX.length; i++) {
              if (dataY[i] !== void 0) {
                if (prevIdx != null) {
                  let delta = abs(dataX[i] - dataX[prevIdx]);
                  if (delta < minDelta) {
                    minDelta = delta;
                    colWid = abs(valToPosX(dataX[i], scaleX, xDim, xOff) - valToPosX(dataX[prevIdx], scaleX, xDim, xOff));
                  }
                }
                prevIdx = i;
              }
            }
          }
          let gapWid = colWid * gapFactor;
          barWid = pxRound(min(maxWidth, max(minWidth, colWid - gapWid)) - strokeWidth - extraGap);
          xShift = (align == 0 ? barWid / 2 : align == _dirX ? 0 : barWid) - align * _dirX * extraGap / 2;
        }
        const _paths = { stroke: null, fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL | BAND_CLIP_STROKE };
        let yLimit;
        if (bandClipDir != 0) {
          _paths.band = new Path2D();
          yLimit = pxRound(valToPosY(bandClipDir == 1 ? scaleY.max : scaleY.min, scaleY, yDim, yOff));
        }
        const stroke = multiPath ? null : new Path2D();
        const band = _paths.band;
        let { y0, y1 } = disp;
        let dataY0 = null;
        if (y0 != null && y1 != null) {
          dataY = y1.values(u, seriesIdx, idx0, idx1);
          dataY0 = y0.values(u, seriesIdx, idx0, idx1);
        }
        for (let i = _dirX == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += _dirX) {
          let yVal = dataY[i];
          if (yVal === void 0)
            continue;
          let xVal = scaleX.distr != 2 || disp != null ? dataX[i] : i;
          let xPos = valToPosX(xVal, scaleX, xDim, xOff);
          let yPos = valToPosY(ifNull(yVal, fillToY), scaleY, yDim, yOff);
          if (dataY0 != null && yVal != null)
            y0Pos = valToPosY(dataY0[i], scaleY, yDim, yOff);
          let lft = pxRound(xPos - xShift);
          let btm = pxRound(max(yPos, y0Pos));
          let top = pxRound(min(yPos, y0Pos));
          let barHgt = btm - top;
          let r = radius * barWid;
          if (yVal != null) {
            if (multiPath) {
              if (strokeWidth > 0 && strokeColors[i] != null)
                rect2(strokePaths.get(strokeColors[i]), lft, top + floor(strokeWidth / 2), barWid, max(0, barHgt - strokeWidth), r);
              if (fillColors[i] != null)
                rect2(fillPaths.get(fillColors[i]), lft, top + floor(strokeWidth / 2), barWid, max(0, barHgt - strokeWidth), r);
            } else
              rect2(stroke, lft, top + floor(strokeWidth / 2), barWid, max(0, barHgt - strokeWidth), r);
            each(u, seriesIdx, i, lft - strokeWidth / 2, top, barWid + strokeWidth, barHgt);
          }
          if (bandClipDir != 0) {
            if (_dirY * bandClipDir == 1) {
              btm = top;
              top = yLimit;
            } else {
              top = btm;
              btm = yLimit;
            }
            barHgt = btm - top;
            rect2(band, lft - strokeWidth / 2, top, barWid + strokeWidth, max(0, barHgt), 0);
          }
        }
        if (strokeWidth > 0)
          _paths.stroke = multiPath ? strokePaths : stroke;
        _paths.fill = multiPath ? fillPaths : stroke;
        return _paths;
      });
    };
  }
  function splineInterp(interp, opts) {
    const alignGaps = ifNull(opts == null ? void 0 : opts.alignGaps, 0);
    return (u, seriesIdx, idx0, idx1) => {
      return orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
        let pxRound = series.pxRound;
        let pixelForX = (val) => pxRound(valToPosX(val, scaleX, xDim, xOff));
        let pixelForY = (val) => pxRound(valToPosY(val, scaleY, yDim, yOff));
        let moveTo, bezierCurveTo, lineTo;
        if (scaleX.ori == 0) {
          moveTo = moveToH;
          lineTo = lineToH;
          bezierCurveTo = bezierCurveToH;
        } else {
          moveTo = moveToV;
          lineTo = lineToV;
          bezierCurveTo = bezierCurveToV;
        }
        const dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);
        idx0 = nonNullIdx(dataY, idx0, idx1, 1);
        idx1 = nonNullIdx(dataY, idx0, idx1, -1);
        let firstXPos = pixelForX(dataX[dir == 1 ? idx0 : idx1]);
        let prevXPos = firstXPos;
        let xCoords = [];
        let yCoords = [];
        for (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {
          let yVal = dataY[i];
          if (yVal != null) {
            let xVal = dataX[i];
            let xPos = pixelForX(xVal);
            xCoords.push(prevXPos = xPos);
            yCoords.push(pixelForY(dataY[i]));
          }
        }
        const _paths = { stroke: interp(xCoords, yCoords, moveTo, lineTo, bezierCurveTo, pxRound), fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL };
        const stroke = _paths.stroke;
        let [bandFillDir, bandClipDir] = bandFillClipDirs(u, seriesIdx);
        if (series.fill != null || bandFillDir != 0) {
          let fill = _paths.fill = new Path2D(stroke);
          let fillTo = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);
          let fillToY = pixelForY(fillTo);
          lineTo(fill, prevXPos, fillToY);
          lineTo(fill, firstXPos, fillToY);
        }
        if (!series.spanGaps) {
          let gaps = [];
          gaps.push(...findGaps(dataX, dataY, idx0, idx1, dir, pixelForX, alignGaps));
          _paths.gaps = gaps = series.gaps(u, seriesIdx, idx0, idx1, gaps);
          _paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);
        }
        if (bandClipDir != 0) {
          _paths.band = bandClipDir == 2 ? [
            clipBandLine(u, seriesIdx, idx0, idx1, stroke, -1),
            clipBandLine(u, seriesIdx, idx0, idx1, stroke, 1)
          ] : clipBandLine(u, seriesIdx, idx0, idx1, stroke, bandClipDir);
        }
        return _paths;
      });
    };
  }
  function monotoneCubic(opts) {
    return splineInterp(_monotoneCubic, opts);
  }
  function _monotoneCubic(xs, ys, moveTo, lineTo, bezierCurveTo, pxRound) {
    const n = xs.length;
    if (n < 2)
      return null;
    const path = new Path2D();
    moveTo(path, xs[0], ys[0]);
    if (n == 2)
      lineTo(path, xs[1], ys[1]);
    else {
      let ms = Array(n), ds = Array(n - 1), dys = Array(n - 1), dxs = Array(n - 1);
      for (let i = 0; i < n - 1; i++) {
        dys[i] = ys[i + 1] - ys[i];
        dxs[i] = xs[i + 1] - xs[i];
        ds[i] = dys[i] / dxs[i];
      }
      ms[0] = ds[0];
      for (let i = 1; i < n - 1; i++) {
        if (ds[i] === 0 || ds[i - 1] === 0 || ds[i - 1] > 0 !== ds[i] > 0)
          ms[i] = 0;
        else {
          ms[i] = 3 * (dxs[i - 1] + dxs[i]) / ((2 * dxs[i] + dxs[i - 1]) / ds[i - 1] + (dxs[i] + 2 * dxs[i - 1]) / ds[i]);
          if (!isFinite(ms[i]))
            ms[i] = 0;
        }
      }
      ms[n - 1] = ds[n - 2];
      for (let i = 0; i < n - 1; i++) {
        bezierCurveTo(path, xs[i] + dxs[i] / 3, ys[i] + ms[i] * dxs[i] / 3, xs[i + 1] - dxs[i] / 3, ys[i + 1] - ms[i + 1] * dxs[i] / 3, xs[i + 1], ys[i + 1]);
      }
    }
    return path;
  }
  var cursorPlots = /* @__PURE__ */ new Set();
  function invalidateRects() {
    cursorPlots.forEach((u) => {
      u.syncRect(true);
    });
  }
  if (domEnv) {
    on(resize, win, invalidateRects);
    on(scroll, win, invalidateRects, true);
    on(dppxchange, win, () => {
      uPlot.pxRatio = pxRatio;
    });
  }
  var linearPath = linear();
  var pointsPath = points();
  function setDefaults(d, xo, yo, initY) {
    let d2 = initY ? [d[0], d[1]].concat(d.slice(2)) : [d[0]].concat(d.slice(1));
    return d2.map((o, i) => setDefault(o, i, xo, yo));
  }
  function setDefaults2(d, xyo) {
    return d.map((o, i) => i == 0 ? null : assign({}, xyo, o));
  }
  function setDefault(o, i, xo, yo) {
    return assign({}, i == 0 ? xo : yo, o);
  }
  function snapNumX(self2, dataMin, dataMax) {
    return dataMin == null ? nullNullTuple : [dataMin, dataMax];
  }
  var snapTimeX = snapNumX;
  function snapNumY(self2, dataMin, dataMax) {
    return dataMin == null ? nullNullTuple : rangeNum(dataMin, dataMax, rangePad, true);
  }
  function snapLogY(self2, dataMin, dataMax, scale) {
    return dataMin == null ? nullNullTuple : rangeLog(dataMin, dataMax, self2.scales[scale].log, false);
  }
  var snapLogX = snapLogY;
  function snapAsinhY(self2, dataMin, dataMax, scale) {
    return dataMin == null ? nullNullTuple : rangeAsinh(dataMin, dataMax, self2.scales[scale].log, false);
  }
  var snapAsinhX = snapAsinhY;
  function findIncr(minVal, maxVal, incrs, dim, minSpace) {
    let intDigits = max(numIntDigits(minVal), numIntDigits(maxVal));
    let delta = maxVal - minVal;
    let incrIdx = closestIdx(minSpace / dim * delta, incrs);
    do {
      let foundIncr = incrs[incrIdx];
      let foundSpace = dim * foundIncr / delta;
      if (foundSpace >= minSpace && intDigits + (foundIncr < 5 ? fixedDec.get(foundIncr) : 0) <= 17)
        return [foundIncr, foundSpace];
    } while (++incrIdx < incrs.length);
    return [0, 0];
  }
  function pxRatioFont(font2) {
    let fontSize, fontSizeCss;
    font2 = font2.replace(/(\d+)px/, (m, p1) => (fontSize = round((fontSizeCss = +p1) * pxRatio)) + "px");
    return [font2, fontSize, fontSizeCss];
  }
  function syncFontSize(axis) {
    if (axis.show) {
      [axis.font, axis.labelFont].forEach((f) => {
        let size = roundDec(f[2] * pxRatio, 1);
        f[0] = f[0].replace(/[0-9.]+px/, size + "px");
        f[1] = size;
      });
    }
  }
  function uPlot(opts, data, then) {
    const self2 = {
      mode: ifNull(opts.mode, 1)
    };
    const mode = self2.mode;
    function getValPct(val, scale) {
      let _val = scale.distr == 3 ? log10(val > 0 ? val : scale.clamp(self2, val, scale.min, scale.max, scale.key)) : scale.distr == 4 ? asinh(val, scale.asinh) : val;
      return (_val - scale._min) / (scale._max - scale._min);
    }
    function getHPos(val, scale, dim, off2) {
      let pct = getValPct(val, scale);
      return off2 + dim * (scale.dir == -1 ? 1 - pct : pct);
    }
    function getVPos(val, scale, dim, off2) {
      let pct = getValPct(val, scale);
      return off2 + dim * (scale.dir == -1 ? pct : 1 - pct);
    }
    function getPos(val, scale, dim, off2) {
      return scale.ori == 0 ? getHPos(val, scale, dim, off2) : getVPos(val, scale, dim, off2);
    }
    self2.valToPosH = getHPos;
    self2.valToPosV = getVPos;
    let ready = false;
    self2.status = 0;
    const root = self2.root = placeDiv(UPLOT);
    if (opts.id != null)
      root.id = opts.id;
    addClass(root, opts.class);
    if (opts.title) {
      let title = placeDiv(TITLE2, root);
      title.textContent = opts.title;
    }
    const can = placeTag("canvas");
    const ctx = self2.ctx = can.getContext("2d");
    const wrap = placeDiv(WRAP, root);
    const under = self2.under = placeDiv(UNDER, wrap);
    wrap.appendChild(can);
    const over = self2.over = placeDiv(OVER, wrap);
    opts = copy(opts);
    const pxAlign = +ifNull(opts.pxAlign, 1);
    const pxRound = pxRoundGen(pxAlign);
    (opts.plugins || []).forEach((p) => {
      if (p.opts)
        opts = p.opts(self2, opts) || opts;
    });
    const ms = opts.ms || 1e-3;
    const series = self2.series = mode == 1 ? setDefaults(opts.series || [], xSeriesOpts, ySeriesOpts, false) : setDefaults2(opts.series || [null], xySeriesOpts);
    const axes = self2.axes = setDefaults(opts.axes || [], xAxisOpts, yAxisOpts, true);
    const scales = self2.scales = {};
    const bands = self2.bands = opts.bands || [];
    bands.forEach((b) => {
      b.fill = fnOrSelf(b.fill || null);
      b.dir = ifNull(b.dir, -1);
    });
    const xScaleKey = mode == 2 ? series[1].facets[0].scale : series[0].scale;
    const drawOrderMap = {
      axes: drawAxesGrid,
      series: drawSeries
    };
    const drawOrder = (opts.drawOrder || ["axes", "series"]).map((key2) => drawOrderMap[key2]);
    function initScale(scaleKey) {
      let sc = scales[scaleKey];
      if (sc == null) {
        let scaleOpts = (opts.scales || EMPTY_OBJ)[scaleKey] || EMPTY_OBJ;
        if (scaleOpts.from != null) {
          initScale(scaleOpts.from);
          scales[scaleKey] = assign({}, scales[scaleOpts.from], scaleOpts, { key: scaleKey });
        } else {
          sc = scales[scaleKey] = assign({}, scaleKey == xScaleKey ? xScaleOpts : yScaleOpts, scaleOpts);
          sc.key = scaleKey;
          let isTime = sc.time;
          let rn = sc.range;
          let rangeIsArr = isArr(rn);
          if (scaleKey != xScaleKey || mode == 2 && !isTime) {
            if (rangeIsArr && (rn[0] == null || rn[1] == null)) {
              rn = {
                min: rn[0] == null ? autoRangePart : {
                  mode: 1,
                  hard: rn[0],
                  soft: rn[0]
                },
                max: rn[1] == null ? autoRangePart : {
                  mode: 1,
                  hard: rn[1],
                  soft: rn[1]
                }
              };
              rangeIsArr = false;
            }
            if (!rangeIsArr && isObj(rn)) {
              let cfg = rn;
              rn = (self3, dataMin, dataMax) => dataMin == null ? nullNullTuple : rangeNum(dataMin, dataMax, cfg);
            }
          }
          sc.range = fnOrSelf(rn || (isTime ? snapTimeX : scaleKey == xScaleKey ? sc.distr == 3 ? snapLogX : sc.distr == 4 ? snapAsinhX : snapNumX : sc.distr == 3 ? snapLogY : sc.distr == 4 ? snapAsinhY : snapNumY));
          sc.auto = fnOrSelf(rangeIsArr ? false : sc.auto);
          sc.clamp = fnOrSelf(sc.clamp || clampScale);
          sc._min = sc._max = null;
        }
      }
    }
    initScale("x");
    initScale("y");
    if (mode == 1) {
      series.forEach((s) => {
        initScale(s.scale);
      });
    }
    axes.forEach((a) => {
      initScale(a.scale);
    });
    for (let k in opts.scales)
      initScale(k);
    const scaleX = scales[xScaleKey];
    const xScaleDistr = scaleX.distr;
    let valToPosX, valToPosY;
    if (scaleX.ori == 0) {
      addClass(root, ORI_HZ);
      valToPosX = getHPos;
      valToPosY = getVPos;
    } else {
      addClass(root, ORI_VT);
      valToPosX = getVPos;
      valToPosY = getHPos;
    }
    const pendScales = {};
    for (let k in scales) {
      let sc = scales[k];
      if (sc.min != null || sc.max != null) {
        pendScales[k] = { min: sc.min, max: sc.max };
        sc.min = sc.max = null;
      }
    }
    const _tzDate = opts.tzDate || ((ts) => new Date(round(ts / ms)));
    const _fmtDate = opts.fmtDate || fmtDate;
    const _timeAxisSplits = ms == 1 ? timeAxisSplitsMs(_tzDate) : timeAxisSplitsS(_tzDate);
    const _timeAxisVals = timeAxisVals(_tzDate, timeAxisStamps(ms == 1 ? _timeAxisStampsMs : _timeAxisStampsS, _fmtDate));
    const _timeSeriesVal = timeSeriesVal(_tzDate, timeSeriesStamp(_timeSeriesStamp, _fmtDate));
    const activeIdxs = [];
    const legend = self2.legend = assign({}, legendOpts, opts.legend);
    const showLegend = legend.show;
    const markers = legend.markers;
    {
      legend.idxs = activeIdxs;
      markers.width = fnOrSelf(markers.width);
      markers.dash = fnOrSelf(markers.dash);
      markers.stroke = fnOrSelf(markers.stroke);
      markers.fill = fnOrSelf(markers.fill);
    }
    let legendEl;
    let legendRows = [];
    let legendCells = [];
    let legendCols;
    let multiValLegend = false;
    let NULL_LEGEND_VALUES = {};
    if (legend.live) {
      const getMultiVals = series[1] ? series[1].values : null;
      multiValLegend = getMultiVals != null;
      legendCols = multiValLegend ? getMultiVals(self2, 1, 0) : { _: 0 };
      for (let k in legendCols)
        NULL_LEGEND_VALUES[k] = "--";
    }
    if (showLegend) {
      legendEl = placeTag("table", LEGEND, root);
      if (multiValLegend) {
        let head = placeTag("tr", LEGEND_THEAD, legendEl);
        placeTag("th", null, head);
        for (var key in legendCols)
          placeTag("th", LEGEND_LABEL, head).textContent = key;
      } else {
        addClass(legendEl, LEGEND_INLINE);
        legend.live && addClass(legendEl, LEGEND_LIVE);
      }
    }
    const son = { show: true };
    const soff = { show: false };
    function initLegendRow(s, i) {
      if (i == 0 && (multiValLegend || !legend.live || mode == 2))
        return nullNullTuple;
      let cells = [];
      let row = placeTag("tr", LEGEND_SERIES, legendEl, legendEl.childNodes[i]);
      addClass(row, s.class);
      if (!s.show)
        addClass(row, OFF);
      let label = placeTag("th", null, row);
      if (markers.show) {
        let indic = placeDiv(LEGEND_MARKER, label);
        if (i > 0) {
          let width = markers.width(self2, i);
          if (width)
            indic.style.border = width + "px " + markers.dash(self2, i) + " " + markers.stroke(self2, i);
          indic.style.background = markers.fill(self2, i);
        }
      }
      let text = placeDiv(LEGEND_LABEL, label);
      text.textContent = s.label;
      if (i > 0) {
        if (!markers.show)
          text.style.color = s.width > 0 ? markers.stroke(self2, i) : markers.fill(self2, i);
        onMouse("click", label, (e) => {
          if (cursor._lock)
            return;
          let seriesIdx = series.indexOf(s);
          if ((e.ctrlKey || e.metaKey) != legend.isolate) {
            let isolate = series.some((s2, i2) => i2 > 0 && i2 != seriesIdx && s2.show);
            series.forEach((s2, i2) => {
              i2 > 0 && setSeries(i2, isolate ? i2 == seriesIdx ? son : soff : son, true, syncOpts.setSeries);
            });
          } else
            setSeries(seriesIdx, { show: !s.show }, true, syncOpts.setSeries);
        });
        if (cursorFocus) {
          onMouse(mouseenter, label, (e) => {
            if (cursor._lock)
              return;
            setSeries(series.indexOf(s), FOCUS_TRUE, true, syncOpts.setSeries);
          });
        }
      }
      for (var key2 in legendCols) {
        let v = placeTag("td", LEGEND_VALUE, row);
        v.textContent = "--";
        cells.push(v);
      }
      return [row, cells];
    }
    const mouseListeners = /* @__PURE__ */ new Map();
    function onMouse(ev, targ, fn) {
      const targListeners = mouseListeners.get(targ) || {};
      const listener = cursor.bind[ev](self2, targ, fn);
      if (listener) {
        on(ev, targ, targListeners[ev] = listener);
        mouseListeners.set(targ, targListeners);
      }
    }
    function offMouse(ev, targ, fn) {
      const targListeners = mouseListeners.get(targ) || {};
      for (let k in targListeners) {
        if (ev == null || k == ev) {
          off(k, targ, targListeners[k]);
          delete targListeners[k];
        }
      }
      if (ev == null)
        mouseListeners.delete(targ);
    }
    let fullWidCss = 0;
    let fullHgtCss = 0;
    let plotWidCss = 0;
    let plotHgtCss = 0;
    let plotLftCss = 0;
    let plotTopCss = 0;
    let plotLft = 0;
    let plotTop = 0;
    let plotWid = 0;
    let plotHgt = 0;
    self2.bbox = {};
    let shouldSetScales = false;
    let shouldSetSize = false;
    let shouldConvergeSize = false;
    let shouldSetCursor = false;
    let shouldSetLegend = false;
    function _setSize(width, height, force) {
      if (force || (width != self2.width || height != self2.height))
        calcSize(width, height);
      resetYSeries(false);
      shouldConvergeSize = true;
      shouldSetSize = true;
      shouldSetCursor = shouldSetLegend = cursor.left >= 0;
      commit();
    }
    function calcSize(width, height) {
      self2.width = fullWidCss = plotWidCss = width;
      self2.height = fullHgtCss = plotHgtCss = height;
      plotLftCss = plotTopCss = 0;
      calcPlotRect();
      calcAxesRects();
      let bb = self2.bbox;
      plotLft = bb.left = incrRound(plotLftCss * pxRatio, 0.5);
      plotTop = bb.top = incrRound(plotTopCss * pxRatio, 0.5);
      plotWid = bb.width = incrRound(plotWidCss * pxRatio, 0.5);
      plotHgt = bb.height = incrRound(plotHgtCss * pxRatio, 0.5);
    }
    const CYCLE_LIMIT = 3;
    function convergeSize() {
      let converged = false;
      let cycleNum = 0;
      while (!converged) {
        cycleNum++;
        let axesConverged = axesCalc(cycleNum);
        let paddingConverged = paddingCalc(cycleNum);
        converged = cycleNum == CYCLE_LIMIT || axesConverged && paddingConverged;
        if (!converged) {
          calcSize(self2.width, self2.height);
          shouldSetSize = true;
        }
      }
    }
    function setSize({ width, height }) {
      _setSize(width, height);
    }
    self2.setSize = setSize;
    function calcPlotRect() {
      let hasTopAxis = false;
      let hasBtmAxis = false;
      let hasRgtAxis = false;
      let hasLftAxis = false;
      axes.forEach((axis, i) => {
        if (axis.show && axis._show) {
          let { side, _size } = axis;
          let isVt = side % 2;
          let labelSize = axis.label != null ? axis.labelSize : 0;
          let fullSize = _size + labelSize;
          if (fullSize > 0) {
            if (isVt) {
              plotWidCss -= fullSize;
              if (side == 3) {
                plotLftCss += fullSize;
                hasLftAxis = true;
              } else
                hasRgtAxis = true;
            } else {
              plotHgtCss -= fullSize;
              if (side == 0) {
                plotTopCss += fullSize;
                hasTopAxis = true;
              } else
                hasBtmAxis = true;
            }
          }
        }
      });
      sidesWithAxes[0] = hasTopAxis;
      sidesWithAxes[1] = hasRgtAxis;
      sidesWithAxes[2] = hasBtmAxis;
      sidesWithAxes[3] = hasLftAxis;
      plotWidCss -= _padding[1] + _padding[3];
      plotLftCss += _padding[3];
      plotHgtCss -= _padding[2] + _padding[0];
      plotTopCss += _padding[0];
    }
    function calcAxesRects() {
      let off1 = plotLftCss + plotWidCss;
      let off2 = plotTopCss + plotHgtCss;
      let off3 = plotLftCss;
      let off0 = plotTopCss;
      function incrOffset(side, size) {
        switch (side) {
          case 1:
            off1 += size;
            return off1 - size;
          case 2:
            off2 += size;
            return off2 - size;
          case 3:
            off3 -= size;
            return off3 + size;
          case 0:
            off0 -= size;
            return off0 + size;
        }
      }
      axes.forEach((axis, i) => {
        if (axis.show && axis._show) {
          let side = axis.side;
          axis._pos = incrOffset(side, axis._size);
          if (axis.label != null)
            axis._lpos = incrOffset(side, axis.labelSize);
        }
      });
    }
    const cursor = self2.cursor = assign({}, cursorOpts, { drag: { y: mode == 2 } }, opts.cursor);
    {
      cursor.idxs = activeIdxs;
      cursor._lock = false;
      let points2 = cursor.points;
      points2.show = fnOrSelf(points2.show);
      points2.size = fnOrSelf(points2.size);
      points2.stroke = fnOrSelf(points2.stroke);
      points2.width = fnOrSelf(points2.width);
      points2.fill = fnOrSelf(points2.fill);
    }
    const focus = self2.focus = assign({}, opts.focus || { alpha: 0.3 }, cursor.focus);
    const cursorFocus = focus.prox >= 0;
    let cursorPts = [null];
    function initCursorPt(s, si) {
      if (si > 0) {
        let pt = cursor.points.show(self2, si);
        if (pt) {
          addClass(pt, CURSOR_PT);
          addClass(pt, s.class);
          elTrans(pt, -10, -10, plotWidCss, plotHgtCss);
          over.insertBefore(pt, cursorPts[si]);
          return pt;
        }
      }
    }
    function initSeries(s, i) {
      if (mode == 1 || i > 0) {
        let isTime = mode == 1 && scales[s.scale].time;
        let sv = s.value;
        s.value = isTime ? isStr(sv) ? timeSeriesVal(_tzDate, timeSeriesStamp(sv, _fmtDate)) : sv || _timeSeriesVal : sv || numSeriesVal;
        s.label = s.label || (isTime ? timeSeriesLabel : numSeriesLabel);
      }
      if (i > 0) {
        s.width = s.width == null ? 1 : s.width;
        s.paths = s.paths || linearPath || retNull;
        s.fillTo = fnOrSelf(s.fillTo || seriesFillTo);
        s.pxAlign = +ifNull(s.pxAlign, pxAlign);
        s.pxRound = pxRoundGen(s.pxAlign);
        s.stroke = fnOrSelf(s.stroke || null);
        s.fill = fnOrSelf(s.fill || null);
        s._stroke = s._fill = s._paths = s._focus = null;
        let _ptDia = ptDia(s.width, 1);
        let points2 = s.points = assign({}, {
          size: _ptDia,
          width: max(1, _ptDia * 0.2),
          stroke: s.stroke,
          space: _ptDia * 2,
          paths: pointsPath,
          _stroke: null,
          _fill: null
        }, s.points);
        points2.show = fnOrSelf(points2.show);
        points2.filter = fnOrSelf(points2.filter);
        points2.fill = fnOrSelf(points2.fill);
        points2.stroke = fnOrSelf(points2.stroke);
        points2.paths = fnOrSelf(points2.paths);
        points2.pxAlign = s.pxAlign;
      }
      if (showLegend) {
        let rowCells = initLegendRow(s, i);
        legendRows.splice(i, 0, rowCells[0]);
        legendCells.splice(i, 0, rowCells[1]);
        legend.values.push(null);
      }
      if (cursor.show) {
        activeIdxs.splice(i, 0, null);
        let pt = initCursorPt(s, i);
        pt && cursorPts.splice(i, 0, pt);
      }
      fire("addSeries", i);
    }
    function addSeries(opts2, si) {
      si = si == null ? series.length : si;
      opts2 = setDefault(opts2, si, xSeriesOpts, ySeriesOpts);
      series.splice(si, 0, opts2);
      initSeries(series[si], si);
    }
    self2.addSeries = addSeries;
    function delSeries(i) {
      series.splice(i, 1);
      if (showLegend) {
        legend.values.splice(i, 1);
        legendCells.splice(i, 1);
        let tr = legendRows.splice(i, 1)[0];
        offMouse(null, tr.firstChild);
        tr.remove();
      }
      if (cursor.show) {
        activeIdxs.splice(i, 1);
        cursorPts.length > 1 && cursorPts.splice(i, 1)[0].remove();
      }
      fire("delSeries", i);
    }
    self2.delSeries = delSeries;
    const sidesWithAxes = [false, false, false, false];
    function initAxis(axis, i) {
      axis._show = axis.show;
      if (axis.show) {
        let isVt = axis.side % 2;
        let sc = scales[axis.scale];
        if (sc == null) {
          axis.scale = isVt ? series[1].scale : xScaleKey;
          sc = scales[axis.scale];
        }
        let isTime = sc.time;
        axis.size = fnOrSelf(axis.size);
        axis.space = fnOrSelf(axis.space);
        axis.rotate = fnOrSelf(axis.rotate);
        axis.incrs = fnOrSelf(axis.incrs || (sc.distr == 2 ? wholeIncrs : isTime ? ms == 1 ? timeIncrsMs : timeIncrsS : numIncrs));
        axis.splits = fnOrSelf(axis.splits || (isTime && sc.distr == 1 ? _timeAxisSplits : sc.distr == 3 ? logAxisSplits : sc.distr == 4 ? asinhAxisSplits : numAxisSplits));
        axis.stroke = fnOrSelf(axis.stroke);
        axis.grid.stroke = fnOrSelf(axis.grid.stroke);
        axis.ticks.stroke = fnOrSelf(axis.ticks.stroke);
        axis.border.stroke = fnOrSelf(axis.border.stroke);
        let av = axis.values;
        axis.values = isArr(av) && !isArr(av[0]) ? fnOrSelf(av) : isTime ? isArr(av) ? timeAxisVals(_tzDate, timeAxisStamps(av, _fmtDate)) : isStr(av) ? timeAxisVal(_tzDate, av) : av || _timeAxisVals : av || numAxisVals;
        axis.filter = fnOrSelf(axis.filter || (sc.distr >= 3 ? logAxisValsFilt : retArg1));
        axis.font = pxRatioFont(axis.font);
        axis.labelFont = pxRatioFont(axis.labelFont);
        axis._size = axis.size(self2, null, i, 0);
        axis._space = axis._rotate = axis._incrs = axis._found = axis._splits = axis._values = null;
        if (axis._size > 0) {
          sidesWithAxes[i] = true;
          axis._el = placeDiv(AXIS, wrap);
        }
      }
    }
    function autoPadSide(self3, side, sidesWithAxes2, cycleNum) {
      let [hasTopAxis, hasRgtAxis, hasBtmAxis, hasLftAxis] = sidesWithAxes2;
      let ori = side % 2;
      let size = 0;
      if (ori == 0 && (hasLftAxis || hasRgtAxis))
        size = side == 0 && !hasTopAxis || side == 2 && !hasBtmAxis ? round(xAxisOpts.size / 3) : 0;
      if (ori == 1 && (hasTopAxis || hasBtmAxis))
        size = side == 1 && !hasRgtAxis || side == 3 && !hasLftAxis ? round(yAxisOpts.size / 2) : 0;
      return size;
    }
    const padding = self2.padding = (opts.padding || [autoPadSide, autoPadSide, autoPadSide, autoPadSide]).map((p) => fnOrSelf(ifNull(p, autoPadSide)));
    const _padding = self2._padding = padding.map((p, i) => p(self2, i, sidesWithAxes, 0));
    let dataLen;
    let i0 = null;
    let i1 = null;
    const idxs = mode == 1 ? series[0].idxs : null;
    let data0 = null;
    let viaAutoScaleX = false;
    function setData(_data, _resetScales) {
      data = _data == null ? [] : copy(_data, fastIsObj);
      if (mode == 2) {
        dataLen = 0;
        for (let i = 1; i < series.length; i++)
          dataLen += data[i][0].length;
        self2.data = data = _data;
      } else {
        if (data[0] == null)
          data[0] = [];
        self2.data = data.slice();
        data0 = data[0];
        dataLen = data0.length;
        if (xScaleDistr == 2) {
          data[0] = Array(dataLen);
          for (let i = 0; i < dataLen; i++)
            data[0][i] = i;
        }
      }
      self2._data = data;
      resetYSeries(true);
      fire("setData");
      if (xScaleDistr == 2) {
        shouldConvergeSize = true;
      }
      if (_resetScales !== false) {
        let xsc = scaleX;
        if (xsc.auto(self2, viaAutoScaleX))
          autoScaleX();
        else
          _setScale(xScaleKey, xsc.min, xsc.max);
        shouldSetCursor = cursor.left >= 0;
        shouldSetLegend = true;
        commit();
      }
    }
    self2.setData = setData;
    function autoScaleX() {
      viaAutoScaleX = true;
      let _min, _max;
      if (mode == 1) {
        if (dataLen > 0) {
          i0 = idxs[0] = 0;
          i1 = idxs[1] = dataLen - 1;
          _min = data[0][i0];
          _max = data[0][i1];
          if (xScaleDistr == 2) {
            _min = i0;
            _max = i1;
          } else if (dataLen == 1) {
            if (xScaleDistr == 3)
              [_min, _max] = rangeLog(_min, _min, scaleX.log, false);
            else if (xScaleDistr == 4)
              [_min, _max] = rangeAsinh(_min, _min, scaleX.log, false);
            else if (scaleX.time)
              _max = _min + round(86400 / ms);
            else
              [_min, _max] = rangeNum(_min, _max, rangePad, true);
          }
        } else {
          i0 = idxs[0] = _min = null;
          i1 = idxs[1] = _max = null;
        }
      }
      _setScale(xScaleKey, _min, _max);
    }
    let ctxStroke, ctxFill, ctxWidth, ctxDash, ctxJoin, ctxCap, ctxFont, ctxAlign, ctxBaseline;
    let ctxAlpha;
    function setCtxStyle(stroke = transparent, width, dash = EMPTY_ARR, cap = "butt", fill = transparent, join2 = "round") {
      if (stroke != ctxStroke)
        ctx.strokeStyle = ctxStroke = stroke;
      if (fill != ctxFill)
        ctx.fillStyle = ctxFill = fill;
      if (width != ctxWidth)
        ctx.lineWidth = ctxWidth = width;
      if (join2 != ctxJoin)
        ctx.lineJoin = ctxJoin = join2;
      if (cap != ctxCap)
        ctx.lineCap = ctxCap = cap;
      if (dash != ctxDash)
        ctx.setLineDash(ctxDash = dash);
    }
    function setFontStyle(font2, fill, align, baseline) {
      if (fill != ctxFill)
        ctx.fillStyle = ctxFill = fill;
      if (font2 != ctxFont)
        ctx.font = ctxFont = font2;
      if (align != ctxAlign)
        ctx.textAlign = ctxAlign = align;
      if (baseline != ctxBaseline)
        ctx.textBaseline = ctxBaseline = baseline;
    }
    function accScale(wsc, psc, facet2, data2, sorted = 0) {
      if (data2.length > 0 && wsc.auto(self2, viaAutoScaleX) && (psc == null || psc.min == null)) {
        let _i0 = ifNull(i0, 0);
        let _i1 = ifNull(i1, data2.length - 1);
        let minMax = facet2.min == null ? wsc.distr == 3 ? getMinMaxLog(data2, _i0, _i1) : getMinMax(data2, _i0, _i1, sorted) : [facet2.min, facet2.max];
        wsc.min = min(wsc.min, facet2.min = minMax[0]);
        wsc.max = max(wsc.max, facet2.max = minMax[1]);
      }
    }
    function setScales() {
      let wipScales = copy(scales, fastIsObj);
      for (let k in wipScales) {
        let wsc = wipScales[k];
        let psc = pendScales[k];
        if (psc != null && psc.min != null) {
          assign(wsc, psc);
          if (k == xScaleKey)
            resetYSeries(true);
        } else if (k != xScaleKey || mode == 2) {
          if (dataLen == 0 && wsc.from == null) {
            let minMax = wsc.range(self2, null, null, k);
            wsc.min = minMax[0];
            wsc.max = minMax[1];
          } else {
            wsc.min = inf;
            wsc.max = -inf;
          }
        }
      }
      if (dataLen > 0) {
        series.forEach((s, i) => {
          if (mode == 1) {
            let k = s.scale;
            let wsc = wipScales[k];
            let psc = pendScales[k];
            if (i == 0) {
              let minMax = wsc.range(self2, wsc.min, wsc.max, k);
              wsc.min = minMax[0];
              wsc.max = minMax[1];
              i0 = closestIdx(wsc.min, data[0]);
              i1 = closestIdx(wsc.max, data[0]);
              if (data[0][i0] < wsc.min)
                i0++;
              if (data[0][i1] > wsc.max)
                i1--;
              s.min = data0[i0];
              s.max = data0[i1];
            } else if (s.show && s.auto)
              accScale(wsc, psc, s, data[i], s.sorted);
            s.idxs[0] = i0;
            s.idxs[1] = i1;
          } else {
            if (i > 0) {
              if (s.show && s.auto) {
                let [xFacet, yFacet] = s.facets;
                let xScaleKey2 = xFacet.scale;
                let yScaleKey = yFacet.scale;
                let [xData, yData] = data[i];
                accScale(wipScales[xScaleKey2], pendScales[xScaleKey2], xFacet, xData, xFacet.sorted);
                accScale(wipScales[yScaleKey], pendScales[yScaleKey], yFacet, yData, yFacet.sorted);
                s.min = yFacet.min;
                s.max = yFacet.max;
              }
            }
          }
        });
        for (let k in wipScales) {
          let wsc = wipScales[k];
          let psc = pendScales[k];
          if (wsc.from == null && (psc == null || psc.min == null)) {
            let minMax = wsc.range(self2, wsc.min == inf ? null : wsc.min, wsc.max == -inf ? null : wsc.max, k);
            wsc.min = minMax[0];
            wsc.max = minMax[1];
          }
        }
      }
      for (let k in wipScales) {
        let wsc = wipScales[k];
        if (wsc.from != null) {
          let base = wipScales[wsc.from];
          if (base.min == null)
            wsc.min = wsc.max = null;
          else {
            let minMax = wsc.range(self2, base.min, base.max, k);
            wsc.min = minMax[0];
            wsc.max = minMax[1];
          }
        }
      }
      let changed = {};
      let anyChanged = false;
      for (let k in wipScales) {
        let wsc = wipScales[k];
        let sc = scales[k];
        if (sc.min != wsc.min || sc.max != wsc.max) {
          sc.min = wsc.min;
          sc.max = wsc.max;
          let distr = sc.distr;
          sc._min = distr == 3 ? log10(sc.min) : distr == 4 ? asinh(sc.min, sc.asinh) : sc.min;
          sc._max = distr == 3 ? log10(sc.max) : distr == 4 ? asinh(sc.max, sc.asinh) : sc.max;
          changed[k] = anyChanged = true;
        }
      }
      if (anyChanged) {
        series.forEach((s, i) => {
          if (mode == 2) {
            if (i > 0 && changed.y)
              s._paths = null;
          } else {
            if (changed[s.scale])
              s._paths = null;
          }
        });
        for (let k in changed) {
          shouldConvergeSize = true;
          fire("setScale", k);
        }
        if (cursor.show)
          shouldSetCursor = shouldSetLegend = cursor.left >= 0;
      }
      for (let k in pendScales)
        pendScales[k] = null;
    }
    function getOuterIdxs(ydata) {
      let _i0 = clamp(i0 - 1, 0, dataLen - 1);
      let _i1 = clamp(i1 + 1, 0, dataLen - 1);
      while (ydata[_i0] == null && _i0 > 0)
        _i0--;
      while (ydata[_i1] == null && _i1 < dataLen - 1)
        _i1++;
      return [_i0, _i1];
    }
    function drawSeries() {
      if (dataLen > 0) {
        series.forEach((s, i) => {
          if (i > 0 && s.show && s._paths == null) {
            let _idxs = getOuterIdxs(data[i]);
            s._paths = s.paths(self2, i, _idxs[0], _idxs[1]);
          }
        });
        series.forEach((s, i) => {
          if (i > 0 && s.show) {
            if (ctxAlpha != s.alpha)
              ctx.globalAlpha = ctxAlpha = s.alpha;
            {
              cacheStrokeFill(i, false);
              s._paths && drawPath(i, false);
            }
            {
              cacheStrokeFill(i, true);
              let show = s.points.show(self2, i, i0, i1);
              let idxs2 = s.points.filter(self2, i, show, s._paths ? s._paths.gaps : null);
              if (show || idxs2) {
                s.points._paths = s.points.paths(self2, i, i0, i1, idxs2);
                drawPath(i, true);
              }
            }
            if (ctxAlpha != 1)
              ctx.globalAlpha = ctxAlpha = 1;
            fire("drawSeries", i);
          }
        });
      }
    }
    function cacheStrokeFill(si, _points) {
      let s = _points ? series[si].points : series[si];
      s._stroke = s.stroke(self2, si);
      s._fill = s.fill(self2, si);
    }
    function drawPath(si, _points) {
      let s = _points ? series[si].points : series[si];
      let strokeStyle = s._stroke;
      let fillStyle = s._fill;
      let { stroke, fill, clip: gapsClip, flags } = s._paths;
      let boundsClip = null;
      let width = roundDec(s.width * pxRatio, 3);
      let offset = width % 2 / 2;
      if (_points && fillStyle == null)
        fillStyle = width > 0 ? "#fff" : strokeStyle;
      let _pxAlign = s.pxAlign == 1;
      _pxAlign && ctx.translate(offset, offset);
      if (!_points) {
        let lft = plotLft, top = plotTop, wid = plotWid, hgt = plotHgt;
        let halfWid = width * pxRatio / 2;
        if (s.min == 0)
          hgt += halfWid;
        if (s.max == 0) {
          top -= halfWid;
          hgt += halfWid;
        }
        boundsClip = new Path2D();
        boundsClip.rect(lft, top, wid, hgt);
      }
      if (_points)
        strokeFill(strokeStyle, width, s.dash, s.cap, fillStyle, stroke, fill, flags, gapsClip);
      else
        fillStroke(si, strokeStyle, width, s.dash, s.cap, fillStyle, stroke, fill, flags, boundsClip, gapsClip);
      _pxAlign && ctx.translate(-offset, -offset);
    }
    function fillStroke(si, strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip) {
      let didStrokeFill = false;
      bands.forEach((b, bi) => {
        if (b.series[0] == si) {
          let lowerEdge = series[b.series[1]];
          let lowerData = data[b.series[1]];
          let bandClip = (lowerEdge._paths || EMPTY_OBJ).band;
          if (isArr(bandClip))
            bandClip = b.dir == 1 ? bandClip[0] : bandClip[1];
          let gapsClip2;
          let _fillStyle = null;
          if (lowerEdge.show && bandClip && hasData(lowerData, i0, i1)) {
            _fillStyle = b.fill(self2, bi) || fillStyle;
            gapsClip2 = lowerEdge._paths.clip;
          } else
            bandClip = null;
          strokeFill(strokeStyle, lineWidth, lineDash, lineCap, _fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip, gapsClip2, bandClip);
          didStrokeFill = true;
        }
      });
      if (!didStrokeFill)
        strokeFill(strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip);
    }
    const CLIP_FILL_STROKE = BAND_CLIP_FILL | BAND_CLIP_STROKE;
    function strokeFill(strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip, gapsClip2, bandClip) {
      setCtxStyle(strokeStyle, lineWidth, lineDash, lineCap, fillStyle);
      if (boundsClip || gapsClip || bandClip) {
        ctx.save();
        boundsClip && ctx.clip(boundsClip);
        gapsClip && ctx.clip(gapsClip);
      }
      if (bandClip) {
        if ((flags & CLIP_FILL_STROKE) == CLIP_FILL_STROKE) {
          ctx.clip(bandClip);
          gapsClip2 && ctx.clip(gapsClip2);
          doFill(fillStyle, fillPath);
          doStroke(strokeStyle, strokePath, lineWidth);
        } else if (flags & BAND_CLIP_STROKE) {
          doFill(fillStyle, fillPath);
          ctx.clip(bandClip);
          doStroke(strokeStyle, strokePath, lineWidth);
        } else if (flags & BAND_CLIP_FILL) {
          ctx.save();
          ctx.clip(bandClip);
          gapsClip2 && ctx.clip(gapsClip2);
          doFill(fillStyle, fillPath);
          ctx.restore();
          doStroke(strokeStyle, strokePath, lineWidth);
        }
      } else {
        doFill(fillStyle, fillPath);
        doStroke(strokeStyle, strokePath, lineWidth);
      }
      if (boundsClip || gapsClip || bandClip)
        ctx.restore();
    }
    function doStroke(strokeStyle, strokePath, lineWidth) {
      if (lineWidth > 0) {
        if (strokePath instanceof Map) {
          strokePath.forEach((strokePath2, strokeStyle2) => {
            ctx.strokeStyle = ctxStroke = strokeStyle2;
            ctx.stroke(strokePath2);
          });
        } else
          strokePath != null && strokeStyle && ctx.stroke(strokePath);
      }
    }
    function doFill(fillStyle, fillPath) {
      if (fillPath instanceof Map) {
        fillPath.forEach((fillPath2, fillStyle2) => {
          ctx.fillStyle = ctxFill = fillStyle2;
          ctx.fill(fillPath2);
        });
      } else
        fillPath != null && fillStyle && ctx.fill(fillPath);
    }
    function getIncrSpace(axisIdx, min2, max2, fullDim) {
      let axis = axes[axisIdx];
      let incrSpace;
      if (fullDim <= 0)
        incrSpace = [0, 0];
      else {
        let minSpace = axis._space = axis.space(self2, axisIdx, min2, max2, fullDim);
        let incrs = axis._incrs = axis.incrs(self2, axisIdx, min2, max2, fullDim, minSpace);
        incrSpace = findIncr(min2, max2, incrs, fullDim, minSpace);
      }
      return axis._found = incrSpace;
    }
    function drawOrthoLines(offs, filts, ori, side, pos0, len, width, stroke, dash, cap) {
      let offset = width % 2 / 2;
      pxAlign == 1 && ctx.translate(offset, offset);
      setCtxStyle(stroke, width, dash, cap, stroke);
      ctx.beginPath();
      let x0, y0, x1, y1, pos1 = pos0 + (side == 0 || side == 3 ? -len : len);
      if (ori == 0) {
        y0 = pos0;
        y1 = pos1;
      } else {
        x0 = pos0;
        x1 = pos1;
      }
      for (let i = 0; i < offs.length; i++) {
        if (filts[i] != null) {
          if (ori == 0)
            x0 = x1 = offs[i];
          else
            y0 = y1 = offs[i];
          ctx.moveTo(x0, y0);
          ctx.lineTo(x1, y1);
        }
      }
      ctx.stroke();
      pxAlign == 1 && ctx.translate(-offset, -offset);
    }
    function axesCalc(cycleNum) {
      let converged = true;
      axes.forEach((axis, i) => {
        if (!axis.show)
          return;
        let scale = scales[axis.scale];
        if (scale.min == null) {
          if (axis._show) {
            converged = false;
            axis._show = false;
            resetYSeries(false);
          }
          return;
        } else {
          if (!axis._show) {
            converged = false;
            axis._show = true;
            resetYSeries(false);
          }
        }
        let side = axis.side;
        let ori = side % 2;
        let { min: min2, max: max2 } = scale;
        let [_incr, _space] = getIncrSpace(i, min2, max2, ori == 0 ? plotWidCss : plotHgtCss);
        if (_space == 0)
          return;
        let forceMin = scale.distr == 2;
        let _splits = axis._splits = axis.splits(self2, i, min2, max2, _incr, _space, forceMin);
        let splits = scale.distr == 2 ? _splits.map((i2) => data0[i2]) : _splits;
        let incr = scale.distr == 2 ? data0[_splits[1]] - data0[_splits[0]] : _incr;
        let values = axis._values = axis.values(self2, axis.filter(self2, splits, i, _space, incr), i, _space, incr);
        axis._rotate = side == 2 ? axis.rotate(self2, values, i, _space) : 0;
        let oldSize = axis._size;
        axis._size = ceil(axis.size(self2, values, i, cycleNum));
        if (oldSize != null && axis._size != oldSize)
          converged = false;
      });
      return converged;
    }
    function paddingCalc(cycleNum) {
      let converged = true;
      padding.forEach((p, i) => {
        let _p = p(self2, i, sidesWithAxes, cycleNum);
        if (_p != _padding[i])
          converged = false;
        _padding[i] = _p;
      });
      return converged;
    }
    function drawAxesGrid() {
      for (let i = 0; i < axes.length; i++) {
        let axis = axes[i];
        if (!axis.show || !axis._show)
          continue;
        let side = axis.side;
        let ori = side % 2;
        let x, y;
        let fillStyle = axis.stroke(self2, i);
        let shiftDir = side == 0 || side == 3 ? -1 : 1;
        if (axis.label) {
          let shiftAmt2 = axis.labelGap * shiftDir;
          let baseLpos = round((axis._lpos + shiftAmt2) * pxRatio);
          setFontStyle(axis.labelFont[0], fillStyle, "center", side == 2 ? TOP : BOTTOM);
          ctx.save();
          if (ori == 1) {
            x = y = 0;
            ctx.translate(baseLpos, round(plotTop + plotHgt / 2));
            ctx.rotate((side == 3 ? -PI : PI) / 2);
          } else {
            x = round(plotLft + plotWid / 2);
            y = baseLpos;
          }
          ctx.fillText(axis.label, x, y);
          ctx.restore();
        }
        let [_incr, _space] = axis._found;
        if (_space == 0)
          continue;
        let scale = scales[axis.scale];
        let plotDim = ori == 0 ? plotWid : plotHgt;
        let plotOff = ori == 0 ? plotLft : plotTop;
        let axisGap = round(axis.gap * pxRatio);
        let _splits = axis._splits;
        let splits = scale.distr == 2 ? _splits.map((i2) => data0[i2]) : _splits;
        let incr = scale.distr == 2 ? data0[_splits[1]] - data0[_splits[0]] : _incr;
        let ticks2 = axis.ticks;
        let border2 = axis.border;
        let tickSize = ticks2.show ? round(ticks2.size * pxRatio) : 0;
        let angle = axis._rotate * -PI / 180;
        let basePos = pxRound(axis._pos * pxRatio);
        let shiftAmt = (tickSize + axisGap) * shiftDir;
        let finalPos = basePos + shiftAmt;
        y = ori == 0 ? finalPos : 0;
        x = ori == 1 ? finalPos : 0;
        let font2 = axis.font[0];
        let textAlign = axis.align == 1 ? LEFT : axis.align == 2 ? RIGHT : angle > 0 ? LEFT : angle < 0 ? RIGHT : ori == 0 ? "center" : side == 3 ? RIGHT : LEFT;
        let textBaseline = angle || ori == 1 ? "middle" : side == 2 ? TOP : BOTTOM;
        setFontStyle(font2, fillStyle, textAlign, textBaseline);
        let lineHeight = axis.font[1] * lineMult;
        let canOffs = _splits.map((val) => pxRound(getPos(val, scale, plotDim, plotOff)));
        let _values = axis._values;
        for (let i2 = 0; i2 < _values.length; i2++) {
          let val = _values[i2];
          if (val != null) {
            if (ori == 0)
              x = canOffs[i2];
            else
              y = canOffs[i2];
            val = "" + val;
            let _parts = val.indexOf("\n") == -1 ? [val] : val.split(/\n/gm);
            for (let j = 0; j < _parts.length; j++) {
              let text = _parts[j];
              if (angle) {
                ctx.save();
                ctx.translate(x, y + j * lineHeight);
                ctx.rotate(angle);
                ctx.fillText(text, 0, 0);
                ctx.restore();
              } else
                ctx.fillText(text, x, y + j * lineHeight);
            }
          }
        }
        if (ticks2.show) {
          drawOrthoLines(canOffs, ticks2.filter(self2, splits, i, _space, incr), ori, side, basePos, tickSize, roundDec(ticks2.width * pxRatio, 3), ticks2.stroke(self2, i), ticks2.dash, ticks2.cap);
        }
        let grid2 = axis.grid;
        if (grid2.show) {
          drawOrthoLines(canOffs, grid2.filter(self2, splits, i, _space, incr), ori, ori == 0 ? 2 : 1, ori == 0 ? plotTop : plotLft, ori == 0 ? plotHgt : plotWid, roundDec(grid2.width * pxRatio, 3), grid2.stroke(self2, i), grid2.dash, grid2.cap);
        }
        if (border2.show) {
          drawOrthoLines([basePos], [1], ori == 0 ? 1 : 0, ori == 0 ? 1 : 2, ori == 1 ? plotTop : plotLft, ori == 1 ? plotHgt : plotWid, roundDec(border2.width * pxRatio, 3), border2.stroke(self2, i), border2.dash, border2.cap);
        }
      }
      fire("drawAxes");
    }
    function resetYSeries(minMax) {
      series.forEach((s, i) => {
        if (i > 0) {
          s._paths = null;
          if (minMax) {
            if (mode == 1) {
              s.min = null;
              s.max = null;
            } else {
              s.facets.forEach((f) => {
                f.min = null;
                f.max = null;
              });
            }
          }
        }
      });
    }
    let queuedCommit = false;
    function commit() {
      if (!queuedCommit) {
        microTask(_commit);
        queuedCommit = true;
      }
    }
    function _commit() {
      if (shouldSetScales) {
        setScales();
        shouldSetScales = false;
      }
      if (shouldConvergeSize) {
        convergeSize();
        shouldConvergeSize = false;
      }
      if (shouldSetSize) {
        setStylePx(under, LEFT, plotLftCss);
        setStylePx(under, TOP, plotTopCss);
        setStylePx(under, WIDTH, plotWidCss);
        setStylePx(under, HEIGHT, plotHgtCss);
        setStylePx(over, LEFT, plotLftCss);
        setStylePx(over, TOP, plotTopCss);
        setStylePx(over, WIDTH, plotWidCss);
        setStylePx(over, HEIGHT, plotHgtCss);
        setStylePx(wrap, WIDTH, fullWidCss);
        setStylePx(wrap, HEIGHT, fullHgtCss);
        can.width = round(fullWidCss * pxRatio);
        can.height = round(fullHgtCss * pxRatio);
        axes.forEach(({ _el, _show, _size, _pos, side }) => {
          if (_el != null) {
            if (_show) {
              let posOffset = side === 3 || side === 0 ? _size : 0;
              let isVt = side % 2 == 1;
              setStylePx(_el, isVt ? "left" : "top", _pos - posOffset);
              setStylePx(_el, isVt ? "width" : "height", _size);
              setStylePx(_el, isVt ? "top" : "left", isVt ? plotTopCss : plotLftCss);
              setStylePx(_el, isVt ? "height" : "width", isVt ? plotHgtCss : plotWidCss);
              remClass(_el, OFF);
            } else
              addClass(_el, OFF);
          }
        });
        ctxStroke = ctxFill = ctxWidth = ctxJoin = ctxCap = ctxFont = ctxAlign = ctxBaseline = ctxDash = null;
        ctxAlpha = 1;
        syncRect(true);
        fire("setSize");
        shouldSetSize = false;
      }
      if (fullWidCss > 0 && fullHgtCss > 0) {
        ctx.clearRect(0, 0, can.width, can.height);
        fire("drawClear");
        drawOrder.forEach((fn) => fn());
        fire("draw");
      }
      if (cursor.show && shouldSetCursor) {
        updateCursor(null, true, false);
        shouldSetCursor = false;
      }
      if (!ready) {
        ready = true;
        self2.status = 1;
        fire("ready");
      }
      viaAutoScaleX = false;
      queuedCommit = false;
    }
    self2.redraw = (rebuildPaths, recalcAxes) => {
      shouldConvergeSize = recalcAxes || false;
      if (rebuildPaths !== false)
        _setScale(xScaleKey, scaleX.min, scaleX.max);
      else
        commit();
    };
    function setScale(key2, opts2) {
      let sc = scales[key2];
      if (sc.from == null) {
        if (dataLen == 0) {
          let minMax = sc.range(self2, opts2.min, opts2.max, key2);
          opts2.min = minMax[0];
          opts2.max = minMax[1];
        }
        if (opts2.min > opts2.max) {
          let _min = opts2.min;
          opts2.min = opts2.max;
          opts2.max = _min;
        }
        if (dataLen > 1 && opts2.min != null && opts2.max != null && opts2.max - opts2.min < 1e-16)
          return;
        if (key2 == xScaleKey) {
          if (sc.distr == 2 && dataLen > 0) {
            opts2.min = closestIdx(opts2.min, data[0]);
            opts2.max = closestIdx(opts2.max, data[0]);
            if (opts2.min == opts2.max)
              opts2.max++;
          }
        }
        pendScales[key2] = opts2;
        shouldSetScales = true;
        commit();
      }
    }
    self2.setScale = setScale;
    let xCursor;
    let yCursor;
    let vCursor;
    let hCursor;
    let rawMouseLeft0;
    let rawMouseTop0;
    let mouseLeft0;
    let mouseTop0;
    let rawMouseLeft1;
    let rawMouseTop1;
    let mouseLeft1;
    let mouseTop1;
    let dragging = false;
    const drag = cursor.drag;
    let dragX = drag.x;
    let dragY = drag.y;
    if (cursor.show) {
      if (cursor.x)
        xCursor = placeDiv(CURSOR_X, over);
      if (cursor.y)
        yCursor = placeDiv(CURSOR_Y, over);
      if (scaleX.ori == 0) {
        vCursor = xCursor;
        hCursor = yCursor;
      } else {
        vCursor = yCursor;
        hCursor = xCursor;
      }
      mouseLeft1 = cursor.left;
      mouseTop1 = cursor.top;
    }
    const select = self2.select = assign({
      show: true,
      over: true,
      left: 0,
      width: 0,
      top: 0,
      height: 0
    }, opts.select);
    const selectDiv = select.show ? placeDiv(SELECT, select.over ? over : under) : null;
    function setSelect(opts2, _fire) {
      if (select.show) {
        for (let prop in opts2)
          setStylePx(selectDiv, prop, select[prop] = opts2[prop]);
        _fire !== false && fire("setSelect");
      }
    }
    self2.setSelect = setSelect;
    function toggleDOM(i, onOff) {
      let s = series[i];
      let label = showLegend ? legendRows[i] : null;
      if (s.show)
        label && remClass(label, OFF);
      else {
        label && addClass(label, OFF);
        cursorPts.length > 1 && elTrans(cursorPts[i], -10, -10, plotWidCss, plotHgtCss);
      }
    }
    function _setScale(key2, min2, max2) {
      setScale(key2, { min: min2, max: max2 });
    }
    function setSeries(i, opts2, _fire, _pub) {
      if (opts2.focus != null)
        setFocus(i);
      if (opts2.show != null) {
        series.forEach((s, si) => {
          if (si > 0 && (i == si || i == null)) {
            s.show = opts2.show;
            toggleDOM(si, opts2.show);
            _setScale(mode == 2 ? s.facets[1].scale : s.scale, null, null);
            commit();
          }
        });
      }
      _fire !== false && fire("setSeries", i, opts2);
      _pub && pubSync("setSeries", self2, i, opts2);
    }
    self2.setSeries = setSeries;
    function setBand(bi, opts2) {
      assign(bands[bi], opts2);
    }
    function addBand(opts2, bi) {
      opts2.fill = fnOrSelf(opts2.fill || null);
      opts2.dir = ifNull(opts2.dir, -1);
      bi = bi == null ? bands.length : bi;
      bands.splice(bi, 0, opts2);
    }
    function delBand(bi) {
      if (bi == null)
        bands.length = 0;
      else
        bands.splice(bi, 1);
    }
    self2.addBand = addBand;
    self2.setBand = setBand;
    self2.delBand = delBand;
    function setAlpha(i, value) {
      series[i].alpha = value;
      if (cursor.show && cursorPts[i])
        cursorPts[i].style.opacity = value;
      if (showLegend && legendRows[i])
        legendRows[i].style.opacity = value;
    }
    let closestDist;
    let closestSeries;
    let focusedSeries;
    const FOCUS_TRUE = { focus: true };
    function setFocus(i) {
      if (i != focusedSeries) {
        let allFocused = i == null;
        let _setAlpha = focus.alpha != 1;
        series.forEach((s, i2) => {
          let isFocused = allFocused || i2 == 0 || i2 == i;
          s._focus = allFocused ? null : isFocused;
          _setAlpha && setAlpha(i2, isFocused ? 1 : focus.alpha);
        });
        focusedSeries = i;
        _setAlpha && commit();
      }
    }
    if (showLegend && cursorFocus) {
      on(mouseleave, legendEl, (e) => {
        if (cursor._lock)
          return;
        if (focusedSeries != null)
          setSeries(null, FOCUS_TRUE, true, syncOpts.setSeries);
      });
    }
    function posToVal(pos, scale, can2) {
      let sc = scales[scale];
      if (can2)
        pos = pos / pxRatio - (sc.ori == 1 ? plotTopCss : plotLftCss);
      let dim = plotWidCss;
      if (sc.ori == 1) {
        dim = plotHgtCss;
        pos = dim - pos;
      }
      if (sc.dir == -1)
        pos = dim - pos;
      let _min = sc._min, _max = sc._max, pct = pos / dim;
      let sv = _min + (_max - _min) * pct;
      let distr = sc.distr;
      return distr == 3 ? pow(10, sv) : distr == 4 ? sinh(sv, sc.asinh) : sv;
    }
    function closestIdxFromXpos(pos, can2) {
      let v = posToVal(pos, xScaleKey, can2);
      return closestIdx(v, data[0], i0, i1);
    }
    self2.valToIdx = (val) => closestIdx(val, data[0]);
    self2.posToIdx = closestIdxFromXpos;
    self2.posToVal = posToVal;
    self2.valToPos = (val, scale, can2) => scales[scale].ori == 0 ? getHPos(val, scales[scale], can2 ? plotWid : plotWidCss, can2 ? plotLft : 0) : getVPos(val, scales[scale], can2 ? plotHgt : plotHgtCss, can2 ? plotTop : 0);
    function batch(fn) {
      fn(self2);
      commit();
    }
    self2.batch = batch;
    self2.setCursor = (opts2, _fire, _pub) => {
      mouseLeft1 = opts2.left;
      mouseTop1 = opts2.top;
      updateCursor(null, _fire, _pub);
    };
    function setSelH(off2, dim) {
      setStylePx(selectDiv, LEFT, select.left = off2);
      setStylePx(selectDiv, WIDTH, select.width = dim);
    }
    function setSelV(off2, dim) {
      setStylePx(selectDiv, TOP, select.top = off2);
      setStylePx(selectDiv, HEIGHT, select.height = dim);
    }
    let setSelX = scaleX.ori == 0 ? setSelH : setSelV;
    let setSelY = scaleX.ori == 1 ? setSelH : setSelV;
    function syncLegend() {
      if (showLegend && legend.live) {
        for (let i = mode == 2 ? 1 : 0; i < series.length; i++) {
          if (i == 0 && multiValLegend)
            continue;
          let vals = legend.values[i];
          let j = 0;
          for (let k in vals)
            legendCells[i][j++].firstChild.nodeValue = vals[k];
        }
      }
    }
    function setLegend(opts2, _fire) {
      if (opts2 != null) {
        let idx = opts2.idx;
        legend.idx = idx;
        series.forEach((s, sidx) => {
          (sidx > 0 || !multiValLegend) && setLegendValues(sidx, idx);
        });
      }
      if (showLegend && legend.live)
        syncLegend();
      shouldSetLegend = false;
      _fire !== false && fire("setLegend");
    }
    self2.setLegend = setLegend;
    function setLegendValues(sidx, idx) {
      let val;
      if (idx == null)
        val = NULL_LEGEND_VALUES;
      else {
        let s = series[sidx];
        let src = sidx == 0 && xScaleDistr == 2 ? data0 : data[sidx];
        val = multiValLegend ? s.values(self2, sidx, idx) : { _: s.value(self2, src[idx], sidx, idx) };
      }
      legend.values[sidx] = val;
    }
    function updateCursor(src, _fire, _pub) {
      rawMouseLeft1 = mouseLeft1;
      rawMouseTop1 = mouseTop1;
      [mouseLeft1, mouseTop1] = cursor.move(self2, mouseLeft1, mouseTop1);
      if (cursor.show) {
        vCursor && elTrans(vCursor, round(mouseLeft1), 0, plotWidCss, plotHgtCss);
        hCursor && elTrans(hCursor, 0, round(mouseTop1), plotWidCss, plotHgtCss);
      }
      let idx;
      let noDataInRange = i0 > i1;
      closestDist = inf;
      let xDim = scaleX.ori == 0 ? plotWidCss : plotHgtCss;
      let yDim = scaleX.ori == 1 ? plotWidCss : plotHgtCss;
      if (mouseLeft1 < 0 || dataLen == 0 || noDataInRange) {
        idx = null;
        for (let i = 0; i < series.length; i++) {
          if (i > 0) {
            cursorPts.length > 1 && elTrans(cursorPts[i], -10, -10, plotWidCss, plotHgtCss);
          }
        }
        if (cursorFocus)
          setSeries(null, FOCUS_TRUE, true, src == null && syncOpts.setSeries);
        if (legend.live) {
          activeIdxs.fill(null);
          shouldSetLegend = true;
          for (let i = 0; i < series.length; i++)
            legend.values[i] = NULL_LEGEND_VALUES;
        }
      } else {
        let mouseXPos, valAtPosX, xPos;
        if (mode == 1) {
          mouseXPos = scaleX.ori == 0 ? mouseLeft1 : mouseTop1;
          valAtPosX = posToVal(mouseXPos, xScaleKey);
          idx = closestIdx(valAtPosX, data[0], i0, i1);
          xPos = incrRoundUp(valToPosX(data[0][idx], scaleX, xDim, 0), 0.5);
        }
        for (let i = mode == 2 ? 1 : 0; i < series.length; i++) {
          let s = series[i];
          let idx1 = activeIdxs[i];
          let yVal1 = mode == 1 ? data[i][idx1] : data[i][1][idx1];
          let idx2 = cursor.dataIdx(self2, i, idx, valAtPosX);
          let yVal2 = mode == 1 ? data[i][idx2] : data[i][1][idx2];
          shouldSetLegend = shouldSetLegend || yVal2 != yVal1 || idx2 != idx1;
          activeIdxs[i] = idx2;
          let xPos2 = idx2 == idx ? xPos : incrRoundUp(valToPosX(mode == 1 ? data[0][idx2] : data[i][0][idx2], scaleX, xDim, 0), 0.5);
          if (i > 0 && s.show) {
            let yPos = yVal2 == null ? -10 : incrRoundUp(valToPosY(yVal2, mode == 1 ? scales[s.scale] : scales[s.facets[1].scale], yDim, 0), 0.5);
            if (yPos > 0 && mode == 1) {
              let dist = abs(yPos - mouseTop1);
              if (dist <= closestDist) {
                closestDist = dist;
                closestSeries = i;
              }
            }
            let hPos, vPos;
            if (scaleX.ori == 0) {
              hPos = xPos2;
              vPos = yPos;
            } else {
              hPos = yPos;
              vPos = xPos2;
            }
            if (shouldSetLegend && cursorPts.length > 1) {
              elColor(cursorPts[i], cursor.points.fill(self2, i), cursor.points.stroke(self2, i));
              let ptWid, ptHgt, ptLft, ptTop, centered = true, getBBox = cursor.points.bbox;
              if (getBBox != null) {
                centered = false;
                let bbox = getBBox(self2, i);
                ptLft = bbox.left;
                ptTop = bbox.top;
                ptWid = bbox.width;
                ptHgt = bbox.height;
              } else {
                ptLft = hPos;
                ptTop = vPos;
                ptWid = ptHgt = cursor.points.size(self2, i);
              }
              elSize(cursorPts[i], ptWid, ptHgt, centered);
              elTrans(cursorPts[i], ptLft, ptTop, plotWidCss, plotHgtCss);
            }
          }
          if (legend.live) {
            if (!shouldSetLegend || i == 0 && multiValLegend)
              continue;
            setLegendValues(i, idx2);
          }
        }
      }
      cursor.idx = idx;
      cursor.left = mouseLeft1;
      cursor.top = mouseTop1;
      if (shouldSetLegend) {
        legend.idx = idx;
        setLegend();
      }
      if (select.show && dragging) {
        if (src != null) {
          let [xKey, yKey] = syncOpts.scales;
          let [matchXKeys, matchYKeys] = syncOpts.match;
          let [xKeySrc, yKeySrc] = src.cursor.sync.scales;
          let sdrag = src.cursor.drag;
          dragX = sdrag._x;
          dragY = sdrag._y;
          if (dragX || dragY) {
            let { left, top, width, height } = src.select;
            let sori = src.scales[xKey].ori;
            let sPosToVal = src.posToVal;
            let sOff, sDim, sc, a, b;
            let matchingX = xKey != null && matchXKeys(xKey, xKeySrc);
            let matchingY = yKey != null && matchYKeys(yKey, yKeySrc);
            if (matchingX && dragX) {
              if (sori == 0) {
                sOff = left;
                sDim = width;
              } else {
                sOff = top;
                sDim = height;
              }
              sc = scales[xKey];
              a = valToPosX(sPosToVal(sOff, xKeySrc), sc, xDim, 0);
              b = valToPosX(sPosToVal(sOff + sDim, xKeySrc), sc, xDim, 0);
              setSelX(min(a, b), abs(b - a));
            } else
              setSelX(0, xDim);
            if (matchingY && dragY) {
              if (sori == 1) {
                sOff = left;
                sDim = width;
              } else {
                sOff = top;
                sDim = height;
              }
              sc = scales[yKey];
              a = valToPosY(sPosToVal(sOff, yKeySrc), sc, yDim, 0);
              b = valToPosY(sPosToVal(sOff + sDim, yKeySrc), sc, yDim, 0);
              setSelY(min(a, b), abs(b - a));
            } else
              setSelY(0, yDim);
          } else
            hideSelect();
        } else {
          let rawDX = abs(rawMouseLeft1 - rawMouseLeft0);
          let rawDY = abs(rawMouseTop1 - rawMouseTop0);
          if (scaleX.ori == 1) {
            let _rawDX = rawDX;
            rawDX = rawDY;
            rawDY = _rawDX;
          }
          dragX = drag.x && rawDX >= drag.dist;
          dragY = drag.y && rawDY >= drag.dist;
          let uni = drag.uni;
          if (uni != null) {
            if (dragX && dragY) {
              dragX = rawDX >= uni;
              dragY = rawDY >= uni;
              if (!dragX && !dragY) {
                if (rawDY > rawDX)
                  dragY = true;
                else
                  dragX = true;
              }
            }
          } else if (drag.x && drag.y && (dragX || dragY))
            dragX = dragY = true;
          let p0, p1;
          if (dragX) {
            if (scaleX.ori == 0) {
              p0 = mouseLeft0;
              p1 = mouseLeft1;
            } else {
              p0 = mouseTop0;
              p1 = mouseTop1;
            }
            setSelX(min(p0, p1), abs(p1 - p0));
            if (!dragY)
              setSelY(0, yDim);
          }
          if (dragY) {
            if (scaleX.ori == 1) {
              p0 = mouseLeft0;
              p1 = mouseLeft1;
            } else {
              p0 = mouseTop0;
              p1 = mouseTop1;
            }
            setSelY(min(p0, p1), abs(p1 - p0));
            if (!dragX)
              setSelX(0, xDim);
          }
          if (!dragX && !dragY) {
            setSelX(0, 0);
            setSelY(0, 0);
          }
        }
      }
      drag._x = dragX;
      drag._y = dragY;
      if (src == null) {
        if (_pub) {
          if (syncKey != null) {
            let [xSyncKey, ySyncKey] = syncOpts.scales;
            syncOpts.values[0] = xSyncKey != null ? posToVal(scaleX.ori == 0 ? mouseLeft1 : mouseTop1, xSyncKey) : null;
            syncOpts.values[1] = ySyncKey != null ? posToVal(scaleX.ori == 1 ? mouseLeft1 : mouseTop1, ySyncKey) : null;
          }
          pubSync(mousemove, self2, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, idx);
        }
        if (cursorFocus) {
          let shouldPub = _pub && syncOpts.setSeries;
          let p = focus.prox;
          if (focusedSeries == null) {
            if (closestDist <= p)
              setSeries(closestSeries, FOCUS_TRUE, true, shouldPub);
          } else {
            if (closestDist > p)
              setSeries(null, FOCUS_TRUE, true, shouldPub);
            else if (closestSeries != focusedSeries)
              setSeries(closestSeries, FOCUS_TRUE, true, shouldPub);
          }
        }
      }
      ready && _fire !== false && fire("setCursor");
    }
    let rect2 = null;
    function syncRect(defer) {
      if (defer === true)
        rect2 = null;
      else {
        rect2 = over.getBoundingClientRect();
        fire("syncRect", rect2);
      }
    }
    function mouseMove(e, src, _l, _t, _w, _h, _i) {
      if (cursor._lock)
        return;
      cacheMouse(e, src, _l, _t, _w, _h, _i, false, e != null);
      if (e != null)
        updateCursor(null, true, true);
      else
        updateCursor(src, true, false);
    }
    function cacheMouse(e, src, _l, _t, _w, _h, _i, initial, snap) {
      if (rect2 == null)
        syncRect(false);
      if (e != null) {
        _l = e.clientX - rect2.left;
        _t = e.clientY - rect2.top;
      } else {
        if (_l < 0 || _t < 0) {
          mouseLeft1 = -10;
          mouseTop1 = -10;
          return;
        }
        let [xKey, yKey] = syncOpts.scales;
        let syncOptsSrc = src.cursor.sync;
        let [xValSrc, yValSrc] = syncOptsSrc.values;
        let [xKeySrc, yKeySrc] = syncOptsSrc.scales;
        let [matchXKeys, matchYKeys] = syncOpts.match;
        let rotSrc = src.axes[0].side % 2 == 1;
        let xDim = scaleX.ori == 0 ? plotWidCss : plotHgtCss, yDim = scaleX.ori == 1 ? plotWidCss : plotHgtCss, _xDim = rotSrc ? _h : _w, _yDim = rotSrc ? _w : _h, _xPos = rotSrc ? _t : _l, _yPos = rotSrc ? _l : _t;
        if (xKeySrc != null)
          _l = matchXKeys(xKey, xKeySrc) ? getPos(xValSrc, scales[xKey], xDim, 0) : -10;
        else
          _l = xDim * (_xPos / _xDim);
        if (yKeySrc != null)
          _t = matchYKeys(yKey, yKeySrc) ? getPos(yValSrc, scales[yKey], yDim, 0) : -10;
        else
          _t = yDim * (_yPos / _yDim);
        if (scaleX.ori == 1) {
          let __l = _l;
          _l = _t;
          _t = __l;
        }
      }
      if (snap) {
        if (_l <= 1 || _l >= plotWidCss - 1)
          _l = incrRound(_l, plotWidCss);
        if (_t <= 1 || _t >= plotHgtCss - 1)
          _t = incrRound(_t, plotHgtCss);
      }
      if (initial) {
        rawMouseLeft0 = _l;
        rawMouseTop0 = _t;
        [mouseLeft0, mouseTop0] = cursor.move(self2, _l, _t);
      } else {
        mouseLeft1 = _l;
        mouseTop1 = _t;
      }
    }
    const _hideProps = {
      width: 0,
      height: 0
    };
    function hideSelect() {
      setSelect(_hideProps, false);
    }
    function mouseDown(e, src, _l, _t, _w, _h, _i) {
      dragging = true;
      dragX = dragY = drag._x = drag._y = false;
      cacheMouse(e, src, _l, _t, _w, _h, _i, true, false);
      if (e != null) {
        onMouse(mouseup, doc2, mouseUp);
        pubSync(mousedown, self2, mouseLeft0, mouseTop0, plotWidCss, plotHgtCss, null);
      }
    }
    function mouseUp(e, src, _l, _t, _w, _h, _i) {
      dragging = drag._x = drag._y = false;
      cacheMouse(e, src, _l, _t, _w, _h, _i, false, true);
      let { left, top, width, height } = select;
      let hasSelect = width > 0 || height > 0;
      hasSelect && setSelect(select);
      if (drag.setScale && hasSelect) {
        let xOff = left, xDim = width, yOff = top, yDim = height;
        if (scaleX.ori == 1) {
          xOff = top, xDim = height, yOff = left, yDim = width;
        }
        if (dragX) {
          _setScale(xScaleKey, posToVal(xOff, xScaleKey), posToVal(xOff + xDim, xScaleKey));
        }
        if (dragY) {
          for (let k in scales) {
            let sc = scales[k];
            if (k != xScaleKey && sc.from == null && sc.min != inf) {
              _setScale(k, posToVal(yOff + yDim, k), posToVal(yOff, k));
            }
          }
        }
        hideSelect();
      } else if (cursor.lock) {
        cursor._lock = !cursor._lock;
        if (!cursor._lock)
          updateCursor(null, true, false);
      }
      if (e != null) {
        offMouse(mouseup, doc2);
        pubSync(mouseup, self2, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, null);
      }
    }
    function mouseLeave(e, src, _l, _t, _w, _h, _i) {
      if (!cursor._lock) {
        let _dragging = dragging;
        if (dragging) {
          let snapH = true;
          let snapV = true;
          let snapProx = 10;
          let dragH, dragV;
          if (scaleX.ori == 0) {
            dragH = dragX;
            dragV = dragY;
          } else {
            dragH = dragY;
            dragV = dragX;
          }
          if (dragH && dragV) {
            snapH = mouseLeft1 <= snapProx || mouseLeft1 >= plotWidCss - snapProx;
            snapV = mouseTop1 <= snapProx || mouseTop1 >= plotHgtCss - snapProx;
          }
          if (dragH && snapH)
            mouseLeft1 = mouseLeft1 < mouseLeft0 ? 0 : plotWidCss;
          if (dragV && snapV)
            mouseTop1 = mouseTop1 < mouseTop0 ? 0 : plotHgtCss;
          updateCursor(null, true, true);
          dragging = false;
        }
        mouseLeft1 = -10;
        mouseTop1 = -10;
        updateCursor(null, true, true);
        if (_dragging)
          dragging = _dragging;
      }
    }
    function dblClick(e, src, _l, _t, _w, _h, _i) {
      autoScaleX();
      hideSelect();
      if (e != null)
        pubSync(dblclick, self2, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, null);
    }
    function syncPxRatio() {
      axes.forEach(syncFontSize);
      _setSize(self2.width, self2.height, true);
    }
    on(dppxchange, win, syncPxRatio);
    const events = {};
    events.mousedown = mouseDown;
    events.mousemove = mouseMove;
    events.mouseup = mouseUp;
    events.dblclick = dblClick;
    events["setSeries"] = (e, src, idx, opts2) => {
      setSeries(idx, opts2, true, false);
    };
    if (cursor.show) {
      onMouse(mousedown, over, mouseDown);
      onMouse(mousemove, over, mouseMove);
      onMouse(mouseenter, over, syncRect);
      onMouse(mouseleave, over, mouseLeave);
      onMouse(dblclick, over, dblClick);
      cursorPlots.add(self2);
      self2.syncRect = syncRect;
    }
    const hooks = self2.hooks = opts.hooks || {};
    function fire(evName, a1, a2) {
      if (evName in hooks) {
        hooks[evName].forEach((fn) => {
          fn.call(null, self2, a1, a2);
        });
      }
    }
    (opts.plugins || []).forEach((p) => {
      for (let evName in p.hooks)
        hooks[evName] = (hooks[evName] || []).concat(p.hooks[evName]);
    });
    const syncOpts = assign({
      key: null,
      setSeries: false,
      filters: {
        pub: retTrue,
        sub: retTrue
      },
      scales: [xScaleKey, series[1] ? series[1].scale : null],
      match: [retEq, retEq],
      values: [null, null]
    }, cursor.sync);
    cursor.sync = syncOpts;
    const syncKey = syncOpts.key;
    const sync = _sync(syncKey);
    function pubSync(type, src, x, y, w, h, i) {
      if (syncOpts.filters.pub(type, src, x, y, w, h, i))
        sync.pub(type, src, x, y, w, h, i);
    }
    sync.sub(self2);
    function pub(type, src, x, y, w, h, i) {
      if (syncOpts.filters.sub(type, src, x, y, w, h, i))
        events[type](null, src, x, y, w, h, i);
    }
    self2.pub = pub;
    function destroy() {
      sync.unsub(self2);
      cursorPlots.delete(self2);
      mouseListeners.clear();
      off(dppxchange, win, syncPxRatio);
      root.remove();
      fire("destroy");
    }
    self2.destroy = destroy;
    function _init() {
      fire("init", opts, data);
      setData(data || opts.data, false);
      if (pendScales[xScaleKey])
        setScale(xScaleKey, pendScales[xScaleKey]);
      else
        autoScaleX();
      _setSize(opts.width, opts.height);
      updateCursor(null, true, false);
      setSelect(select, false);
    }
    series.forEach(initSeries);
    axes.forEach(initAxis);
    if (then) {
      if (then instanceof HTMLElement) {
        then.appendChild(root);
        _init();
      } else
        then(self2, _init);
    } else
      _init();
    return self2;
  }
  uPlot.assign = assign;
  uPlot.fmtNum = fmtNum;
  uPlot.rangeNum = rangeNum;
  uPlot.rangeLog = rangeLog;
  uPlot.rangeAsinh = rangeAsinh;
  uPlot.orient = orient;
  uPlot.pxRatio = pxRatio;
  {
    uPlot.join = join;
  }
  {
    uPlot.fmtDate = fmtDate;
    uPlot.tzDate = tzDate;
  }
  {
    uPlot.sync = _sync;
  }
  {
    uPlot.addGap = addGap;
    uPlot.clipGaps = clipGaps;
    let paths = uPlot.paths = {
      points
    };
    paths.linear = linear;
    paths.stepped = stepped;
    paths.bars = bars;
    paths.spline = monotoneCubic;
  }

  // js/chart.js
  var ChartHook = {
    mounted() {
      let product_id = this.el.product_id, event = `new-trade:${product_id}`, self2 = this;
      this.trades = [];
      this.plot = new uPlot(plotOptions(), [[], []], this.el);
      this.handleEvent(event, (payload) => self2.handleNewTrade(payload));
    },
    handleNewTrade(trade) {
      let price = parseFloat(trade.price), timestamp = trade.tradedAt;
      this.trades.push({
        timestamp,
        price
      });
      if (this.trades.length > 20) {
        this.trades.splice(0, 1);
      }
      this.updateChart();
    },
    updateChart() {
      let x = this.trades.map((t) => t.timestamp);
      let y = this.trades.map((t) => t.price);
      this.plot.setData([x, y]);
    }
  };
  function plotOptions() {
    return {
      width: 200,
      height: 80,
      class: "chart-container",
      cursor: { show: false },
      select: { show: false },
      legend: { show: false },
      scales: {},
      axes: [
        { show: false },
        { show: false }
      ],
      series: [
        {},
        {
          size: 0,
          width: 2,
          stroke: "white",
          fill: "rgb(45,85,150)"
        }
      ]
    };
  }

  // js/app.js
  var Hooks2 = {
    Chart: ChartHook
  };
  var timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  var csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content");
  var liveSocket = new LiveSocket("/live", Socket, { hooks: Hooks2, params: { _csrf_token: csrfToken, timezone } });
  import_topbar.default.config({ barColors: { 0: "#29d" }, shadowColor: "rgba(0, 0, 0, .3)" });
  window.addEventListener("phx:page-loading-start", (info) => import_topbar.default.show());
  window.addEventListener("phx:page-loading-stop", (info) => import_topbar.default.hide());
  liveSocket.connect();
  window.liveSocket = liveSocket;
})();
/**
 * @license MIT
 * topbar 1.0.0, 2021-01-06
 * https://buunguyen.github.io/topbar
 * Copyright (c) 2021 Buu Nguyen
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vYXNzZXRzL3ZlbmRvci90b3BiYXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2h0bWwvcHJpdi9zdGF0aWMvcGhvZW5peF9odG1sLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC91dGlscy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9wdXNoLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC90aW1lci5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvY2hhbm5lbC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvYWpheC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvbG9uZ3BvbGwuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3ByZXNlbmNlLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9zZXJpYWxpemVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9zb2NrZXQuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2VudHJ5X3VwbG9hZGVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3V0aWxzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2Jyb3dzZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3VwbG9hZF9lbnRyeS5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9saXZlX3VwbG9hZGVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2hvb2tzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2RvbV9wb3N0X21vcnBoX3Jlc3RvcmVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL25vZGVfbW9kdWxlcy9tb3JwaGRvbS9kaXN0L21vcnBoZG9tLWVzbS5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9kb21fcGF0Y2guanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvcmVuZGVyZWQuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvdmlld19ob29rLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2pzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3ZpZXcuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvbGl2ZV9zb2NrZXQuanMiLCAiLi4vLi4vLi4vYXNzZXRzL2pzL2FwcC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3VwbG90L2Rpc3QvdVBsb3QuZXNtLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9qcy9jaGFydC5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyoqXG4gKiBAbGljZW5zZSBNSVRcbiAqIHRvcGJhciAxLjAuMCwgMjAyMS0wMS0wNlxuICogaHR0cHM6Ly9idXVuZ3V5ZW4uZ2l0aHViLmlvL3RvcGJhclxuICogQ29weXJpZ2h0IChjKSAyMDIxIEJ1dSBOZ3V5ZW5cbiAqL1xuKGZ1bmN0aW9uICh3aW5kb3csIGRvY3VtZW50KSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICB2YXIgdmVuZG9ycyA9IFtcIm1zXCIsIFwibW96XCIsIFwid2Via2l0XCIsIFwib1wiXTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxuICAgICAgICB3aW5kb3dbdmVuZG9yc1t4XSArIFwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID1cbiAgICAgICAgd2luZG93W3ZlbmRvcnNbeF0gKyBcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCJdIHx8XG4gICAgICAgIHdpbmRvd1t2ZW5kb3JzW3hdICsgXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XG4gICAgfVxuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICAgICAgICB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgICAgICAgfSwgdGltZVRvQ2FsbCk7XG4gICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9O1xuICAgIGlmICghd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKVxuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICB9O1xuICB9KSgpO1xuXG4gIHZhciBjYW52YXMsXG4gICAgcHJvZ3Jlc3NUaW1lcklkLFxuICAgIGZhZGVUaW1lcklkLFxuICAgIGN1cnJlbnRQcm9ncmVzcyxcbiAgICBzaG93aW5nLFxuICAgIGFkZEV2ZW50ID0gZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICBlbHNlIGlmIChlbGVtLmF0dGFjaEV2ZW50KSBlbGVtLmF0dGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGhhbmRsZXIpO1xuICAgICAgZWxzZSBlbGVtW1wib25cIiArIHR5cGVdID0gaGFuZGxlcjtcbiAgICB9LFxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBhdXRvUnVuOiB0cnVlLFxuICAgICAgYmFyVGhpY2tuZXNzOiAzLFxuICAgICAgYmFyQ29sb3JzOiB7XG4gICAgICAgIDA6IFwicmdiYSgyNiwgIDE4OCwgMTU2LCAuOSlcIixcbiAgICAgICAgXCIuMjVcIjogXCJyZ2JhKDUyLCAgMTUyLCAyMTksIC45KVwiLFxuICAgICAgICBcIi41MFwiOiBcInJnYmEoMjQxLCAxOTYsIDE1LCAgLjkpXCIsXG4gICAgICAgIFwiLjc1XCI6IFwicmdiYSgyMzAsIDEyNiwgMzQsICAuOSlcIixcbiAgICAgICAgXCIxLjBcIjogXCJyZ2JhKDIxMSwgODQsICAwLCAgIC45KVwiLFxuICAgICAgfSxcbiAgICAgIHNoYWRvd0JsdXI6IDEwLFxuICAgICAgc2hhZG93Q29sb3I6IFwicmdiYSgwLCAgIDAsICAgMCwgICAuNilcIixcbiAgICAgIGNsYXNzTmFtZTogbnVsbCxcbiAgICB9LFxuICAgIHJlcGFpbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRpb25zLmJhclRoaWNrbmVzcyAqIDU7IC8vIG5lZWQgc3BhY2UgZm9yIHNoYWRvd1xuXG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gb3B0aW9ucy5zaGFkb3dCbHVyO1xuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gb3B0aW9ucy5zaGFkb3dDb2xvcjtcblxuICAgICAgdmFyIGxpbmVHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCBjYW52YXMud2lkdGgsIDApO1xuICAgICAgZm9yICh2YXIgc3RvcCBpbiBvcHRpb25zLmJhckNvbG9ycylcbiAgICAgICAgbGluZUdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLCBvcHRpb25zLmJhckNvbG9yc1tzdG9wXSk7XG4gICAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKDAsIG9wdGlvbnMuYmFyVGhpY2tuZXNzIC8gMik7XG4gICAgICBjdHgubGluZVRvKFxuICAgICAgICBNYXRoLmNlaWwoY3VycmVudFByb2dyZXNzICogY2FudmFzLndpZHRoKSxcbiAgICAgICAgb3B0aW9ucy5iYXJUaGlja25lc3MgLyAyXG4gICAgICApO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGluZUdyYWRpZW50O1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIHZhciBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcbiAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgICAgc3R5bGUudG9wID0gc3R5bGUubGVmdCA9IHN0eWxlLnJpZ2h0ID0gc3R5bGUubWFyZ2luID0gc3R5bGUucGFkZGluZyA9IDA7XG4gICAgICBzdHlsZS56SW5kZXggPSAxMDAwMDE7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBpZiAob3B0aW9ucy5jbGFzc05hbWUpIGNhbnZhcy5jbGFzc0xpc3QuYWRkKG9wdGlvbnMuY2xhc3NOYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIGFkZEV2ZW50KHdpbmRvdywgXCJyZXNpemVcIiwgcmVwYWludCk7XG4gICAgfSxcbiAgICB0b3BiYXIgPSB7XG4gICAgICBjb25maWc6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRzKVxuICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIG9wdGlvbnNba2V5XSA9IG9wdHNba2V5XTtcbiAgICAgIH0sXG4gICAgICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzaG93aW5nKSByZXR1cm47XG4gICAgICAgIHNob3dpbmcgPSB0cnVlO1xuICAgICAgICBpZiAoZmFkZVRpbWVySWQgIT09IG51bGwpIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShmYWRlVGltZXJJZCk7XG4gICAgICAgIGlmICghY2FudmFzKSBjcmVhdGVDYW52YXMoKTtcbiAgICAgICAgY2FudmFzLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBjYW52YXMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgdG9wYmFyLnByb2dyZXNzKDApO1xuICAgICAgICBpZiAob3B0aW9ucy5hdXRvUnVuKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICBwcm9ncmVzc1RpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgICAgICAgdG9wYmFyLnByb2dyZXNzKFxuICAgICAgICAgICAgICBcIitcIiArIDAuMDUgKiBNYXRoLnBvdygxIC0gTWF0aC5zcXJ0KGN1cnJlbnRQcm9ncmVzcyksIDIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9ncmVzczogZnVuY3Rpb24gKHRvKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBjdXJyZW50UHJvZ3Jlc3M7XG4gICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0byA9XG4gICAgICAgICAgICAodG8uaW5kZXhPZihcIitcIikgPj0gMCB8fCB0by5pbmRleE9mKFwiLVwiKSA+PSAwXG4gICAgICAgICAgICAgID8gY3VycmVudFByb2dyZXNzXG4gICAgICAgICAgICAgIDogMCkgKyBwYXJzZUZsb2F0KHRvKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UHJvZ3Jlc3MgPSB0byA+IDEgPyAxIDogdG87XG4gICAgICAgIHJlcGFpbnQoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQcm9ncmVzcztcbiAgICAgIH0sXG4gICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc2hvd2luZykgcmV0dXJuO1xuICAgICAgICBzaG93aW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9ncmVzc1RpbWVySWQgIT0gbnVsbCkge1xuICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShwcm9ncmVzc1RpbWVySWQpO1xuICAgICAgICAgIHByb2dyZXNzVGltZXJJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgKGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgaWYgKHRvcGJhci5wcm9ncmVzcyhcIisuMVwiKSA+PSAxKSB7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUub3BhY2l0eSAtPSAwLjA1O1xuICAgICAgICAgICAgaWYgKGNhbnZhcy5zdHlsZS5vcGFjaXR5IDw9IDAuMDUpIHtcbiAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgZmFkZVRpbWVySWQgPSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZhZGVUaW1lcklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH0sXG4gICAgfTtcblxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRvcGJhcjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdG9wYmFyO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudG9wYmFyID0gdG9wYmFyO1xuICB9XG59LmNhbGwodGhpcywgd2luZG93LCBkb2N1bWVudCkpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBQb2x5ZmlsbEV2ZW50ID0gZXZlbnRDb25zdHJ1Y3RvcigpO1xuXG4gIGZ1bmN0aW9uIGV2ZW50Q29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHdpbmRvdy5DdXN0b21FdmVudDtcbiAgICAvLyBJRTw9OSBTdXBwb3J0XG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHtidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdW5kZWZpbmVkfTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICByZXR1cm4gZXZ0O1xuICAgIH1cbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICAgIHJldHVybiBDdXN0b21FdmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkSGlkZGVuSW5wdXQobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgaW5wdXQubmFtZSA9IG5hbWU7XG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDbGljayhlbGVtZW50LCB0YXJnZXRNb2RpZmllcktleSkge1xuICAgIHZhciB0byA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10b1wiKSxcbiAgICAgICAgbWV0aG9kID0gYnVpbGRIaWRkZW5JbnB1dChcIl9tZXRob2RcIiwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSksXG4gICAgICAgIGNzcmYgPSBidWlsZEhpZGRlbklucHV0KFwiX2NzcmZfdG9rZW5cIiwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNzcmZcIikpLFxuICAgICAgICBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG4gICAgICAgIHRhcmdldCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpO1xuXG4gICAgZm9ybS5tZXRob2QgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSA9PT0gXCJnZXRcIikgPyBcImdldFwiIDogXCJwb3N0XCI7XG4gICAgZm9ybS5hY3Rpb24gPSB0bztcbiAgICBmb3JtLnN0eWxlLmRpc3BsYXkgPSBcImhpZGRlblwiO1xuXG4gICAgaWYgKHRhcmdldCkgZm9ybS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgZWxzZSBpZiAodGFyZ2V0TW9kaWZpZXJLZXkpIGZvcm0udGFyZ2V0ID0gXCJfYmxhbmtcIjtcblxuICAgIGZvcm0uYXBwZW5kQ2hpbGQoY3NyZik7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChtZXRob2QpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgZm9ybS5zdWJtaXQoKTtcbiAgfVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlbGVtZW50ID0gZS50YXJnZXQ7XG4gICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBwaG9lbml4TGlua0V2ZW50ID0gbmV3IFBvbHlmaWxsRXZlbnQoJ3Bob2VuaXgubGluay5jbGljaycsIHtcbiAgICAgICAgXCJidWJibGVzXCI6IHRydWUsIFwiY2FuY2VsYWJsZVwiOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFlbGVtZW50LmRpc3BhdGNoRXZlbnQocGhvZW5peExpbmtFdmVudCkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpKSB7XG4gICAgICAgIGhhbmRsZUNsaWNrKGVsZW1lbnQsIGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5KTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfSwgZmFsc2UpO1xuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwaG9lbml4LmxpbmsuY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtZXNzYWdlID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb25maXJtXCIpO1xuICAgIGlmKG1lc3NhZ2UgJiYgIXdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG59KSgpO1xuIiwgIi8vIHdyYXBzIHZhbHVlIGluIGNsb3N1cmUgb3IgcmV0dXJucyBjbG9zdXJlXG5leHBvcnQgbGV0IGNsb3N1cmUgPSAodmFsdWUpID0+IHtcbiAgaWYodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpe1xuICAgIHJldHVybiB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIGxldCBjbG9zdXJlID0gZnVuY3Rpb24gKCl7IHJldHVybiB2YWx1ZSB9XG4gICAgcmV0dXJuIGNsb3N1cmVcbiAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBnbG9iYWxTZWxmID0gdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogbnVsbFxuZXhwb3J0IGNvbnN0IHBoeFdpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBudWxsXG5leHBvcnQgY29uc3QgZ2xvYmFsID0gZ2xvYmFsU2VsZiB8fCBwaHhXaW5kb3cgfHwgZ2xvYmFsXG5leHBvcnQgY29uc3QgREVGQVVMVF9WU04gPSBcIjIuMC4wXCJcbmV4cG9ydCBjb25zdCBTT0NLRVRfU1RBVEVTID0ge2Nvbm5lY3Rpbmc6IDAsIG9wZW46IDEsIGNsb3Npbmc6IDIsIGNsb3NlZDogM31cbmV4cG9ydCBjb25zdCBERUZBVUxUX1RJTUVPVVQgPSAxMDAwMFxuZXhwb3J0IGNvbnN0IFdTX0NMT1NFX05PUk1BTCA9IDEwMDBcbmV4cG9ydCBjb25zdCBDSEFOTkVMX1NUQVRFUyA9IHtcbiAgY2xvc2VkOiBcImNsb3NlZFwiLFxuICBlcnJvcmVkOiBcImVycm9yZWRcIixcbiAgam9pbmVkOiBcImpvaW5lZFwiLFxuICBqb2luaW5nOiBcImpvaW5pbmdcIixcbiAgbGVhdmluZzogXCJsZWF2aW5nXCIsXG59XG5leHBvcnQgY29uc3QgQ0hBTk5FTF9FVkVOVFMgPSB7XG4gIGNsb3NlOiBcInBoeF9jbG9zZVwiLFxuICBlcnJvcjogXCJwaHhfZXJyb3JcIixcbiAgam9pbjogXCJwaHhfam9pblwiLFxuICByZXBseTogXCJwaHhfcmVwbHlcIixcbiAgbGVhdmU6IFwicGh4X2xlYXZlXCJcbn1cblxuZXhwb3J0IGNvbnN0IFRSQU5TUE9SVFMgPSB7XG4gIGxvbmdwb2xsOiBcImxvbmdwb2xsXCIsXG4gIHdlYnNvY2tldDogXCJ3ZWJzb2NrZXRcIlxufVxuZXhwb3J0IGNvbnN0IFhIUl9TVEFURVMgPSB7XG4gIGNvbXBsZXRlOiA0XG59XG4iLCAiLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgUHVzaFxuICogQHBhcmFtIHtDaGFubmVsfSBjaGFubmVsIC0gVGhlIENoYW5uZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIFRoZSBldmVudCwgZm9yIGV4YW1wbGUgYFwicGh4X2pvaW5cImBcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIC0gVGhlIHBheWxvYWQsIGZvciBleGFtcGxlIGB7dXNlcl9pZDogMTIzfWBcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IC0gVGhlIHB1c2ggdGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHVzaCB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWwsIGV2ZW50LCBwYXlsb2FkLCB0aW1lb3V0KXtcbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsXG4gICAgdGhpcy5ldmVudCA9IGV2ZW50XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZCB8fCBmdW5jdGlvbiAoKXsgcmV0dXJuIHt9IH1cbiAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSBudWxsXG4gICAgdGhpcy5yZWNIb29rcyA9IFtdXG4gICAgdGhpcy5zZW50ID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICAgKi9cbiAgcmVzZW5kKHRpbWVvdXQpe1xuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXRcbiAgICB0aGlzLnJlc2V0KClcbiAgICB0aGlzLnNlbmQoKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICBzZW5kKCl7XG4gICAgaWYodGhpcy5oYXNSZWNlaXZlZChcInRpbWVvdXRcIikpeyByZXR1cm4gfVxuICAgIHRoaXMuc3RhcnRUaW1lb3V0KClcbiAgICB0aGlzLnNlbnQgPSB0cnVlXG4gICAgdGhpcy5jaGFubmVsLnNvY2tldC5wdXNoKHtcbiAgICAgIHRvcGljOiB0aGlzLmNoYW5uZWwudG9waWMsXG4gICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZCgpLFxuICAgICAgcmVmOiB0aGlzLnJlZixcbiAgICAgIGpvaW5fcmVmOiB0aGlzLmNoYW5uZWwuam9pblJlZigpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHN0YXR1c1xuICAgKiBAcGFyYW0geyp9IGNhbGxiYWNrXG4gICAqL1xuICByZWNlaXZlKHN0YXR1cywgY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuaGFzUmVjZWl2ZWQoc3RhdHVzKSl7XG4gICAgICBjYWxsYmFjayh0aGlzLnJlY2VpdmVkUmVzcC5yZXNwb25zZSlcbiAgICB9XG5cbiAgICB0aGlzLnJlY0hvb2tzLnB1c2goe3N0YXR1cywgY2FsbGJhY2t9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlc2V0KCl7XG4gICAgdGhpcy5jYW5jZWxSZWZFdmVudCgpXG4gICAgdGhpcy5yZWYgPSBudWxsXG4gICAgdGhpcy5yZWZFdmVudCA9IG51bGxcbiAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IG51bGxcbiAgICB0aGlzLnNlbnQgPSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBtYXRjaFJlY2VpdmUoe3N0YXR1cywgcmVzcG9uc2UsIF9yZWZ9KXtcbiAgICB0aGlzLnJlY0hvb2tzLmZpbHRlcihoID0+IGguc3RhdHVzID09PSBzdGF0dXMpXG4gICAgICAuZm9yRWFjaChoID0+IGguY2FsbGJhY2socmVzcG9uc2UpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5jZWxSZWZFdmVudCgpe1xuICAgIGlmKCF0aGlzLnJlZkV2ZW50KXsgcmV0dXJuIH1cbiAgICB0aGlzLmNoYW5uZWwub2ZmKHRoaXMucmVmRXZlbnQpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbmNlbFRpbWVvdXQoKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0VGltZXIpXG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXJ0VGltZW91dCgpe1xuICAgIGlmKHRoaXMudGltZW91dFRpbWVyKXsgdGhpcy5jYW5jZWxUaW1lb3V0KCkgfVxuICAgIHRoaXMucmVmID0gdGhpcy5jaGFubmVsLnNvY2tldC5tYWtlUmVmKClcbiAgICB0aGlzLnJlZkV2ZW50ID0gdGhpcy5jaGFubmVsLnJlcGx5RXZlbnROYW1lKHRoaXMucmVmKVxuXG4gICAgdGhpcy5jaGFubmVsLm9uKHRoaXMucmVmRXZlbnQsIHBheWxvYWQgPT4ge1xuICAgICAgdGhpcy5jYW5jZWxSZWZFdmVudCgpXG4gICAgICB0aGlzLmNhbmNlbFRpbWVvdXQoKVxuICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBwYXlsb2FkXG4gICAgICB0aGlzLm1hdGNoUmVjZWl2ZShwYXlsb2FkKVxuICAgIH0pXG5cbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKFwidGltZW91dFwiLCB7fSlcbiAgICB9LCB0aGlzLnRpbWVvdXQpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhc1JlY2VpdmVkKHN0YXR1cyl7XG4gICAgcmV0dXJuIHRoaXMucmVjZWl2ZWRSZXNwICYmIHRoaXMucmVjZWl2ZWRSZXNwLnN0YXR1cyA9PT0gc3RhdHVzXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRyaWdnZXIoc3RhdHVzLCByZXNwb25zZSl7XG4gICAgdGhpcy5jaGFubmVsLnRyaWdnZXIodGhpcy5yZWZFdmVudCwge3N0YXR1cywgcmVzcG9uc2V9KVxuICB9XG59XG4iLCAiLyoqXG4gKlxuICogQ3JlYXRlcyBhIHRpbWVyIHRoYXQgYWNjZXB0cyBhIGB0aW1lckNhbGNgIGZ1bmN0aW9uIHRvIHBlcmZvcm1cbiAqIGNhbGN1bGF0ZWQgdGltZW91dCByZXRyaWVzLCBzdWNoIGFzIGV4cG9uZW50aWFsIGJhY2tvZmYuXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCByZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB0aGlzLmNvbm5lY3QoKSwgZnVuY3Rpb24odHJpZXMpe1xuICogICByZXR1cm4gWzEwMDAsIDUwMDAsIDEwMDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiB9KVxuICogcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICogcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgNTAwMFxuICogcmVjb25uZWN0VGltZXIucmVzZXQoKVxuICogcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0aW1lckNhbGNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZXIge1xuICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgdGltZXJDYWxjKXtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsY1xuICAgIHRoaXMudGltZXIgPSBudWxsXG4gICAgdGhpcy50cmllcyA9IDBcbiAgfVxuXG4gIHJlc2V0KCl7XG4gICAgdGhpcy50cmllcyA9IDBcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcilcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGFueSBwcmV2aW91cyBzY2hlZHVsZVRpbWVvdXQgYW5kIHNjaGVkdWxlcyBjYWxsYmFja1xuICAgKi9cbiAgc2NoZWR1bGVUaW1lb3V0KCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpXG5cbiAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyaWVzID0gdGhpcy50cmllcyArIDFcbiAgICAgIHRoaXMuY2FsbGJhY2soKVxuICAgIH0sIHRoaXMudGltZXJDYWxjKHRoaXMudHJpZXMgKyAxKSlcbiAgfVxufVxuIiwgImltcG9ydCB7Y2xvc3VyZX0gZnJvbSBcIi4vdXRpbHNcIlxuaW1wb3J0IHtcbiAgQ0hBTk5FTF9FVkVOVFMsXG4gIENIQU5ORUxfU1RBVEVTLFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQgUHVzaCBmcm9tIFwiLi9wdXNoXCJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi90aW1lclwiXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY1xuICogQHBhcmFtIHsoT2JqZWN0fGZ1bmN0aW9uKX0gcGFyYW1zXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYW5uZWwge1xuICBjb25zdHJ1Y3Rvcih0b3BpYywgcGFyYW1zLCBzb2NrZXQpe1xuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgICB0aGlzLnRvcGljID0gdG9waWNcbiAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUocGFyYW1zIHx8IHt9KVxuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0XG4gICAgdGhpcy5iaW5kaW5ncyA9IFtdXG4gICAgdGhpcy5iaW5kaW5nUmVmID0gMFxuICAgIHRoaXMudGltZW91dCA9IHRoaXMuc29ja2V0LnRpbWVvdXRcbiAgICB0aGlzLmpvaW5lZE9uY2UgPSBmYWxzZVxuICAgIHRoaXMuam9pblB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5qb2luLCB0aGlzLnBhcmFtcywgdGhpcy50aW1lb3V0KVxuICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdXG4gICAgdGhpcy5zdGF0ZUNoYW5nZVJlZnMgPSBbXVxuXG4gICAgdGhpcy5yZWpvaW5UaW1lciA9IG5ldyBUaW1lcigoKSA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5yZWpvaW4oKSB9XG4gICAgfSwgdGhpcy5zb2NrZXQucmVqb2luQWZ0ZXJNcylcbiAgICB0aGlzLnN0YXRlQ2hhbmdlUmVmcy5wdXNoKHRoaXMuc29ja2V0Lm9uRXJyb3IoKCkgPT4gdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpKSlcbiAgICB0aGlzLnN0YXRlQ2hhbmdlUmVmcy5wdXNoKHRoaXMuc29ja2V0Lm9uT3BlbigoKSA9PiB7XG4gICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICAgIGlmKHRoaXMuaXNFcnJvcmVkKCkpeyB0aGlzLnJlam9pbigpIH1cbiAgICB9KVxuICAgIClcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJva1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmVkXG4gICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICAgIHRoaXMucHVzaEJ1ZmZlci5mb3JFYWNoKHB1c2hFdmVudCA9PiBwdXNoRXZlbnQuc2VuZCgpKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW11cbiAgICB9KVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcImVycm9yXCIsICgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkXG4gICAgICBpZih0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKSB9XG4gICAgfSlcbiAgICB0aGlzLm9uQ2xvc2UoKCkgPT4ge1xuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgY2xvc2UgJHt0aGlzLnRvcGljfSAke3RoaXMuam9pblJlZigpfWApXG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkXG4gICAgICB0aGlzLnNvY2tldC5yZW1vdmUodGhpcylcbiAgICB9KVxuICAgIHRoaXMub25FcnJvcihyZWFzb24gPT4ge1xuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGVycm9yICR7dGhpcy50b3BpY31gLCByZWFzb24pXG4gICAgICBpZih0aGlzLmlzSm9pbmluZygpKXsgdGhpcy5qb2luUHVzaC5yZXNldCgpIH1cbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkXG4gICAgICBpZih0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKSB9XG4gICAgfSlcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGB0aW1lb3V0ICR7dGhpcy50b3BpY30gKCR7dGhpcy5qb2luUmVmKCl9KWAsIHRoaXMuam9pblB1c2gudGltZW91dClcbiAgICAgIGxldCBsZWF2ZVB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5sZWF2ZSwgY2xvc3VyZSh7fSksIHRoaXMudGltZW91dClcbiAgICAgIGxlYXZlUHVzaC5zZW5kKClcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkXG4gICAgICB0aGlzLmpvaW5QdXNoLnJlc2V0KClcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpIH1cbiAgICB9KVxuICAgIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMucmVwbHksIChwYXlsb2FkLCByZWYpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcih0aGlzLnJlcGx5RXZlbnROYW1lKHJlZiksIHBheWxvYWQpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBKb2luIHRoZSBjaGFubmVsXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gdGltZW91dFxuICAgKiBAcmV0dXJucyB7UHVzaH1cbiAgICovXG4gIGpvaW4odGltZW91dCA9IHRoaXMudGltZW91dCl7XG4gICAgaWYodGhpcy5qb2luZWRPbmNlKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInRyaWVkIHRvIGpvaW4gbXVsdGlwbGUgdGltZXMuICdqb2luJyBjYW4gb25seSBiZSBjYWxsZWQgYSBzaW5nbGUgdGltZSBwZXIgY2hhbm5lbCBpbnN0YW5jZVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgICB0aGlzLmpvaW5lZE9uY2UgPSB0cnVlXG4gICAgICB0aGlzLnJlam9pbigpXG4gICAgICByZXR1cm4gdGhpcy5qb2luUHVzaFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIb29rIGludG8gY2hhbm5lbCBjbG9zZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25DbG9zZShjYWxsYmFjayl7XG4gICAgdGhpcy5vbihDSEFOTkVMX0VWRU5UUy5jbG9zZSwgY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogSG9vayBpbnRvIGNoYW5uZWwgZXJyb3JzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbkVycm9yKGNhbGxiYWNrKXtcbiAgICByZXR1cm4gdGhpcy5vbihDSEFOTkVMX0VWRU5UUy5lcnJvciwgcmVhc29uID0+IGNhbGxiYWNrKHJlYXNvbikpXG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlcyBvbiBjaGFubmVsIGV2ZW50c1xuICAgKlxuICAgKiBTdWJzY3JpcHRpb24gcmV0dXJucyBhIHJlZiBjb3VudGVyLCB3aGljaCBjYW4gYmUgdXNlZCBsYXRlciB0b1xuICAgKiB1bnN1YnNjcmliZSB0aGUgZXhhY3QgZXZlbnQgbGlzdGVuZXJcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcmVmMSA9IGNoYW5uZWwub24oXCJldmVudFwiLCBkb19zdHVmZilcbiAgICogY29uc3QgcmVmMiA9IGNoYW5uZWwub24oXCJldmVudFwiLCBkb19vdGhlcl9zdHVmZilcbiAgICogY2hhbm5lbC5vZmYoXCJldmVudFwiLCByZWYxKVxuICAgKiAvLyBTaW5jZSB1bnN1YnNjcmlwdGlvbiwgZG9fc3R1ZmYgd29uJ3QgZmlyZSxcbiAgICogLy8gd2hpbGUgZG9fb3RoZXJfc3R1ZmYgd2lsbCBrZWVwIGZpcmluZyBvbiB0aGUgXCJldmVudFwiXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7aW50ZWdlcn0gcmVmXG4gICAqL1xuICBvbihldmVudCwgY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLmJpbmRpbmdSZWYrK1xuICAgIHRoaXMuYmluZGluZ3MucHVzaCh7ZXZlbnQsIHJlZiwgY2FsbGJhY2t9KVxuICAgIHJldHVybiByZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgb2ZmIG9mIGNoYW5uZWwgZXZlbnRzXG4gICAqXG4gICAqIFVzZSB0aGUgcmVmIHJldHVybmVkIGZyb20gYSBjaGFubmVsLm9uKCkgdG8gdW5zdWJzY3JpYmUgb25lXG4gICAqIGhhbmRsZXIsIG9yIHBhc3Mgbm90aGluZyBmb3IgdGhlIHJlZiB0byB1bnN1YnNjcmliZSBhbGxcbiAgICogaGFuZGxlcnMgZm9yIHRoZSBnaXZlbiBldmVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gVW5zdWJzY3JpYmUgdGhlIGRvX3N0dWZmIGhhbmRsZXJcbiAgICogY29uc3QgcmVmMSA9IGNoYW5uZWwub24oXCJldmVudFwiLCBkb19zdHVmZilcbiAgICogY2hhbm5lbC5vZmYoXCJldmVudFwiLCByZWYxKVxuICAgKlxuICAgKiAvLyBVbnN1YnNjcmliZSBhbGwgaGFuZGxlcnMgZnJvbSBldmVudFxuICAgKiBjaGFubmVsLm9mZihcImV2ZW50XCIpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHJlZlxuICAgKi9cbiAgb2ZmKGV2ZW50LCByZWYpe1xuICAgIHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgcmV0dXJuICEoYmluZC5ldmVudCA9PT0gZXZlbnQgJiYgKHR5cGVvZiByZWYgPT09IFwidW5kZWZpbmVkXCIgfHwgcmVmID09PSBiaW5kLnJlZikpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FuUHVzaCgpeyByZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLmlzSm9pbmVkKCkgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIG1lc3NhZ2UgYGV2ZW50YCB0byBwaG9lbml4IHdpdGggdGhlIHBheWxvYWQgYHBheWxvYWRgLlxuICAgKiBQaG9lbml4IHJlY2VpdmVzIHRoaXMgaW4gdGhlIGBoYW5kbGVfaW4oZXZlbnQsIHBheWxvYWQsIHNvY2tldClgXG4gICAqIGZ1bmN0aW9uLiBpZiBwaG9lbml4IHJlcGxpZXMgb3IgaXQgdGltZXMgb3V0IChkZWZhdWx0IDEwMDAwbXMpLFxuICAgKiB0aGVuIG9wdGlvbmFsbHkgdGhlIHJlcGx5IGNhbiBiZSByZWNlaXZlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY2hhbm5lbC5wdXNoKFwiZXZlbnRcIilcbiAgICogICAucmVjZWl2ZShcIm9rXCIsIHBheWxvYWQgPT4gY29uc29sZS5sb2coXCJwaG9lbml4IHJlcGxpZWQ6XCIsIHBheWxvYWQpKVxuICAgKiAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgZXJyID0+IGNvbnNvbGUubG9nKFwicGhvZW5peCBlcnJvcmVkXCIsIGVycikpXG4gICAqICAgLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IGNvbnNvbGUubG9nKFwidGltZWQgb3V0IHB1c2hpbmdcIikpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVvdXRdXG4gICAqIEByZXR1cm5zIHtQdXNofVxuICAgKi9cbiAgcHVzaChldmVudCwgcGF5bG9hZCwgdGltZW91dCA9IHRoaXMudGltZW91dCl7XG4gICAgcGF5bG9hZCA9IHBheWxvYWQgfHwge31cbiAgICBpZighdGhpcy5qb2luZWRPbmNlKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHJpZWQgdG8gcHVzaCAnJHtldmVudH0nIHRvICcke3RoaXMudG9waWN9JyBiZWZvcmUgam9pbmluZy4gVXNlIGNoYW5uZWwuam9pbigpIGJlZm9yZSBwdXNoaW5nIGV2ZW50c2ApXG4gICAgfVxuICAgIGxldCBwdXNoRXZlbnQgPSBuZXcgUHVzaCh0aGlzLCBldmVudCwgZnVuY3Rpb24gKCl7IHJldHVybiBwYXlsb2FkIH0sIHRpbWVvdXQpXG4gICAgaWYodGhpcy5jYW5QdXNoKCkpe1xuICAgICAgcHVzaEV2ZW50LnNlbmQoKVxuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoRXZlbnQuc3RhcnRUaW1lb3V0KClcbiAgICAgIHRoaXMucHVzaEJ1ZmZlci5wdXNoKHB1c2hFdmVudClcbiAgICB9XG5cbiAgICByZXR1cm4gcHVzaEV2ZW50XG4gIH1cblxuICAvKiogTGVhdmVzIHRoZSBjaGFubmVsXG4gICAqXG4gICAqIFVuc3Vic2NyaWJlcyBmcm9tIHNlcnZlciBldmVudHMsIGFuZFxuICAgKiBpbnN0cnVjdHMgY2hhbm5lbCB0byB0ZXJtaW5hdGUgb24gc2VydmVyXG4gICAqXG4gICAqIFRyaWdnZXJzIG9uQ2xvc2UoKSBob29rc1xuICAgKlxuICAgKiBUbyByZWNlaXZlIGxlYXZlIGFja25vd2xlZGdlbWVudHMsIHVzZSB0aGUgYHJlY2VpdmVgXG4gICAqIGhvb2sgdG8gYmluZCB0byB0aGUgc2VydmVyIGFjaywgaWU6XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNoYW5uZWwubGVhdmUoKS5yZWNlaXZlKFwib2tcIiwgKCkgPT4gYWxlcnQoXCJsZWZ0IVwiKSApXG4gICAqXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gdGltZW91dFxuICAgKiBAcmV0dXJucyB7UHVzaH1cbiAgICovXG4gIGxlYXZlKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpe1xuICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgIHRoaXMuam9pblB1c2guY2FuY2VsVGltZW91dCgpXG5cbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMubGVhdmluZ1xuICAgIGxldCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGxlYXZlICR7dGhpcy50b3BpY31gKVxuICAgICAgdGhpcy50cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmNsb3NlLCBcImxlYXZlXCIpXG4gICAgfVxuICAgIGxldCBsZWF2ZVB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5sZWF2ZSwgY2xvc3VyZSh7fSksIHRpbWVvdXQpXG4gICAgbGVhdmVQdXNoLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBvbkNsb3NlKCkpXG4gICAgICAucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4gb25DbG9zZSgpKVxuICAgIGxlYXZlUHVzaC5zZW5kKClcbiAgICBpZighdGhpcy5jYW5QdXNoKCkpeyBsZWF2ZVB1c2gudHJpZ2dlcihcIm9rXCIsIHt9KSB9XG5cbiAgICByZXR1cm4gbGVhdmVQdXNoXG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGFibGUgbWVzc2FnZSBob29rXG4gICAqXG4gICAqIFJlY2VpdmVzIGFsbCBldmVudHMgZm9yIHNwZWNpYWxpemVkIG1lc3NhZ2UgaGFuZGxpbmdcbiAgICogYmVmb3JlIGRpc3BhdGNoaW5nIHRvIHRoZSBjaGFubmVsIGNhbGxiYWNrcy5cbiAgICpcbiAgICogTXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gcmVmXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBvbk1lc3NhZ2UoX2V2ZW50LCBwYXlsb2FkLCBfcmVmKXsgcmV0dXJuIHBheWxvYWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNNZW1iZXIodG9waWMsIGV2ZW50LCBwYXlsb2FkLCBqb2luUmVmKXtcbiAgICBpZih0aGlzLnRvcGljICE9PSB0b3BpYyl7IHJldHVybiBmYWxzZSB9XG5cbiAgICBpZihqb2luUmVmICYmIGpvaW5SZWYgIT09IHRoaXMuam9pblJlZigpKXtcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIFwiZHJvcHBpbmcgb3V0ZGF0ZWQgbWVzc2FnZVwiLCB7dG9waWMsIGV2ZW50LCBwYXlsb2FkLCBqb2luUmVmfSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgam9pblJlZigpeyByZXR1cm4gdGhpcy5qb2luUHVzaC5yZWYgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpe1xuICAgIGlmKHRoaXMuaXNMZWF2aW5nKCkpeyByZXR1cm4gfVxuICAgIHRoaXMuc29ja2V0LmxlYXZlT3BlblRvcGljKHRoaXMudG9waWMpXG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5pbmdcbiAgICB0aGlzLmpvaW5QdXNoLnJlc2VuZCh0aW1lb3V0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5SZWYpe1xuICAgIGxldCBoYW5kbGVkUGF5bG9hZCA9IHRoaXMub25NZXNzYWdlKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5SZWYpXG4gICAgaWYocGF5bG9hZCAmJiAhaGFuZGxlZFBheWxvYWQpeyB0aHJvdyBuZXcgRXJyb3IoXCJjaGFubmVsIG9uTWVzc2FnZSBjYWxsYmFja3MgbXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWRcIikgfVxuXG4gICAgbGV0IGV2ZW50QmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmZpbHRlcihiaW5kID0+IGJpbmQuZXZlbnQgPT09IGV2ZW50KVxuXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGV2ZW50QmluZGluZ3MubGVuZ3RoOyBpKyspe1xuICAgICAgbGV0IGJpbmQgPSBldmVudEJpbmRpbmdzW2ldXG4gICAgICBiaW5kLmNhbGxiYWNrKGhhbmRsZWRQYXlsb2FkLCByZWYsIGpvaW5SZWYgfHwgdGhpcy5qb2luUmVmKCkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXBseUV2ZW50TmFtZShyZWYpeyByZXR1cm4gYGNoYW5fcmVwbHlfJHtyZWZ9YCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0Nsb3NlZCgpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzRXJyb3JlZCgpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0pvaW5lZCgpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmVkIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzSm9pbmluZygpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmluZyB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0xlYXZpbmcoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmxlYXZpbmcgfVxufVxuIiwgImltcG9ydCB7XG4gIGdsb2JhbCxcbiAgWEhSX1NUQVRFU1xufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBamF4IHtcblxuICBzdGF0aWMgcmVxdWVzdChtZXRob2QsIGVuZFBvaW50LCBhY2NlcHQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spe1xuICAgIGlmKGdsb2JhbC5YRG9tYWluUmVxdWVzdCl7XG4gICAgICBsZXQgcmVxID0gbmV3IGdsb2JhbC5YRG9tYWluUmVxdWVzdCgpIC8vIElFOCwgSUU5XG4gICAgICByZXR1cm4gdGhpcy54ZG9tYWluUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KCkgLy8gSUU3KywgRmlyZWZveCwgQ2hyb21lLCBPcGVyYSwgU2FmYXJpXG4gICAgICByZXR1cm4gdGhpcy54aHJSZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyB4ZG9tYWluUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spe1xuICAgIHJlcS50aW1lb3V0ID0gdGltZW91dFxuICAgIHJlcS5vcGVuKG1ldGhvZCwgZW5kUG9pbnQpXG4gICAgcmVxLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGxldCByZXNwb25zZSA9IHRoaXMucGFyc2VKU09OKHJlcS5yZXNwb25zZVRleHQpXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwb25zZSlcbiAgICB9XG4gICAgaWYob250aW1lb3V0KXsgcmVxLm9udGltZW91dCA9IG9udGltZW91dCB9XG5cbiAgICAvLyBXb3JrIGFyb3VuZCBidWcgaW4gSUU5IHRoYXQgcmVxdWlyZXMgYW4gYXR0YWNoZWQgb25wcm9ncmVzcyBoYW5kbGVyXG4gICAgcmVxLm9ucHJvZ3Jlc3MgPSAoKSA9PiB7IH1cblxuICAgIHJlcS5zZW5kKGJvZHkpXG4gICAgcmV0dXJuIHJlcVxuICB9XG5cbiAgc3RhdGljIHhoclJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBhY2NlcHQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spe1xuICAgIHJlcS5vcGVuKG1ldGhvZCwgZW5kUG9pbnQsIHRydWUpXG4gICAgcmVxLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgYWNjZXB0KVxuICAgIHJlcS5vbmVycm9yID0gKCkgPT4gY2FsbGJhY2sgJiYgY2FsbGJhY2sobnVsbClcbiAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYocmVxLnJlYWR5U3RhdGUgPT09IFhIUl9TVEFURVMuY29tcGxldGUgJiYgY2FsbGJhY2spe1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KVxuICAgICAgICBjYWxsYmFjayhyZXNwb25zZSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYob250aW1lb3V0KXsgcmVxLm9udGltZW91dCA9IG9udGltZW91dCB9XG5cbiAgICByZXEuc2VuZChib2R5KVxuICAgIHJldHVybiByZXFcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZUpTT04ocmVzcCl7XG4gICAgaWYoIXJlc3AgfHwgcmVzcCA9PT0gXCJcIil7IHJldHVybiBudWxsIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwKVxuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgY29uc29sZSAmJiBjb25zb2xlLmxvZyhcImZhaWxlZCB0byBwYXJzZSBKU09OIHJlc3BvbnNlXCIsIHJlc3ApXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBzZXJpYWxpemUob2JqLCBwYXJlbnRLZXkpe1xuICAgIGxldCBxdWVyeVN0ciA9IFtdXG4gICAgZm9yKHZhciBrZXkgaW4gb2JqKXtcbiAgICAgIGlmKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKXsgY29udGludWUgfVxuICAgICAgbGV0IHBhcmFtS2V5ID0gcGFyZW50S2V5ID8gYCR7cGFyZW50S2V5fVske2tleX1dYCA6IGtleVxuICAgICAgbGV0IHBhcmFtVmFsID0gb2JqW2tleV1cbiAgICAgIGlmKHR5cGVvZiBwYXJhbVZhbCA9PT0gXCJvYmplY3RcIil7XG4gICAgICAgIHF1ZXJ5U3RyLnB1c2godGhpcy5zZXJpYWxpemUocGFyYW1WYWwsIHBhcmFtS2V5KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5U3RyLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtS2V5KSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtVmFsKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5U3RyLmpvaW4oXCImXCIpXG4gIH1cblxuICBzdGF0aWMgYXBwZW5kUGFyYW1zKHVybCwgcGFyYW1zKXtcbiAgICBpZihPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMCl7IHJldHVybiB1cmwgfVxuXG4gICAgbGV0IHByZWZpeCA9IHVybC5tYXRjaCgvXFw/LykgPyBcIiZcIiA6IFwiP1wiXG4gICAgcmV0dXJuIGAke3VybH0ke3ByZWZpeH0ke3RoaXMuc2VyaWFsaXplKHBhcmFtcyl9YFxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgU09DS0VUX1NUQVRFUyxcbiAgVFJBTlNQT1JUU1xufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQgQWpheCBmcm9tIFwiLi9hamF4XCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9uZ1BvbGwge1xuXG4gIGNvbnN0cnVjdG9yKGVuZFBvaW50KXtcbiAgICB0aGlzLmVuZFBvaW50ID0gbnVsbFxuICAgIHRoaXMudG9rZW4gPSBudWxsXG4gICAgdGhpcy5za2lwSGVhcnRiZWF0ID0gdHJ1ZVxuICAgIHRoaXMucmVxcyA9IG5ldyBTZXQoKVxuICAgIHRoaXMub25vcGVuID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMub25lcnJvciA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICB0aGlzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICB0aGlzLm9uY2xvc2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5wb2xsRW5kcG9pbnQgPSB0aGlzLm5vcm1hbGl6ZUVuZHBvaW50KGVuZFBvaW50KVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZ1xuICAgIHRoaXMucG9sbCgpXG4gIH1cblxuICBub3JtYWxpemVFbmRwb2ludChlbmRQb2ludCl7XG4gICAgcmV0dXJuIChlbmRQb2ludFxuICAgICAgLnJlcGxhY2UoXCJ3czovL1wiLCBcImh0dHA6Ly9cIilcbiAgICAgIC5yZXBsYWNlKFwid3NzOi8vXCIsIFwiaHR0cHM6Ly9cIilcbiAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoLiopXFwvXCIgKyBUUkFOU1BPUlRTLndlYnNvY2tldCksIFwiJDEvXCIgKyBUUkFOU1BPUlRTLmxvbmdwb2xsKSlcbiAgfVxuXG4gIGVuZHBvaW50VVJMKCl7XG4gICAgcmV0dXJuIEFqYXguYXBwZW5kUGFyYW1zKHRoaXMucG9sbEVuZHBvaW50LCB7dG9rZW46IHRoaXMudG9rZW59KVxuICB9XG5cbiAgY2xvc2VBbmRSZXRyeShjb2RlLCByZWFzb24sIHdhc0NsZWFuKXtcbiAgICB0aGlzLmNsb3NlKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nXG4gIH1cblxuICBvbnRpbWVvdXQoKXtcbiAgICB0aGlzLm9uZXJyb3IoXCJ0aW1lb3V0XCIpXG4gICAgdGhpcy5jbG9zZUFuZFJldHJ5KDEwMDUsIFwidGltZW91dFwiLCBmYWxzZSlcbiAgfVxuXG4gIGlzQWN0aXZlKCl7IHJldHVybiB0aGlzLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMub3BlbiB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZyB9XG5cbiAgcG9sbCgpe1xuICAgIHRoaXMuYWpheChcIkdFVFwiLCBudWxsLCAoKSA9PiB0aGlzLm9udGltZW91dCgpLCByZXNwID0+IHtcbiAgICAgIGlmKHJlc3Ape1xuICAgICAgICB2YXIge3N0YXR1cywgdG9rZW4sIG1lc3NhZ2VzfSA9IHJlc3BcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0dXMgPSAwXG4gICAgICB9XG5cbiAgICAgIHN3aXRjaChzdGF0dXMpe1xuICAgICAgICBjYXNlIDIwMDpcbiAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKG1zZyA9PiB7XG4gICAgICAgICAgICAvLyBUYXNrcyBhcmUgd2hhdCB0aGluZ3MgbGlrZSBldmVudCBoYW5kbGVycywgc2V0VGltZW91dCBjYWxsYmFja3MsXG4gICAgICAgICAgICAvLyBwcm9taXNlIHJlc29sdmVzIGFuZCBtb3JlIGFyZSBydW4gd2l0aGluLlxuICAgICAgICAgICAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzLCB0aGVyZSBhcmUgdHdvIGRpZmZlcmVudCBraW5kcyBvZiB0YXNrcyxcbiAgICAgICAgICAgIC8vIG1pY3JvdGFza3MgYW5kIG1hY3JvdGFza3MuXG4gICAgICAgICAgICAvLyBNaWNyb3Rhc2tzIGFyZSBtYWlubHkgdXNlZCBmb3IgUHJvbWlzZXMsIHdoaWxlIG1hY3JvdGFza3MgYXJlXG4gICAgICAgICAgICAvLyB1c2VkIGZvciBldmVyeXRoaW5nIGVsc2UuXG4gICAgICAgICAgICAvLyBNaWNyb3Rhc2tzIGFsd2F5cyBoYXZlIHByaW9yaXR5IG92ZXIgbWFjcm90YXNrcy4gSWYgdGhlIEpTIGVuZ2luZVxuICAgICAgICAgICAgLy8gaXMgbG9va2luZyBmb3IgYSB0YXNrIHRvIHJ1biwgaXQgd2lsbCBhbHdheXMgdHJ5IHRvIGVtcHR5IHRoZVxuICAgICAgICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHJ1biBhbnl0aGluZyBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gbWFjcm90YXNrIHF1ZXVlLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEZvciB0aGUgV2ViU29ja2V0IHRyYW5zcG9ydCwgbWVzc2FnZXMgYWx3YXlzIGFycml2ZSBpbiB0aGVpciBvd25cbiAgICAgICAgICAgIC8vIGV2ZW50LiBUaGlzIG1lYW5zIHRoYXQgaWYgYW55IHByb21pc2VzIGFyZSByZXNvbHZlZCBmcm9tIHdpdGhpbixcbiAgICAgICAgICAgIC8vIHRoZWlyIGNhbGxiYWNrcyB3aWxsIGFsd2F5cyBmaW5pc2ggZXhlY3V0aW9uIGJ5IHRoZSB0aW1lIHRoZVxuICAgICAgICAgICAgLy8gbmV4dCBtZXNzYWdlIGV2ZW50IGhhbmRsZXIgaXMgcnVuLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIGVtdWxhdGUgdGhpcyBiZWhhdmlvdXIsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGVhY2hcbiAgICAgICAgICAgIC8vIG9ubWVzc2FnZSBoYW5kbGVyIGlzIHJ1biB3aXRoaW4gaXQncyBvd24gbWFjcm90YXNrLlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLm9ubWVzc2FnZSh7ZGF0YTogbXNnfSksIDApXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0aGlzLnBvbGwoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgIHRoaXMucG9sbCgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0MTA6XG4gICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5vcGVuXG4gICAgICAgICAgdGhpcy5vbm9wZW4oe30pXG4gICAgICAgICAgdGhpcy5wb2xsKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQwMzpcbiAgICAgICAgICB0aGlzLm9uZXJyb3IoNDAzKVxuICAgICAgICAgIHRoaXMuY2xvc2UoMTAwOCwgXCJmb3JiaWRkZW5cIiwgZmFsc2UpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDUwMDpcbiAgICAgICAgICB0aGlzLm9uZXJyb3IoNTAwKVxuICAgICAgICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgxMDExLCBcImludGVybmFsIHNlcnZlciBlcnJvclwiLCA1MDApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgcG9sbCBzdGF0dXMgJHtzdGF0dXN9YClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc2VuZChib2R5KXtcbiAgICB0aGlzLmFqYXgoXCJQT1NUXCIsIGJvZHksICgpID0+IHRoaXMub25lcnJvcihcInRpbWVvdXRcIiksIHJlc3AgPT4ge1xuICAgICAgaWYoIXJlc3AgfHwgcmVzcC5zdGF0dXMgIT09IDIwMCl7XG4gICAgICAgIHRoaXMub25lcnJvcihyZXNwICYmIHJlc3Auc3RhdHVzKVxuICAgICAgICB0aGlzLmNsb3NlQW5kUmV0cnkoMTAxMSwgXCJpbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIiwgZmFsc2UpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNsb3NlKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pe1xuICAgIGZvcihsZXQgcmVxIG9mIHRoaXMucmVxcyl7IHJlcS5hYm9ydCgpIH1cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNsb3NlZFxuICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7Y29kZTogMTAwMCwgcmVhc29uOiB1bmRlZmluZWQsIHdhc0NsZWFuOiB0cnVlfSwge2NvZGUsIHJlYXNvbiwgd2FzQ2xlYW59KVxuICAgIGlmKHR5cGVvZihDbG9zZUV2ZW50KSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICB0aGlzLm9uY2xvc2UobmV3IENsb3NlRXZlbnQoXCJjbG9zZVwiLCBvcHRzKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbmNsb3NlKG9wdHMpXG4gICAgfVxuICB9XG5cbiAgYWpheChtZXRob2QsIGJvZHksIG9uQ2FsbGVyVGltZW91dCwgY2FsbGJhY2spe1xuICAgIGxldCByZXFcbiAgICBsZXQgb250aW1lb3V0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5yZXFzLmRlbGV0ZShyZXEpXG4gICAgICBvbkNhbGxlclRpbWVvdXQoKVxuICAgIH1cbiAgICByZXEgPSBBamF4LnJlcXVlc3QobWV0aG9kLCB0aGlzLmVuZHBvaW50VVJMKCksIFwiYXBwbGljYXRpb24vanNvblwiLCBib2R5LCB0aGlzLnRpbWVvdXQsIG9udGltZW91dCwgcmVzcCA9PiB7XG4gICAgICB0aGlzLnJlcXMuZGVsZXRlKHJlcSlcbiAgICAgIGlmKHRoaXMuaXNBY3RpdmUoKSl7IGNhbGxiYWNrKHJlc3ApIH1cbiAgICB9KVxuICAgIHRoaXMucmVxcy5hZGQocmVxKVxuICB9XG59XG4iLCAiLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgUHJlc2VuY2VcbiAqIEBwYXJhbSB7Q2hhbm5lbH0gY2hhbm5lbCAtIFRoZSBDaGFubmVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBvcHRpb25zLFxuICogICAgICAgIGZvciBleGFtcGxlIGB7ZXZlbnRzOiB7c3RhdGU6IFwic3RhdGVcIiwgZGlmZjogXCJkaWZmXCJ9fWBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJlc2VuY2Uge1xuXG4gIGNvbnN0cnVjdG9yKGNoYW5uZWwsIG9wdHMgPSB7fSl7XG4gICAgbGV0IGV2ZW50cyA9IG9wdHMuZXZlbnRzIHx8IHtzdGF0ZTogXCJwcmVzZW5jZV9zdGF0ZVwiLCBkaWZmOiBcInByZXNlbmNlX2RpZmZcIn1cbiAgICB0aGlzLnN0YXRlID0ge31cbiAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdXG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbFxuICAgIHRoaXMuam9pblJlZiA9IG51bGxcbiAgICB0aGlzLmNhbGxlciA9IHtcbiAgICAgIG9uSm9pbjogZnVuY3Rpb24gKCl7IH0sXG4gICAgICBvbkxlYXZlOiBmdW5jdGlvbiAoKXsgfSxcbiAgICAgIG9uU3luYzogZnVuY3Rpb24gKCl7IH1cbiAgICB9XG5cbiAgICB0aGlzLmNoYW5uZWwub24oZXZlbnRzLnN0YXRlLCBuZXdTdGF0ZSA9PiB7XG4gICAgICBsZXQge29uSm9pbiwgb25MZWF2ZSwgb25TeW5jfSA9IHRoaXMuY2FsbGVyXG5cbiAgICAgIHRoaXMuam9pblJlZiA9IHRoaXMuY2hhbm5lbC5qb2luUmVmKClcbiAgICAgIHRoaXMuc3RhdGUgPSBQcmVzZW5jZS5zeW5jU3RhdGUodGhpcy5zdGF0ZSwgbmV3U3RhdGUsIG9uSm9pbiwgb25MZWF2ZSlcblxuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMuZm9yRWFjaChkaWZmID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFByZXNlbmNlLnN5bmNEaWZmKHRoaXMuc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSlcbiAgICAgIH0pXG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdXG4gICAgICBvblN5bmMoKVxuICAgIH0pXG5cbiAgICB0aGlzLmNoYW5uZWwub24oZXZlbnRzLmRpZmYsIGRpZmYgPT4ge1xuICAgICAgbGV0IHtvbkpvaW4sIG9uTGVhdmUsIG9uU3luY30gPSB0aGlzLmNhbGxlclxuXG4gICAgICBpZih0aGlzLmluUGVuZGluZ1N5bmNTdGF0ZSgpKXtcbiAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMucHVzaChkaWZmKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFByZXNlbmNlLnN5bmNEaWZmKHRoaXMuc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSlcbiAgICAgICAgb25TeW5jKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgb25Kb2luKGNhbGxiYWNrKXsgdGhpcy5jYWxsZXIub25Kb2luID0gY2FsbGJhY2sgfVxuXG4gIG9uTGVhdmUoY2FsbGJhY2speyB0aGlzLmNhbGxlci5vbkxlYXZlID0gY2FsbGJhY2sgfVxuXG4gIG9uU3luYyhjYWxsYmFjayl7IHRoaXMuY2FsbGVyLm9uU3luYyA9IGNhbGxiYWNrIH1cblxuICBsaXN0KGJ5KXsgcmV0dXJuIFByZXNlbmNlLmxpc3QodGhpcy5zdGF0ZSwgYnkpIH1cblxuICBpblBlbmRpbmdTeW5jU3RhdGUoKXtcbiAgICByZXR1cm4gIXRoaXMuam9pblJlZiB8fCAodGhpcy5qb2luUmVmICE9PSB0aGlzLmNoYW5uZWwuam9pblJlZigpKVxuICB9XG5cbiAgLy8gbG93ZXItbGV2ZWwgcHVibGljIHN0YXRpYyBBUElcblxuICAvKipcbiAgICogVXNlZCB0byBzeW5jIHRoZSBsaXN0IG9mIHByZXNlbmNlcyBvbiB0aGUgc2VydmVyXG4gICAqIHdpdGggdGhlIGNsaWVudCdzIHN0YXRlLiBBbiBvcHRpb25hbCBgb25Kb2luYCBhbmQgYG9uTGVhdmVgIGNhbGxiYWNrIGNhblxuICAgKiBiZSBwcm92aWRlZCB0byByZWFjdCB0byBjaGFuZ2VzIGluIHRoZSBjbGllbnQncyBsb2NhbCBwcmVzZW5jZXMgYWNyb3NzXG4gICAqIGRpc2Nvbm5lY3RzIGFuZCByZWNvbm5lY3RzIHdpdGggdGhlIHNlcnZlci5cbiAgICpcbiAgICogQHJldHVybnMge1ByZXNlbmNlfVxuICAgKi9cbiAgc3RhdGljIHN5bmNTdGF0ZShjdXJyZW50U3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpe1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuY2xvbmUoY3VycmVudFN0YXRlKVxuICAgIGxldCBqb2lucyA9IHt9XG4gICAgbGV0IGxlYXZlcyA9IHt9XG5cbiAgICB0aGlzLm1hcChzdGF0ZSwgKGtleSwgcHJlc2VuY2UpID0+IHtcbiAgICAgIGlmKCFuZXdTdGF0ZVtrZXldKXtcbiAgICAgICAgbGVhdmVzW2tleV0gPSBwcmVzZW5jZVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5tYXAobmV3U3RhdGUsIChrZXksIG5ld1ByZXNlbmNlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XVxuICAgICAgaWYoY3VycmVudFByZXNlbmNlKXtcbiAgICAgICAgbGV0IG5ld1JlZnMgPSBuZXdQcmVzZW5jZS5tZXRhcy5tYXAobSA9PiBtLnBoeF9yZWYpXG4gICAgICAgIGxldCBjdXJSZWZzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgICAgbGV0IGpvaW5lZE1ldGFzID0gbmV3UHJlc2VuY2UubWV0YXMuZmlsdGVyKG0gPT4gY3VyUmVmcy5pbmRleE9mKG0ucGh4X3JlZikgPCAwKVxuICAgICAgICBsZXQgbGVmdE1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcihtID0+IG5ld1JlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMClcbiAgICAgICAgaWYoam9pbmVkTWV0YXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgam9pbnNba2V5XSA9IG5ld1ByZXNlbmNlXG4gICAgICAgICAgam9pbnNba2V5XS5tZXRhcyA9IGpvaW5lZE1ldGFzXG4gICAgICAgIH1cbiAgICAgICAgaWYobGVmdE1ldGFzLmxlbmd0aCA+IDApe1xuICAgICAgICAgIGxlYXZlc1trZXldID0gdGhpcy5jbG9uZShjdXJyZW50UHJlc2VuY2UpXG4gICAgICAgICAgbGVhdmVzW2tleV0ubWV0YXMgPSBsZWZ0TWV0YXNcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgam9pbnNba2V5XSA9IG5ld1ByZXNlbmNlXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy5zeW5jRGlmZihzdGF0ZSwge2pvaW5zOiBqb2lucywgbGVhdmVzOiBsZWF2ZXN9LCBvbkpvaW4sIG9uTGVhdmUpXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogVXNlZCB0byBzeW5jIGEgZGlmZiBvZiBwcmVzZW5jZSBqb2luIGFuZCBsZWF2ZVxuICAgKiBldmVudHMgZnJvbSB0aGUgc2VydmVyLCBhcyB0aGV5IGhhcHBlbi4gTGlrZSBgc3luY1N0YXRlYCwgYHN5bmNEaWZmYFxuICAgKiBhY2NlcHRzIG9wdGlvbmFsIGBvbkpvaW5gIGFuZCBgb25MZWF2ZWAgY2FsbGJhY2tzIHRvIHJlYWN0IHRvIGEgdXNlclxuICAgKiBqb2luaW5nIG9yIGxlYXZpbmcgZnJvbSBhIGRldmljZS5cbiAgICpcbiAgICogQHJldHVybnMge1ByZXNlbmNlfVxuICAgKi9cbiAgc3RhdGljIHN5bmNEaWZmKHN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpe1xuICAgIGxldCB7am9pbnMsIGxlYXZlc30gPSB0aGlzLmNsb25lKGRpZmYpXG4gICAgaWYoIW9uSm9pbil7IG9uSm9pbiA9IGZ1bmN0aW9uICgpeyB9IH1cbiAgICBpZighb25MZWF2ZSl7IG9uTGVhdmUgPSBmdW5jdGlvbiAoKXsgfSB9XG5cbiAgICB0aGlzLm1hcChqb2lucywgKGtleSwgbmV3UHJlc2VuY2UpID0+IHtcbiAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldXG4gICAgICBzdGF0ZVtrZXldID0gdGhpcy5jbG9uZShuZXdQcmVzZW5jZSlcbiAgICAgIGlmKGN1cnJlbnRQcmVzZW5jZSl7XG4gICAgICAgIGxldCBqb2luZWRSZWZzID0gc3RhdGVba2V5XS5tZXRhcy5tYXAobSA9PiBtLnBoeF9yZWYpXG4gICAgICAgIGxldCBjdXJNZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIobSA9PiBqb2luZWRSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApXG4gICAgICAgIHN0YXRlW2tleV0ubWV0YXMudW5zaGlmdCguLi5jdXJNZXRhcylcbiAgICAgIH1cbiAgICAgIG9uSm9pbihrZXksIGN1cnJlbnRQcmVzZW5jZSwgbmV3UHJlc2VuY2UpXG4gICAgfSlcbiAgICB0aGlzLm1hcChsZWF2ZXMsIChrZXksIGxlZnRQcmVzZW5jZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZSA9IHN0YXRlW2tleV1cbiAgICAgIGlmKCFjdXJyZW50UHJlc2VuY2UpeyByZXR1cm4gfVxuICAgICAgbGV0IHJlZnNUb1JlbW92ZSA9IGxlZnRQcmVzZW5jZS5tZXRhcy5tYXAobSA9PiBtLnBoeF9yZWYpXG4gICAgICBjdXJyZW50UHJlc2VuY2UubWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKHAgPT4ge1xuICAgICAgICByZXR1cm4gcmVmc1RvUmVtb3ZlLmluZGV4T2YocC5waHhfcmVmKSA8IDBcbiAgICAgIH0pXG4gICAgICBvbkxlYXZlKGtleSwgY3VycmVudFByZXNlbmNlLCBsZWZ0UHJlc2VuY2UpXG4gICAgICBpZihjdXJyZW50UHJlc2VuY2UubWV0YXMubGVuZ3RoID09PSAwKXtcbiAgICAgICAgZGVsZXRlIHN0YXRlW2tleV1cbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBzdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFycmF5IG9mIHByZXNlbmNlcywgd2l0aCBzZWxlY3RlZCBtZXRhZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByZXNlbmNlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaG9vc2VyXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcmVzZW5jZX1cbiAgICovXG4gIHN0YXRpYyBsaXN0KHByZXNlbmNlcywgY2hvb3Nlcil7XG4gICAgaWYoIWNob29zZXIpeyBjaG9vc2VyID0gZnVuY3Rpb24gKGtleSwgcHJlcyl7IHJldHVybiBwcmVzIH0gfVxuXG4gICAgcmV0dXJuIHRoaXMubWFwKHByZXNlbmNlcywgKGtleSwgcHJlc2VuY2UpID0+IHtcbiAgICAgIHJldHVybiBjaG9vc2VyKGtleSwgcHJlc2VuY2UpXG4gICAgfSlcbiAgfVxuXG4gIC8vIHByaXZhdGVcblxuICBzdGF0aWMgbWFwKG9iaiwgZnVuYyl7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubWFwKGtleSA9PiBmdW5jKGtleSwgb2JqW2tleV0pKVxuICB9XG5cbiAgc3RhdGljIGNsb25lKG9iail7IHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpIH1cbn1cbiIsICIvKiBUaGUgZGVmYXVsdCBzZXJpYWxpemVyIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgbWVzc2FnZXMgKi9cbmltcG9ydCB7XG4gIENIQU5ORUxfRVZFTlRTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgSEVBREVSX0xFTkdUSDogMSxcbiAgTUVUQV9MRU5HVEg6IDQsXG4gIEtJTkRTOiB7cHVzaDogMCwgcmVwbHk6IDEsIGJyb2FkY2FzdDogMn0sXG5cbiAgZW5jb2RlKG1zZywgY2FsbGJhY2spe1xuICAgIGlmKG1zZy5wYXlsb2FkLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcil7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5iaW5hcnlFbmNvZGUobXNnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBheWxvYWQgPSBbbXNnLmpvaW5fcmVmLCBtc2cucmVmLCBtc2cudG9waWMsIG1zZy5ldmVudCwgbXNnLnBheWxvYWRdXG4gICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpXG4gICAgfVxuICB9LFxuXG4gIGRlY29kZShyYXdQYXlsb2FkLCBjYWxsYmFjayl7XG4gICAgaWYocmF3UGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpe1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuYmluYXJ5RGVjb2RlKHJhd1BheWxvYWQpKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgW2pvaW5fcmVmLCByZWYsIHRvcGljLCBldmVudCwgcGF5bG9hZF0gPSBKU09OLnBhcnNlKHJhd1BheWxvYWQpXG4gICAgICByZXR1cm4gY2FsbGJhY2soe2pvaW5fcmVmLCByZWYsIHRvcGljLCBldmVudCwgcGF5bG9hZH0pXG4gICAgfVxuICB9LFxuXG4gIC8vIHByaXZhdGVcblxuICBiaW5hcnlFbmNvZGUobWVzc2FnZSl7XG4gICAgbGV0IHtqb2luX3JlZiwgcmVmLCBldmVudCwgdG9waWMsIHBheWxvYWR9ID0gbWVzc2FnZVxuICAgIGxldCBtZXRhTGVuZ3RoID0gdGhpcy5NRVRBX0xFTkdUSCArIGpvaW5fcmVmLmxlbmd0aCArIHJlZi5sZW5ndGggKyB0b3BpYy5sZW5ndGggKyBldmVudC5sZW5ndGhcbiAgICBsZXQgaGVhZGVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuSEVBREVSX0xFTkdUSCArIG1ldGFMZW5ndGgpXG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoaGVhZGVyKVxuICAgIGxldCBvZmZzZXQgPSAwXG5cbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCB0aGlzLktJTkRTLnB1c2gpIC8vIGtpbmRcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBqb2luX3JlZi5sZW5ndGgpXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgcmVmLmxlbmd0aClcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCB0b3BpYy5sZW5ndGgpXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgZXZlbnQubGVuZ3RoKVxuICAgIEFycmF5LmZyb20oam9pbl9yZWYsIGNoYXIgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcbiAgICBBcnJheS5mcm9tKHJlZiwgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuICAgIEFycmF5LmZyb20odG9waWMsIGNoYXIgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcbiAgICBBcnJheS5mcm9tKGV2ZW50LCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG5cbiAgICB2YXIgY29tYmluZWQgPSBuZXcgVWludDhBcnJheShoZWFkZXIuYnl0ZUxlbmd0aCArIHBheWxvYWQuYnl0ZUxlbmd0aClcbiAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkoaGVhZGVyKSwgMClcbiAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIGhlYWRlci5ieXRlTGVuZ3RoKVxuXG4gICAgcmV0dXJuIGNvbWJpbmVkLmJ1ZmZlclxuICB9LFxuXG4gIGJpbmFyeURlY29kZShidWZmZXIpe1xuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcilcbiAgICBsZXQga2luZCA9IHZpZXcuZ2V0VWludDgoMClcbiAgICBsZXQgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSB0aGlzLktJTkRTLnB1c2g6IHJldHVybiB0aGlzLmRlY29kZVB1c2goYnVmZmVyLCB2aWV3LCBkZWNvZGVyKVxuICAgICAgY2FzZSB0aGlzLktJTkRTLnJlcGx5OiByZXR1cm4gdGhpcy5kZWNvZGVSZXBseShidWZmZXIsIHZpZXcsIGRlY29kZXIpXG4gICAgICBjYXNlIHRoaXMuS0lORFMuYnJvYWRjYXN0OiByZXR1cm4gdGhpcy5kZWNvZGVCcm9hZGNhc3QoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKVxuICAgIH1cbiAgfSxcblxuICBkZWNvZGVQdXNoKGJ1ZmZlciwgdmlldywgZGVjb2Rlcil7XG4gICAgbGV0IGpvaW5SZWZTaXplID0gdmlldy5nZXRVaW50OCgxKVxuICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDIpXG4gICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoMylcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgdGhpcy5NRVRBX0xFTkdUSCAtIDEgLy8gcHVzaGVzIGhhdmUgbm8gcmVmXG4gICAgbGV0IGpvaW5SZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBqb2luUmVmU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgam9pblJlZlNpemVcbiAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZVxuICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplXG4gICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aClcbiAgICByZXR1cm4ge2pvaW5fcmVmOiBqb2luUmVmLCByZWY6IG51bGwsIHRvcGljOiB0b3BpYywgZXZlbnQ6IGV2ZW50LCBwYXlsb2FkOiBkYXRhfVxuICB9LFxuXG4gIGRlY29kZVJlcGx5KGJ1ZmZlciwgdmlldywgZGVjb2Rlcil7XG4gICAgbGV0IGpvaW5SZWZTaXplID0gdmlldy5nZXRVaW50OCgxKVxuICAgIGxldCByZWZTaXplID0gdmlldy5nZXRVaW50OCgyKVxuICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDMpXG4gICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoNClcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgdGhpcy5NRVRBX0xFTkdUSFxuICAgIGxldCBqb2luUmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgam9pblJlZlNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGpvaW5SZWZTaXplXG4gICAgbGV0IHJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHJlZlNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIHJlZlNpemVcbiAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZVxuICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplXG4gICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aClcbiAgICBsZXQgcGF5bG9hZCA9IHtzdGF0dXM6IGV2ZW50LCByZXNwb25zZTogZGF0YX1cbiAgICByZXR1cm4ge2pvaW5fcmVmOiBqb2luUmVmLCByZWY6IHJlZiwgdG9waWM6IHRvcGljLCBldmVudDogQ0hBTk5FTF9FVkVOVFMucmVwbHksIHBheWxvYWQ6IHBheWxvYWR9XG4gIH0sXG5cbiAgZGVjb2RlQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2Rlcil7XG4gICAgbGV0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBsZXQgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCgyKVxuICAgIGxldCBvZmZzZXQgPSB0aGlzLkhFQURFUl9MRU5HVEggKyAyXG4gICAgbGV0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemVcbiAgICBsZXQgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZVxuICAgIGxldCBkYXRhID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpXG5cbiAgICByZXR1cm4ge2pvaW5fcmVmOiBudWxsLCByZWY6IG51bGwsIHRvcGljOiB0b3BpYywgZXZlbnQ6IGV2ZW50LCBwYXlsb2FkOiBkYXRhfVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgZ2xvYmFsLFxuICBwaHhXaW5kb3csXG4gIENIQU5ORUxfRVZFTlRTLFxuICBERUZBVUxUX1RJTUVPVVQsXG4gIERFRkFVTFRfVlNOLFxuICBTT0NLRVRfU1RBVEVTLFxuICBUUkFOU1BPUlRTLFxuICBXU19DTE9TRV9OT1JNQUxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgY2xvc3VyZVxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBBamF4IGZyb20gXCIuL2FqYXhcIlxuaW1wb3J0IENoYW5uZWwgZnJvbSBcIi4vY2hhbm5lbFwiXG5pbXBvcnQgTG9uZ1BvbGwgZnJvbSBcIi4vbG9uZ3BvbGxcIlxuaW1wb3J0IFNlcmlhbGl6ZXIgZnJvbSBcIi4vc2VyaWFsaXplclwiXG5pbXBvcnQgVGltZXIgZnJvbSBcIi4vdGltZXJcIlxuXG4vKiogSW5pdGlhbGl6ZXMgdGhlIFNvY2tldCAqXG4gKlxuICogRm9yIElFOCBzdXBwb3J0IHVzZSBhbiBFUzUtc2hpbSAoaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRQb2ludCAtIFRoZSBzdHJpbmcgV2ViU29ja2V0IGVuZHBvaW50LCBpZSwgYFwid3M6Ly9leGFtcGxlLmNvbS9zb2NrZXRcImAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFwid3NzOi8vZXhhbXBsZS5jb21cImBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXCIvc29ja2V0XCJgIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLnRyYW5zcG9ydF0gLSBUaGUgV2Vic29ja2V0IFRyYW5zcG9ydCwgZm9yIGV4YW1wbGUgV2ViU29ja2V0IG9yIFBob2VuaXguTG9uZ1BvbGwuXG4gKlxuICogRGVmYXVsdHMgdG8gV2ViU29ja2V0IHdpdGggYXV0b21hdGljIExvbmdQb2xsIGZhbGxiYWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMuZW5jb2RlXSAtIFRoZSBmdW5jdGlvbiB0byBlbmNvZGUgb3V0Z29pbmcgbWVzc2FnZXMuXG4gKlxuICogRGVmYXVsdHMgdG8gSlNPTiBlbmNvZGVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmRlY29kZV0gLSBUaGUgZnVuY3Rpb24gdG8gZGVjb2RlIGluY29taW5nIG1lc3NhZ2VzLlxuICpcbiAqIERlZmF1bHRzIHRvIEpTT046XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogKHBheWxvYWQsIGNhbGxiYWNrKSA9PiBjYWxsYmFjayhKU09OLnBhcnNlKHBheWxvYWQpKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVvdXRdIC0gVGhlIGRlZmF1bHQgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gdHJpZ2dlciBwdXNoIHRpbWVvdXRzLlxuICpcbiAqIERlZmF1bHRzIGBERUZBVUxUX1RJTUVPVVRgXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaGVhcnRiZWF0SW50ZXJ2YWxNc10gLSBUaGUgbWlsbGlzZWMgaW50ZXJ2YWwgdG8gc2VuZCBhIGhlYXJ0YmVhdCBtZXNzYWdlXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMucmVjb25uZWN0QWZ0ZXJNc10gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsc2VjXG4gKiBzb2NrZXQgcmVjb25uZWN0IGludGVydmFsLlxuICpcbiAqIERlZmF1bHRzIHRvIHN0ZXBwZWQgYmFja29mZiBvZjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBmdW5jdGlvbih0cmllcyl7XG4gKiAgIHJldHVybiBbMTAsIDUwLCAxMDAsIDE1MCwgMjAwLCAyNTAsIDUwMCwgMTAwMCwgMjAwMF1bdHJpZXMgLSAxXSB8fCA1MDAwXG4gKiB9XG4gKiBgYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnJlam9pbkFmdGVyTXNdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWlsbHNlY1xuICogcmVqb2luIGludGVydmFsIGZvciBpbmRpdmlkdWFsIGNoYW5uZWxzLlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMDAwLCAyMDAwLCA1MDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiB9XG4gKiBgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMubG9nZ2VyXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZywgaWU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZnVuY3Rpb24oa2luZCwgbXNnLCBkYXRhKSB7XG4gKiAgIGNvbnNvbGUubG9nKGAke2tpbmR9OiAke21zZ31gLCBkYXRhKVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmxvbmdwb2xsZXJUaW1lb3V0XSAtIFRoZSBtYXhpbXVtIHRpbWVvdXQgb2YgYSBsb25nIHBvbGwgQUpBWCByZXF1ZXN0LlxuICpcbiAqIERlZmF1bHRzIHRvIDIwcyAoZG91YmxlIHRoZSBzZXJ2ZXIgbG9uZyBwb2xsIHRpbWVyKS5cbiAqXG4gKiBAcGFyYW0geyhPYmplY3R8ZnVuY3Rpb24pfSBbb3B0cy5wYXJhbXNdIC0gVGhlIG9wdGlvbmFsIHBhcmFtcyB0byBwYXNzIHdoZW4gY29ubmVjdGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJpbmFyeVR5cGVdIC0gVGhlIGJpbmFyeSB0eXBlIHRvIHVzZSBmb3IgYmluYXJ5IFdlYlNvY2tldCBmcmFtZXMuXG4gKlxuICogRGVmYXVsdHMgdG8gXCJhcnJheWJ1ZmZlclwiXG4gKlxuICogQHBhcmFtIHt2c259IFtvcHRzLnZzbl0gLSBUaGUgc2VyaWFsaXplcidzIHByb3RvY29sIHZlcnNpb24gdG8gc2VuZCBvbiBjb25uZWN0LlxuICpcbiAqIERlZmF1bHRzIHRvIERFRkFVTFRfVlNOLlxuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNvY2tldCB7XG4gIGNvbnN0cnVjdG9yKGVuZFBvaW50LCBvcHRzID0ge30pe1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB7b3BlbjogW10sIGNsb3NlOiBbXSwgZXJyb3I6IFtdLCBtZXNzYWdlOiBbXX1cbiAgICB0aGlzLmNoYW5uZWxzID0gW11cbiAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXVxuICAgIHRoaXMucmVmID0gMFxuICAgIHRoaXMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCBERUZBVUxUX1RJTUVPVVRcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG9wdHMudHJhbnNwb3J0IHx8IGdsb2JhbC5XZWJTb2NrZXQgfHwgTG9uZ1BvbGxcbiAgICB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnMgPSAwXG4gICAgdGhpcy5kZWZhdWx0RW5jb2RlciA9IFNlcmlhbGl6ZXIuZW5jb2RlLmJpbmQoU2VyaWFsaXplcilcbiAgICB0aGlzLmRlZmF1bHREZWNvZGVyID0gU2VyaWFsaXplci5kZWNvZGUuYmluZChTZXJpYWxpemVyKVxuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgdGhpcy5iaW5hcnlUeXBlID0gb3B0cy5iaW5hcnlUeXBlIHx8IFwiYXJyYXlidWZmZXJcIlxuICAgIHRoaXMuY29ubmVjdENsb2NrID0gMVxuICAgIGlmKHRoaXMudHJhbnNwb3J0ICE9PSBMb25nUG9sbCl7XG4gICAgICB0aGlzLmVuY29kZSA9IG9wdHMuZW5jb2RlIHx8IHRoaXMuZGVmYXVsdEVuY29kZXJcbiAgICAgIHRoaXMuZGVjb2RlID0gb3B0cy5kZWNvZGUgfHwgdGhpcy5kZWZhdWx0RGVjb2RlclxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuY29kZSA9IHRoaXMuZGVmYXVsdEVuY29kZXJcbiAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWZhdWx0RGVjb2RlclxuICAgIH1cbiAgICBsZXQgYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9IG51bGxcbiAgICBpZihwaHhXaW5kb3cgJiYgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIpe1xuICAgICAgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfZSA9PiB7XG4gICAgICAgIGlmKHRoaXMuY29ubil7XG4gICAgICAgICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICAgICAgICBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gdGhpcy5jb25uZWN0Q2xvY2tcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZXNob3dcIiwgX2UgPT4ge1xuICAgICAgICBpZihhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID09PSB0aGlzLmNvbm5lY3RDbG9jayl7XG4gICAgICAgICAgYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9IG51bGxcbiAgICAgICAgICB0aGlzLmNvbm5lY3QoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMgPSBvcHRzLmhlYXJ0YmVhdEludGVydmFsTXMgfHwgMzAwMDBcbiAgICB0aGlzLnJlam9pbkFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgIGlmKG9wdHMucmVqb2luQWZ0ZXJNcyl7XG4gICAgICAgIHJldHVybiBvcHRzLnJlam9pbkFmdGVyTXModHJpZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzEwMDAsIDIwMDAsIDUwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZWNvbm5lY3RBZnRlck1zID0gKHRyaWVzKSA9PiB7XG4gICAgICBpZihvcHRzLnJlY29ubmVjdEFmdGVyTXMpe1xuICAgICAgICByZXR1cm4gb3B0cy5yZWNvbm5lY3RBZnRlck1zKHRyaWVzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFsxMCwgNTAsIDEwMCwgMTUwLCAyMDAsIDI1MCwgNTAwLCAxMDAwLCAyMDAwXVt0cmllcyAtIDFdIHx8IDUwMDBcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2dnZXIgPSBvcHRzLmxvZ2dlciB8fCBudWxsXG4gICAgdGhpcy5sb25ncG9sbGVyVGltZW91dCA9IG9wdHMubG9uZ3BvbGxlclRpbWVvdXQgfHwgMjAwMDBcbiAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUob3B0cy5wYXJhbXMgfHwge30pXG4gICAgdGhpcy5lbmRQb2ludCA9IGAke2VuZFBvaW50fS8ke1RSQU5TUE9SVFMud2Vic29ja2V0fWBcbiAgICB0aGlzLnZzbiA9IG9wdHMudnNuIHx8IERFRkFVTFRfVlNOXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IG51bGxcbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB7XG4gICAgICB0aGlzLnRlYXJkb3duKCgpID0+IHRoaXMuY29ubmVjdCgpKVxuICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBMb25nUG9sbCB0cmFuc3BvcnQgcmVmZXJlbmNlXG4gICAqL1xuICBnZXRMb25nUG9sbFRyYW5zcG9ydCgpeyByZXR1cm4gTG9uZ1BvbGwgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyBhbmQgcmVwbGFjZXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnRcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV3VHJhbnNwb3J0IC0gVGhlIG5ldyB0cmFuc3BvcnQgY2xhc3MgdG8gaW5zdGFudGlhdGVcbiAgICpcbiAgICovXG4gIHJlcGxhY2VUcmFuc3BvcnQobmV3VHJhbnNwb3J0KXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gdHJ1ZVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdXG4gICAgaWYodGhpcy5jb25uKXtcbiAgICAgIHRoaXMuY29ubi5jbG9zZSgpXG4gICAgICB0aGlzLmNvbm4gPSBudWxsXG4gICAgfVxuICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3VHJhbnNwb3J0XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc29ja2V0IHByb3RvY29sXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBwcm90b2NvbCgpeyByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wubWF0Y2goL15odHRwcy8pID8gXCJ3c3NcIiA6IFwid3NcIiB9XG5cbiAgLyoqXG4gICAqIFRoZSBmdWxseSBxdWFsaWZlZCBzb2NrZXQgdXJsXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBlbmRQb2ludFVSTCgpe1xuICAgIGxldCB1cmkgPSBBamF4LmFwcGVuZFBhcmFtcyhcbiAgICAgIEFqYXguYXBwZW5kUGFyYW1zKHRoaXMuZW5kUG9pbnQsIHRoaXMucGFyYW1zKCkpLCB7dnNuOiB0aGlzLnZzbn0pXG4gICAgaWYodXJpLmNoYXJBdCgwKSAhPT0gXCIvXCIpeyByZXR1cm4gdXJpIH1cbiAgICBpZih1cmkuY2hhckF0KDEpID09PSBcIi9cIil7IHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9OiR7dXJpfWAgfVxuXG4gICAgcmV0dXJuIGAke3RoaXMucHJvdG9jb2woKX06Ly8ke2xvY2F0aW9uLmhvc3R9JHt1cml9YFxuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXRcbiAgICpcbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50I1N0YXR1c19jb2RlcyBmb3IgdmFsaWQgc3RhdHVzIGNvZGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIE9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBzb2NrZXQgaXMgZGlzY29ubmVjdGVkLlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IGNvZGUgLSBBIHN0YXR1cyBjb2RlIGZvciBkaXNjb25uZWN0aW9uIChPcHRpb25hbCkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBBIHRleHR1YWwgZGVzY3JpcHRpb24gb2YgdGhlIHJlYXNvbiB0byBkaXNjb25uZWN0LiAoT3B0aW9uYWwpXG4gICAqL1xuICBkaXNjb25uZWN0KGNhbGxiYWNrLCBjb2RlLCByZWFzb24pe1xuICAgIHRoaXMuY29ubmVjdENsb2NrKytcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSB0cnVlXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgdGhpcy50ZWFyZG93bihjYWxsYmFjaywgY29kZSwgcmVhc29uKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1zIHRvIHNlbmQgd2hlbiBjb25uZWN0aW5nLCBmb3IgZXhhbXBsZSBge3VzZXJfaWQ6IHVzZXJUb2tlbn1gXG4gICAqXG4gICAqIFBhc3NpbmcgcGFyYW1zIHRvIGNvbm5lY3QgaXMgZGVwcmVjYXRlZDsgcGFzcyB0aGVtIGluIHRoZSBTb2NrZXQgY29uc3RydWN0b3IgaW5zdGVhZDpcbiAgICogYG5ldyBTb2NrZXQoXCIvc29ja2V0XCIsIHtwYXJhbXM6IHt1c2VyX2lkOiB1c2VyVG9rZW59fSlgLlxuICAgKi9cbiAgY29ubmVjdChwYXJhbXMpe1xuICAgIGlmKHBhcmFtcyl7XG4gICAgICBjb25zb2xlICYmIGNvbnNvbGUubG9nKFwicGFzc2luZyBwYXJhbXMgdG8gY29ubmVjdCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHBhc3MgOnBhcmFtcyB0byB0aGUgU29ja2V0IGNvbnN0cnVjdG9yXCIpXG4gICAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUocGFyYW1zKVxuICAgIH1cbiAgICBpZih0aGlzLmNvbm4peyByZXR1cm4gfVxuXG4gICAgdGhpcy5jb25uZWN0Q2xvY2srK1xuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgdGhpcy5jb25uID0gbmV3IHRoaXMudHJhbnNwb3J0KHRoaXMuZW5kUG9pbnRVUkwoKSlcbiAgICB0aGlzLmNvbm4uYmluYXJ5VHlwZSA9IHRoaXMuYmluYXJ5VHlwZVxuICAgIHRoaXMuY29ubi50aW1lb3V0ID0gdGhpcy5sb25ncG9sbGVyVGltZW91dFxuICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLm9uQ29ubk9wZW4oKVxuICAgIHRoaXMuY29ubi5vbmVycm9yID0gZXJyb3IgPT4gdGhpcy5vbkNvbm5FcnJvcihlcnJvcilcbiAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gZXZlbnQgPT4gdGhpcy5vbkNvbm5NZXNzYWdlKGV2ZW50KVxuICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZXZlbnQgPT4gdGhpcy5vbkNvbm5DbG9zZShldmVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIHRoZSBtZXNzYWdlLiBPdmVycmlkZSBgdGhpcy5sb2dnZXJgIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLiBub29wcyBieSBkZWZhdWx0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBraW5kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG4gIGxvZyhraW5kLCBtc2csIGRhdGEpeyB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgbG9nZ2VyIGhhcyBiZWVuIHNldCBvbiB0aGlzIHNvY2tldC5cbiAgICovXG4gIGhhc0xvZ2dlcigpeyByZXR1cm4gdGhpcy5sb2dnZXIgIT09IG51bGwgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGZvciBjb25uZWN0aW9uIG9wZW4gZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlIHNvY2tldC5vbk9wZW4oZnVuY3Rpb24oKXsgY29uc29sZS5pbmZvKFwidGhlIHNvY2tldCB3YXMgb3BlbmVkXCIpIH0pXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbk9wZW4oY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBjbG9zZSBldmVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uQ2xvc2UoY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgZm9yIGNvbm5lY3Rpb24gZXJyb3IgZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlIHNvY2tldC5vbkVycm9yKGZ1bmN0aW9uKGVycm9yKXsgYWxlcnQoXCJBbiBlcnJvciBvY2N1cnJlZFwiKSB9KVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25FcnJvcihjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBtZXNzYWdlIGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25NZXNzYWdlKGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFBpbmdzIHRoZSBzZXJ2ZXIgYW5kIGludm9rZXMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIFJUVCBpbiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwaW5nIHdhcyBwdXNoZWQgb3IgZmFsc2UgaWYgdW5hYmxlIHRvIGJlIHB1c2hlZC5cbiAgICovXG4gIHBpbmcoY2FsbGJhY2spe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gZmFsc2UgfVxuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIGxldCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgdGhpcy5wdXNoKHt0b3BpYzogXCJwaG9lbml4XCIsIGV2ZW50OiBcImhlYXJ0YmVhdFwiLCBwYXlsb2FkOiB7fSwgcmVmOiByZWZ9KVxuICAgIGxldCBvbk1zZ1JlZiA9IHRoaXMub25NZXNzYWdlKG1zZyA9PiB7XG4gICAgICBpZihtc2cucmVmID09PSByZWYpe1xuICAgICAgICB0aGlzLm9mZihbb25Nc2dSZWZdKVxuICAgICAgICBjYWxsYmFjayhEYXRlLm5vdygpIC0gc3RhcnRUaW1lKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25Db25uT3Blbigpe1xuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBjb25uZWN0ZWQgdG8gJHt0aGlzLmVuZFBvaW50VVJMKCl9YClcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucysrXG4gICAgdGhpcy5mbHVzaFNlbmRCdWZmZXIoKVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIHRoaXMucmVzZXRIZWFydGJlYXQoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5mb3JFYWNoKChbLCBjYWxsYmFja10pID0+IGNhbGxiYWNrKCkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgaGVhcnRiZWF0VGltZW91dCgpe1xuICAgIGlmKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZil7XG4gICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgICBpZih0aGlzLmhhc0xvZ2dlcigpKXsgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJoZWFydGJlYXQgdGltZW91dC4gQXR0ZW1wdGluZyB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvblwiKSB9XG4gICAgICB0aGlzLmFibm9ybWFsQ2xvc2UoXCJoZWFydGJlYXQgdGltZW91dFwiKVxuICAgIH1cbiAgfVxuXG4gIHJlc2V0SGVhcnRiZWF0KCl7XG4gICAgaWYodGhpcy5jb25uICYmIHRoaXMuY29ubi5za2lwSGVhcnRiZWF0KXsgcmV0dXJuIH1cbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbmRIZWFydGJlYXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKVxuICB9XG5cbiAgdGVhcmRvd24oY2FsbGJhY2ssIGNvZGUsIHJlYXNvbil7XG4gICAgaWYoIXRoaXMuY29ubil7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgIH1cblxuICAgIHRoaXMud2FpdEZvckJ1ZmZlckRvbmUoKCkgPT4ge1xuICAgICAgaWYodGhpcy5jb25uKXtcbiAgICAgICAgaWYoY29kZSl7IHRoaXMuY29ubi5jbG9zZShjb2RlLCByZWFzb24gfHwgXCJcIikgfSBlbHNlIHsgdGhpcy5jb25uLmNsb3NlKCkgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLndhaXRGb3JTb2NrZXRDbG9zZWQoKCkgPT4ge1xuICAgICAgICBpZih0aGlzLmNvbm4pe1xuICAgICAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgICAgICAgIHRoaXMuY29ubiA9IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHdhaXRGb3JCdWZmZXJEb25lKGNhbGxiYWNrLCB0cmllcyA9IDEpe1xuICAgIGlmKHRyaWVzID09PSA1IHx8ICF0aGlzLmNvbm4gfHwgIXRoaXMuY29ubi5idWZmZXJlZEFtb3VudCl7XG4gICAgICBjYWxsYmFjaygpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMud2FpdEZvckJ1ZmZlckRvbmUoY2FsbGJhY2ssIHRyaWVzICsgMSlcbiAgICB9LCAxNTAgKiB0cmllcylcbiAgfVxuXG4gIHdhaXRGb3JTb2NrZXRDbG9zZWQoY2FsbGJhY2ssIHRyaWVzID0gMSl7XG4gICAgaWYodHJpZXMgPT09IDUgfHwgIXRoaXMuY29ubiB8fCB0aGlzLmNvbm4ucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5jbG9zZWQpe1xuICAgICAgY2FsbGJhY2soKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLndhaXRGb3JTb2NrZXRDbG9zZWQoY2FsbGJhY2ssIHRyaWVzICsgMSlcbiAgICB9LCAxNTAgKiB0cmllcylcbiAgfVxuXG4gIG9uQ29ubkNsb3NlKGV2ZW50KXtcbiAgICBsZXQgY2xvc2VDb2RlID0gZXZlbnQgJiYgZXZlbnQuY29kZVxuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIFwiY2xvc2VcIiwgZXZlbnQpXG4gICAgdGhpcy50cmlnZ2VyQ2hhbkVycm9yKClcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFydGJlYXRUaW1lcilcbiAgICBpZighdGhpcy5jbG9zZVdhc0NsZWFuICYmIGNsb3NlQ29kZSAhPT0gMTAwMCl7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpXG4gICAgfVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UuZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiBjYWxsYmFjayhldmVudCkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uQ29ubkVycm9yKGVycm9yKXtcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBlcnJvcilcbiAgICBsZXQgdHJhbnNwb3J0QmVmb3JlID0gdGhpcy50cmFuc3BvcnRcbiAgICBsZXQgZXN0YWJsaXNoZWRCZWZvcmUgPSB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnNcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4ge1xuICAgICAgY2FsbGJhY2soZXJyb3IsIHRyYW5zcG9ydEJlZm9yZSwgZXN0YWJsaXNoZWRCZWZvcmUpXG4gICAgfSlcbiAgICBpZih0cmFuc3BvcnRCZWZvcmUgPT09IHRoaXMudHJhbnNwb3J0IHx8IGVzdGFibGlzaGVkQmVmb3JlID4gMCl7XG4gICAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlckNoYW5FcnJvcigpe1xuICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaChjaGFubmVsID0+IHtcbiAgICAgIGlmKCEoY2hhbm5lbC5pc0Vycm9yZWQoKSB8fCBjaGFubmVsLmlzTGVhdmluZygpIHx8IGNoYW5uZWwuaXNDbG9zZWQoKSkpe1xuICAgICAgICBjaGFubmVsLnRyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgY29ubmVjdGlvblN0YXRlKCl7XG4gICAgc3dpdGNoKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4ucmVhZHlTdGF0ZSl7XG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzogcmV0dXJuIFwiY29ubmVjdGluZ1wiXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMub3BlbjogcmV0dXJuIFwib3BlblwiXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY2xvc2luZzogcmV0dXJuIFwiY2xvc2luZ1wiXG4gICAgICBkZWZhdWx0OiByZXR1cm4gXCJjbG9zZWRcIlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ29ubmVjdGVkKCl7IHJldHVybiB0aGlzLmNvbm5lY3Rpb25TdGF0ZSgpID09PSBcIm9wZW5cIiB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Q2hhbm5lbH1cbiAgICovXG4gIHJlbW92ZShjaGFubmVsKXtcbiAgICB0aGlzLm9mZihjaGFubmVsLnN0YXRlQ2hhbmdlUmVmcylcbiAgICB0aGlzLmNoYW5uZWxzID0gdGhpcy5jaGFubmVscy5maWx0ZXIoYyA9PiBjLmpvaW5SZWYoKSAhPT0gY2hhbm5lbC5qb2luUmVmKCkpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBgb25PcGVuYCwgYG9uQ2xvc2VgLCBgb25FcnJvcixgIGFuZCBgb25NZXNzYWdlYCByZWdpc3RyYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge3JlZnN9IC0gbGlzdCBvZiByZWZzIHJldHVybmVkIGJ5IGNhbGxzIHRvXG4gICAqICAgICAgICAgICAgICAgICBgb25PcGVuYCwgYG9uQ2xvc2VgLCBgb25FcnJvcixgIGFuZCBgb25NZXNzYWdlYFxuICAgKi9cbiAgb2ZmKHJlZnMpe1xuICAgIGZvcihsZXQga2V5IGluIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mpe1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1trZXldID0gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1trZXldLmZpbHRlcigoW3JlZl0pID0+IHtcbiAgICAgICAgcmV0dXJuIHJlZnMuaW5kZXhPZihyZWYpID09PSAtMVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgbmV3IGNoYW5uZWwgZm9yIHRoZSBnaXZlbiB0b3BpY1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5QYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgY2hhbm5lbFxuICAgKiBAcmV0dXJucyB7Q2hhbm5lbH1cbiAgICovXG4gIGNoYW5uZWwodG9waWMsIGNoYW5QYXJhbXMgPSB7fSl7XG4gICAgbGV0IGNoYW4gPSBuZXcgQ2hhbm5lbCh0b3BpYywgY2hhblBhcmFtcywgdGhpcylcbiAgICB0aGlzLmNoYW5uZWxzLnB1c2goY2hhbilcbiAgICByZXR1cm4gY2hhblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICBwdXNoKGRhdGEpe1xuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpe1xuICAgICAgbGV0IHt0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWZ9ID0gZGF0YVxuICAgICAgdGhpcy5sb2coXCJwdXNoXCIsIGAke3RvcGljfSAke2V2ZW50fSAoJHtqb2luX3JlZn0sICR7cmVmfSlgLCBwYXlsb2FkKVxuICAgIH1cblxuICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQoKSl7XG4gICAgICB0aGlzLmVuY29kZShkYXRhLCByZXN1bHQgPT4gdGhpcy5jb25uLnNlbmQocmVzdWx0KSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2goKCkgPT4gdGhpcy5lbmNvZGUoZGF0YSwgcmVzdWx0ID0+IHRoaXMuY29ubi5zZW5kKHJlc3VsdCkpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5leHQgbWVzc2FnZSByZWYsIGFjY291bnRpbmcgZm9yIG92ZXJmbG93c1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgbWFrZVJlZigpe1xuICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZiArIDFcbiAgICBpZihuZXdSZWYgPT09IHRoaXMucmVmKXsgdGhpcy5yZWYgPSAwIH0gZWxzZSB7IHRoaXMucmVmID0gbmV3UmVmIH1cblxuICAgIHJldHVybiB0aGlzLnJlZi50b1N0cmluZygpXG4gIH1cblxuICBzZW5kSGVhcnRiZWF0KCl7XG4gICAgaWYodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmICYmICF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5wdXNoKHt0b3BpYzogXCJwaG9lbml4XCIsIGV2ZW50OiBcImhlYXJ0YmVhdFwiLCBwYXlsb2FkOiB7fSwgcmVmOiB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWZ9KVxuICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGVhcnRiZWF0VGltZW91dCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpXG4gIH1cblxuICBhYm5vcm1hbENsb3NlKHJlYXNvbil7XG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2VcbiAgICBpZih0aGlzLmlzQ29ubmVjdGVkKCkpeyB0aGlzLmNvbm4uY2xvc2UoV1NfQ0xPU0VfTk9STUFMLCByZWFzb24pIH1cbiAgfVxuXG4gIGZsdXNoU2VuZEJ1ZmZlcigpe1xuICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCl7XG4gICAgICB0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjaygpKVxuICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW11cbiAgICB9XG4gIH1cblxuICBvbkNvbm5NZXNzYWdlKHJhd01lc3NhZ2Upe1xuICAgIHRoaXMuZGVjb2RlKHJhd01lc3NhZ2UuZGF0YSwgbXNnID0+IHtcbiAgICAgIGxldCB7dG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5fcmVmfSA9IG1zZ1xuICAgICAgaWYocmVmICYmIHJlZiA9PT0gdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbmRIZWFydGJlYXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKVxuICAgICAgfVxuXG4gICAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInJlY2VpdmVcIiwgYCR7cGF5bG9hZC5zdGF0dXMgfHwgXCJcIn0gJHt0b3BpY30gJHtldmVudH0gJHtyZWYgJiYgXCIoXCIgKyByZWYgKyBcIilcIiB8fCBcIlwifWAsIHBheWxvYWQpXG5cbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbaV1cbiAgICAgICAgaWYoIWNoYW5uZWwuaXNNZW1iZXIodG9waWMsIGV2ZW50LCBwYXlsb2FkLCBqb2luX3JlZikpeyBjb250aW51ZSB9XG4gICAgICAgIGNoYW5uZWwudHJpZ2dlcihldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZilcbiAgICAgIH1cblxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGxldCBbLCBjYWxsYmFja10gPSB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2VbaV1cbiAgICAgICAgY2FsbGJhY2sobXNnKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBsZWF2ZU9wZW5Ub3BpYyh0b3BpYyl7XG4gICAgbGV0IGR1cENoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmZpbmQoYyA9PiBjLnRvcGljID09PSB0b3BpYyAmJiAoYy5pc0pvaW5lZCgpIHx8IGMuaXNKb2luaW5nKCkpKVxuICAgIGlmKGR1cENoYW5uZWwpe1xuICAgICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgYGxlYXZpbmcgZHVwbGljYXRlIHRvcGljIFwiJHt0b3BpY31cImApXG4gICAgICBkdXBDaGFubmVsLmxlYXZlKClcbiAgICB9XG4gIH1cbn1cbiIsICJcbmV4cG9ydCBjb25zdCBDT05TRUNVVElWRV9SRUxPQURTID0gXCJjb25zZWN1dGl2ZS1yZWxvYWRzXCJcbmV4cG9ydCBjb25zdCBNQVhfUkVMT0FEUyA9IDEwXG5leHBvcnQgY29uc3QgUkVMT0FEX0pJVFRFUl9NSU4gPSA1MDAwXG5leHBvcnQgY29uc3QgUkVMT0FEX0pJVFRFUl9NQVggPSAxMDAwMFxuZXhwb3J0IGNvbnN0IEZBSUxTQUZFX0pJVFRFUiA9IDMwMDAwXG5leHBvcnQgY29uc3QgUEhYX0VWRU5UX0NMQVNTRVMgPSBbXG4gIFwicGh4LWNsaWNrLWxvYWRpbmdcIiwgXCJwaHgtY2hhbmdlLWxvYWRpbmdcIiwgXCJwaHgtc3VibWl0LWxvYWRpbmdcIixcbiAgXCJwaHgta2V5ZG93bi1sb2FkaW5nXCIsIFwicGh4LWtleXVwLWxvYWRpbmdcIiwgXCJwaHgtYmx1ci1sb2FkaW5nXCIsIFwicGh4LWZvY3VzLWxvYWRpbmdcIlxuXVxuZXhwb3J0IGNvbnN0IFBIWF9DT01QT05FTlQgPSBcImRhdGEtcGh4LWNvbXBvbmVudFwiXG5leHBvcnQgY29uc3QgUEhYX0xJVkVfTElOSyA9IFwiZGF0YS1waHgtbGlua1wiXG5leHBvcnQgY29uc3QgUEhYX1RSQUNLX1NUQVRJQyA9IFwidHJhY2stc3RhdGljXCJcbmV4cG9ydCBjb25zdCBQSFhfTElOS19TVEFURSA9IFwiZGF0YS1waHgtbGluay1zdGF0ZVwiXG5leHBvcnQgY29uc3QgUEhYX1JFRiA9IFwiZGF0YS1waHgtcmVmXCJcbmV4cG9ydCBjb25zdCBQSFhfUkVGX1NSQyA9IFwiZGF0YS1waHgtcmVmLXNyY1wiXG5leHBvcnQgY29uc3QgUEhYX1RSQUNLX1VQTE9BRFMgPSBcInRyYWNrLXVwbG9hZHNcIlxuZXhwb3J0IGNvbnN0IFBIWF9VUExPQURfUkVGID0gXCJkYXRhLXBoeC11cGxvYWQtcmVmXCJcbmV4cG9ydCBjb25zdCBQSFhfUFJFRkxJR0hURURfUkVGUyA9IFwiZGF0YS1waHgtcHJlZmxpZ2h0ZWQtcmVmc1wiXG5leHBvcnQgY29uc3QgUEhYX0RPTkVfUkVGUyA9IFwiZGF0YS1waHgtZG9uZS1yZWZzXCJcbmV4cG9ydCBjb25zdCBQSFhfRFJPUF9UQVJHRVQgPSBcImRyb3AtdGFyZ2V0XCJcbmV4cG9ydCBjb25zdCBQSFhfQUNUSVZFX0VOVFJZX1JFRlMgPSBcImRhdGEtcGh4LWFjdGl2ZS1yZWZzXCJcbmV4cG9ydCBjb25zdCBQSFhfTElWRV9GSUxFX1VQREFURUQgPSBcInBoeDpsaXZlLWZpbGU6dXBkYXRlZFwiXG5leHBvcnQgY29uc3QgUEhYX1NLSVAgPSBcImRhdGEtcGh4LXNraXBcIlxuZXhwb3J0IGNvbnN0IFBIWF9QUlVORSA9IFwiZGF0YS1waHgtcHJ1bmVcIlxuZXhwb3J0IGNvbnN0IFBIWF9QQUdFX0xPQURJTkcgPSBcInBhZ2UtbG9hZGluZ1wiXG5leHBvcnQgY29uc3QgUEhYX0NPTk5FQ1RFRF9DTEFTUyA9IFwicGh4LWNvbm5lY3RlZFwiXG5leHBvcnQgY29uc3QgUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUyA9IFwicGh4LWxvYWRpbmdcIlxuZXhwb3J0IGNvbnN0IFBIWF9OT19GRUVEQkFDS19DTEFTUyA9IFwicGh4LW5vLWZlZWRiYWNrXCJcbmV4cG9ydCBjb25zdCBQSFhfRVJST1JfQ0xBU1MgPSBcInBoeC1lcnJvclwiXG5leHBvcnQgY29uc3QgUEhYX1BBUkVOVF9JRCA9IFwiZGF0YS1waHgtcGFyZW50LWlkXCJcbmV4cG9ydCBjb25zdCBQSFhfTUFJTiA9IFwiZGF0YS1waHgtbWFpblwiXG5leHBvcnQgY29uc3QgUEhYX1JPT1RfSUQgPSBcImRhdGEtcGh4LXJvb3QtaWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9UUklHR0VSX0FDVElPTiA9IFwidHJpZ2dlci1hY3Rpb25cIlxuZXhwb3J0IGNvbnN0IFBIWF9GRUVEQkFDS19GT1IgPSBcImZlZWRiYWNrLWZvclwiXG5leHBvcnQgY29uc3QgUEhYX0hBU19GT0NVU0VEID0gXCJwaHgtaGFzLWZvY3VzZWRcIlxuZXhwb3J0IGNvbnN0IEZPQ1VTQUJMRV9JTlBVVFMgPSBbXCJ0ZXh0XCIsIFwidGV4dGFyZWFcIiwgXCJudW1iZXJcIiwgXCJlbWFpbFwiLCBcInBhc3N3b3JkXCIsIFwic2VhcmNoXCIsIFwidGVsXCIsIFwidXJsXCIsIFwiZGF0ZVwiLCBcInRpbWVcIiwgXCJkYXRldGltZS1sb2NhbFwiLCBcImNvbG9yXCIsIFwicmFuZ2VcIl1cbmV4cG9ydCBjb25zdCBDSEVDS0FCTEVfSU5QVVRTID0gW1wiY2hlY2tib3hcIiwgXCJyYWRpb1wiXVxuZXhwb3J0IGNvbnN0IFBIWF9IQVNfU1VCTUlUVEVEID0gXCJwaHgtaGFzLXN1Ym1pdHRlZFwiXG5leHBvcnQgY29uc3QgUEhYX1NFU1NJT04gPSBcImRhdGEtcGh4LXNlc3Npb25cIlxuZXhwb3J0IGNvbnN0IFBIWF9WSUVXX1NFTEVDVE9SID0gYFske1BIWF9TRVNTSU9OfV1gXG5leHBvcnQgY29uc3QgUEhYX1NUSUNLWSA9IFwiZGF0YS1waHgtc3RpY2t5XCJcbmV4cG9ydCBjb25zdCBQSFhfU1RBVElDID0gXCJkYXRhLXBoeC1zdGF0aWNcIlxuZXhwb3J0IGNvbnN0IFBIWF9SRUFET05MWSA9IFwiZGF0YS1waHgtcmVhZG9ubHlcIlxuZXhwb3J0IGNvbnN0IFBIWF9ESVNBQkxFRCA9IFwiZGF0YS1waHgtZGlzYWJsZWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9ESVNBQkxFX1dJVEggPSBcImRpc2FibGUtd2l0aFwiXG5leHBvcnQgY29uc3QgUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFID0gXCJkYXRhLXBoeC1kaXNhYmxlLXdpdGgtcmVzdG9yZVwiXG5leHBvcnQgY29uc3QgUEhYX0hPT0sgPSBcImhvb2tcIlxuZXhwb3J0IGNvbnN0IFBIWF9ERUJPVU5DRSA9IFwiZGVib3VuY2VcIlxuZXhwb3J0IGNvbnN0IFBIWF9USFJPVFRMRSA9IFwidGhyb3R0bGVcIlxuZXhwb3J0IGNvbnN0IFBIWF9VUERBVEUgPSBcInVwZGF0ZVwiXG5leHBvcnQgY29uc3QgUEhYX0tFWSA9IFwia2V5XCJcbmV4cG9ydCBjb25zdCBQSFhfUFJJVkFURSA9IFwicGh4UHJpdmF0ZVwiXG5leHBvcnQgY29uc3QgUEhYX0FVVE9fUkVDT1ZFUiA9IFwiYXV0by1yZWNvdmVyXCJcbmV4cG9ydCBjb25zdCBQSFhfTFZfREVCVUcgPSBcInBoeDpsaXZlLXNvY2tldDpkZWJ1Z1wiXG5leHBvcnQgY29uc3QgUEhYX0xWX1BST0ZJTEUgPSBcInBoeDpsaXZlLXNvY2tldDpwcm9maWxpbmdcIlxuZXhwb3J0IGNvbnN0IFBIWF9MVl9MQVRFTkNZX1NJTSA9IFwicGh4OmxpdmUtc29ja2V0OmxhdGVuY3ktc2ltXCJcbmV4cG9ydCBjb25zdCBQSFhfUFJPR1JFU1MgPSBcInByb2dyZXNzXCJcbmV4cG9ydCBjb25zdCBMT0FERVJfVElNRU9VVCA9IDFcbmV4cG9ydCBjb25zdCBCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VUID0gMjAwXG5leHBvcnQgY29uc3QgQklORElOR19QUkVGSVggPSBcInBoeC1cIlxuZXhwb3J0IGNvbnN0IFBVU0hfVElNRU9VVCA9IDMwMDAwXG5leHBvcnQgY29uc3QgTElOS19IRUFERVIgPSBcIngtcmVxdWVzdGVkLXdpdGhcIlxuZXhwb3J0IGNvbnN0IFJFU1BPTlNFX1VSTF9IRUFERVIgPSBcIngtcmVzcG9uc2UtdXJsXCJcbmV4cG9ydCBjb25zdCBERUJPVU5DRV9UUklHR0VSID0gXCJkZWJvdW5jZS10cmlnZ2VyXCJcbmV4cG9ydCBjb25zdCBUSFJPVFRMRUQgPSBcInRocm90dGxlZFwiXG5leHBvcnQgY29uc3QgREVCT1VOQ0VfUFJFVl9LRVkgPSBcImRlYm91bmNlLXByZXYta2V5XCJcbmV4cG9ydCBjb25zdCBERUZBVUxUUyA9IHtcbiAgZGVib3VuY2U6IDMwMCxcbiAgdGhyb3R0bGU6IDMwMFxufVxuXG4vLyBSZW5kZXJlZFxuZXhwb3J0IGNvbnN0IERZTkFNSUNTID0gXCJkXCJcbmV4cG9ydCBjb25zdCBTVEFUSUMgPSBcInNcIlxuZXhwb3J0IGNvbnN0IENPTVBPTkVOVFMgPSBcImNcIlxuZXhwb3J0IGNvbnN0IEVWRU5UUyA9IFwiZVwiXG5leHBvcnQgY29uc3QgUkVQTFkgPSBcInJcIlxuZXhwb3J0IGNvbnN0IFRJVExFID0gXCJ0XCJcbmV4cG9ydCBjb25zdCBURU1QTEFURVMgPSBcInBcIlxuIiwgImltcG9ydCB7XG4gIGxvZ0Vycm9yXG59IGZyb20gXCIuL3V0aWxzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50cnlVcGxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGVudHJ5LCBjaHVua1NpemUsIGxpdmVTb2NrZXQpe1xuICAgIHRoaXMubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXRcbiAgICB0aGlzLmVudHJ5ID0gZW50cnlcbiAgICB0aGlzLm9mZnNldCA9IDBcbiAgICB0aGlzLmNodW5rU2l6ZSA9IGNodW5rU2l6ZVxuICAgIHRoaXMuY2h1bmtUaW1lciA9IG51bGxcbiAgICB0aGlzLnVwbG9hZENoYW5uZWwgPSBsaXZlU29ja2V0LmNoYW5uZWwoYGx2dToke2VudHJ5LnJlZn1gLCB7dG9rZW46IGVudHJ5Lm1ldGFkYXRhKCl9KVxuICB9XG5cbiAgZXJyb3IocmVhc29uKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5jaHVua1RpbWVyKVxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5sZWF2ZSgpXG4gICAgdGhpcy5lbnRyeS5lcnJvcihyZWFzb24pXG4gIH1cblxuICB1cGxvYWQoKXtcbiAgICB0aGlzLnVwbG9hZENoYW5uZWwub25FcnJvcihyZWFzb24gPT4gdGhpcy5lcnJvcihyZWFzb24pKVxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5qb2luKClcbiAgICAgIC5yZWNlaXZlKFwib2tcIiwgX2RhdGEgPT4gdGhpcy5yZWFkTmV4dENodW5rKCkpXG4gICAgICAucmVjZWl2ZShcImVycm9yXCIsIHJlYXNvbiA9PiB0aGlzLmVycm9yKHJlYXNvbikpXG4gIH1cblxuICBpc0RvbmUoKXsgcmV0dXJuIHRoaXMub2Zmc2V0ID49IHRoaXMuZW50cnkuZmlsZS5zaXplIH1cblxuICByZWFkTmV4dENodW5rKCl7XG4gICAgbGV0IHJlYWRlciA9IG5ldyB3aW5kb3cuRmlsZVJlYWRlcigpXG4gICAgbGV0IGJsb2IgPSB0aGlzLmVudHJ5LmZpbGUuc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMuY2h1bmtTaXplICsgdGhpcy5vZmZzZXQpXG4gICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICBpZihlLnRhcmdldC5lcnJvciA9PT0gbnVsbCl7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IGUudGFyZ2V0LnJlc3VsdC5ieXRlTGVuZ3RoXG4gICAgICAgIHRoaXMucHVzaENodW5rKGUudGFyZ2V0LnJlc3VsdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2dFcnJvcihcIlJlYWQgZXJyb3I6IFwiICsgZS50YXJnZXQuZXJyb3IpXG4gICAgICB9XG4gICAgfVxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICB9XG5cbiAgcHVzaENodW5rKGNodW5rKXtcbiAgICBpZighdGhpcy51cGxvYWRDaGFubmVsLmlzSm9pbmVkKCkpeyByZXR1cm4gfVxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5wdXNoKFwiY2h1bmtcIiwgY2h1bmspXG4gICAgICAucmVjZWl2ZShcIm9rXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5lbnRyeS5wcm9ncmVzcygodGhpcy5vZmZzZXQgLyB0aGlzLmVudHJ5LmZpbGUuc2l6ZSkgKiAxMDApXG4gICAgICAgIGlmKCF0aGlzLmlzRG9uZSgpKXtcbiAgICAgICAgICB0aGlzLmNodW5rVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVhZE5leHRDaHVuaygpLCB0aGlzLmxpdmVTb2NrZXQuZ2V0TGF0ZW5jeVNpbSgpIHx8IDApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBQSFhfVklFV19TRUxFQ1RPUlxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQgRW50cnlVcGxvYWRlciBmcm9tIFwiLi9lbnRyeV91cGxvYWRlclwiXG5cbmV4cG9ydCBsZXQgbG9nRXJyb3IgPSAobXNnLCBvYmopID0+IGNvbnNvbGUuZXJyb3IgJiYgY29uc29sZS5lcnJvcihtc2csIG9iailcblxuZXhwb3J0IGxldCBpc0NpZCA9IChjaWQpID0+IHtcbiAgbGV0IHR5cGUgPSB0eXBlb2YoY2lkKVxuICByZXR1cm4gdHlwZSA9PT0gXCJudW1iZXJcIiB8fCAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAvXigwfFsxLTldXFxkKikkLy50ZXN0KGNpZCkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3REdXBsaWNhdGVJZHMoKXtcbiAgbGV0IGlkcyA9IG5ldyBTZXQoKVxuICBsZXQgZWxlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiKltpZF1cIilcbiAgZm9yKGxldCBpID0gMCwgbGVuID0gZWxlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgIGlmKGlkcy5oYXMoZWxlbXNbaV0uaWQpKXtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYE11bHRpcGxlIElEcyBkZXRlY3RlZDogJHtlbGVtc1tpXS5pZH0uIEVuc3VyZSB1bmlxdWUgZWxlbWVudCBpZHMuYClcbiAgICB9IGVsc2Uge1xuICAgICAgaWRzLmFkZChlbGVtc1tpXS5pZClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGxldCBkZWJ1ZyA9ICh2aWV3LCBraW5kLCBtc2csIG9iaikgPT4ge1xuICBpZih2aWV3LmxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSl7XG4gICAgY29uc29sZS5sb2coYCR7dmlldy5pZH0gJHtraW5kfTogJHttc2d9IC0gYCwgb2JqKVxuICB9XG59XG5cbi8vIHdyYXBzIHZhbHVlIGluIGNsb3N1cmUgb3IgcmV0dXJucyBjbG9zdXJlXG5leHBvcnQgbGV0IGNsb3N1cmUgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCIgPyB2YWwgOiBmdW5jdGlvbiAoKXsgcmV0dXJuIHZhbCB9XG5cbmV4cG9ydCBsZXQgY2xvbmUgPSAob2JqKSA9PiB7IHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpIH1cblxuZXhwb3J0IGxldCBjbG9zZXN0UGh4QmluZGluZyA9IChlbCwgYmluZGluZywgYm9yZGVyRWwpID0+IHtcbiAgZG8ge1xuICAgIGlmKGVsLm1hdGNoZXMoYFske2JpbmRpbmd9XWApKXsgcmV0dXJuIGVsIH1cbiAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQgfHwgZWwucGFyZW50Tm9kZVxuICB9IHdoaWxlKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxICYmICEoKGJvcmRlckVsICYmIGJvcmRlckVsLmlzU2FtZU5vZGUoZWwpKSB8fCBlbC5tYXRjaGVzKFBIWF9WSUVXX1NFTEVDVE9SKSkpXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBsZXQgaXNPYmplY3QgPSAob2JqKSA9PiB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiAhKG9iaiBpbnN0YW5jZW9mIEFycmF5KVxufVxuXG5leHBvcnQgbGV0IGlzRXF1YWxPYmogPSAob2JqMSwgb2JqMikgPT4gSlNPTi5zdHJpbmdpZnkob2JqMSkgPT09IEpTT04uc3RyaW5naWZ5KG9iajIpXG5cbmV4cG9ydCBsZXQgaXNFbXB0eSA9IChvYmopID0+IHtcbiAgZm9yKGxldCB4IGluIG9iail7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBsZXQgbWF5YmUgPSAoZWwsIGNhbGxiYWNrKSA9PiBlbCAmJiBjYWxsYmFjayhlbClcblxuZXhwb3J0IGxldCBjaGFubmVsVXBsb2FkZXIgPSBmdW5jdGlvbiAoZW50cmllcywgb25FcnJvciwgcmVzcCwgbGl2ZVNvY2tldCl7XG4gIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgbGV0IGVudHJ5VXBsb2FkZXIgPSBuZXcgRW50cnlVcGxvYWRlcihlbnRyeSwgcmVzcC5jb25maWcuY2h1bmtfc2l6ZSwgbGl2ZVNvY2tldClcbiAgICBlbnRyeVVwbG9hZGVyLnVwbG9hZCgpXG4gIH0pXG59XG4iLCAibGV0IEJyb3dzZXIgPSB7XG4gIGNhblB1c2hTdGF0ZSgpeyByZXR1cm4gKHR5cGVvZiAoaGlzdG9yeS5wdXNoU3RhdGUpICE9PSBcInVuZGVmaW5lZFwiKSB9LFxuXG4gIGRyb3BMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KXtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5sb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSkpXG4gIH0sXG5cbiAgdXBkYXRlTG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSwgaW5pdGlhbCwgZnVuYyl7XG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLmdldExvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXkpXG4gICAgbGV0IGtleSA9IHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpXG4gICAgbGV0IG5ld1ZhbCA9IGN1cnJlbnQgPT09IG51bGwgPyBpbml0aWFsIDogZnVuYyhjdXJyZW50KVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkobmV3VmFsKSlcbiAgICByZXR1cm4gbmV3VmFsXG4gIH0sXG5cbiAgZ2V0TG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSl7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5sb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSkpKVxuICB9LFxuXG4gIHVwZGF0ZUN1cnJlbnRTdGF0ZShjYWxsYmFjayl7XG4gICAgaWYoIXRoaXMuY2FuUHVzaFN0YXRlKCkpeyByZXR1cm4gfVxuICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKGNhbGxiYWNrKGhpc3Rvcnkuc3RhdGUgfHwge30pLCBcIlwiLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgfSxcblxuICBwdXNoU3RhdGUoa2luZCwgbWV0YSwgdG8pe1xuICAgIGlmKHRoaXMuY2FuUHVzaFN0YXRlKCkpe1xuICAgICAgaWYodG8gIT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmKXtcbiAgICAgICAgaWYobWV0YS50eXBlID09IFwicmVkaXJlY3RcIiAmJiBtZXRhLnNjcm9sbCl7XG4gICAgICAgICAgLy8gSWYgd2UncmUgcmVkaXJlY3Rpbmcgc3RvcmUgdGhlIGN1cnJlbnQgc2Nyb2xsWSBmb3IgdGhlIGN1cnJlbnQgaGlzdG9yeSBzdGF0ZS5cbiAgICAgICAgICBsZXQgY3VycmVudFN0YXRlID0gaGlzdG9yeS5zdGF0ZSB8fCB7fVxuICAgICAgICAgIGN1cnJlbnRTdGF0ZS5zY3JvbGwgPSBtZXRhLnNjcm9sbFxuICAgICAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKGN1cnJlbnRTdGF0ZSwgXCJcIiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgbWV0YS5zY3JvbGwgLy8gT25seSBzdG9yZSB0aGUgc2Nyb2xsIGluIHRoZSByZWRpcmVjdCBjYXNlLlxuICAgICAgICBoaXN0b3J5W2tpbmQgKyBcIlN0YXRlXCJdKG1ldGEsIFwiXCIsIHRvIHx8IG51bGwpIC8vIElFIHdpbGwgY29lcmNlIHVuZGVmaW5lZCB0byBzdHJpbmdcbiAgICAgICAgbGV0IGhhc2hFbCA9IHRoaXMuZ2V0SGFzaFRhcmdldEVsKHdpbmRvdy5sb2NhdGlvbi5oYXNoKVxuXG4gICAgICAgIGlmKGhhc2hFbCl7XG4gICAgICAgICAgaGFzaEVsLnNjcm9sbEludG9WaWV3KClcbiAgICAgICAgfSBlbHNlIGlmKG1ldGEudHlwZSA9PT0gXCJyZWRpcmVjdFwiKXtcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsKDAsIDApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWRpcmVjdCh0bylcbiAgICB9XG4gIH0sXG5cbiAgc2V0Q29va2llKG5hbWUsIHZhbHVlKXtcbiAgICBkb2N1bWVudC5jb29raWUgPSBgJHtuYW1lfT0ke3ZhbHVlfWBcbiAgfSxcblxuICBnZXRDb29raWUobmFtZSl7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNvb2tpZS5yZXBsYWNlKG5ldyBSZWdFeHAoYCg/Oig/Ol58Lio7XFxzKikke25hbWV9XFxzKlxcPVxccyooW147XSopLiokKXxeLiokYCksIFwiJDFcIilcbiAgfSxcblxuICByZWRpcmVjdCh0b1VSTCwgZmxhc2gpe1xuICAgIGlmKGZsYXNoKXsgQnJvd3Nlci5zZXRDb29raWUoXCJfX3Bob2VuaXhfZmxhc2hfX1wiLCBmbGFzaCArIFwiOyBtYXgtYWdlPTYwMDAwOyBwYXRoPS9cIikgfVxuICAgIHdpbmRvdy5sb2NhdGlvbiA9IHRvVVJMXG4gIH0sXG5cbiAgbG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpeyByZXR1cm4gYCR7bmFtZXNwYWNlfS0ke3N1YmtleX1gIH0sXG5cbiAgZ2V0SGFzaFRhcmdldEVsKG1heWJlSGFzaCl7XG4gICAgbGV0IGhhc2ggPSBtYXliZUhhc2gudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSlcbiAgICBpZihoYXNoID09PSBcIlwiKXsgcmV0dXJuIH1cbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaCkgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgYVtuYW1lPVwiJHtoYXNofVwiXWApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnJvd3NlclxuIiwgImltcG9ydCB7XG4gIENIRUNLQUJMRV9JTlBVVFMsXG4gIERFQk9VTkNFX1BSRVZfS0VZLFxuICBERUJPVU5DRV9UUklHR0VSLFxuICBGT0NVU0FCTEVfSU5QVVRTLFxuICBQSFhfQ09NUE9ORU5ULFxuICBQSFhfRVZFTlRfQ0xBU1NFUyxcbiAgUEhYX0hBU19GT0NVU0VELFxuICBQSFhfSEFTX1NVQk1JVFRFRCxcbiAgUEhYX01BSU4sXG4gIFBIWF9OT19GRUVEQkFDS19DTEFTUyxcbiAgUEhYX1BBUkVOVF9JRCxcbiAgUEhYX1BSSVZBVEUsXG4gIFBIWF9SRUYsXG4gIFBIWF9SRUZfU1JDLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1NFU1NJT04sXG4gIFBIWF9TVEFUSUMsXG4gIFBIWF9VUExPQURfUkVGLFxuICBQSFhfVklFV19TRUxFQ1RPUixcbiAgUEhYX1NUSUNLWSxcbiAgVEhST1RUTEVEXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGxvZ0Vycm9yXG59IGZyb20gXCIuL3V0aWxzXCJcblxubGV0IERPTSA9IHtcbiAgYnlJZChpZCl7IHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgfHwgbG9nRXJyb3IoYG5vIGlkIGZvdW5kIGZvciAke2lkfWApIH0sXG5cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNsYXNzTmFtZSl7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpXG4gICAgaWYoZWwuY2xhc3NMaXN0Lmxlbmd0aCA9PT0gMCl7IGVsLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpIH1cbiAgfSxcblxuICBhbGwobm9kZSwgcXVlcnksIGNhbGxiYWNrKXtcbiAgICBpZighbm9kZSl7IHJldHVybiBbXSB9XG4gICAgbGV0IGFycmF5ID0gQXJyYXkuZnJvbShub2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKVxuICAgIHJldHVybiBjYWxsYmFjayA/IGFycmF5LmZvckVhY2goY2FsbGJhY2spIDogYXJyYXlcbiAgfSxcblxuICBjaGlsZE5vZGVMZW5ndGgoaHRtbCl7XG4gICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpXG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbFxuICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmNoaWxkRWxlbWVudENvdW50XG4gIH0sXG5cbiAgaXNVcGxvYWRJbnB1dChlbCl7IHJldHVybiBlbC50eXBlID09PSBcImZpbGVcIiAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpICE9PSBudWxsIH0sXG5cbiAgZmluZFVwbG9hZElucHV0cyhub2RlKXsgcmV0dXJuIHRoaXMuYWxsKG5vZGUsIGBpbnB1dFt0eXBlPVwiZmlsZVwiXVske1BIWF9VUExPQURfUkVGfV1gKSB9LFxuXG4gIGZpbmRDb21wb25lbnROb2RlTGlzdChub2RlLCBjaWQpe1xuICAgIHJldHVybiB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChub2RlLCBgWyR7UEhYX0NPTVBPTkVOVH09XCIke2NpZH1cIl1gKSwgbm9kZSlcbiAgfSxcblxuICBpc1BoeERlc3Ryb3llZChub2RlKXtcbiAgICByZXR1cm4gbm9kZS5pZCAmJiBET00ucHJpdmF0ZShub2RlLCBcImRlc3Ryb3llZFwiKSA/IHRydWUgOiBmYWxzZVxuICB9LFxuXG4gIG1hcmtQaHhDaGlsZERlc3Ryb3llZChlbCl7XG4gICAgaWYodGhpcy5pc1BoeENoaWxkKGVsKSl7IGVsLnNldEF0dHJpYnV0ZShQSFhfU0VTU0lPTiwgXCJcIikgfVxuICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgXCJkZXN0cm95ZWRcIiwgdHJ1ZSlcbiAgfSxcblxuICBmaW5kUGh4Q2hpbGRyZW5JbkZyYWdtZW50KGh0bWwsIHBhcmVudElkKXtcbiAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIilcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sXG4gICAgcmV0dXJuIHRoaXMuZmluZFBoeENoaWxkcmVuKHRlbXBsYXRlLmNvbnRlbnQsIHBhcmVudElkKVxuICB9LFxuXG4gIGlzSWdub3JlZChlbCwgcGh4VXBkYXRlKXtcbiAgICByZXR1cm4gKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpIHx8IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXVwZGF0ZVwiKSkgPT09IFwiaWdub3JlXCJcbiAgfSxcblxuICBpc1BoeFVwZGF0ZShlbCwgcGh4VXBkYXRlLCB1cGRhdGVUeXBlcyl7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiB1cGRhdGVUeXBlcy5pbmRleE9mKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpKSA+PSAwXG4gIH0sXG5cbiAgZmluZFBoeFN0aWNreShlbCl7IHJldHVybiB0aGlzLmFsbChlbCwgYFske1BIWF9TVElDS1l9XWApIH0sXG5cbiAgZmluZFBoeENoaWxkcmVuKGVsLCBwYXJlbnRJZCl7XG4gICAgcmV0dXJuIHRoaXMuYWxsKGVsLCBgJHtQSFhfVklFV19TRUxFQ1RPUn1bJHtQSFhfUEFSRU5UX0lEfT1cIiR7cGFyZW50SWR9XCJdYClcbiAgfSxcblxuICBmaW5kUGFyZW50Q0lEcyhub2RlLCBjaWRzKXtcbiAgICBsZXQgaW5pdGlhbCA9IG5ldyBTZXQoY2lkcylcbiAgICByZXR1cm4gY2lkcy5yZWR1Y2UoKGFjYywgY2lkKSA9PiB7XG4gICAgICBsZXQgc2VsZWN0b3IgPSBgWyR7UEhYX0NPTVBPTkVOVH09XCIke2NpZH1cIl0gWyR7UEhYX0NPTVBPTkVOVH1dYFxuXG4gICAgICB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChub2RlLCBzZWxlY3RvciksIG5vZGUpXG4gICAgICAgIC5tYXAoZWwgPT4gcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpKSlcbiAgICAgICAgLmZvckVhY2goY2hpbGRDSUQgPT4gYWNjLmRlbGV0ZShjaGlsZENJRCkpXG5cbiAgICAgIHJldHVybiBhY2NcbiAgICB9LCBpbml0aWFsKVxuICB9LFxuXG4gIGZpbHRlcldpdGhpblNhbWVMaXZlVmlldyhub2RlcywgcGFyZW50KXtcbiAgICBpZihwYXJlbnQucXVlcnlTZWxlY3RvcihQSFhfVklFV19TRUxFQ1RPUikpe1xuICAgICAgcmV0dXJuIG5vZGVzLmZpbHRlcihlbCA9PiB0aGlzLndpdGhpblNhbWVMaXZlVmlldyhlbCwgcGFyZW50KSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGVzXG4gICAgfVxuICB9LFxuXG4gIHdpdGhpblNhbWVMaXZlVmlldyhub2RlLCBwYXJlbnQpe1xuICAgIHdoaWxlKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpe1xuICAgICAgaWYobm9kZS5pc1NhbWVOb2RlKHBhcmVudCkpeyByZXR1cm4gdHJ1ZSB9XG4gICAgICBpZihub2RlLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTikgIT09IG51bGwpeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgfSxcblxuICBwcml2YXRlKGVsLCBrZXkpeyByZXR1cm4gZWxbUEhYX1BSSVZBVEVdICYmIGVsW1BIWF9QUklWQVRFXVtrZXldIH0sXG5cbiAgZGVsZXRlUHJpdmF0ZShlbCwga2V5KXsgZWxbUEhYX1BSSVZBVEVdICYmIGRlbGV0ZSAoZWxbUEhYX1BSSVZBVEVdW2tleV0pIH0sXG5cbiAgcHV0UHJpdmF0ZShlbCwga2V5LCB2YWx1ZSl7XG4gICAgaWYoIWVsW1BIWF9QUklWQVRFXSl7IGVsW1BIWF9QUklWQVRFXSA9IHt9IH1cbiAgICBlbFtQSFhfUFJJVkFURV1ba2V5XSA9IHZhbHVlXG4gIH0sXG5cbiAgdXBkYXRlUHJpdmF0ZShlbCwga2V5LCBkZWZhdWx0VmFsLCB1cGRhdGVGdW5jKXtcbiAgICBsZXQgZXhpc3RpbmcgPSB0aGlzLnByaXZhdGUoZWwsIGtleSlcbiAgICBpZihleGlzdGluZyA9PT0gdW5kZWZpbmVkKXtcbiAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwga2V5LCB1cGRhdGVGdW5jKGRlZmF1bHRWYWwpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdXBkYXRlRnVuYyhleGlzdGluZykpXG4gICAgfVxuICB9LFxuXG4gIGNvcHlQcml2YXRlcyh0YXJnZXQsIHNvdXJjZSl7XG4gICAgaWYoc291cmNlW1BIWF9QUklWQVRFXSl7XG4gICAgICB0YXJnZXRbUEhYX1BSSVZBVEVdID0gc291cmNlW1BIWF9QUklWQVRFXVxuICAgIH1cbiAgfSxcblxuICBwdXRUaXRsZShzdHIpe1xuICAgIGxldCB0aXRsZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInRpdGxlXCIpXG4gICAgbGV0IHtwcmVmaXgsIHN1ZmZpeH0gPSB0aXRsZUVsLmRhdGFzZXRcbiAgICBkb2N1bWVudC50aXRsZSA9IGAke3ByZWZpeCB8fCBcIlwifSR7c3RyfSR7c3VmZml4IHx8IFwiXCJ9YFxuICB9LFxuXG4gIGRlYm91bmNlKGVsLCBldmVudCwgcGh4RGVib3VuY2UsIGRlZmF1bHREZWJvdW5jZSwgcGh4VGhyb3R0bGUsIGRlZmF1bHRUaHJvdHRsZSwgYXN5bmNGaWx0ZXIsIGNhbGxiYWNrKXtcbiAgICBsZXQgZGVib3VuY2UgPSBlbC5nZXRBdHRyaWJ1dGUocGh4RGVib3VuY2UpXG4gICAgbGV0IHRocm90dGxlID0gZWwuZ2V0QXR0cmlidXRlKHBoeFRocm90dGxlKVxuICAgIGlmKGRlYm91bmNlID09PSBcIlwiKXsgZGVib3VuY2UgPSBkZWZhdWx0RGVib3VuY2UgfVxuICAgIGlmKHRocm90dGxlID09PSBcIlwiKXsgdGhyb3R0bGUgPSBkZWZhdWx0VGhyb3R0bGUgfVxuICAgIGxldCB2YWx1ZSA9IGRlYm91bmNlIHx8IHRocm90dGxlXG4gICAgc3dpdGNoKHZhbHVlKXtcbiAgICAgIGNhc2UgbnVsbDogcmV0dXJuIGNhbGxiYWNrKClcblxuICAgICAgY2FzZSBcImJsdXJcIjpcbiAgICAgICAgaWYodGhpcy5vbmNlKGVsLCBcImRlYm91bmNlLWJsdXJcIikpe1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IGNhbGxiYWNrKCkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxldCB0aW1lb3V0ID0gcGFyc2VJbnQodmFsdWUpXG4gICAgICAgIGxldCB0cmlnZ2VyID0gKCkgPT4gdGhyb3R0bGUgPyB0aGlzLmRlbGV0ZVByaXZhdGUoZWwsIFRIUk9UVExFRCkgOiBjYWxsYmFjaygpXG4gICAgICAgIGxldCBjdXJyZW50Q3ljbGUgPSB0aGlzLmluY0N5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSLCB0cmlnZ2VyKVxuICAgICAgICBpZihpc05hTih0aW1lb3V0KSl7IHJldHVybiBsb2dFcnJvcihgaW52YWxpZCB0aHJvdHRsZS9kZWJvdW5jZSB2YWx1ZTogJHt2YWx1ZX1gKSB9XG4gICAgICAgIGlmKHRocm90dGxlKXtcbiAgICAgICAgICBsZXQgbmV3S2V5RG93biA9IGZhbHNlXG4gICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gXCJrZXlkb3duXCIpe1xuICAgICAgICAgICAgbGV0IHByZXZLZXkgPSB0aGlzLnByaXZhdGUoZWwsIERFQk9VTkNFX1BSRVZfS0VZKVxuICAgICAgICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBERUJPVU5DRV9QUkVWX0tFWSwgZXZlbnQua2V5KVxuICAgICAgICAgICAgbmV3S2V5RG93biA9IHByZXZLZXkgIT09IGV2ZW50LmtleVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCFuZXdLZXlEb3duICYmIHRoaXMucHJpdmF0ZShlbCwgVEhST1RUTEVEKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBUSFJPVFRMRUQsIHRydWUpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYoYXN5bmNGaWx0ZXIoKSl7IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSKSB9XG4gICAgICAgICAgICB9LCB0aW1lb3V0KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmKGFzeW5jRmlsdGVyKCkpeyB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUiwgY3VycmVudEN5Y2xlKSB9XG4gICAgICAgICAgfSwgdGltZW91dClcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmb3JtID0gZWwuZm9ybVxuICAgICAgICBpZihmb3JtICYmIHRoaXMub25jZShmb3JtLCBcImJpbmQtZGVib3VuY2VcIikpe1xuICAgICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKChuZXcgRm9ybURhdGEoZm9ybSkpLmVudHJpZXMoKSwgKFtuYW1lXSkgPT4ge1xuICAgICAgICAgICAgICBsZXQgaW5wdXQgPSBmb3JtLnF1ZXJ5U2VsZWN0b3IoYFtuYW1lPVwiJHtuYW1lfVwiXWApXG4gICAgICAgICAgICAgIHRoaXMuaW5jQ3ljbGUoaW5wdXQsIERFQk9VTkNFX1RSSUdHRVIpXG4gICAgICAgICAgICAgIHRoaXMuZGVsZXRlUHJpdmF0ZShpbnB1dCwgVEhST1RUTEVEKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMub25jZShlbCwgXCJiaW5kLWRlYm91bmNlXCIpKXtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUikpXG4gICAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJpZ2dlckN5Y2xlKGVsLCBrZXksIGN1cnJlbnRDeWNsZSl7XG4gICAgbGV0IFtjeWNsZSwgdHJpZ2dlcl0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSlcbiAgICBpZighY3VycmVudEN5Y2xlKXsgY3VycmVudEN5Y2xlID0gY3ljbGUgfVxuICAgIGlmKGN1cnJlbnRDeWNsZSA9PT0gY3ljbGUpe1xuICAgICAgdGhpcy5pbmNDeWNsZShlbCwga2V5KVxuICAgICAgdHJpZ2dlcigpXG4gICAgfVxuICB9LFxuXG4gIG9uY2UoZWwsIGtleSl7XG4gICAgaWYodGhpcy5wcml2YXRlKGVsLCBrZXkpID09PSB0cnVlKXsgcmV0dXJuIGZhbHNlIH1cbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdHJ1ZSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9LFxuXG4gIGluY0N5Y2xlKGVsLCBrZXksIHRyaWdnZXIgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgbGV0IFtjdXJyZW50Q3ljbGVdID0gdGhpcy5wcml2YXRlKGVsLCBrZXkpIHx8IFswLCB0cmlnZ2VyXVxuICAgIGN1cnJlbnRDeWNsZSsrXG4gICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIFtjdXJyZW50Q3ljbGUsIHRyaWdnZXJdKVxuICAgIHJldHVybiBjdXJyZW50Q3ljbGVcbiAgfSxcblxuICBkaXNjYXJkRXJyb3IoY29udGFpbmVyLCBlbCwgcGh4RmVlZGJhY2tGb3Ipe1xuICAgIGxldCBmaWVsZCA9IGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUocGh4RmVlZGJhY2tGb3IpXG4gICAgLy8gVE9ETzogUmVtb3ZlIGlkIGxvb2t1cCBhZnRlciB3ZSB1cGRhdGUgUGhvZW5peCB0byB1c2UgaW5wdXRfbmFtZSBpbnN0ZWFkIG9mIGlucHV0X2lkXG4gICAgbGV0IGlucHV0ID0gZmllbGQgJiYgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYFtpZD1cIiR7ZmllbGR9XCJdLCBbbmFtZT1cIiR7ZmllbGR9XCJdYClcbiAgICBpZighaW5wdXQpeyByZXR1cm4gfVxuXG4gICAgaWYoISh0aGlzLnByaXZhdGUoaW5wdXQsIFBIWF9IQVNfRk9DVVNFRCkgfHwgdGhpcy5wcml2YXRlKGlucHV0LmZvcm0sIFBIWF9IQVNfU1VCTUlUVEVEKSkpe1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChQSFhfTk9fRkVFREJBQ0tfQ0xBU1MpXG4gICAgfVxuICB9LFxuXG4gIHNob3dFcnJvcihpbnB1dEVsLCBwaHhGZWVkYmFja0Zvcil7XG4gICAgaWYoaW5wdXRFbC5pZCB8fCBpbnB1dEVsLm5hbWUpe1xuICAgICAgdGhpcy5hbGwoaW5wdXRFbC5mb3JtLCBgWyR7cGh4RmVlZGJhY2tGb3J9PVwiJHtpbnB1dEVsLmlkfVwiXSwgWyR7cGh4RmVlZGJhY2tGb3J9PVwiJHtpbnB1dEVsLm5hbWV9XCJdYCwgKGVsKSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoZWwsIFBIWF9OT19GRUVEQkFDS19DTEFTUylcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIGlzUGh4Q2hpbGQobm9kZSl7XG4gICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKFBIWF9QQVJFTlRfSUQpXG4gIH0sXG5cbiAgaXNQaHhTdGlja3kobm9kZSl7XG4gICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKFBIWF9TVElDS1kpICE9PSBudWxsXG4gIH0sXG5cbiAgZmlyc3RQaHhDaGlsZChlbCl7XG4gICAgcmV0dXJuIHRoaXMuaXNQaHhDaGlsZChlbCkgPyBlbCA6IHRoaXMuYWxsKGVsLCBgWyR7UEhYX1BBUkVOVF9JRH1dYClbMF1cbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50KHRhcmdldCwgbmFtZSwgb3B0cyA9IHt9KXtcbiAgICBsZXQgYnViYmxlcyA9IG9wdHMuYnViYmxlcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhb3B0cy5idWJibGVzXG4gICAgbGV0IGV2ZW50T3B0cyA9IHtidWJibGVzOiBidWJibGVzLCBjYW5jZWxhYmxlOiB0cnVlLCBkZXRhaWw6IG9wdHMuZGV0YWlsIHx8IHt9fVxuICAgIGxldCBldmVudCA9IG5hbWUgPT09IFwiY2xpY2tcIiA/IG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIiwgZXZlbnRPcHRzKSA6IG5ldyBDdXN0b21FdmVudChuYW1lLCBldmVudE9wdHMpXG4gICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gIH0sXG5cbiAgY2xvbmVOb2RlKG5vZGUsIGh0bWwpe1xuICAgIGlmKHR5cGVvZiAoaHRtbCkgPT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjbG9uZWQgPSBub2RlLmNsb25lTm9kZShmYWxzZSlcbiAgICAgIGNsb25lZC5pbm5lckhUTUwgPSBodG1sXG4gICAgICByZXR1cm4gY2xvbmVkXG4gICAgfVxuICB9LFxuXG4gIG1lcmdlQXR0cnModGFyZ2V0LCBzb3VyY2UsIG9wdHMgPSB7fSl7XG4gICAgbGV0IGV4Y2x1ZGUgPSBvcHRzLmV4Y2x1ZGUgfHwgW11cbiAgICBsZXQgaXNJZ25vcmVkID0gb3B0cy5pc0lnbm9yZWRcbiAgICBsZXQgc291cmNlQXR0cnMgPSBzb3VyY2UuYXR0cmlidXRlc1xuICAgIGZvcihsZXQgaSA9IHNvdXJjZUF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcbiAgICAgIGxldCBuYW1lID0gc291cmNlQXR0cnNbaV0ubmFtZVxuICAgICAgaWYoZXhjbHVkZS5pbmRleE9mKG5hbWUpIDwgMCl7IHRhcmdldC5zZXRBdHRyaWJ1dGUobmFtZSwgc291cmNlLmdldEF0dHJpYnV0ZShuYW1lKSkgfVxuICAgIH1cblxuICAgIGxldCB0YXJnZXRBdHRycyA9IHRhcmdldC5hdHRyaWJ1dGVzXG4gICAgZm9yKGxldCBpID0gdGFyZ2V0QXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgbGV0IG5hbWUgPSB0YXJnZXRBdHRyc1tpXS5uYW1lXG4gICAgICBpZihpc0lnbm9yZWQpe1xuICAgICAgICBpZihuYW1lLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKSAmJiAhc291cmNlLmhhc0F0dHJpYnV0ZShuYW1lKSl7IHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUobmFtZSkgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoIXNvdXJjZS5oYXNBdHRyaWJ1dGUobmFtZSkpeyB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbWVyZ2VGb2N1c2VkSW5wdXQodGFyZ2V0LCBzb3VyY2Upe1xuICAgIC8vIHNraXAgc2VsZWN0cyBiZWNhdXNlIEZGIHdpbGwgcmVzZXQgaGlnaGxpZ2h0ZWQgaW5kZXggZm9yIGFueSBzZXRBdHRyaWJ1dGVcbiAgICBpZighKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50KSl7IERPTS5tZXJnZUF0dHJzKHRhcmdldCwgc291cmNlLCB7ZXhjbHVkZTogW1widmFsdWVcIl19KSB9XG4gICAgaWYoc291cmNlLnJlYWRPbmx5KXtcbiAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCB0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwicmVhZG9ubHlcIilcbiAgICB9XG4gIH0sXG5cbiAgaGFzU2VsZWN0aW9uUmFuZ2UoZWwpe1xuICAgIHJldHVybiBlbC5zZXRTZWxlY3Rpb25SYW5nZSAmJiAoZWwudHlwZSA9PT0gXCJ0ZXh0XCIgfHwgZWwudHlwZSA9PT0gXCJ0ZXh0YXJlYVwiKVxuICB9LFxuXG4gIHJlc3RvcmVGb2N1cyhmb2N1c2VkLCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKXtcbiAgICBpZighRE9NLmlzVGV4dHVhbElucHV0KGZvY3VzZWQpKXsgcmV0dXJuIH1cbiAgICBsZXQgd2FzRm9jdXNlZCA9IGZvY3VzZWQubWF0Y2hlcyhcIjpmb2N1c1wiKVxuICAgIGlmKGZvY3VzZWQucmVhZE9ubHkpeyBmb2N1c2VkLmJsdXIoKSB9XG4gICAgaWYoIXdhc0ZvY3VzZWQpeyBmb2N1c2VkLmZvY3VzKCkgfVxuICAgIGlmKHRoaXMuaGFzU2VsZWN0aW9uUmFuZ2UoZm9jdXNlZCkpe1xuICAgICAgZm9jdXNlZC5zZXRTZWxlY3Rpb25SYW5nZShzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKVxuICAgIH1cbiAgfSxcblxuICBpc0Zvcm1JbnB1dChlbCl7IHJldHVybiAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYSkkL2kudGVzdChlbC50YWdOYW1lKSAmJiBlbC50eXBlICE9PSBcImJ1dHRvblwiIH0sXG5cbiAgc3luY0F0dHJzVG9Qcm9wcyhlbCl7XG4gICAgaWYoZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmIENIRUNLQUJMRV9JTlBVVFMuaW5kZXhPZihlbC50eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkpID49IDApe1xuICAgICAgZWwuY2hlY2tlZCA9IGVsLmdldEF0dHJpYnV0ZShcImNoZWNrZWRcIikgIT09IG51bGxcbiAgICB9XG4gIH0sXG5cbiAgaXNUZXh0dWFsSW5wdXQoZWwpeyByZXR1cm4gRk9DVVNBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUpID49IDAgfSxcblxuICBpc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWwoZWwsIHBoeFRyaWdnZXJFeHRlcm5hbCl7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUocGh4VHJpZ2dlckV4dGVybmFsKSAhPT0gbnVsbFxuICB9LFxuXG4gIHN5bmNQZW5kaW5nUmVmKGZyb21FbCwgdG9FbCwgZGlzYWJsZVdpdGgpe1xuICAgIGxldCByZWYgPSBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9SRUYpXG4gICAgaWYocmVmID09PSBudWxsKXsgcmV0dXJuIHRydWUgfVxuICAgIGxldCByZWZTcmMgPSBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9SRUZfU1JDKVxuXG4gICAgaWYoRE9NLmlzRm9ybUlucHV0KGZyb21FbCkgfHwgZnJvbUVsLmdldEF0dHJpYnV0ZShkaXNhYmxlV2l0aCkgIT09IG51bGwpe1xuICAgICAgaWYoRE9NLmlzVXBsb2FkSW5wdXQoZnJvbUVsKSl7IERPTS5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwge2lzSWdub3JlZDogdHJ1ZX0pIH1cbiAgICAgIERPTS5wdXRQcml2YXRlKGZyb21FbCwgUEhYX1JFRiwgdG9FbClcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICBQSFhfRVZFTlRfQ0xBU1NFUy5mb3JFYWNoKGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIGZyb21FbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSAmJiB0b0VsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKVxuICAgICAgfSlcbiAgICAgIHRvRWwuc2V0QXR0cmlidXRlKFBIWF9SRUYsIHJlZilcbiAgICAgIHRvRWwuc2V0QXR0cmlidXRlKFBIWF9SRUZfU1JDLCByZWZTcmMpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfSxcblxuICBjbGVhbkNoaWxkTm9kZXMoY29udGFpbmVyLCBwaHhVcGRhdGUpe1xuICAgIGlmKERPTS5pc1BoeFVwZGF0ZShjb250YWluZXIsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkpe1xuICAgICAgbGV0IHRvUmVtb3ZlID0gW11cbiAgICAgIGNvbnRhaW5lci5jaGlsZE5vZGVzLmZvckVhY2goY2hpbGROb2RlID0+IHtcbiAgICAgICAgaWYoIWNoaWxkTm9kZS5pZCl7XG4gICAgICAgICAgLy8gU2tpcCB3YXJuaW5nIGlmIGl0J3MgYW4gZW1wdHkgdGV4dCBub2RlIChlLmcuIGEgbmV3LWxpbmUpXG4gICAgICAgICAgbGV0IGlzRW1wdHlUZXh0Tm9kZSA9IGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgY2hpbGROb2RlLm5vZGVWYWx1ZS50cmltKCkgPT09IFwiXCJcbiAgICAgICAgICBpZighaXNFbXB0eVRleHROb2RlKXtcbiAgICAgICAgICAgIGxvZ0Vycm9yKFwib25seSBIVE1MIGVsZW1lbnQgdGFncyB3aXRoIGFuIGlkIGFyZSBhbGxvd2VkIGluc2lkZSBjb250YWluZXJzIHdpdGggcGh4LXVwZGF0ZS5cXG5cXG5cIiArXG4gICAgICAgICAgICAgIGByZW1vdmluZyBpbGxlZ2FsIG5vZGU6IFwiJHsoY2hpbGROb2RlLm91dGVySFRNTCB8fCBjaGlsZE5vZGUubm9kZVZhbHVlKS50cmltKCl9XCJcXG5cXG5gKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0b1JlbW92ZS5wdXNoKGNoaWxkTm9kZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRvUmVtb3ZlLmZvckVhY2goY2hpbGROb2RlID0+IGNoaWxkTm9kZS5yZW1vdmUoKSlcbiAgICB9XG4gIH0sXG5cbiAgcmVwbGFjZVJvb3RDb250YWluZXIoY29udGFpbmVyLCB0YWdOYW1lLCBhdHRycyl7XG4gICAgbGV0IHJldGFpbmVkQXR0cnMgPSBuZXcgU2V0KFtcImlkXCIsIFBIWF9TRVNTSU9OLCBQSFhfU1RBVElDLCBQSFhfTUFJTiwgUEhYX1JPT1RfSURdKVxuICAgIGlmKGNvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHRhZ05hbWUudG9Mb3dlckNhc2UoKSl7XG4gICAgICBBcnJheS5mcm9tKGNvbnRhaW5lci5hdHRyaWJ1dGVzKVxuICAgICAgICAuZmlsdGVyKGF0dHIgPT4gIXJldGFpbmVkQXR0cnMuaGFzKGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgLmZvckVhY2goYXR0ciA9PiBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKGF0dHIubmFtZSkpXG5cbiAgICAgIE9iamVjdC5rZXlzKGF0dHJzKVxuICAgICAgICAuZmlsdGVyKG5hbWUgPT4gIXJldGFpbmVkQXR0cnMuaGFzKG5hbWUudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgIC5mb3JFYWNoKGF0dHIgPT4gY29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSkpXG5cbiAgICAgIHJldHVybiBjb250YWluZXJcblxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKVxuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goYXR0ciA9PiBuZXdDb250YWluZXIuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKSlcbiAgICAgIHJldGFpbmVkQXR0cnMuZm9yRWFjaChhdHRyID0+IG5ld0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoYXR0ciwgY29udGFpbmVyLmdldEF0dHJpYnV0ZShhdHRyKSkpXG4gICAgICBuZXdDb250YWluZXIuaW5uZXJIVE1MID0gY29udGFpbmVyLmlubmVySFRNTFxuICAgICAgY29udGFpbmVyLnJlcGxhY2VXaXRoKG5ld0NvbnRhaW5lcilcbiAgICAgIHJldHVybiBuZXdDb250YWluZXJcbiAgICB9XG4gIH0sXG5cbiAgZ2V0U3RpY2t5KGVsLCBuYW1lLCBkZWZhdWx0VmFsKXtcbiAgICBsZXQgb3AgPSAoRE9NLnByaXZhdGUoZWwsIFwic3RpY2t5XCIpIHx8IFtdKS5maW5kKChbZXhpc3RpbmdOYW1lLCBdKSA9PiBuYW1lID09PSBleGlzdGluZ05hbWUpXG4gICAgaWYob3Ape1xuICAgICAgbGV0IFtfbmFtZSwgX29wLCBzdGFzaGVkUmVzdWx0XSA9IG9wXG4gICAgICByZXR1cm4gc3Rhc2hlZFJlc3VsdFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHlwZW9mKGRlZmF1bHRWYWwpID09PSBcImZ1bmN0aW9uXCIgPyBkZWZhdWx0VmFsKCkgOiBkZWZhdWx0VmFsXG4gICAgfVxuICB9LFxuXG4gIGRlbGV0ZVN0aWNreShlbCwgbmFtZSl7XG4gICAgdGhpcy51cGRhdGVQcml2YXRlKGVsLCBcInN0aWNreVwiLCBbXSwgb3BzID0+IHtcbiAgICAgIHJldHVybiBvcHMuZmlsdGVyKChbZXhpc3RpbmdOYW1lLCBfXSkgPT4gZXhpc3RpbmdOYW1lICE9PSBuYW1lKVxuICAgIH0pXG4gIH0sXG5cbiAgcHV0U3RpY2t5KGVsLCBuYW1lLCBvcCl7XG4gICAgbGV0IHN0YXNoZWRSZXN1bHQgPSBvcChlbClcbiAgICB0aGlzLnVwZGF0ZVByaXZhdGUoZWwsIFwic3RpY2t5XCIsIFtdLCBvcHMgPT4ge1xuICAgICAgbGV0IGV4aXN0aW5nSW5kZXggPSBvcHMuZmluZEluZGV4KChbZXhpc3RpbmdOYW1lLCBdKSA9PiBuYW1lID09PSBleGlzdGluZ05hbWUpXG4gICAgICBpZihleGlzdGluZ0luZGV4ID49IDApe1xuICAgICAgICBvcHNbZXhpc3RpbmdJbmRleF0gPSBbbmFtZSwgb3AsIHN0YXNoZWRSZXN1bHRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHMucHVzaChbbmFtZSwgb3AsIHN0YXNoZWRSZXN1bHRdKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9wc1xuICAgIH0pXG4gIH0sXG5cbiAgYXBwbHlTdGlja3lPcGVyYXRpb25zKGVsKXtcbiAgICBsZXQgb3BzID0gRE9NLnByaXZhdGUoZWwsIFwic3RpY2t5XCIpXG4gICAgaWYoIW9wcyl7IHJldHVybiB9XG5cbiAgICBvcHMuZm9yRWFjaCgoW25hbWUsIG9wLCBfc3Rhc2hlZF0pID0+IHRoaXMucHV0U3RpY2t5KGVsLCBuYW1lLCBvcCkpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRE9NXG4iLCAiaW1wb3J0IHtcbiAgUEhYX0FDVElWRV9FTlRSWV9SRUZTLFxuICBQSFhfTElWRV9GSUxFX1VQREFURUQsXG4gIFBIWF9QUkVGTElHSFRFRF9SRUZTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNoYW5uZWxVcGxvYWRlcixcbiAgbG9nRXJyb3Jcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgTGl2ZVVwbG9hZGVyIGZyb20gXCIuL2xpdmVfdXBsb2FkZXJcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVcGxvYWRFbnRyeSB7XG4gIHN0YXRpYyBpc0FjdGl2ZShmaWxlRWwsIGZpbGUpe1xuICAgIGxldCBpc05ldyA9IGZpbGUuX3BoeFJlZiA9PT0gdW5kZWZpbmVkXG4gICAgbGV0IGFjdGl2ZVJlZnMgPSBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykuc3BsaXQoXCIsXCIpXG4gICAgbGV0IGlzQWN0aXZlID0gYWN0aXZlUmVmcy5pbmRleE9mKExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpKSA+PSAwXG4gICAgcmV0dXJuIGZpbGUuc2l6ZSA+IDAgJiYgKGlzTmV3IHx8IGlzQWN0aXZlKVxuICB9XG5cbiAgc3RhdGljIGlzUHJlZmxpZ2h0ZWQoZmlsZUVsLCBmaWxlKXtcbiAgICBsZXQgcHJlZmxpZ2h0ZWRSZWZzID0gZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykuc3BsaXQoXCIsXCIpXG4gICAgbGV0IGlzUHJlZmxpZ2h0ZWQgPSBwcmVmbGlnaHRlZFJlZnMuaW5kZXhPZihMaXZlVXBsb2FkZXIuZ2VuRmlsZVJlZihmaWxlKSkgPj0gMFxuICAgIHJldHVybiBpc1ByZWZsaWdodGVkICYmIHRoaXMuaXNBY3RpdmUoZmlsZUVsLCBmaWxlKVxuICB9XG5cbiAgY29uc3RydWN0b3IoZmlsZUVsLCBmaWxlLCB2aWV3KXtcbiAgICB0aGlzLnJlZiA9IExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpXG4gICAgdGhpcy5maWxlRWwgPSBmaWxlRWxcbiAgICB0aGlzLmZpbGUgPSBmaWxlXG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMubWV0YSA9IG51bGxcbiAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IGZhbHNlXG4gICAgdGhpcy5faXNEb25lID0gZmFsc2VcbiAgICB0aGlzLl9wcm9ncmVzcyA9IDBcbiAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50ID0gLTFcbiAgICB0aGlzLl9vbkRvbmUgPSBmdW5jdGlvbiAoKXsgfVxuICAgIHRoaXMuX29uRWxVcGRhdGVkID0gdGhpcy5vbkVsVXBkYXRlZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5maWxlRWwuYWRkRXZlbnRMaXN0ZW5lcihQSFhfTElWRV9GSUxFX1VQREFURUQsIHRoaXMuX29uRWxVcGRhdGVkKVxuICB9XG5cbiAgbWV0YWRhdGEoKXsgcmV0dXJuIHRoaXMubWV0YSB9XG5cbiAgcHJvZ3Jlc3MocHJvZ3Jlc3Mpe1xuICAgIHRoaXMuX3Byb2dyZXNzID0gTWF0aC5mbG9vcihwcm9ncmVzcylcbiAgICBpZih0aGlzLl9wcm9ncmVzcyA+IHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQpe1xuICAgICAgaWYodGhpcy5fcHJvZ3Jlc3MgPj0gMTAwKXtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSAxMDBcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IDEwMFxuICAgICAgICB0aGlzLl9pc0RvbmUgPSB0cnVlXG4gICAgICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwgMTAwLCAoKSA9PiB7XG4gICAgICAgICAgTGl2ZVVwbG9hZGVyLnVudHJhY2tGaWxlKHRoaXMuZmlsZUVsLCB0aGlzLmZpbGUpXG4gICAgICAgICAgdGhpcy5fb25Eb25lKClcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQgPSB0aGlzLl9wcm9ncmVzc1xuICAgICAgICB0aGlzLnZpZXcucHVzaEZpbGVQcm9ncmVzcyh0aGlzLmZpbGVFbCwgdGhpcy5yZWYsIHRoaXMuX3Byb2dyZXNzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNhbmNlbCgpe1xuICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gdHJ1ZVxuICAgIHRoaXMuX2lzRG9uZSA9IHRydWVcbiAgICB0aGlzLl9vbkRvbmUoKVxuICB9XG5cbiAgaXNEb25lKCl7IHJldHVybiB0aGlzLl9pc0RvbmUgfVxuXG4gIGVycm9yKHJlYXNvbiA9IFwiZmFpbGVkXCIpe1xuICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwge2Vycm9yOiByZWFzb259KVxuICAgIExpdmVVcGxvYWRlci5jbGVhckZpbGVzKHRoaXMuZmlsZUVsKVxuICB9XG5cbiAgLy9wcml2YXRlXG5cbiAgb25Eb25lKGNhbGxiYWNrKXtcbiAgICB0aGlzLl9vbkRvbmUgPSAoKSA9PiB7XG4gICAgICB0aGlzLmZpbGVFbC5yZW1vdmVFdmVudExpc3RlbmVyKFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCwgdGhpcy5fb25FbFVwZGF0ZWQpXG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgb25FbFVwZGF0ZWQoKXtcbiAgICBsZXQgYWN0aXZlUmVmcyA9IHRoaXMuZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfQUNUSVZFX0VOVFJZX1JFRlMpLnNwbGl0KFwiLFwiKVxuICAgIGlmKGFjdGl2ZVJlZnMuaW5kZXhPZih0aGlzLnJlZikgPT09IC0xKXsgdGhpcy5jYW5jZWwoKSB9XG4gIH1cblxuICB0b1ByZWZsaWdodFBheWxvYWQoKXtcbiAgICByZXR1cm4ge1xuICAgICAgbGFzdF9tb2RpZmllZDogdGhpcy5maWxlLmxhc3RNb2RpZmllZCxcbiAgICAgIG5hbWU6IHRoaXMuZmlsZS5uYW1lLFxuICAgICAgc2l6ZTogdGhpcy5maWxlLnNpemUsXG4gICAgICB0eXBlOiB0aGlzLmZpbGUudHlwZSxcbiAgICAgIHJlZjogdGhpcy5yZWZcbiAgICB9XG4gIH1cblxuICB1cGxvYWRlcih1cGxvYWRlcnMpe1xuICAgIGlmKHRoaXMubWV0YS51cGxvYWRlcil7XG4gICAgICBsZXQgY2FsbGJhY2sgPSB1cGxvYWRlcnNbdGhpcy5tZXRhLnVwbG9hZGVyXSB8fCBsb2dFcnJvcihgbm8gdXBsb2FkZXIgY29uZmlndXJlZCBmb3IgJHt0aGlzLm1ldGEudXBsb2FkZXJ9YClcbiAgICAgIHJldHVybiB7bmFtZTogdGhpcy5tZXRhLnVwbG9hZGVyLCBjYWxsYmFjazogY2FsbGJhY2t9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7bmFtZTogXCJjaGFubmVsXCIsIGNhbGxiYWNrOiBjaGFubmVsVXBsb2FkZXJ9XG4gICAgfVxuICB9XG5cbiAgemlwUG9zdEZsaWdodChyZXNwKXtcbiAgICB0aGlzLm1ldGEgPSByZXNwLmVudHJpZXNbdGhpcy5yZWZdXG4gICAgaWYoIXRoaXMubWV0YSl7IGxvZ0Vycm9yKGBubyBwcmVmbGlnaHQgdXBsb2FkIHJlc3BvbnNlIHJldHVybmVkIHdpdGggcmVmICR7dGhpcy5yZWZ9YCwge2lucHV0OiB0aGlzLmZpbGVFbCwgcmVzcG9uc2U6IHJlc3B9KSB9XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBQSFhfRE9ORV9SRUZTLFxuICBQSFhfUFJFRkxJR0hURURfUkVGUyxcbiAgUEhYX1VQTE9BRF9SRUZcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgVXBsb2FkRW50cnkgZnJvbSBcIi4vdXBsb2FkX2VudHJ5XCJcblxubGV0IGxpdmVVcGxvYWRlckZpbGVSZWYgPSAwXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpdmVVcGxvYWRlciB7XG4gIHN0YXRpYyBnZW5GaWxlUmVmKGZpbGUpe1xuICAgIGxldCByZWYgPSBmaWxlLl9waHhSZWZcbiAgICBpZihyZWYgIT09IHVuZGVmaW5lZCl7XG4gICAgICByZXR1cm4gcmVmXG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGUuX3BoeFJlZiA9IChsaXZlVXBsb2FkZXJGaWxlUmVmKyspLnRvU3RyaW5nKClcbiAgICAgIHJldHVybiBmaWxlLl9waHhSZWZcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0RW50cnlEYXRhVVJMKGlucHV0RWwsIHJlZiwgY2FsbGJhY2spe1xuICAgIGxldCBmaWxlID0gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKS5maW5kKGZpbGUgPT4gdGhpcy5nZW5GaWxlUmVmKGZpbGUpID09PSByZWYpXG4gICAgY2FsbGJhY2soVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKSlcbiAgfVxuXG4gIHN0YXRpYyBoYXNVcGxvYWRzSW5Qcm9ncmVzcyhmb3JtRWwpe1xuICAgIGxldCBhY3RpdmUgPSAwXG4gICAgRE9NLmZpbmRVcGxvYWRJbnB1dHMoZm9ybUVsKS5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgIGlmKGlucHV0LmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykgIT09IGlucHV0LmdldEF0dHJpYnV0ZShQSFhfRE9ORV9SRUZTKSl7XG4gICAgICAgIGFjdGl2ZSsrXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gYWN0aXZlID4gMFxuICB9XG5cbiAgc3RhdGljIHNlcmlhbGl6ZVVwbG9hZHMoaW5wdXRFbCl7XG4gICAgbGV0IGZpbGVzID0gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKVxuICAgIGxldCBmaWxlRGF0YSA9IHt9XG4gICAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgIGxldCBlbnRyeSA9IHtwYXRoOiBpbnB1dEVsLm5hbWV9XG4gICAgICBsZXQgdXBsb2FkUmVmID0gaW5wdXRFbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpXG4gICAgICBmaWxlRGF0YVt1cGxvYWRSZWZdID0gZmlsZURhdGFbdXBsb2FkUmVmXSB8fCBbXVxuICAgICAgZW50cnkucmVmID0gdGhpcy5nZW5GaWxlUmVmKGZpbGUpXG4gICAgICBlbnRyeS5uYW1lID0gZmlsZS5uYW1lIHx8IGVudHJ5LnJlZlxuICAgICAgZW50cnkudHlwZSA9IGZpbGUudHlwZVxuICAgICAgZW50cnkuc2l6ZSA9IGZpbGUuc2l6ZVxuICAgICAgZmlsZURhdGFbdXBsb2FkUmVmXS5wdXNoKGVudHJ5KVxuICAgIH0pXG4gICAgcmV0dXJuIGZpbGVEYXRhXG4gIH1cblxuICBzdGF0aWMgY2xlYXJGaWxlcyhpbnB1dEVsKXtcbiAgICBpbnB1dEVsLnZhbHVlID0gbnVsbFxuICAgIGlucHV0RWwucmVtb3ZlQXR0cmlidXRlKFBIWF9VUExPQURfUkVGKVxuICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgW10pXG4gIH1cblxuICBzdGF0aWMgdW50cmFja0ZpbGUoaW5wdXRFbCwgZmlsZSl7XG4gICAgRE9NLnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCBET00ucHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIpLmZpbHRlcihmID0+ICFPYmplY3QuaXMoZiwgZmlsZSkpKVxuICB9XG5cbiAgc3RhdGljIHRyYWNrRmlsZXMoaW5wdXRFbCwgZmlsZXMpe1xuICAgIGlmKGlucHV0RWwuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikgIT09IG51bGwpe1xuICAgICAgbGV0IG5ld0ZpbGVzID0gZmlsZXMuZmlsdGVyKGZpbGUgPT4gIXRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuZmluZChmID0+IE9iamVjdC5pcyhmLCBmaWxlKSkpXG4gICAgICBET00ucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIHRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuY29uY2F0KG5ld0ZpbGVzKSlcbiAgICAgIGlucHV0RWwudmFsdWUgPSBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgZmlsZXMpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFjdGl2ZUZpbGVJbnB1dHMoZm9ybUVsKXtcbiAgICBsZXQgZmlsZUlucHV0cyA9IERPTS5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbClcbiAgICByZXR1cm4gQXJyYXkuZnJvbShmaWxlSW5wdXRzKS5maWx0ZXIoZWwgPT4gZWwuZmlsZXMgJiYgdGhpcy5hY3RpdmVGaWxlcyhlbCkubGVuZ3RoID4gMClcbiAgfVxuXG4gIHN0YXRpYyBhY3RpdmVGaWxlcyhpbnB1dCl7XG4gICAgcmV0dXJuIChET00ucHJpdmF0ZShpbnB1dCwgXCJmaWxlc1wiKSB8fCBbXSkuZmlsdGVyKGYgPT4gVXBsb2FkRW50cnkuaXNBY3RpdmUoaW5wdXQsIGYpKVxuICB9XG5cbiAgc3RhdGljIGlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0KGZvcm1FbCl7XG4gICAgbGV0IGZpbGVJbnB1dHMgPSBET00uZmluZFVwbG9hZElucHV0cyhmb3JtRWwpXG4gICAgcmV0dXJuIEFycmF5LmZyb20oZmlsZUlucHV0cykuZmlsdGVyKGlucHV0ID0+IHRoaXMuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dCkubGVuZ3RoID4gMClcbiAgfVxuXG4gIHN0YXRpYyBmaWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0KXtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dCkuZmlsdGVyKGYgPT4gIVVwbG9hZEVudHJ5LmlzUHJlZmxpZ2h0ZWQoaW5wdXQsIGYpKVxuICB9XG5cbiAgY29uc3RydWN0b3IoaW5wdXRFbCwgdmlldywgb25Db21wbGV0ZSl7XG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMub25Db21wbGV0ZSA9IG9uQ29tcGxldGVcbiAgICB0aGlzLl9lbnRyaWVzID1cbiAgICAgIEFycmF5LmZyb20oTGl2ZVVwbG9hZGVyLmZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXRFbCkgfHwgW10pXG4gICAgICAgIC5tYXAoZmlsZSA9PiBuZXcgVXBsb2FkRW50cnkoaW5wdXRFbCwgZmlsZSwgdmlldykpXG5cbiAgICB0aGlzLm51bUVudHJpZXNJblByb2dyZXNzID0gdGhpcy5fZW50cmllcy5sZW5ndGhcbiAgfVxuXG4gIGVudHJpZXMoKXsgcmV0dXJuIHRoaXMuX2VudHJpZXMgfVxuXG4gIGluaXRBZGFwdGVyVXBsb2FkKHJlc3AsIG9uRXJyb3IsIGxpdmVTb2NrZXQpe1xuICAgIHRoaXMuX2VudHJpZXMgPVxuICAgICAgdGhpcy5fZW50cmllcy5tYXAoZW50cnkgPT4ge1xuICAgICAgICBlbnRyeS56aXBQb3N0RmxpZ2h0KHJlc3ApXG4gICAgICAgIGVudHJ5Lm9uRG9uZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcy0tXG4gICAgICAgICAgaWYodGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcyA9PT0gMCl7IHRoaXMub25Db21wbGV0ZSgpIH1cbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIGVudHJ5XG4gICAgICB9KVxuXG4gICAgbGV0IGdyb3VwZWRFbnRyaWVzID0gdGhpcy5fZW50cmllcy5yZWR1Y2UoKGFjYywgZW50cnkpID0+IHtcbiAgICAgIGxldCB7bmFtZSwgY2FsbGJhY2t9ID0gZW50cnkudXBsb2FkZXIobGl2ZVNvY2tldC51cGxvYWRlcnMpXG4gICAgICBhY2NbbmFtZV0gPSBhY2NbbmFtZV0gfHwge2NhbGxiYWNrOiBjYWxsYmFjaywgZW50cmllczogW119XG4gICAgICBhY2NbbmFtZV0uZW50cmllcy5wdXNoKGVudHJ5KVxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIHt9KVxuXG4gICAgZm9yKGxldCBuYW1lIGluIGdyb3VwZWRFbnRyaWVzKXtcbiAgICAgIGxldCB7Y2FsbGJhY2ssIGVudHJpZXN9ID0gZ3JvdXBlZEVudHJpZXNbbmFtZV1cbiAgICAgIGNhbGxiYWNrKGVudHJpZXMsIG9uRXJyb3IsIHJlc3AsIGxpdmVTb2NrZXQpXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgUEhYX0FDVElWRV9FTlRSWV9SRUZTLFxuICBQSFhfTElWRV9GSUxFX1VQREFURUQsXG4gIFBIWF9QUkVGTElHSFRFRF9SRUZTLFxuICBQSFhfVVBMT0FEX1JFRlxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQgTGl2ZVVwbG9hZGVyIGZyb20gXCIuL2xpdmVfdXBsb2FkZXJcIlxuXG5sZXQgSG9va3MgPSB7XG4gIExpdmVGaWxlVXBsb2FkOiB7XG4gICAgYWN0aXZlUmVmcygpeyByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX0FDVElWRV9FTlRSWV9SRUZTKSB9LFxuXG4gICAgcHJlZmxpZ2h0ZWRSZWZzKCl7IHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykgfSxcblxuICAgIG1vdW50ZWQoKXsgdGhpcy5wcmVmbGlnaHRlZFdhcyA9IHRoaXMucHJlZmxpZ2h0ZWRSZWZzKCkgfSxcblxuICAgIHVwZGF0ZWQoKXtcbiAgICAgIGxldCBuZXdQcmVmbGlnaHRzID0gdGhpcy5wcmVmbGlnaHRlZFJlZnMoKVxuICAgICAgaWYodGhpcy5wcmVmbGlnaHRlZFdhcyAhPT0gbmV3UHJlZmxpZ2h0cyl7XG4gICAgICAgIHRoaXMucHJlZmxpZ2h0ZWRXYXMgPSBuZXdQcmVmbGlnaHRzXG4gICAgICAgIGlmKG5ld1ByZWZsaWdodHMgPT09IFwiXCIpe1xuICAgICAgICAgIHRoaXMuX192aWV3LmNhbmNlbFN1Ym1pdCh0aGlzLmVsLmZvcm0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYodGhpcy5hY3RpdmVSZWZzKCkgPT09IFwiXCIpeyB0aGlzLmVsLnZhbHVlID0gbnVsbCB9XG4gICAgICB0aGlzLmVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCkpXG4gICAgfVxuICB9LFxuXG4gIExpdmVJbWdQcmV2aWV3OiB7XG4gICAgbW91bnRlZCgpe1xuICAgICAgdGhpcy5yZWYgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWVudHJ5LXJlZlwiKVxuICAgICAgdGhpcy5pbnB1dEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpKVxuICAgICAgTGl2ZVVwbG9hZGVyLmdldEVudHJ5RGF0YVVSTCh0aGlzLmlucHV0RWwsIHRoaXMucmVmLCB1cmwgPT4ge1xuICAgICAgICB0aGlzLnVybCA9IHVybFxuICAgICAgICB0aGlzLmVsLnNyYyA9IHVybFxuICAgICAgfSlcbiAgICB9LFxuICAgIGRlc3Ryb3llZCgpe1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLnVybClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSG9va3NcbiIsICJpbXBvcnQge1xuICBtYXliZVxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRE9NUG9zdE1vcnBoUmVzdG9yZXIge1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXJCZWZvcmUsIGNvbnRhaW5lckFmdGVyLCB1cGRhdGVUeXBlKXtcbiAgICBsZXQgaWRzQmVmb3JlID0gbmV3IFNldCgpXG4gICAgbGV0IGlkc0FmdGVyID0gbmV3IFNldChbLi4uY29udGFpbmVyQWZ0ZXIuY2hpbGRyZW5dLm1hcChjaGlsZCA9PiBjaGlsZC5pZCkpXG5cbiAgICBsZXQgZWxlbWVudHNUb01vZGlmeSA9IFtdXG5cbiAgICBBcnJheS5mcm9tKGNvbnRhaW5lckJlZm9yZS5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBpZihjaGlsZC5pZCl7IC8vIGFsbCBvZiBvdXIgY2hpbGRyZW4gc2hvdWxkIGJlIGVsZW1lbnRzIHdpdGggaWRzXG4gICAgICAgIGlkc0JlZm9yZS5hZGQoY2hpbGQuaWQpXG4gICAgICAgIGlmKGlkc0FmdGVyLmhhcyhjaGlsZC5pZCkpe1xuICAgICAgICAgIGxldCBwcmV2aW91c0VsZW1lbnRJZCA9IGNoaWxkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgY2hpbGQucHJldmlvdXNFbGVtZW50U2libGluZy5pZFxuICAgICAgICAgIGVsZW1lbnRzVG9Nb2RpZnkucHVzaCh7ZWxlbWVudElkOiBjaGlsZC5pZCwgcHJldmlvdXNFbGVtZW50SWQ6IHByZXZpb3VzRWxlbWVudElkfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmNvbnRhaW5lcklkID0gY29udGFpbmVyQWZ0ZXIuaWRcbiAgICB0aGlzLnVwZGF0ZVR5cGUgPSB1cGRhdGVUeXBlXG4gICAgdGhpcy5lbGVtZW50c1RvTW9kaWZ5ID0gZWxlbWVudHNUb01vZGlmeVxuICAgIHRoaXMuZWxlbWVudElkc1RvQWRkID0gWy4uLmlkc0FmdGVyXS5maWx0ZXIoaWQgPT4gIWlkc0JlZm9yZS5oYXMoaWQpKVxuICB9XG5cbiAgLy8gV2UgZG8gdGhlIGZvbGxvd2luZyB0byBvcHRpbWl6ZSBhcHBlbmQvcHJlcGVuZCBvcGVyYXRpb25zOlxuICAvLyAgIDEpIFRyYWNrIGlkcyBvZiBtb2RpZmllZCBlbGVtZW50cyAmIG9mIG5ldyBlbGVtZW50c1xuICAvLyAgIDIpIEFsbCB0aGUgbW9kaWZpZWQgZWxlbWVudHMgYXJlIHB1dCBiYWNrIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluIHRoZSBET00gdHJlZVxuICAvLyAgICAgIGJ5IHN0b3JpbmcgdGhlIGlkIG9mIHRoZWlyIHByZXZpb3VzIHNpYmxpbmdcbiAgLy8gICAzKSBOZXcgZWxlbWVudHMgYXJlIGdvaW5nIHRvIGJlIHB1dCBpbiB0aGUgcmlnaHQgcGxhY2UgYnkgbW9ycGhkb20gZHVyaW5nIGFwcGVuZC5cbiAgLy8gICAgICBGb3IgcHJlcGVuZCwgd2UgbW92ZSB0aGVtIHRvIHRoZSBmaXJzdCBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyXG4gIHBlcmZvcm0oKXtcbiAgICBsZXQgY29udGFpbmVyID0gRE9NLmJ5SWQodGhpcy5jb250YWluZXJJZClcbiAgICB0aGlzLmVsZW1lbnRzVG9Nb2RpZnkuZm9yRWFjaChlbGVtZW50VG9Nb2RpZnkgPT4ge1xuICAgICAgaWYoZWxlbWVudFRvTW9kaWZ5LnByZXZpb3VzRWxlbWVudElkKXtcbiAgICAgICAgbWF5YmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudFRvTW9kaWZ5LnByZXZpb3VzRWxlbWVudElkKSwgcHJldmlvdXNFbGVtID0+IHtcbiAgICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkuZWxlbWVudElkKSwgZWxlbSA9PiB7XG4gICAgICAgICAgICBsZXQgaXNJblJpZ2h0UGxhY2UgPSBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmlkID09IHByZXZpb3VzRWxlbS5pZFxuICAgICAgICAgICAgaWYoIWlzSW5SaWdodFBsYWNlKXtcbiAgICAgICAgICAgICAgcHJldmlvdXNFbGVtLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIGVsZW0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGNvbnRhaW5lclxuICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkuZWxlbWVudElkKSwgZWxlbSA9PiB7XG4gICAgICAgICAgbGV0IGlzSW5SaWdodFBsYWNlID0gZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nID09IG51bGxcbiAgICAgICAgICBpZighaXNJblJpZ2h0UGxhY2Upe1xuICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIiwgZWxlbSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmKHRoaXMudXBkYXRlVHlwZSA9PSBcInByZXBlbmRcIil7XG4gICAgICB0aGlzLmVsZW1lbnRJZHNUb0FkZC5yZXZlcnNlKCkuZm9yRWFjaChlbGVtSWQgPT4ge1xuICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtSWQpLCBlbGVtID0+IGNvbnRhaW5lci5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsIGVsZW0pKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cbiIsICJ2YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuXG5mdW5jdGlvbiBtb3JwaEF0dHJzKGZyb21Ob2RlLCB0b05vZGUpIHtcbiAgICB2YXIgdG9Ob2RlQXR0cnMgPSB0b05vZGUuYXR0cmlidXRlcztcbiAgICB2YXIgYXR0cjtcbiAgICB2YXIgYXR0ck5hbWU7XG4gICAgdmFyIGF0dHJOYW1lc3BhY2VVUkk7XG4gICAgdmFyIGF0dHJWYWx1ZTtcbiAgICB2YXIgZnJvbVZhbHVlO1xuXG4gICAgLy8gZG9jdW1lbnQtZnJhZ21lbnRzIGRvbnQgaGF2ZSBhdHRyaWJ1dGVzIHNvIGxldHMgbm90IGRvIGFueXRoaW5nXG4gICAgaWYgKHRvTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBmcm9tTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBhdHRyaWJ1dGVzIG9uIG9yaWdpbmFsIERPTSBlbGVtZW50XG4gICAgZm9yICh2YXIgaSA9IHRvTm9kZUF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGF0dHIgPSB0b05vZGVBdHRyc1tpXTtcbiAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgIGF0dHJOYW1lc3BhY2VVUkkgPSBhdHRyLm5hbWVzcGFjZVVSSTtcbiAgICAgICAgYXR0clZhbHVlID0gYXR0ci52YWx1ZTtcblxuICAgICAgICBpZiAoYXR0ck5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLmxvY2FsTmFtZSB8fCBhdHRyTmFtZTtcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIucHJlZml4ID09PSAneG1sbnMnKXtcbiAgICAgICAgICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7IC8vIEl0J3Mgbm90IGFsbG93ZWQgdG8gc2V0IGFuIGF0dHJpYnV0ZSB3aXRoIHRoZSBYTUxOUyBuYW1lc3BhY2Ugd2l0aG91dCBzcGVjaWZ5aW5nIHRoZSBgeG1sbnNgIHByZWZpeFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChmcm9tVmFsdWUgIT09IGF0dHJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgZXh0cmEgYXR0cmlidXRlcyBmb3VuZCBvbiB0aGUgb3JpZ2luYWwgRE9NIGVsZW1lbnQgdGhhdFxuICAgIC8vIHdlcmVuJ3QgZm91bmQgb24gdGhlIHRhcmdldCBlbGVtZW50LlxuICAgIHZhciBmcm9tTm9kZUF0dHJzID0gZnJvbU5vZGUuYXR0cmlidXRlcztcblxuICAgIGZvciAodmFyIGQgPSBmcm9tTm9kZUF0dHJzLmxlbmd0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGF0dHIgPSBmcm9tTm9kZUF0dHJzW2RdO1xuICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuXG4gICAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubG9jYWxOYW1lIHx8IGF0dHJOYW1lO1xuXG4gICAgICAgICAgICBpZiAoIXRvTm9kZS5oYXNBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5yZW1vdmVBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRvTm9kZS5oYXNBdHRyaWJ1dGUoYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHJhbmdlOyAvLyBDcmVhdGUgYSByYW5nZSBvYmplY3QgZm9yIGVmZmljZW50bHkgcmVuZGVyaW5nIHN0cmluZ3MgdG8gZWxlbWVudHMuXG52YXIgTlNfWEhUTUwgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5cbnZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZG9jdW1lbnQ7XG52YXIgSEFTX1RFTVBMQVRFX1NVUFBPUlQgPSAhIWRvYyAmJiAnY29udGVudCcgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG52YXIgSEFTX1JBTkdFX1NVUFBPUlQgPSAhIWRvYyAmJiBkb2MuY3JlYXRlUmFuZ2UgJiYgJ2NyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCcgaW4gZG9jLmNyZWF0ZVJhbmdlKCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVRlbXBsYXRlKHN0cikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IGRvYy5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHN0cjtcbiAgICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21SYW5nZShzdHIpIHtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJhbmdlID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGUoZG9jLmJvZHkpO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudCA9IHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChzdHIpO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21XcmFwKHN0cikge1xuICAgIHZhciBmcmFnbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KCdib2R5Jyk7XG4gICAgZnJhZ21lbnQuaW5uZXJIVE1MID0gc3RyO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYWJvdXQgdGhlIHNhbWVcbiAqIHZhciBodG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdHIsICd0ZXh0L2h0bWwnKTtcbiAqIHJldHVybiBodG1sLmJvZHkuZmlyc3RDaGlsZDtcbiAqXG4gKiBAbWV0aG9kIHRvRWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiB0b0VsZW1lbnQoc3RyKSB7XG4gICAgc3RyID0gc3RyLnRyaW0oKTtcbiAgICBpZiAoSEFTX1RFTVBMQVRFX1NVUFBPUlQpIHtcbiAgICAgIC8vIGF2b2lkIHJlc3RyaWN0aW9ucyBvbiBjb250ZW50IGZvciB0aGluZ3MgbGlrZSBgPHRyPjx0aD5IaTwvdGg+PC90cj5gIHdoaWNoXG4gICAgICAvLyBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQgZG9lc24ndCBzdXBwb3J0XG4gICAgICAvLyA8dGVtcGxhdGU+IHN1cHBvcnQgbm90IGF2YWlsYWJsZSBpbiBJRVxuICAgICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVRlbXBsYXRlKHN0cik7XG4gICAgfSBlbHNlIGlmIChIQVNfUkFOR0VfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVJhbmdlKHN0cik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVdyYXAoc3RyKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdHdvIG5vZGUncyBuYW1lcyBhcmUgdGhlIHNhbWUuXG4gKlxuICogTk9URTogV2UgZG9uJ3QgYm90aGVyIGNoZWNraW5nIGBuYW1lc3BhY2VVUklgIGJlY2F1c2UgeW91IHdpbGwgbmV2ZXIgZmluZCB0d28gSFRNTCBlbGVtZW50cyB3aXRoIHRoZSBzYW1lXG4gKiAgICAgICBub2RlTmFtZSBhbmQgZGlmZmVyZW50IG5hbWVzcGFjZSBVUklzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiIFRoZSB0YXJnZXQgZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29tcGFyZU5vZGVOYW1lcyhmcm9tRWwsIHRvRWwpIHtcbiAgICB2YXIgZnJvbU5vZGVOYW1lID0gZnJvbUVsLm5vZGVOYW1lO1xuICAgIHZhciB0b05vZGVOYW1lID0gdG9FbC5ub2RlTmFtZTtcbiAgICB2YXIgZnJvbUNvZGVTdGFydCwgdG9Db2RlU3RhcnQ7XG5cbiAgICBpZiAoZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZyb21Db2RlU3RhcnQgPSBmcm9tTm9kZU5hbWUuY2hhckNvZGVBdCgwKTtcbiAgICB0b0NvZGVTdGFydCA9IHRvTm9kZU5hbWUuY2hhckNvZGVBdCgwKTtcblxuICAgIC8vIElmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIHZpcnR1YWwgRE9NIG5vZGUgb3IgU1ZHIG5vZGUgdGhlbiB3ZSBtYXlcbiAgICAvLyBuZWVkIHRvIG5vcm1hbGl6ZSB0aGUgdGFnIG5hbWUgYmVmb3JlIGNvbXBhcmluZy4gTm9ybWFsIEhUTUwgZWxlbWVudHMgdGhhdCBhcmVcbiAgICAvLyBpbiB0aGUgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCJcbiAgICAvLyBhcmUgY29udmVydGVkIHRvIHVwcGVyIGNhc2VcbiAgICBpZiAoZnJvbUNvZGVTdGFydCA8PSA5MCAmJiB0b0NvZGVTdGFydCA+PSA5NykgeyAvLyBmcm9tIGlzIHVwcGVyIGFuZCB0byBpcyBsb3dlclxuICAgICAgICByZXR1cm4gZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmICh0b0NvZGVTdGFydCA8PSA5MCAmJiBmcm9tQ29kZVN0YXJ0ID49IDk3KSB7IC8vIHRvIGlzIHVwcGVyIGFuZCBmcm9tIGlzIGxvd2VyXG4gICAgICAgIHJldHVybiB0b05vZGVOYW1lID09PSBmcm9tTm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBlbGVtZW50LCBvcHRpb25hbGx5IHdpdGggYSBrbm93biBuYW1lc3BhY2UgVVJJLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBlbGVtZW50IG5hbWUsIGUuZy4gJ2Rpdicgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZXNwYWNlVVJJXSB0aGUgZWxlbWVudCdzIG5hbWVzcGFjZSBVUkksIGkuZS4gdGhlIHZhbHVlIG9mXG4gKiBpdHMgYHhtbG5zYCBhdHRyaWJ1dGUgb3IgaXRzIGluZmVycmVkIG5hbWVzcGFjZS5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZSwgbmFtZXNwYWNlVVJJKSB7XG4gICAgcmV0dXJuICFuYW1lc3BhY2VVUkkgfHwgbmFtZXNwYWNlVVJJID09PSBOU19YSFRNTCA/XG4gICAgICAgIGRvYy5jcmVhdGVFbGVtZW50KG5hbWUpIDpcbiAgICAgICAgZG9jLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIG5hbWUpO1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgY2hpbGRyZW4gb2Ygb25lIERPTSBlbGVtZW50IHRvIGFub3RoZXIgRE9NIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gbW92ZUNoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgIHZhciBjdXJDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICB2YXIgbmV4dENoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIHRvRWwuYXBwZW5kQ2hpbGQoY3VyQ2hpbGQpO1xuICAgICAgICBjdXJDaGlsZCA9IG5leHRDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIHRvRWw7XG59XG5cbmZ1bmN0aW9uIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCBuYW1lKSB7XG4gICAgaWYgKGZyb21FbFtuYW1lXSAhPT0gdG9FbFtuYW1lXSkge1xuICAgICAgICBmcm9tRWxbbmFtZV0gPSB0b0VsW25hbWVdO1xuICAgICAgICBpZiAoZnJvbUVsW25hbWVdKSB7XG4gICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBzcGVjaWFsRWxIYW5kbGVycyA9IHtcbiAgICBPUFRJT046IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGZyb21FbC5wYXJlbnROb2RlO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudE5hbWUgPSBwYXJlbnROb2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZSA9PT0gJ09QVEdST1VQJykge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgcGFyZW50TmFtZSA9IHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudE5hbWUgPT09ICdTRUxFQ1QnICYmICFwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSkge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tRWwuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpICYmICF0b0VsLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIE1TIEVkZ2UgYnVnIHdoZXJlIHRoZSAnc2VsZWN0ZWQnIGF0dHJpYnV0ZSBjYW4gb25seSBiZVxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmVkIGlmIHNldCB0byBhIG5vbi1lbXB0eSB2YWx1ZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTIwODc2NzkvXG4gICAgICAgICAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gcmVzZXQgc2VsZWN0IGVsZW1lbnQncyBzZWxlY3RlZEluZGV4IHRvIC0xLCBvdGhlcndpc2Ugc2V0dGluZ1xuICAgICAgICAgICAgICAgIC8vIGZyb21FbC5zZWxlY3RlZCB1c2luZyB0aGUgc3luY0Jvb2xlYW5BdHRyUHJvcCBiZWxvdyBoYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgICAgIC8vIFRoZSBjb3JyZWN0IHNlbGVjdGVkSW5kZXggd2lsbCBiZSBzZXQgaW4gdGhlIFNFTEVDVCBzcGVjaWFsIGhhbmRsZXIgYmVsb3cuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdzZWxlY3RlZCcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIFwidmFsdWVcIiBhdHRyaWJ1dGUgaXMgc3BlY2lhbCBmb3IgdGhlIDxpbnB1dD4gZWxlbWVudCBzaW5jZSBpdCBzZXRzXG4gICAgICogdGhlIGluaXRpYWwgdmFsdWUuIENoYW5naW5nIHRoZSBcInZhbHVlXCIgYXR0cmlidXRlIHdpdGhvdXQgY2hhbmdpbmcgdGhlXG4gICAgICogXCJ2YWx1ZVwiIHByb3BlcnR5IHdpbGwgaGF2ZSBubyBlZmZlY3Qgc2luY2UgaXQgaXMgb25seSB1c2VkIHRvIHRoZSBzZXQgdGhlXG4gICAgICogaW5pdGlhbCB2YWx1ZS4gIFNpbWlsYXIgZm9yIHRoZSBcImNoZWNrZWRcIiBhdHRyaWJ1dGUsIGFuZCBcImRpc2FibGVkXCIuXG4gICAgICovXG4gICAgSU5QVVQ6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ2NoZWNrZWQnKTtcbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdkaXNhYmxlZCcpO1xuXG4gICAgICAgIGlmIChmcm9tRWwudmFsdWUgIT09IHRvRWwudmFsdWUpIHtcbiAgICAgICAgICAgIGZyb21FbC52YWx1ZSA9IHRvRWwudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRvRWwuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICBmcm9tRWwucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIFRFWFRBUkVBOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgICAgaWYgKGZyb21FbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGZyb21FbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIE5lZWRlZCBmb3IgSUUuIEFwcGFyZW50bHkgSUUgc2V0cyB0aGUgcGxhY2Vob2xkZXIgYXMgdGhlXG4gICAgICAgICAgICAvLyBub2RlIHZhbHVlIGFuZCB2aXNlIHZlcnNhLiBUaGlzIGlnbm9yZXMgYW4gZW1wdHkgdXBkYXRlLlxuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gZmlyc3RDaGlsZC5ub2RlVmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSA9PSBuZXdWYWx1ZSB8fCAoIW5ld1ZhbHVlICYmIG9sZFZhbHVlID09IGZyb21FbC5wbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFNFTEVDVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIGlmICghdG9FbC5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJykpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGxvb3AgdGhyb3VnaCBjaGlsZHJlbiBvZiBmcm9tRWwsIG5vdCB0b0VsIHNpbmNlIG5vZGVzIGNhbiBiZSBtb3ZlZFxuICAgICAgICAgICAgLy8gZnJvbSB0b0VsIHRvIGZyb21FbCBkaXJlY3RseSB3aGVuIG1vcnBoaW5nLlxuICAgICAgICAgICAgLy8gQXQgdGhlIHRpbWUgdGhpcyBzcGVjaWFsIGhhbmRsZXIgaXMgaW52b2tlZCwgYWxsIGNoaWxkcmVuIGhhdmUgYWxyZWFkeSBiZWVuIG1vcnBoZWRcbiAgICAgICAgICAgIC8vIGFuZCBhcHBlbmRlZCB0byAvIHJlbW92ZWQgZnJvbSBmcm9tRWwsIHNvIHVzaW5nIGZyb21FbCBoZXJlIGlzIHNhZmUgYW5kIGNvcnJlY3QuXG4gICAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBvcHRncm91cDtcbiAgICAgICAgICAgIHZhciBub2RlTmFtZTtcbiAgICAgICAgICAgIHdoaWxlKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgbm9kZU5hbWUgPSBjdXJDaGlsZC5ub2RlTmFtZSAmJiBjdXJDaGlsZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ09QVEdST1VQJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cCA9IGN1ckNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IG9wdGdyb3VwLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnT1BUSU9OJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckNoaWxkLmhhc0F0dHJpYnV0ZSgnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VyQ2hpbGQgJiYgb3B0Z3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRncm91cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZyb21FbC5zZWxlY3RlZEluZGV4ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBFTEVNRU5UX05PREUgPSAxO1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUkMSA9IDExO1xudmFyIFRFWFRfTk9ERSA9IDM7XG52YXIgQ09NTUVOVF9OT0RFID0gODtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXROb2RlS2V5KG5vZGUpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJykpIHx8IG5vZGUuaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9ycGhkb21GYWN0b3J5KG1vcnBoQXR0cnMpIHtcblxuICAgIHJldHVybiBmdW5jdGlvbiBtb3JwaGRvbShmcm9tTm9kZSwgdG9Ob2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0b05vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoZnJvbU5vZGUubm9kZU5hbWUgPT09ICcjZG9jdW1lbnQnIHx8IGZyb21Ob2RlLm5vZGVOYW1lID09PSAnSFRNTCcgfHwgZnJvbU5vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICAgICAgICAgIHZhciB0b05vZGVIdG1sID0gdG9Ob2RlO1xuICAgICAgICAgICAgICAgIHRvTm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdodG1sJyk7XG4gICAgICAgICAgICAgICAgdG9Ob2RlLmlubmVySFRNTCA9IHRvTm9kZUh0bWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvTm9kZSA9IHRvRWxlbWVudCh0b05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdldE5vZGVLZXkgPSBvcHRpb25zLmdldE5vZGVLZXkgfHwgZGVmYXVsdEdldE5vZGVLZXk7XG4gICAgICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlQWRkZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uTm9kZUFkZGVkID0gb3B0aW9ucy5vbk5vZGVBZGRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25CZWZvcmVFbFVwZGF0ZWQgPSBvcHRpb25zLm9uQmVmb3JlRWxVcGRhdGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbkVsVXBkYXRlZCA9IG9wdGlvbnMub25FbFVwZGF0ZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uQmVmb3JlTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbk5vZGVEaXNjYXJkZWQgPSBvcHRpb25zLm9uTm9kZURpc2NhcmRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZCA9IG9wdGlvbnMub25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZCB8fCBub29wO1xuICAgICAgICB2YXIgY2hpbGRyZW5Pbmx5ID0gb3B0aW9ucy5jaGlsZHJlbk9ubHkgPT09IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBvYmplY3QgaXMgdXNlZCBhcyBhIGxvb2t1cCB0byBxdWlja2x5IGZpbmQgYWxsIGtleWVkIGVsZW1lbnRzIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS5cbiAgICAgICAgdmFyIGZyb21Ob2Rlc0xvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZhciBrZXllZFJlbW92YWxMaXN0ID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkS2V5ZWRSZW1vdmFsKGtleSkge1xuICAgICAgICAgICAga2V5ZWRSZW1vdmFsTGlzdC5wdXNoKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB3YWxrRGlzY2FyZGVkQ2hpbGROb2Rlcyhub2RlLCBza2lwS2V5ZWROb2Rlcykge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lwS2V5ZWROb2RlcyAmJiAoa2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgc2tpcHBpbmcga2V5ZWQgbm9kZXMgdGhlbiB3ZSBhZGQgdGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYSBsaXN0IHNvIHRoYXQgaXQgY2FuIGJlIGhhbmRsZWQgYXQgdGhlIHZlcnkgZW5kLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHJlcG9ydCB0aGUgbm9kZSBhcyBkaXNjYXJkZWQgaWYgaXQgaXMgbm90IGtleWVkLiBXZSBkbyB0aGlzIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0IHRoZSBlbmQgd2UgbG9vcCB0aHJvdWdoIGFsbCBrZXllZCBlbGVtZW50cyB0aGF0IHdlcmUgdW5tYXRjaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlbiBkaXNjYXJkIHRoZW0gaW4gb25lIGZpbmFsIHBhc3MuXG4gICAgICAgICAgICAgICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckNoaWxkLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxrRGlzY2FyZGVkQ2hpbGROb2RlcyhjdXJDaGlsZCwgc2tpcEtleWVkTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIERPTSBub2RlIG91dCBvZiB0aGUgb3JpZ2luYWwgRE9NXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gICAgICAgICAqIEBwYXJhbSAge05vZGV9IHBhcmVudE5vZGUgVGhlIG5vZGVzIHBhcmVudFxuICAgICAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBza2lwS2V5ZWROb2RlcyBJZiB0cnVlIHRoZW4gZWxlbWVudHMgd2l0aCBrZXlzIHdpbGwgYmUgc2tpcHBlZCBhbmQgbm90IGRpc2NhcmRlZC5cbiAgICAgICAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlLCBwYXJlbnROb2RlLCBza2lwS2V5ZWROb2Rlcykge1xuICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZURpc2NhcmRlZChub2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKG5vZGUpO1xuICAgICAgICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMobm9kZSwgc2tpcEtleWVkTm9kZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLy8gVHJlZVdhbGtlciBpbXBsZW1lbnRhdGlvbiBpcyBubyBmYXN0ZXIsIGJ1dCBrZWVwaW5nIHRoaXMgYXJvdW5kIGluIGNhc2UgdGhpcyBjaGFuZ2VzIGluIHRoZSBmdXR1cmVcbiAgICAgICAgLy8gZnVuY3Rpb24gaW5kZXhUcmVlKHJvb3QpIHtcbiAgICAgICAgLy8gICAgIHZhciB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcbiAgICAgICAgLy8gICAgICAgICByb290LFxuICAgICAgICAvLyAgICAgICAgIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIHZhciBlbDtcbiAgICAgICAgLy8gICAgIHdoaWxlKChlbCA9IHRyZWVXYWxrZXIubmV4dE5vZGUoKSkpIHtcbiAgICAgICAgLy8gICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShlbCk7XG4gICAgICAgIC8vICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAvLyAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGVsO1xuICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIC8vIE5vZGVJdGVyYXRvciBpbXBsZW1lbnRhdGlvbiBpcyBubyBmYXN0ZXIsIGJ1dCBrZWVwaW5nIHRoaXMgYXJvdW5kIGluIGNhc2UgdGhpcyBjaGFuZ2VzIGluIHRoZSBmdXR1cmVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gZnVuY3Rpb24gaW5kZXhUcmVlKG5vZGUpIHtcbiAgICAgICAgLy8gICAgIHZhciBub2RlSXRlcmF0b3IgPSBkb2N1bWVudC5jcmVhdGVOb2RlSXRlcmF0b3Iobm9kZSwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQpO1xuICAgICAgICAvLyAgICAgdmFyIGVsO1xuICAgICAgICAvLyAgICAgd2hpbGUoKGVsID0gbm9kZUl0ZXJhdG9yLm5leHROb2RlKCkpKSB7XG4gICAgICAgIC8vICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoZWwpO1xuICAgICAgICAvLyAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBlbDtcbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICBmdW5jdGlvbiBpbmRleFRyZWUobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFJDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBjdXJDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdhbGsgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhUcmVlKGN1ckNoaWxkKTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4VHJlZShmcm9tTm9kZSk7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTm9kZUFkZGVkKGVsKSB7XG4gICAgICAgICAgICBvbk5vZGVBZGRlZChlbCk7XG5cbiAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IGVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjdXJDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1bm1hdGNoZWRGcm9tRWwgPSBmcm9tTm9kZXNMb29rdXBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZmluZCBhIGR1cGxpY2F0ZSAjaWQgbm9kZSBpbiBjYWNoZSwgcmVwbGFjZSBgZWxgIHdpdGggY2FjaGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG1vcnBoIGl0IHRvIHRoZSBjaGlsZCBub2RlLlxuICAgICAgICAgICAgICAgICAgICBpZiAodW5tYXRjaGVkRnJvbUVsICYmIGNvbXBhcmVOb2RlTmFtZXMoY3VyQ2hpbGQsIHVubWF0Y2hlZEZyb21FbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhFbCh1bm1hdGNoZWRGcm9tRWwsIGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNhbGwgZm9yIGN1ckNoaWxkIGFuZCBpdCdzIGNoaWxkcmVuIHRvIHNlZSBpZiB3ZSBmaW5kIHNvbWV0aGluZyBpblxuICAgICAgICAgICAgICAgICAgLy8gZnJvbU5vZGVzTG9va3VwXG4gICAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gbmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjbGVhbnVwRnJvbUVsKGZyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCwgY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBvZiB0aGUgXCJ0byBub2Rlc1wiLiBJZiBjdXJGcm9tTm9kZUNoaWxkIGlzXG4gICAgICAgICAgICAvLyBub24tbnVsbCB0aGVuIHdlIHN0aWxsIGhhdmUgc29tZSBmcm9tIG5vZGVzIGxlZnQgb3ZlciB0aGF0IG5lZWRcbiAgICAgICAgICAgIC8vIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgaWYgKChjdXJGcm9tTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyRnJvbU5vZGVDaGlsZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbW9ycGhFbChmcm9tRWwsIHRvRWwsIGNoaWxkcmVuT25seSkge1xuICAgICAgICAgICAgdmFyIHRvRWxLZXkgPSBnZXROb2RlS2V5KHRvRWwpO1xuXG4gICAgICAgICAgICBpZiAodG9FbEtleSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGFuIGVsZW1lbnQgd2l0aCBhbiBJRCBpcyBiZWluZyBtb3JwaGVkIHRoZW4gaXQgd2lsbCBiZSBpbiB0aGUgZmluYWxcbiAgICAgICAgICAgICAgICAvLyBET00gc28gY2xlYXIgaXQgb3V0IG9mIHRoZSBzYXZlZCBlbGVtZW50cyBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgZGVsZXRlIGZyb21Ob2Rlc0xvb2t1cFt0b0VsS2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk9ubHkpIHtcbiAgICAgICAgICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICAgICAgICAgIGlmIChvbkJlZm9yZUVsVXBkYXRlZChmcm9tRWwsIHRvRWwpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGF0dHJpYnV0ZXMgb24gb3JpZ2luYWwgRE9NIGVsZW1lbnQgZmlyc3RcbiAgICAgICAgICAgICAgICBtb3JwaEF0dHJzKGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW9uYWxcbiAgICAgICAgICAgICAgICBvbkVsVXBkYXRlZChmcm9tRWwpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQoZnJvbUVsLCB0b0VsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZyb21FbC5ub2RlTmFtZSAhPT0gJ1RFWFRBUkVBJykge1xuICAgICAgICAgICAgICBtb3JwaENoaWxkcmVuKGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzcGVjaWFsRWxIYW5kbGVycy5URVhUQVJFQShmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbW9ycGhDaGlsZHJlbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgICAgIHZhciBjdXJUb05vZGVDaGlsZCA9IHRvRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB2YXIgY3VyVG9Ob2RlS2V5O1xuICAgICAgICAgICAgdmFyIGN1ckZyb21Ob2RlS2V5O1xuXG4gICAgICAgICAgICB2YXIgZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgdmFyIHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdGcm9tRWw7XG5cbiAgICAgICAgICAgIC8vIHdhbGsgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICBvdXRlcjogd2hpbGUgKGN1clRvTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdG9OZXh0U2libGluZyA9IGN1clRvTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGN1clRvTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyVG9Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgLy8gd2FsayB0aGUgZnJvbU5vZGUgY2hpbGRyZW4gYWxsIHRoZSB3YXkgdGhyb3VnaFxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUNoaWxkLmlzU2FtZU5vZGUgJiYgY3VyVG9Ob2RlQ2hpbGQuaXNTYW1lTm9kZShjdXJGcm9tTm9kZUNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJGcm9tTm9kZVR5cGUgPSBjdXJGcm9tTm9kZUNoaWxkLm5vZGVUeXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgaWYgdGhlIGN1ckZyb21Ob2RlQ2hpbGQgZG9lc250IGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJUb05vZGVDaGlsZFxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNDb21wYXRpYmxlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IGN1clRvTm9kZUNoaWxkLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCb3RoIG5vZGVzIGJlaW5nIGNvbXBhcmVkIGFyZSBFbGVtZW50IG5vZGVzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgbm9kZSBoYXMgYSBrZXkgc28gd2Ugd2FudCB0byBtYXRjaCBpdCB1cCB3aXRoIHRoZSBjb3JyZWN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkgIT09IGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCBET00gdHJlZSBkb2VzIG5vdCBoYXZlIGEgbWF0Y2hpbmcga2V5IHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBjaGVjayBvdXIgbG9va3VwIHRvIHNlZSBpZiB0aGVyZSBpcyBhIG1hdGNoaW5nIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBET00gdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tTmV4dFNpYmxpbmcgPT09IG1hdGNoaW5nRnJvbUVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3Igc2luZ2xlIGVsZW1lbnQgcmVtb3ZhbHMuIFRvIGF2b2lkIHJlbW92aW5nIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBET00gbm9kZSBvdXQgb2YgdGhlIHRyZWUgKHNpbmNlIHRoYXQgY2FuIGJyZWFrIENTUyB0cmFuc2l0aW9ucywgZXRjLiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHdpbGwgaW5zdGVhZCBkaXNjYXJkIHRoZSBjdXJyZW50IG5vZGUgYW5kIHdhaXQgdW50aWwgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0aW9uIHRvIHByb3Blcmx5IG1hdGNoIHVwIHRoZSBrZXllZCB0YXJnZXQgZWxlbWVudCB3aXRoIGl0cyBtYXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgbWF0Y2hpbmcga2V5ZWQgZWxlbWVudCBzb21ld2hlcmUgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZXQncyBtb3ZlIHRoZSBvcmlnaW5hbCBET00gbm9kZSBpbnRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBtb3JwaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdC5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBXZSB1c2UgaW5zZXJ0QmVmb3JlIGluc3RlYWQgb2YgcmVwbGFjZUNoaWxkIGJlY2F1c2Ugd2Ugd2FudCB0byBnbyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBgcmVtb3ZlTm9kZSgpYCBmdW5jdGlvbiBmb3IgdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBkaXNjYXJkZWQgc28gdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgbGlmZWN5Y2xlIGhvb2tzIGFyZSBjb3JyZWN0bHkgaW52b2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tRWwuaW5zZXJ0QmVmb3JlKG1hdGNoaW5nRnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gbWF0Y2hpbmdGcm9tRWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbm9kZXMgYXJlIG5vdCBjb21wYXRpYmxlIHNpbmNlIHRoZSBcInRvXCIgbm9kZSBoYXMgYSBrZXkgYW5kIHRoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm8gbWF0Y2hpbmcga2V5ZWQgbm9kZSBpbiB0aGUgc291cmNlIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9yaWdpbmFsIGhhcyBhIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBpc0NvbXBhdGlibGUgIT09IGZhbHNlICYmIGNvbXBhcmVOb2RlTmFtZXMoY3VyRnJvbU5vZGVDaGlsZCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgY29tcGF0aWJsZSBET00gZWxlbWVudHMgc28gdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IFwiZnJvbVwiIG5vZGUgdG8gbWF0Y2ggdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFyZ2V0IERPTSBub2RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNT1JQSFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3JwaEVsKGN1ckZyb21Ob2RlQ2hpbGQsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBURVhUX05PREUgfHwgY3VyRnJvbU5vZGVUeXBlID09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvdGggbm9kZXMgYmVpbmcgY29tcGFyZWQgYXJlIFRleHQgb3IgQ29tbWVudCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2ltcGx5IHVwZGF0ZSBub2RlVmFsdWUgb24gdGhlIG9yaWdpbmFsIG5vZGUgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIHRleHQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVDaGlsZC5ub2RlVmFsdWUgIT09IGN1clRvTm9kZUNoaWxkLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkLm5vZGVWYWx1ZSA9IGN1clRvTm9kZUNoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgYm90aCB0aGUgXCJ0b1wiIGNoaWxkIGFuZCB0aGUgXCJmcm9tXCIgY2hpbGQgc2luY2Ugd2UgZm91bmQgYSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBlbHNlIHRvIGRvIGFzIHdlIGFscmVhZHkgcmVjdXJzaXZlbHkgY2FsbGVkIG1vcnBoQ2hpbGRyZW4gYWJvdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGNvbXBhdGlibGUgbWF0Y2ggc28gcmVtb3ZlIHRoZSBvbGQgbm9kZSBmcm9tIHRoZSBET00gYW5kIGNvbnRpbnVlIHRyeWluZyB0byBmaW5kIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2ggaW4gdGhlIG9yaWdpbmFsIERPTS4gSG93ZXZlciwgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSBmcm9tIG5vZGUgaXMgbm90IGtleWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0IGlzIHBvc3NpYmxlIHRoYXQgYSBrZXllZCBub2RlIG1pZ2h0IG1hdGNoIHVwIHdpdGggYSBub2RlIHNvbWV3aGVyZSBlbHNlIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB0YXJnZXQgdHJlZSBhbmQgd2UgZG9uJ3Qgd2FudCB0byBkaXNjYXJkIGl0IGp1c3QgeWV0IHNpbmNlIGl0IHN0aWxsIG1pZ2h0IGZpbmQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBob21lIGluIHRoZSBmaW5hbCBET00gdHJlZS4gQWZ0ZXIgZXZlcnl0aGluZyBpcyBkb25lIHdlIHdpbGwgcmVtb3ZlIGFueSBrZXllZCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGRpZG4ndCBmaW5kIGEgaG9tZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgcmVtb3ZhbCB0byBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIHNraXAgbmVzdGVkIGtleWVkIG5vZGVzIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc3RpbGwgYSBjaGFuY2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgdXAgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9IC8vIEVORDogd2hpbGUoY3VyRnJvbU5vZGVDaGlsZCkge31cblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGdvdCB0aGlzIGZhciB0aGVuIHdlIGRpZCBub3QgZmluZCBhIGNhbmRpZGF0ZSBtYXRjaCBmb3JcbiAgICAgICAgICAgICAgICAvLyBvdXIgXCJ0byBub2RlXCIgYW5kIHdlIGV4aGF1c3RlZCBhbGwgb2YgdGhlIGNoaWxkcmVuIFwiZnJvbVwiXG4gICAgICAgICAgICAgICAgLy8gbm9kZXMuIFRoZXJlZm9yZSwgd2Ugd2lsbCBqdXN0IGFwcGVuZCB0aGUgY3VycmVudCBcInRvXCIgbm9kZVxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBlbmRcbiAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5ICYmIChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSAmJiBjb21wYXJlTm9kZU5hbWVzKG1hdGNoaW5nRnJvbUVsLCBjdXJUb05vZGVDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUVsLmFwcGVuZENoaWxkKG1hdGNoaW5nRnJvbUVsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTU9SUEhcbiAgICAgICAgICAgICAgICAgICAgbW9ycGhFbChtYXRjaGluZ0Zyb21FbCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCA9IG9uQmVmb3JlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUNoaWxkLmFjdHVhbGl6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gY3VyVG9Ob2RlQ2hpbGQuYWN0dWFsaXplKGZyb21FbC5vd25lckRvY3VtZW50IHx8IGRvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tRWwuYXBwZW5kQ2hpbGQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbGVhbnVwRnJvbUVsKGZyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCwgY3VyRnJvbU5vZGVLZXkpO1xuXG4gICAgICAgICAgICB2YXIgc3BlY2lhbEVsSGFuZGxlciA9IHNwZWNpYWxFbEhhbmRsZXJzW2Zyb21FbC5ub2RlTmFtZV07XG4gICAgICAgICAgICBpZiAoc3BlY2lhbEVsSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHNwZWNpYWxFbEhhbmRsZXIoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBFTkQ6IG1vcnBoQ2hpbGRyZW4oLi4uKVxuXG4gICAgICAgIHZhciBtb3JwaGVkTm9kZSA9IGZyb21Ob2RlO1xuICAgICAgICB2YXIgbW9ycGhlZE5vZGVUeXBlID0gbW9ycGhlZE5vZGUubm9kZVR5cGU7XG4gICAgICAgIHZhciB0b05vZGVUeXBlID0gdG9Ob2RlLm5vZGVUeXBlO1xuXG4gICAgICAgIGlmICghY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgYXJlIGdpdmVuIHR3byBET00gbm9kZXMgdGhhdCBhcmUgbm90XG4gICAgICAgICAgICAvLyBjb21wYXRpYmxlIChlLmcuIDxkaXY+IC0tPiA8c3Bhbj4gb3IgPGRpdj4gLS0+IFRFWFQpXG4gICAgICAgICAgICBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9Ob2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGFyZU5vZGVOYW1lcyhmcm9tTm9kZSwgdG9Ob2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gbW92ZUNoaWxkcmVuKGZyb21Ob2RlLCBjcmVhdGVFbGVtZW50TlModG9Ob2RlLm5vZGVOYW1lLCB0b05vZGUubmFtZXNwYWNlVVJJKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBHb2luZyBmcm9tIGFuIGVsZW1lbnQgbm9kZSB0byBhIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZSA9IHRvTm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vcnBoZWROb2RlVHlwZSA9PT0gVEVYVF9OT0RFIHx8IG1vcnBoZWROb2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7IC8vIFRleHQgb3IgY29tbWVudCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT09IG1vcnBoZWROb2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9ycGhlZE5vZGUubm9kZVZhbHVlICE9PSB0b05vZGUubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZS5ub2RlVmFsdWUgPSB0b05vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRleHQgbm9kZSB0byBzb21ldGhpbmcgZWxzZVxuICAgICAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZSA9IHRvTm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9ycGhlZE5vZGUgPT09IHRvTm9kZSkge1xuICAgICAgICAgICAgLy8gVGhlIFwidG8gbm9kZVwiIHdhcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBcImZyb20gbm9kZVwiIHNvIHdlIGhhZCB0b1xuICAgICAgICAgICAgLy8gdG9zcyBvdXQgdGhlIFwiZnJvbSBub2RlXCIgYW5kIHVzZSB0aGUgXCJ0byBub2RlXCJcbiAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChmcm9tTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodG9Ob2RlLmlzU2FtZU5vZGUgJiYgdG9Ob2RlLmlzU2FtZU5vZGUobW9ycGhlZE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb3JwaEVsKG1vcnBoZWROb2RlLCB0b05vZGUsIGNoaWxkcmVuT25seSk7XG5cbiAgICAgICAgICAgIC8vIFdlIG5vdyBuZWVkIHRvIGxvb3Agb3ZlciBhbnkga2V5ZWQgbm9kZXMgdGhhdCBtaWdodCBuZWVkIHRvIGJlXG4gICAgICAgICAgICAvLyByZW1vdmVkLiBXZSBvbmx5IGRvIHRoZSByZW1vdmFsIGlmIHdlIGtub3cgdGhhdCB0aGUga2V5ZWQgbm9kZVxuICAgICAgICAgICAgLy8gbmV2ZXIgZm91bmQgYSBtYXRjaC4gV2hlbiBhIGtleWVkIG5vZGUgaXMgbWF0Y2hlZCB1cCB3ZSByZW1vdmVcbiAgICAgICAgICAgIC8vIGl0IG91dCBvZiBmcm9tTm9kZXNMb29rdXAgYW5kIHdlIHVzZSBmcm9tTm9kZXNMb29rdXAgdG8gZGV0ZXJtaW5lXG4gICAgICAgICAgICAvLyBpZiBhIGtleWVkIG5vZGUgaGFzIGJlZW4gbWF0Y2hlZCB1cCBvciBub3RcbiAgICAgICAgICAgIGlmIChrZXllZFJlbW92YWxMaXN0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBsZW49a2V5ZWRSZW1vdmFsTGlzdC5sZW5ndGg7IGk8bGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsVG9SZW1vdmUgPSBmcm9tTm9kZXNMb29rdXBba2V5ZWRSZW1vdmFsTGlzdFtpXV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbFRvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGVsVG9SZW1vdmUsIGVsVG9SZW1vdmUucGFyZW50Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjaGlsZHJlbk9ubHkgJiYgbW9ycGhlZE5vZGUgIT09IGZyb21Ob2RlICYmIGZyb21Ob2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChtb3JwaGVkTm9kZS5hY3R1YWxpemUpIHtcbiAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZSA9IG1vcnBoZWROb2RlLmFjdHVhbGl6ZShmcm9tTm9kZS5vd25lckRvY3VtZW50IHx8IGRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYWQgdG8gc3dhcCBvdXQgdGhlIGZyb20gbm9kZSB3aXRoIGEgbmV3IG5vZGUgYmVjYXVzZSB0aGUgb2xkXG4gICAgICAgICAgICAvLyBub2RlIHdhcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSB0YXJnZXQgbm9kZSB0aGVuIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIG9sZCBET00gbm9kZSBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuIFRoaXMgaXMgb25seVxuICAgICAgICAgICAgLy8gcG9zc2libGUgaWYgdGhlIG9yaWdpbmFsIERPTSBub2RlIHdhcyBwYXJ0IG9mIGEgRE9NIHRyZWUgd2hpY2hcbiAgICAgICAgICAgIC8vIHdlIGtub3cgaXMgdGhlIGNhc2UgaWYgaXQgaGFzIGEgcGFyZW50IG5vZGUuXG4gICAgICAgICAgICBmcm9tTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChtb3JwaGVkTm9kZSwgZnJvbU5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICAgIH07XG59XG5cbnZhciBtb3JwaGRvbSA9IG1vcnBoZG9tRmFjdG9yeShtb3JwaEF0dHJzKTtcblxuZXhwb3J0IGRlZmF1bHQgbW9ycGhkb207XG4iLCAiaW1wb3J0IHtcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX0RJU0FCTEVfV0lUSCxcbiAgUEhYX0ZFRURCQUNLX0ZPUixcbiAgUEhYX1BSVU5FLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1NFU1NJT04sXG4gIFBIWF9TS0lQLFxuICBQSFhfU1RBVElDLFxuICBQSFhfVFJJR0dFUl9BQ1RJT04sXG4gIFBIWF9VUERBVEVcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgZGV0ZWN0RHVwbGljYXRlSWRzLFxuICBpc0NpZFxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcbmltcG9ydCBET01Qb3N0TW9ycGhSZXN0b3JlciBmcm9tIFwiLi9kb21fcG9zdF9tb3JwaF9yZXN0b3JlclwiXG5pbXBvcnQgbW9ycGhkb20gZnJvbSBcIm1vcnBoZG9tXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRE9NUGF0Y2gge1xuICBzdGF0aWMgcGF0Y2hFbChmcm9tRWwsIHRvRWwsIGFjdGl2ZUVsZW1lbnQpe1xuICAgIG1vcnBoZG9tKGZyb21FbCwgdG9FbCwge1xuICAgICAgY2hpbGRyZW5Pbmx5OiBmYWxzZSxcbiAgICAgIG9uQmVmb3JlRWxVcGRhdGVkOiAoZnJvbUVsLCB0b0VsKSA9PiB7XG4gICAgICAgIGlmKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC5pc1NhbWVOb2RlKGZyb21FbCkgJiYgRE9NLmlzRm9ybUlucHV0KGZyb21FbCkpe1xuICAgICAgICAgIERPTS5tZXJnZUZvY3VzZWRJbnB1dChmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgY29uc3RydWN0b3IodmlldywgY29udGFpbmVyLCBpZCwgaHRtbCwgdGFyZ2V0Q0lEKXtcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5saXZlU29ja2V0ID0gdmlldy5saXZlU29ja2V0XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXJcbiAgICB0aGlzLmlkID0gaWRcbiAgICB0aGlzLnJvb3RJRCA9IHZpZXcucm9vdC5pZFxuICAgIHRoaXMuaHRtbCA9IGh0bWxcbiAgICB0aGlzLnRhcmdldENJRCA9IHRhcmdldENJRFxuICAgIHRoaXMuY2lkUGF0Y2ggPSBpc0NpZCh0aGlzLnRhcmdldENJRClcbiAgICB0aGlzLmNhbGxiYWNrcyA9IHtcbiAgICAgIGJlZm9yZWFkZGVkOiBbXSwgYmVmb3JldXBkYXRlZDogW10sIGJlZm9yZXBoeENoaWxkQWRkZWQ6IFtdLFxuICAgICAgYWZ0ZXJhZGRlZDogW10sIGFmdGVydXBkYXRlZDogW10sIGFmdGVyZGlzY2FyZGVkOiBbXSwgYWZ0ZXJwaHhDaGlsZEFkZGVkOiBbXSxcbiAgICAgIGFmdGVydHJhbnNpdGlvbnNEaXNjYXJkZWQ6IFtdXG4gICAgfVxuICB9XG5cbiAgYmVmb3JlKGtpbmQsIGNhbGxiYWNrKXsgdGhpcy5jYWxsYmFja3NbYGJlZm9yZSR7a2luZH1gXS5wdXNoKGNhbGxiYWNrKSB9XG4gIGFmdGVyKGtpbmQsIGNhbGxiYWNrKXsgdGhpcy5jYWxsYmFja3NbYGFmdGVyJHtraW5kfWBdLnB1c2goY2FsbGJhY2spIH1cblxuICB0cmFja0JlZm9yZShraW5kLCAuLi5hcmdzKXtcbiAgICB0aGlzLmNhbGxiYWNrc1tgYmVmb3JlJHtraW5kfWBdLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soLi4uYXJncykpXG4gIH1cblxuICB0cmFja0FmdGVyKGtpbmQsIC4uLmFyZ3Mpe1xuICAgIHRoaXMuY2FsbGJhY2tzW2BhZnRlciR7a2luZH1gXS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKC4uLmFyZ3MpKVxuICB9XG5cbiAgbWFya1BydW5hYmxlQ29udGVudEZvclJlbW92YWwoKXtcbiAgICBET00uYWxsKHRoaXMuY29udGFpbmVyLCBcIltwaHgtdXBkYXRlPWFwcGVuZF0gPiAqLCBbcGh4LXVwZGF0ZT1wcmVwZW5kXSA+ICpcIiwgZWwgPT4ge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9QUlVORSwgXCJcIilcbiAgICB9KVxuICB9XG5cbiAgcGVyZm9ybSgpe1xuICAgIGxldCB7dmlldywgbGl2ZVNvY2tldCwgY29udGFpbmVyLCBodG1sfSA9IHRoaXNcbiAgICBsZXQgdGFyZ2V0Q29udGFpbmVyID0gdGhpcy5pc0NJRFBhdGNoKCkgPyB0aGlzLnRhcmdldENJRENvbnRhaW5lcihodG1sKSA6IGNvbnRhaW5lclxuICAgIGlmKHRoaXMuaXNDSURQYXRjaCgpICYmICF0YXJnZXRDb250YWluZXIpeyByZXR1cm4gfVxuXG4gICAgbGV0IGZvY3VzZWQgPSBsaXZlU29ja2V0LmdldEFjdGl2ZUVsZW1lbnQoKVxuICAgIGxldCB7c2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZH0gPSBmb2N1c2VkICYmIERPTS5oYXNTZWxlY3Rpb25SYW5nZShmb2N1c2VkKSA/IGZvY3VzZWQgOiB7fVxuICAgIGxldCBwaHhVcGRhdGUgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX1VQREFURSlcbiAgICBsZXQgcGh4RmVlZGJhY2tGb3IgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX0ZFRURCQUNLX0ZPUilcbiAgICBsZXQgZGlzYWJsZVdpdGggPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX0RJU0FCTEVfV0lUSClcbiAgICBsZXQgcGh4VHJpZ2dlckV4dGVybmFsID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9UUklHR0VSX0FDVElPTilcbiAgICBsZXQgcGh4UmVtb3ZlID0gbGl2ZVNvY2tldC5iaW5kaW5nKFwicmVtb3ZlXCIpXG4gICAgbGV0IGFkZGVkID0gW11cbiAgICBsZXQgdXBkYXRlcyA9IFtdXG4gICAgbGV0IGFwcGVuZFByZXBlbmRVcGRhdGVzID0gW11cbiAgICBsZXQgcGVuZGluZ1JlbW92ZXMgPSBbXVxuICAgIGxldCBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBudWxsXG5cbiAgICBsZXQgZGlmZkhUTUwgPSBsaXZlU29ja2V0LnRpbWUoXCJwcmVtb3JwaCBjb250YWluZXIgcHJlcFwiLCAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5idWlsZERpZmZIVE1MKGNvbnRhaW5lciwgaHRtbCwgcGh4VXBkYXRlLCB0YXJnZXRDb250YWluZXIpXG4gICAgfSlcblxuICAgIHRoaXMudHJhY2tCZWZvcmUoXCJhZGRlZFwiLCBjb250YWluZXIpXG4gICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgY29udGFpbmVyLCBjb250YWluZXIpXG5cbiAgICBsaXZlU29ja2V0LnRpbWUoXCJtb3JwaGRvbVwiLCAoKSA9PiB7XG4gICAgICBtb3JwaGRvbSh0YXJnZXRDb250YWluZXIsIGRpZmZIVE1MLCB7XG4gICAgICAgIGNoaWxkcmVuT25seTogdGFyZ2V0Q29udGFpbmVyLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSA9PT0gbnVsbCxcbiAgICAgICAgZ2V0Tm9kZUtleTogKG5vZGUpID0+IHtcbiAgICAgICAgICByZXR1cm4gRE9NLmlzUGh4RGVzdHJveWVkKG5vZGUpID8gbnVsbCA6IG5vZGUuaWRcbiAgICAgICAgfSxcbiAgICAgICAgb25CZWZvcmVOb2RlQWRkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJhZGRlZFwiLCBlbClcbiAgICAgICAgICByZXR1cm4gZWxcbiAgICAgICAgfSxcbiAgICAgICAgb25Ob2RlQWRkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIC8vIGhhY2sgdG8gZml4IFNhZmFyaSBoYW5kbGluZyBvZiBpbWcgc3Jjc2V0IGFuZCB2aWRlbyB0YWdzXG4gICAgICAgICAgaWYoZWwgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ICYmIGVsLnNyY3NldCl7XG4gICAgICAgICAgICBlbC5zcmNzZXQgPSBlbC5zcmNzZXRcbiAgICAgICAgICB9IGVsc2UgaWYoZWwgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ICYmIGVsLmF1dG9wbGF5KXtcbiAgICAgICAgICAgIGVsLnBsYXkoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihET00uaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKGVsLCBwaHhUcmlnZ2VyRXh0ZXJuYWwpKXtcbiAgICAgICAgICAgIGV4dGVybmFsRm9ybVRyaWdnZXJlZCA9IGVsXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vaW5wdXQgaGFuZGxpbmdcbiAgICAgICAgICBET00uZGlzY2FyZEVycm9yKHRhcmdldENvbnRhaW5lciwgZWwsIHBoeEZlZWRiYWNrRm9yKVxuICAgICAgICAgIC8vIG5lc3RlZCB2aWV3IGhhbmRsaW5nXG4gICAgICAgICAgaWYoKERPTS5pc1BoeENoaWxkKGVsKSAmJiB2aWV3Lm93bnNFbGVtZW50KGVsKSkgfHwgRE9NLmlzUGh4U3RpY2t5KGVsKSAmJiB2aWV3Lm93bnNFbGVtZW50KGVsLnBhcmVudE5vZGUpKXtcbiAgICAgICAgICAgIHRoaXMudHJhY2tBZnRlcihcInBoeENoaWxkQWRkZWRcIiwgZWwpXG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZGVkLnB1c2goZWwpXG4gICAgICAgIH0sXG4gICAgICAgIG9uTm9kZURpc2NhcmRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgLy8gbmVzdGVkIHZpZXcgaGFuZGxpbmdcbiAgICAgICAgICBpZihET00uaXNQaHhDaGlsZChlbCkgfHwgRE9NLmlzUGh4U3RpY2t5KGVsKSl7IGxpdmVTb2NrZXQuZGVzdHJveVZpZXdCeUVsKGVsKSB9XG4gICAgICAgICAgdGhpcy50cmFja0FmdGVyKFwiZGlzY2FyZGVkXCIsIGVsKVxuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZU5vZGVEaXNjYXJkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIGlmKGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1BSVU5FKSAhPT0gbnVsbCl7IHJldHVybiB0cnVlIH1cbiAgICAgICAgICBpZihlbC5wYXJlbnROb2RlICE9PSBudWxsICYmIERPTS5pc1BoeFVwZGF0ZShlbC5wYXJlbnROb2RlLCBwaHhVcGRhdGUsIFtcImFwcGVuZFwiLCBcInByZXBlbmRcIl0pICYmIGVsLmlkKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICBpZihlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKHBoeFJlbW92ZSkpe1xuICAgICAgICAgICAgcGVuZGluZ1JlbW92ZXMucHVzaChlbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZih0aGlzLnNraXBDSURTaWJsaW5nKGVsKSl7IHJldHVybiBmYWxzZSB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgb25FbFVwZGF0ZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIGlmKERPTS5pc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWwoZWwsIHBoeFRyaWdnZXJFeHRlcm5hbCkpe1xuICAgICAgICAgICAgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkID0gZWxcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlcy5wdXNoKGVsKVxuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZUVsVXBkYXRlZDogKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgICAgIERPTS5jbGVhbkNoaWxkTm9kZXModG9FbCwgcGh4VXBkYXRlKVxuICAgICAgICAgIGlmKHRoaXMuc2tpcENJRFNpYmxpbmcodG9FbCkpeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIGlmKERPTS5pc1BoeFN0aWNreShmcm9tRWwpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICBpZihET00uaXNJZ25vcmVkKGZyb21FbCwgcGh4VXBkYXRlKSl7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICBET00ubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHtpc0lnbm9yZWQ6IHRydWV9KVxuICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbClcbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGZyb21FbC50eXBlID09PSBcIm51bWJlclwiICYmIChmcm9tRWwudmFsaWRpdHkgJiYgZnJvbUVsLnZhbGlkaXR5LmJhZElucHV0KSl7IHJldHVybiBmYWxzZSB9XG4gICAgICAgICAgaWYoIURPTS5zeW5jUGVuZGluZ1JlZihmcm9tRWwsIHRvRWwsIGRpc2FibGVXaXRoKSl7XG4gICAgICAgICAgICBpZihET00uaXNVcGxvYWRJbnB1dChmcm9tRWwpKXtcbiAgICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgICB1cGRhdGVzLnB1c2goZnJvbUVsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBuZXN0ZWQgdmlldyBoYW5kbGluZ1xuICAgICAgICAgIGlmKERPTS5pc1BoeENoaWxkKHRvRWwpKXtcbiAgICAgICAgICAgIGxldCBwcmV2U2Vzc2lvbiA9IGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pXG4gICAgICAgICAgICBET00ubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHtleGNsdWRlOiBbUEhYX1NUQVRJQ119KVxuICAgICAgICAgICAgaWYocHJldlNlc3Npb24gIT09IFwiXCIpeyBmcm9tRWwuc2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OLCBwcmV2U2Vzc2lvbikgfVxuICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCwgdGhpcy5yb290SUQpXG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlucHV0IGhhbmRsaW5nXG4gICAgICAgICAgRE9NLmNvcHlQcml2YXRlcyh0b0VsLCBmcm9tRWwpXG4gICAgICAgICAgRE9NLmRpc2NhcmRFcnJvcih0YXJnZXRDb250YWluZXIsIHRvRWwsIHBoeEZlZWRiYWNrRm9yKVxuXG4gICAgICAgICAgbGV0IGlzRm9jdXNlZEZvcm1FbCA9IGZvY3VzZWQgJiYgZnJvbUVsLmlzU2FtZU5vZGUoZm9jdXNlZCkgJiYgRE9NLmlzRm9ybUlucHV0KGZyb21FbClcbiAgICAgICAgICBpZihpc0ZvY3VzZWRGb3JtRWwpe1xuICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgRE9NLm1lcmdlRm9jdXNlZElucHV0KGZyb21FbCwgdG9FbClcbiAgICAgICAgICAgIERPTS5zeW5jQXR0cnNUb1Byb3BzKGZyb21FbClcbiAgICAgICAgICAgIHVwZGF0ZXMucHVzaChmcm9tRWwpXG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZihET00uaXNQaHhVcGRhdGUodG9FbCwgcGh4VXBkYXRlLCBbXCJhcHBlbmRcIiwgXCJwcmVwZW5kXCJdKSl7XG4gICAgICAgICAgICAgIGFwcGVuZFByZXBlbmRVcGRhdGVzLnB1c2gobmV3IERPTVBvc3RNb3JwaFJlc3RvcmVyKGZyb21FbCwgdG9FbCwgdG9FbC5nZXRBdHRyaWJ1dGUocGh4VXBkYXRlKSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBET00uc3luY0F0dHJzVG9Qcm9wcyh0b0VsKVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyh0b0VsKVxuICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGlmKGxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSl7IGRldGVjdER1cGxpY2F0ZUlkcygpIH1cblxuICAgIGlmKGFwcGVuZFByZXBlbmRVcGRhdGVzLmxlbmd0aCA+IDApe1xuICAgICAgbGl2ZVNvY2tldC50aW1lKFwicG9zdC1tb3JwaCBhcHBlbmQvcHJlcGVuZCByZXN0b3JhdGlvblwiLCAoKSA9PiB7XG4gICAgICAgIGFwcGVuZFByZXBlbmRVcGRhdGVzLmZvckVhY2godXBkYXRlID0+IHVwZGF0ZS5wZXJmb3JtKCkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGxpdmVTb2NrZXQuc2lsZW5jZUV2ZW50cygoKSA9PiBET00ucmVzdG9yZUZvY3VzKGZvY3VzZWQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpKVxuICAgIERPTS5kaXNwYXRjaEV2ZW50KGRvY3VtZW50LCBcInBoeDp1cGRhdGVcIilcbiAgICBhZGRlZC5mb3JFYWNoKGVsID0+IHRoaXMudHJhY2tBZnRlcihcImFkZGVkXCIsIGVsKSlcbiAgICB1cGRhdGVzLmZvckVhY2goZWwgPT4gdGhpcy50cmFja0FmdGVyKFwidXBkYXRlZFwiLCBlbCkpXG5cbiAgICBpZihwZW5kaW5nUmVtb3Zlcy5sZW5ndGggPiAwKXtcbiAgICAgIGxpdmVTb2NrZXQudHJhbnNpdGlvblJlbW92ZXMocGVuZGluZ1JlbW92ZXMpXG4gICAgICBsaXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBwZW5kaW5nUmVtb3Zlcy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBsZXQgY2hpbGQgPSBET00uZmlyc3RQaHhDaGlsZChlbClcbiAgICAgICAgICBpZihjaGlsZCl7IGxpdmVTb2NrZXQuZGVzdHJveVZpZXdCeUVsKGNoaWxkKSB9XG4gICAgICAgICAgZWwucmVtb3ZlKClcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy50cmFja0FmdGVyKFwidHJhbnNpdGlvbnNEaXNjYXJkZWRcIiwgcGVuZGluZ1JlbW92ZXMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmKGV4dGVybmFsRm9ybVRyaWdnZXJlZCl7XG4gICAgICBsaXZlU29ja2V0LmRpc2Nvbm5lY3QoKVxuICAgICAgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkLnN1Ym1pdCgpXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpc0NJRFBhdGNoKCl7IHJldHVybiB0aGlzLmNpZFBhdGNoIH1cblxuICBza2lwQ0lEU2libGluZyhlbCl7XG4gICAgcmV0dXJuIGVsLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1NLSVApICE9PSBudWxsXG4gIH1cblxuICB0YXJnZXRDSURDb250YWluZXIoaHRtbCl7XG4gICAgaWYoIXRoaXMuaXNDSURQYXRjaCgpKXsgcmV0dXJuIH1cbiAgICBsZXQgW2ZpcnN0LCAuLi5yZXN0XSA9IERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5jb250YWluZXIsIHRoaXMudGFyZ2V0Q0lEKVxuICAgIGlmKHJlc3QubGVuZ3RoID09PSAwICYmIERPTS5jaGlsZE5vZGVMZW5ndGgoaHRtbCkgPT09IDEpe1xuICAgICAgcmV0dXJuIGZpcnN0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC5wYXJlbnROb2RlXG4gICAgfVxuICB9XG5cbiAgLy8gYnVpbGRzIEhUTUwgZm9yIG1vcnBoZG9tIHBhdGNoXG4gIC8vIC0gZm9yIGZ1bGwgcGF0Y2hlcyBvZiBMaXZlVmlldyBvciBhIGNvbXBvbmVudCB3aXRoIGEgc2luZ2xlXG4gIC8vICAgcm9vdCBub2RlLCBzaW1wbHkgcmV0dXJucyB0aGUgSFRNTFxuICAvLyAtIGZvciBwYXRjaGVzIG9mIGEgY29tcG9uZW50IHdpdGggbXVsdGlwbGUgcm9vdCBub2RlcywgdGhlXG4gIC8vICAgcGFyZW50IG5vZGUgYmVjb21lcyB0aGUgdGFyZ2V0IGNvbnRhaW5lciBhbmQgbm9uLWNvbXBvbmVudFxuICAvLyAgIHNpYmxpbmdzIGFyZSBtYXJrZWQgYXMgc2tpcC5cbiAgYnVpbGREaWZmSFRNTChjb250YWluZXIsIGh0bWwsIHBoeFVwZGF0ZSwgdGFyZ2V0Q29udGFpbmVyKXtcbiAgICBsZXQgaXNDSURQYXRjaCA9IHRoaXMuaXNDSURQYXRjaCgpXG4gICAgbGV0IGlzQ0lEV2l0aFNpbmdsZVJvb3QgPSBpc0NJRFBhdGNoICYmIHRhcmdldENvbnRhaW5lci5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkgPT09IHRoaXMudGFyZ2V0Q0lELnRvU3RyaW5nKClcbiAgICBpZighaXNDSURQYXRjaCB8fCBpc0NJRFdpdGhTaW5nbGVSb290KXtcbiAgICAgIHJldHVybiBodG1sXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBvbmVudCBwYXRjaCB3aXRoIG11bHRpcGxlIENJRCByb290c1xuICAgICAgbGV0IGRpZmZDb250YWluZXIgPSBudWxsXG4gICAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIilcbiAgICAgIGRpZmZDb250YWluZXIgPSBET00uY2xvbmVOb2RlKHRhcmdldENvbnRhaW5lcilcbiAgICAgIGxldCBbZmlyc3RDb21wb25lbnQsIC4uLnJlc3RdID0gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdChkaWZmQ29udGFpbmVyLCB0aGlzLnRhcmdldENJRClcbiAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWxcbiAgICAgIHJlc3QuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSlcbiAgICAgIEFycmF5LmZyb20oZGlmZkNvbnRhaW5lci5jaGlsZE5vZGVzKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgLy8gd2UgY2FuIG9ubHkgc2tpcCB0cmFja2FibGUgbm9kZXMgd2l0aCBhbiBJRFxuICAgICAgICBpZihjaGlsZC5pZCAmJiBjaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgY2hpbGQuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpICE9PSB0aGlzLnRhcmdldENJRC50b1N0cmluZygpKXtcbiAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoUEhYX1NLSVAsIFwiXCIpXG4gICAgICAgICAgY2hpbGQuaW5uZXJIVE1MID0gXCJcIlxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgQXJyYXkuZnJvbSh0ZW1wbGF0ZS5jb250ZW50LmNoaWxkTm9kZXMpLmZvckVhY2goZWwgPT4gZGlmZkNvbnRhaW5lci5pbnNlcnRCZWZvcmUoZWwsIGZpcnN0Q29tcG9uZW50KSlcbiAgICAgIGZpcnN0Q29tcG9uZW50LnJlbW92ZSgpXG4gICAgICByZXR1cm4gZGlmZkNvbnRhaW5lci5vdXRlckhUTUxcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBDT01QT05FTlRTLFxuICBEWU5BTUlDUyxcbiAgVEVNUExBVEVTLFxuICBFVkVOVFMsXG4gIFBIWF9DT01QT05FTlQsXG4gIFBIWF9TS0lQLFxuICBSRVBMWSxcbiAgU1RBVElDLFxuICBUSVRMRVxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBpc09iamVjdCxcbiAgbG9nRXJyb3IsXG4gIGlzQ2lkLFxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmVkIHtcbiAgc3RhdGljIGV4dHJhY3QoZGlmZil7XG4gICAgbGV0IHtbUkVQTFldOiByZXBseSwgW0VWRU5UU106IGV2ZW50cywgW1RJVExFXTogdGl0bGV9ID0gZGlmZlxuICAgIGRlbGV0ZSBkaWZmW1JFUExZXVxuICAgIGRlbGV0ZSBkaWZmW0VWRU5UU11cbiAgICBkZWxldGUgZGlmZltUSVRMRV1cbiAgICByZXR1cm4ge2RpZmYsIHRpdGxlLCByZXBseTogcmVwbHkgfHwgbnVsbCwgZXZlbnRzOiBldmVudHMgfHwgW119XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih2aWV3SWQsIHJlbmRlcmVkKXtcbiAgICB0aGlzLnZpZXdJZCA9IHZpZXdJZFxuICAgIHRoaXMucmVuZGVyZWQgPSB7fVxuICAgIHRoaXMubWVyZ2VEaWZmKHJlbmRlcmVkKVxuICB9XG5cbiAgcGFyZW50Vmlld0lkKCl7IHJldHVybiB0aGlzLnZpZXdJZCB9XG5cbiAgdG9TdHJpbmcob25seUNpZHMpe1xuICAgIHJldHVybiB0aGlzLnJlY3Vyc2l2ZVRvU3RyaW5nKHRoaXMucmVuZGVyZWQsIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10sIG9ubHlDaWRzKVxuICB9XG5cbiAgcmVjdXJzaXZlVG9TdHJpbmcocmVuZGVyZWQsIGNvbXBvbmVudHMgPSByZW5kZXJlZFtDT01QT05FTlRTXSwgb25seUNpZHMpe1xuICAgIG9ubHlDaWRzID0gb25seUNpZHMgPyBuZXcgU2V0KG9ubHlDaWRzKSA6IG51bGxcbiAgICBsZXQgb3V0cHV0ID0ge2J1ZmZlcjogXCJcIiwgY29tcG9uZW50czogY29tcG9uZW50cywgb25seUNpZHM6IG9ubHlDaWRzfVxuICAgIHRoaXMudG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIG51bGwsIG91dHB1dClcbiAgICByZXR1cm4gb3V0cHV0LmJ1ZmZlclxuICB9XG5cbiAgY29tcG9uZW50Q0lEcyhkaWZmKXsgcmV0dXJuIE9iamVjdC5rZXlzKGRpZmZbQ09NUE9ORU5UU10gfHwge30pLm1hcChpID0+IHBhcnNlSW50KGkpKSB9XG5cbiAgaXNDb21wb25lbnRPbmx5RGlmZihkaWZmKXtcbiAgICBpZighZGlmZltDT01QT05FTlRTXSl7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGRpZmYpLmxlbmd0aCA9PT0gMVxuICB9XG5cbiAgZ2V0Q29tcG9uZW50KGRpZmYsIGNpZCl7IHJldHVybiBkaWZmW0NPTVBPTkVOVFNdW2NpZF0gfVxuXG4gIG1lcmdlRGlmZihkaWZmKXtcbiAgICBsZXQgbmV3YyA9IGRpZmZbQ09NUE9ORU5UU11cbiAgICBsZXQgY2FjaGUgPSB7fVxuICAgIGRlbGV0ZSBkaWZmW0NPTVBPTkVOVFNdXG4gICAgdGhpcy5yZW5kZXJlZCA9IHRoaXMubXV0YWJsZU1lcmdlKHRoaXMucmVuZGVyZWQsIGRpZmYpXG4gICAgdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSA9IHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10gfHwge31cblxuICAgIGlmKG5ld2Mpe1xuICAgICAgbGV0IG9sZGMgPSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdXG5cbiAgICAgIGZvcihsZXQgY2lkIGluIG5ld2Mpe1xuICAgICAgICBuZXdjW2NpZF0gPSB0aGlzLmNhY2hlZEZpbmRDb21wb25lbnQoY2lkLCBuZXdjW2NpZF0sIG9sZGMsIG5ld2MsIGNhY2hlKVxuICAgICAgfVxuXG4gICAgICBmb3IobGV0IGNpZCBpbiBuZXdjKXsgb2xkY1tjaWRdID0gbmV3Y1tjaWRdIH1cbiAgICAgIGRpZmZbQ09NUE9ORU5UU10gPSBuZXdjXG4gICAgfVxuICB9XG5cbiAgY2FjaGVkRmluZENvbXBvbmVudChjaWQsIGNkaWZmLCBvbGRjLCBuZXdjLCBjYWNoZSl7XG4gICAgaWYoY2FjaGVbY2lkXSl7XG4gICAgICByZXR1cm4gY2FjaGVbY2lkXVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmRpZmYsIHN0YXQsIHNjaWQgPSBjZGlmZltTVEFUSUNdXG5cbiAgICAgIGlmKGlzQ2lkKHNjaWQpKXtcbiAgICAgICAgbGV0IHRkaWZmXG5cbiAgICAgICAgaWYoc2NpZCA+IDApe1xuICAgICAgICAgIHRkaWZmID0gdGhpcy5jYWNoZWRGaW5kQ29tcG9uZW50KHNjaWQsIG5ld2Nbc2NpZF0sIG9sZGMsIG5ld2MsIGNhY2hlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRkaWZmID0gb2xkY1stc2NpZF1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXQgPSB0ZGlmZltTVEFUSUNdXG4gICAgICAgIG5kaWZmID0gdGhpcy5jbG9uZU1lcmdlKHRkaWZmLCBjZGlmZilcbiAgICAgICAgbmRpZmZbU1RBVElDXSA9IHN0YXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5kaWZmID0gY2RpZmZbU1RBVElDXSAhPT0gdW5kZWZpbmVkID8gY2RpZmYgOiB0aGlzLmNsb25lTWVyZ2Uob2xkY1tjaWRdIHx8IHt9LCBjZGlmZilcbiAgICAgIH1cblxuICAgICAgY2FjaGVbY2lkXSA9IG5kaWZmXG4gICAgICByZXR1cm4gbmRpZmZcbiAgICB9XG4gIH1cblxuICBtdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2Upe1xuICAgIGlmKHNvdXJjZVtTVEFUSUNdICE9PSB1bmRlZmluZWQpe1xuICAgICAgcmV0dXJuIHNvdXJjZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvTXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKVxuICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH1cbiAgfVxuXG4gIGRvTXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKXtcbiAgICBmb3IobGV0IGtleSBpbiBzb3VyY2Upe1xuICAgICAgbGV0IHZhbCA9IHNvdXJjZVtrZXldXG4gICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV1cbiAgICAgIGlmKGlzT2JqZWN0KHZhbCkgJiYgdmFsW1NUQVRJQ10gPT09IHVuZGVmaW5lZCAmJiBpc09iamVjdCh0YXJnZXRWYWwpKXtcbiAgICAgICAgdGhpcy5kb011dGFibGVNZXJnZSh0YXJnZXRWYWwsIHZhbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xvbmVNZXJnZSh0YXJnZXQsIHNvdXJjZSl7XG4gICAgbGV0IG1lcmdlZCA9IHsuLi50YXJnZXQsIC4uLnNvdXJjZX1cbiAgICBmb3IobGV0IGtleSBpbiBtZXJnZWQpe1xuICAgICAgbGV0IHZhbCA9IHNvdXJjZVtrZXldXG4gICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV1cbiAgICAgIGlmKGlzT2JqZWN0KHZhbCkgJiYgdmFsW1NUQVRJQ10gPT09IHVuZGVmaW5lZCAmJiBpc09iamVjdCh0YXJnZXRWYWwpKXtcbiAgICAgICAgbWVyZ2VkW2tleV0gPSB0aGlzLmNsb25lTWVyZ2UodGFyZ2V0VmFsLCB2YWwpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRcbiAgfVxuXG4gIGNvbXBvbmVudFRvU3RyaW5nKGNpZCl7IHJldHVybiB0aGlzLnJlY3Vyc2l2ZUNJRFRvU3RyaW5nKHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10sIGNpZCkgfVxuXG4gIHBydW5lQ0lEcyhjaWRzKXtcbiAgICBjaWRzLmZvckVhY2goY2lkID0+IGRlbGV0ZSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdW2NpZF0pXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgZ2V0KCl7IHJldHVybiB0aGlzLnJlbmRlcmVkIH1cblxuICBpc05ld0ZpbmdlcnByaW50KGRpZmYgPSB7fSl7IHJldHVybiAhIWRpZmZbU1RBVElDXSB9XG5cbiAgdGVtcGxhdGVTdGF0aWMocGFydCwgdGVtcGxhdGVzKXtcbiAgICBpZih0eXBlb2YgKHBhcnQpID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdGVtcGxhdGVzW3BhcnRdXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJ0XG4gICAgfVxuICB9XG5cbiAgdG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KXtcbiAgICBpZihyZW5kZXJlZFtEWU5BTUlDU10peyByZXR1cm4gdGhpcy5jb21wcmVoZW5zaW9uVG9CdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KSB9XG4gICAgbGV0IHtbU1RBVElDXTogc3RhdGljc30gPSByZW5kZXJlZFxuICAgIHN0YXRpY3MgPSB0aGlzLnRlbXBsYXRlU3RhdGljKHN0YXRpY3MsIHRlbXBsYXRlcylcblxuICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1swXVxuICAgIGZvcihsZXQgaSA9IDE7IGkgPCBzdGF0aWNzLmxlbmd0aDsgaSsrKXtcbiAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKHJlbmRlcmVkW2kgLSAxXSwgdGVtcGxhdGVzLCBvdXRwdXQpXG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbaV1cbiAgICB9XG4gIH1cblxuICBjb21wcmVoZW5zaW9uVG9CdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KXtcbiAgICBsZXQge1tEWU5BTUlDU106IGR5bmFtaWNzLCBbU1RBVElDXTogc3RhdGljc30gPSByZW5kZXJlZFxuICAgIHN0YXRpY3MgPSB0aGlzLnRlbXBsYXRlU3RhdGljKHN0YXRpY3MsIHRlbXBsYXRlcylcbiAgICBsZXQgY29tcFRlbXBsYXRlcyA9IHRlbXBsYXRlcyB8fCByZW5kZXJlZFtURU1QTEFURVNdXG5cbiAgICBmb3IobGV0IGQgPSAwOyBkIDwgZHluYW1pY3MubGVuZ3RoOyBkKyspe1xuICAgICAgbGV0IGR5bmFtaWMgPSBkeW5hbWljc1tkXVxuICAgICAgb3V0cHV0LmJ1ZmZlciArPSBzdGF0aWNzWzBdXG4gICAgICBmb3IobGV0IGkgPSAxOyBpIDwgc3RhdGljcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKGR5bmFtaWNbaSAtIDFdLCBjb21wVGVtcGxhdGVzLCBvdXRwdXQpXG4gICAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1tpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGR5bmFtaWNUb0J1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpe1xuICAgIGlmKHR5cGVvZiAocmVuZGVyZWQpID09PSBcIm51bWJlclwiKXtcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyhvdXRwdXQuY29tcG9uZW50cywgcmVuZGVyZWQsIG91dHB1dC5vbmx5Q2lkcylcbiAgICB9IGVsc2UgaWYoaXNPYmplY3QocmVuZGVyZWQpKXtcbiAgICAgIHRoaXMudG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHJlbmRlcmVkXG4gICAgfVxuICB9XG5cbiAgcmVjdXJzaXZlQ0lEVG9TdHJpbmcoY29tcG9uZW50cywgY2lkLCBvbmx5Q2lkcyl7XG4gICAgbGV0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY2lkXSB8fCBsb2dFcnJvcihgbm8gY29tcG9uZW50IGZvciBDSUQgJHtjaWR9YCwgY29tcG9uZW50cylcbiAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIilcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0aGlzLnJlY3Vyc2l2ZVRvU3RyaW5nKGNvbXBvbmVudCwgY29tcG9uZW50cywgb25seUNpZHMpXG4gICAgbGV0IGNvbnRhaW5lciA9IHRlbXBsYXRlLmNvbnRlbnRcbiAgICBsZXQgc2tpcCA9IG9ubHlDaWRzICYmICFvbmx5Q2lkcy5oYXMoY2lkKVxuXG4gICAgbGV0IFtoYXNDaGlsZE5vZGVzLCBoYXNDaGlsZENvbXBvbmVudHNdID1cbiAgICAgIEFycmF5LmZyb20oY29udGFpbmVyLmNoaWxkTm9kZXMpLnJlZHVjZSgoW2hhc05vZGVzLCBoYXNDb21wb25lbnRzXSwgY2hpbGQsIGkpID0+IHtcbiAgICAgICAgaWYoY2hpbGQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKXtcbiAgICAgICAgICBpZihjaGlsZC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkpe1xuICAgICAgICAgICAgcmV0dXJuIFtoYXNOb2RlcywgdHJ1ZV1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQsIGNpZClcbiAgICAgICAgICBpZighY2hpbGQuaWQpeyBjaGlsZC5pZCA9IGAke3RoaXMucGFyZW50Vmlld0lkKCl9LSR7Y2lkfS0ke2l9YCB9XG4gICAgICAgICAgaWYoc2tpcCl7XG4gICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoUEhYX1NLSVAsIFwiXCIpXG4gICAgICAgICAgICBjaGlsZC5pbm5lckhUTUwgPSBcIlwiXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbdHJ1ZSwgaGFzQ29tcG9uZW50c11cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZihjaGlsZC5ub2RlVmFsdWUudHJpbSgpICE9PSBcIlwiKXtcbiAgICAgICAgICAgIGxvZ0Vycm9yKFwib25seSBIVE1MIGVsZW1lbnQgdGFncyBhcmUgYWxsb3dlZCBhdCB0aGUgcm9vdCBvZiBjb21wb25lbnRzLlxcblxcblwiICtcbiAgICAgICAgICAgICAgYGdvdDogXCIke2NoaWxkLm5vZGVWYWx1ZS50cmltKCl9XCJcXG5cXG5gICtcbiAgICAgICAgICAgICAgXCJ3aXRoaW46XFxuXCIsIHRlbXBsYXRlLmlubmVySFRNTC50cmltKCkpXG4gICAgICAgICAgICBjaGlsZC5yZXBsYWNlV2l0aCh0aGlzLmNyZWF0ZVNwYW4oY2hpbGQubm9kZVZhbHVlLCBjaWQpKVxuICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCBoYXNDb21wb25lbnRzXVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZC5yZW1vdmUoKVxuICAgICAgICAgICAgcmV0dXJuIFtoYXNOb2RlcywgaGFzQ29tcG9uZW50c11cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIFtmYWxzZSwgZmFsc2VdKVxuXG4gICAgaWYoIWhhc0NoaWxkTm9kZXMgJiYgIWhhc0NoaWxkQ29tcG9uZW50cyl7XG4gICAgICBsb2dFcnJvcihcImV4cGVjdGVkIGF0IGxlYXN0IG9uZSBIVE1MIGVsZW1lbnQgdGFnIGluc2lkZSBhIGNvbXBvbmVudCwgYnV0IHRoZSBjb21wb25lbnQgaXMgZW1wdHk6XFxuXCIsXG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTC50cmltKCkpXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVTcGFuKFwiXCIsIGNpZCkub3V0ZXJIVE1MXG4gICAgfSBlbHNlIGlmKCFoYXNDaGlsZE5vZGVzICYmIGhhc0NoaWxkQ29tcG9uZW50cyl7XG4gICAgICBsb2dFcnJvcihcImV4cGVjdGVkIGF0IGxlYXN0IG9uZSBIVE1MIGVsZW1lbnQgdGFnIGRpcmVjdGx5IGluc2lkZSBhIGNvbXBvbmVudCwgYnV0IG9ubHkgc3ViY29tcG9uZW50cyB3ZXJlIGZvdW5kLiBBIGNvbXBvbmVudCBtdXN0IHJlbmRlciBhdCBsZWFzdCBvbmUgSFRNTCB0YWcgZGlyZWN0bHkgaW5zaWRlIGl0c2VsZi5cIixcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MLnRyaW0oKSlcbiAgICAgIHJldHVybiB0ZW1wbGF0ZS5pbm5lckhUTUxcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRlbXBsYXRlLmlubmVySFRNTFxuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZVNwYW4odGV4dCwgY2lkKXtcbiAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgc3Bhbi5pbm5lclRleHQgPSB0ZXh0XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCwgY2lkKVxuICAgIHJldHVybiBzcGFuXG4gIH1cbn1cbiIsICJsZXQgdmlld0hvb2tJRCA9IDFcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdIb29rIHtcbiAgc3RhdGljIG1ha2VJRCgpeyByZXR1cm4gdmlld0hvb2tJRCsrIH1cbiAgc3RhdGljIGVsZW1lbnRJRChlbCl7IHJldHVybiBlbC5waHhIb29rSWQgfVxuXG4gIGNvbnN0cnVjdG9yKHZpZXcsIGVsLCBjYWxsYmFja3Mpe1xuICAgIHRoaXMuX192aWV3ID0gdmlld1xuICAgIHRoaXMubGl2ZVNvY2tldCA9IHZpZXcubGl2ZVNvY2tldFxuICAgIHRoaXMuX19jYWxsYmFja3MgPSBjYWxsYmFja3NcbiAgICB0aGlzLl9fbGlzdGVuZXJzID0gbmV3IFNldCgpXG4gICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gZmFsc2VcbiAgICB0aGlzLmVsID0gZWxcbiAgICB0aGlzLmVsLnBoeEhvb2tJZCA9IHRoaXMuY29uc3RydWN0b3IubWFrZUlEKClcbiAgICBmb3IobGV0IGtleSBpbiB0aGlzLl9fY2FsbGJhY2tzKXsgdGhpc1trZXldID0gdGhpcy5fX2NhbGxiYWNrc1trZXldIH1cbiAgfVxuXG4gIF9fbW91bnRlZCgpeyB0aGlzLm1vdW50ZWQgJiYgdGhpcy5tb3VudGVkKCkgfVxuICBfX3VwZGF0ZWQoKXsgdGhpcy51cGRhdGVkICYmIHRoaXMudXBkYXRlZCgpIH1cbiAgX19iZWZvcmVVcGRhdGUoKXsgdGhpcy5iZWZvcmVVcGRhdGUgJiYgdGhpcy5iZWZvcmVVcGRhdGUoKSB9XG4gIF9fZGVzdHJveWVkKCl7IHRoaXMuZGVzdHJveWVkICYmIHRoaXMuZGVzdHJveWVkKCkgfVxuICBfX3JlY29ubmVjdGVkKCl7XG4gICAgaWYodGhpcy5fX2lzRGlzY29ubmVjdGVkKXtcbiAgICAgIHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgICB0aGlzLnJlY29ubmVjdGVkICYmIHRoaXMucmVjb25uZWN0ZWQoKVxuICAgIH1cbiAgfVxuICBfX2Rpc2Nvbm5lY3RlZCgpe1xuICAgIHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCA9IHRydWVcbiAgICB0aGlzLmRpc2Nvbm5lY3RlZCAmJiB0aGlzLmRpc2Nvbm5lY3RlZCgpXG4gIH1cblxuICBwdXNoRXZlbnQoZXZlbnQsIHBheWxvYWQgPSB7fSwgb25SZXBseSA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcucHVzaEhvb2tFdmVudChudWxsLCBldmVudCwgcGF5bG9hZCwgb25SZXBseSlcbiAgfVxuXG4gIHB1c2hFdmVudFRvKHBoeFRhcmdldCwgZXZlbnQsIHBheWxvYWQgPSB7fSwgb25SZXBseSA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcud2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsICh2aWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIHJldHVybiB2aWV3LnB1c2hIb29rRXZlbnQodGFyZ2V0Q3R4LCBldmVudCwgcGF5bG9hZCwgb25SZXBseSlcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlRXZlbnQoZXZlbnQsIGNhbGxiYWNrKXtcbiAgICBsZXQgY2FsbGJhY2tSZWYgPSAoY3VzdG9tRXZlbnQsIGJ5cGFzcykgPT4gYnlwYXNzID8gZXZlbnQgOiBjYWxsYmFjayhjdXN0b21FdmVudC5kZXRhaWwpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoYHBoeDoke2V2ZW50fWAsIGNhbGxiYWNrUmVmKVxuICAgIHRoaXMuX19saXN0ZW5lcnMuYWRkKGNhbGxiYWNrUmVmKVxuICAgIHJldHVybiBjYWxsYmFja1JlZlxuICB9XG5cbiAgcmVtb3ZlSGFuZGxlRXZlbnQoY2FsbGJhY2tSZWYpe1xuICAgIGxldCBldmVudCA9IGNhbGxiYWNrUmVmKG51bGwsIHRydWUpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoYHBoeDoke2V2ZW50fWAsIGNhbGxiYWNrUmVmKVxuICAgIHRoaXMuX19saXN0ZW5lcnMuZGVsZXRlKGNhbGxiYWNrUmVmKVxuICB9XG5cbiAgdXBsb2FkKG5hbWUsIGZpbGVzKXtcbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcuZGlzcGF0Y2hVcGxvYWRzKG5hbWUsIGZpbGVzKVxuICB9XG5cbiAgdXBsb2FkVG8ocGh4VGFyZ2V0LCBuYW1lLCBmaWxlcyl7XG4gICAgcmV0dXJuIHRoaXMuX192aWV3LndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCB2aWV3ID0+IHZpZXcuZGlzcGF0Y2hVcGxvYWRzKG5hbWUsIGZpbGVzKSlcbiAgfVxuXG4gIF9fY2xlYW51cF9fKCl7XG4gICAgdGhpcy5fX2xpc3RlbmVycy5mb3JFYWNoKGNhbGxiYWNrUmVmID0+IHRoaXMucmVtb3ZlSGFuZGxlRXZlbnQoY2FsbGJhY2tSZWYpKVxuICB9XG59XG4iLCAiaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuXG5sZXQgSlMgPSB7XG4gIGV4ZWMoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGRlZmF1bHRzKXtcbiAgICBsZXQgW2RlZmF1bHRLaW5kLCBkZWZhdWx0QXJnc10gPSBkZWZhdWx0cyB8fCBbbnVsbCwge31dXG4gICAgbGV0IGNvbW1hbmRzID0gcGh4RXZlbnQuY2hhckF0KDApID09PSBcIltcIiA/XG4gICAgICBKU09OLnBhcnNlKHBoeEV2ZW50KSA6IFtbZGVmYXVsdEtpbmQsIGRlZmF1bHRBcmdzXV1cblxuICAgIGNvbW1hbmRzLmZvckVhY2goKFtraW5kLCBhcmdzXSkgPT4ge1xuICAgICAgaWYoa2luZCA9PT0gZGVmYXVsdEtpbmQgJiYgZGVmYXVsdEFyZ3MuZGF0YSl7XG4gICAgICAgIGFyZ3MuZGF0YSA9IE9iamVjdC5hc3NpZ24oYXJncy5kYXRhIHx8IHt9LCBkZWZhdWx0QXJncy5kYXRhKVxuICAgICAgfVxuICAgICAgdGhpcy5maWx0ZXJUb0Vscyhzb3VyY2VFbCwgYXJncykuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIHRoaXNbYGV4ZWNfJHtraW5kfWBdKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgYXJncylcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcblxuICBpc1Zpc2libGUoZWwpe1xuICAgIHJldHVybiAhIShlbC5vZmZzZXRXaWR0aCB8fCBlbC5vZmZzZXRIZWlnaHQgfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPiAwKVxuICB9LFxuXG4gIC8vIHByaXZhdGVcblxuICAvLyBjb21tYW5kc1xuXG4gIGV4ZWNfZGlzcGF0Y2goZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7dG8sIGV2ZW50LCBkZXRhaWwsIGJ1YmJsZXN9KXtcbiAgICBkZXRhaWwgPSBkZXRhaWwgfHwge31cbiAgICBkZXRhaWwuZGlzcGF0Y2hlciA9IHNvdXJjZUVsXG4gICAgRE9NLmRpc3BhdGNoRXZlbnQoZWwsIGV2ZW50LCB7ZGV0YWlsLCBidWJibGVzfSlcbiAgfSxcblxuICBleGVjX3B1c2goZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCBhcmdzKXtcbiAgICBpZighdmlldy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIH1cblxuICAgIGxldCB7ZXZlbnQsIGRhdGEsIHRhcmdldCwgcGFnZV9sb2FkaW5nLCBsb2FkaW5nLCB2YWx1ZSwgZGlzcGF0Y2hlcn0gPSBhcmdzXG4gICAgbGV0IHB1c2hPcHRzID0ge2xvYWRpbmcsIHZhbHVlLCB0YXJnZXQsIHBhZ2VfbG9hZGluZzogISFwYWdlX2xvYWRpbmd9XG4gICAgbGV0IHRhcmdldFNyYyA9IGV2ZW50VHlwZSA9PT0gXCJjaGFuZ2VcIiAmJiBkaXNwYXRjaGVyID8gZGlzcGF0Y2hlciA6IHNvdXJjZUVsXG4gICAgbGV0IHBoeFRhcmdldCA9IHRhcmdldCB8fCB0YXJnZXRTcmMuZ2V0QXR0cmlidXRlKHZpZXcuYmluZGluZyhcInRhcmdldFwiKSkgfHwgdGFyZ2V0U3JjXG4gICAgdmlldy53aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgKHRhcmdldFZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgaWYoZXZlbnRUeXBlID09PSBcImNoYW5nZVwiKXtcbiAgICAgICAgbGV0IHtuZXdDaWQsIF90YXJnZXQsIGNhbGxiYWNrfSA9IGFyZ3NcbiAgICAgICAgX3RhcmdldCA9IF90YXJnZXQgfHwgKHNvdXJjZUVsIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCA/IHNvdXJjZUVsLm5hbWUgOiB1bmRlZmluZWQpXG4gICAgICAgIGlmKF90YXJnZXQpeyBwdXNoT3B0cy5fdGFyZ2V0ID0gX3RhcmdldCB9XG4gICAgICAgIHRhcmdldFZpZXcucHVzaElucHV0KHNvdXJjZUVsLCB0YXJnZXRDdHgsIG5ld0NpZCwgZXZlbnQgfHwgcGh4RXZlbnQsIHB1c2hPcHRzLCBjYWxsYmFjaylcbiAgICAgIH0gZWxzZSBpZihldmVudFR5cGUgPT09IFwic3VibWl0XCIpe1xuICAgICAgICB0YXJnZXRWaWV3LnN1Ym1pdEZvcm0oc291cmNlRWwsIHRhcmdldEN0eCwgZXZlbnQgfHwgcGh4RXZlbnQsIHB1c2hPcHRzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Vmlldy5wdXNoRXZlbnQoZXZlbnRUeXBlLCBzb3VyY2VFbCwgdGFyZ2V0Q3R4LCBldmVudCB8fCBwaHhFdmVudCwgZGF0YSwgcHVzaE9wdHMpXG4gICAgICB9XG4gICAgfSlcbiAgfSxcblxuICBleGVjX2FkZF9jbGFzcyhldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtuYW1lcywgdHJhbnNpdGlvbiwgdGltZX0pe1xuICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBuYW1lcywgW10sIHRyYW5zaXRpb24sIHRpbWUsIHZpZXcpXG4gIH0sXG5cbiAgZXhlY19yZW1vdmVfY2xhc3MoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7bmFtZXMsIHRyYW5zaXRpb24sIHRpbWV9KXtcbiAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIG5hbWVzLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3KVxuICB9LFxuXG4gIGV4ZWNfdHJhbnNpdGlvbihldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHt0aW1lLCB0cmFuc2l0aW9ufSl7XG4gICAgbGV0IFt0cmFuc2l0aW9uX3N0YXJ0LCBydW5uaW5nLCB0cmFuc2l0aW9uX2VuZF0gPSB0cmFuc2l0aW9uXG4gICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgdHJhbnNpdGlvbl9zdGFydC5jb25jYXQocnVubmluZyksIFtdKVxuICAgIGxldCBvbkRvbmUgPSAoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgdHJhbnNpdGlvbl9lbmQsIHRyYW5zaXRpb25fc3RhcnQuY29uY2F0KHJ1bm5pbmcpKVxuICAgIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpXG4gIH0sXG5cbiAgZXhlY190b2dnbGUoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7ZGlzcGxheSwgaW5zLCBvdXRzLCB0aW1lfSl7XG4gICAgdGhpcy50b2dnbGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgaW5zLCBvdXRzLCB0aW1lKVxuICB9LFxuXG4gIGV4ZWNfc2hvdyhldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lfSl7XG4gICAgdGhpcy5zaG93KGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUpXG4gIH0sXG5cbiAgZXhlY19oaWRlKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2Rpc3BsYXksIHRyYW5zaXRpb24sIHRpbWV9KXtcbiAgICB0aGlzLmhpZGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSlcbiAgfSxcblxuICBleGVjX3NldF9hdHRyKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2F0dHI6IFthdHRyLCB2YWxdfSl7XG4gICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbF1dLCBbXSlcbiAgfSxcblxuICBleGVjX3JlbW92ZV9hdHRyKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2F0dHJ9KXtcbiAgICB0aGlzLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtdLCBbYXR0cl0pXG4gIH0sXG5cbiAgLy8gdXRpbHMgZm9yIGNvbW1hbmRzXG5cbiAgc2hvdyhldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lKXtcbiAgICBpZighdGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgIHRoaXMudG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIG51bGwsIHRpbWUpXG4gICAgfVxuICB9LFxuXG4gIGhpZGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSl7XG4gICAgaWYodGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgIHRoaXMudG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIG51bGwsIHRyYW5zaXRpb24sIHRpbWUpXG4gICAgfVxuICB9LFxuXG4gIHRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCBpbnMsIG91dHMsIHRpbWUpe1xuICAgIGxldCBbaW5DbGFzc2VzLCBpblN0YXJ0Q2xhc3NlcywgaW5FbmRDbGFzc2VzXSA9IGlucyB8fCBbW10sIFtdLCBbXV1cbiAgICBsZXQgW291dENsYXNzZXMsIG91dFN0YXJ0Q2xhc3Nlcywgb3V0RW5kQ2xhc3Nlc10gPSBvdXRzIHx8IFtbXSwgW10sIFtdXVxuICAgIGlmKGluQ2xhc3Nlcy5sZW5ndGggPiAwIHx8IG91dENsYXNzZXMubGVuZ3RoID4gMCl7XG4gICAgICBpZih0aGlzLmlzVmlzaWJsZShlbCkpe1xuICAgICAgICBsZXQgb25TdGFydCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgb3V0U3RhcnRDbGFzc2VzLCBpbkNsYXNzZXMuY29uY2F0KGluU3RhcnRDbGFzc2VzKS5jb25jYXQoaW5FbmRDbGFzc2VzKSlcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBvdXRDbGFzc2VzLCBbXSlcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG91dEVuZENsYXNzZXMsIG91dFN0YXJ0Q2xhc3NlcykpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpoaWRlLXN0YXJ0XCIpKVxuICAgICAgICB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBbXSwgb3V0Q2xhc3Nlcy5jb25jYXQob3V0RW5kQ2xhc3NlcykpXG4gICAgICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgY3VycmVudEVsID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1lbmRcIikpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZihldmVudFR5cGUgPT09IFwicmVtb3ZlXCIpeyByZXR1cm4gfVxuICAgICAgICBsZXQgb25TdGFydCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgaW5TdGFydENsYXNzZXMsIG91dENsYXNzZXMuY29uY2F0KG91dFN0YXJ0Q2xhc3NlcykuY29uY2F0KG91dEVuZENsYXNzZXMpKVxuICAgICAgICAgIERPTS5wdXRTdGlja3koZWwsIFwidG9nZ2xlXCIsIGN1cnJlbnRFbCA9PiBjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IChkaXNwbGF5IHx8IFwiYmxvY2tcIikpXG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgaW5DbGFzc2VzLCBbXSlcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGluRW5kQ2xhc3NlcywgaW5TdGFydENsYXNzZXMpKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1zdGFydFwiKSlcbiAgICAgICAgdmlldy50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIGluQ2xhc3Nlcy5jb25jYXQoaW5FbmRDbGFzc2VzKSlcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LWVuZFwiKSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYodGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1zdGFydFwiKSlcbiAgICAgICAgICBET00ucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCBjdXJyZW50RWwgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIilcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpoaWRlLWVuZFwiKSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OnNob3ctc3RhcnRcIikpXG4gICAgICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgY3VycmVudEVsID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheSB8fCBcImJsb2NrXCIpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1lbmRcIikpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgYWRkcywgcmVtb3ZlcywgdHJhbnNpdGlvbiwgdGltZSwgdmlldyl7XG4gICAgbGV0IFt0cmFuc2l0aW9uX3J1biwgdHJhbnNpdGlvbl9zdGFydCwgdHJhbnNpdGlvbl9lbmRdID0gdHJhbnNpdGlvbiB8fCBbW10sIFtdLCBbXV1cbiAgICBpZih0cmFuc2l0aW9uX3J1bi5sZW5ndGggPiAwKXtcbiAgICAgIGxldCBvblN0YXJ0ID0gKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIHRyYW5zaXRpb25fc3RhcnQuY29uY2F0KHRyYW5zaXRpb25fcnVuKSwgW10pXG4gICAgICBsZXQgb25Eb25lID0gKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGFkZHMuY29uY2F0KHRyYW5zaXRpb25fZW5kKSwgcmVtb3Zlcy5jb25jYXQodHJhbnNpdGlvbl9ydW4pLmNvbmNhdCh0cmFuc2l0aW9uX3N0YXJ0KSlcbiAgICAgIHJldHVybiB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKVxuICAgIH1cbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGxldCBbcHJldkFkZHMsIHByZXZSZW1vdmVzXSA9IERPTS5nZXRTdGlja3koZWwsIFwiY2xhc3Nlc1wiLCBbW10sIFtdXSlcbiAgICAgIGxldCBrZWVwQWRkcyA9IGFkZHMuZmlsdGVyKG5hbWUgPT4gcHJldkFkZHMuaW5kZXhPZihuYW1lKSA8IDAgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSlcbiAgICAgIGxldCBrZWVwUmVtb3ZlcyA9IHJlbW92ZXMuZmlsdGVyKG5hbWUgPT4gcHJldlJlbW92ZXMuaW5kZXhPZihuYW1lKSA8IDAgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKVxuICAgICAgbGV0IG5ld0FkZHMgPSBwcmV2QWRkcy5maWx0ZXIobmFtZSA9PiByZW1vdmVzLmluZGV4T2YobmFtZSkgPCAwKS5jb25jYXQoa2VlcEFkZHMpXG4gICAgICBsZXQgbmV3UmVtb3ZlcyA9IHByZXZSZW1vdmVzLmZpbHRlcihuYW1lID0+IGFkZHMuaW5kZXhPZihuYW1lKSA8IDApLmNvbmNhdChrZWVwUmVtb3ZlcylcblxuICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJjbGFzc2VzXCIsIGN1cnJlbnRFbCA9PiB7XG4gICAgICAgIGN1cnJlbnRFbC5jbGFzc0xpc3QucmVtb3ZlKC4uLm5ld1JlbW92ZXMpXG4gICAgICAgIGN1cnJlbnRFbC5jbGFzc0xpc3QuYWRkKC4uLm5ld0FkZHMpXG4gICAgICAgIHJldHVybiBbbmV3QWRkcywgbmV3UmVtb3Zlc11cbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcblxuICBzZXRPclJlbW92ZUF0dHJzKGVsLCBzZXRzLCByZW1vdmVzKXtcbiAgICBsZXQgW3ByZXZTZXRzLCBwcmV2UmVtb3Zlc10gPSBET00uZ2V0U3RpY2t5KGVsLCBcImF0dHJzXCIsIFtbXSwgW11dKVxuXG4gICAgbGV0IGFsdGVyZWRBdHRycyA9IHNldHMubWFwKChbYXR0ciwgX3ZhbF0pID0+IGF0dHIpLmNvbmNhdChyZW1vdmVzKTtcbiAgICBsZXQgbmV3U2V0cyA9IHByZXZTZXRzLmZpbHRlcigoW2F0dHIsIF92YWxdKSA9PiAhYWx0ZXJlZEF0dHJzLmluY2x1ZGVzKGF0dHIpKS5jb25jYXQoc2V0cyk7XG4gICAgbGV0IG5ld1JlbW92ZXMgPSBwcmV2UmVtb3Zlcy5maWx0ZXIoKGF0dHIpID0+ICFhbHRlcmVkQXR0cnMuaW5jbHVkZXMoYXR0cikpLmNvbmNhdChyZW1vdmVzKTtcblxuICAgIERPTS5wdXRTdGlja3koZWwsIFwiYXR0cnNcIiwgY3VycmVudEVsID0+IHtcbiAgICAgIG5ld1JlbW92ZXMuZm9yRWFjaChhdHRyID0+IGN1cnJlbnRFbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cikpXG4gICAgICBuZXdTZXRzLmZvckVhY2goKFthdHRyLCB2YWxdKSA9PiBjdXJyZW50RWwuc2V0QXR0cmlidXRlKGF0dHIsIHZhbCkpXG4gICAgICByZXR1cm4gW25ld1NldHMsIG5ld1JlbW92ZXNdXG4gICAgfSlcbiAgfSxcblxuICBoYXNBbGxDbGFzc2VzKGVsLCBjbGFzc2VzKXsgcmV0dXJuIGNsYXNzZXMuZXZlcnkobmFtZSA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSkpIH0sXG5cbiAgaXNUb2dnbGVkT3V0KGVsLCBvdXRDbGFzc2VzKXtcbiAgICByZXR1cm4gIXRoaXMuaXNWaXNpYmxlKGVsKSB8fCB0aGlzLmhhc0FsbENsYXNzZXMoZWwsIG91dENsYXNzZXMpXG4gIH0sXG5cbiAgZmlsdGVyVG9FbHMoc291cmNlRWwsIHt0b30pe1xuICAgIHJldHVybiB0byA/IERPTS5hbGwoZG9jdW1lbnQsIHRvKSA6IFtzb3VyY2VFbF1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBKU1xuIiwgImltcG9ydCB7XG4gIEJFRk9SRV9VTkxPQURfTE9BREVSX1RJTUVPVVQsXG4gIENIRUNLQUJMRV9JTlBVVFMsXG4gIENPTlNFQ1VUSVZFX1JFTE9BRFMsXG4gIFBIWF9BVVRPX1JFQ09WRVIsXG4gIFBIWF9DT01QT05FTlQsXG4gIFBIWF9DT05ORUNURURfQ0xBU1MsXG4gIFBIWF9ESVNBQkxFX1dJVEgsXG4gIFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSxcbiAgUEhYX0RJU0FCTEVELFxuICBQSFhfRElTQ09OTkVDVEVEX0NMQVNTLFxuICBQSFhfRVZFTlRfQ0xBU1NFUyxcbiAgUEhYX0VSUk9SX0NMQVNTLFxuICBQSFhfRkVFREJBQ0tfRk9SLFxuICBQSFhfSEFTX1NVQk1JVFRFRCxcbiAgUEhYX0hPT0ssXG4gIFBIWF9QQUdFX0xPQURJTkcsXG4gIFBIWF9QQVJFTlRfSUQsXG4gIFBIWF9QUk9HUkVTUyxcbiAgUEhYX1JFQURPTkxZLFxuICBQSFhfUkVGLFxuICBQSFhfUkVGX1NSQyxcbiAgUEhYX1JPT1RfSUQsXG4gIFBIWF9TRVNTSU9OLFxuICBQSFhfU1RBVElDLFxuICBQSFhfVFJBQ0tfU1RBVElDLFxuICBQSFhfVFJBQ0tfVVBMT0FEUyxcbiAgUEhYX1VQREFURSxcbiAgUEhYX1VQTE9BRF9SRUYsXG4gIFBIWF9WSUVXX1NFTEVDVE9SLFxuICBQVVNIX1RJTUVPVVQsXG4gIFBIWF9NQUlOLFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBjbG9uZSxcbiAgY2xvc2VzdFBoeEJpbmRpbmcsXG4gIGlzRW1wdHksXG4gIGlzRXF1YWxPYmosXG4gIGxvZ0Vycm9yLFxuICBtYXliZSxcbiAgaXNDaWQsXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IEJyb3dzZXIgZnJvbSBcIi4vYnJvd3NlclwiXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgRE9NUGF0Y2ggZnJvbSBcIi4vZG9tX3BhdGNoXCJcbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5pbXBvcnQgUmVuZGVyZWQgZnJvbSBcIi4vcmVuZGVyZWRcIlxuaW1wb3J0IFZpZXdIb29rIGZyb20gXCIuL3ZpZXdfaG9va1wiXG5pbXBvcnQgSlMgZnJvbSBcIi4vanNcIlxuXG5sZXQgc2VyaWFsaXplRm9ybSA9IChmb3JtLCBtZXRhLCBvbmx5TmFtZXMgPSBbXSkgPT4ge1xuICBsZXQgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoZm9ybSlcbiAgbGV0IHRvUmVtb3ZlID0gW11cblxuICBmb3JtRGF0YS5mb3JFYWNoKCh2YWwsIGtleSwgX2luZGV4KSA9PiB7XG4gICAgaWYodmFsIGluc3RhbmNlb2YgRmlsZSl7IHRvUmVtb3ZlLnB1c2goa2V5KSB9XG4gIH0pXG5cbiAgLy8gQ2xlYW51cCBhZnRlciBidWlsZGluZyBmaWxlRGF0YVxuICB0b1JlbW92ZS5mb3JFYWNoKGtleSA9PiBmb3JtRGF0YS5kZWxldGUoa2V5KSlcblxuICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG4gIGZvcihsZXQgW2tleSwgdmFsXSBvZiBmb3JtRGF0YS5lbnRyaWVzKCkpe1xuICAgIGlmKG9ubHlOYW1lcy5sZW5ndGggPT09IDAgfHwgb25seU5hbWVzLmluZGV4T2Yoa2V5KSA+PSAwKXtcbiAgICAgIHBhcmFtcy5hcHBlbmQoa2V5LCB2YWwpXG4gICAgfVxuICB9XG4gIGZvcihsZXQgbWV0YUtleSBpbiBtZXRhKXsgcGFyYW1zLmFwcGVuZChtZXRhS2V5LCBtZXRhW21ldGFLZXldKSB9XG5cbiAgcmV0dXJuIHBhcmFtcy50b1N0cmluZygpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXcge1xuICBjb25zdHJ1Y3RvcihlbCwgbGl2ZVNvY2tldCwgcGFyZW50VmlldywgZmxhc2gpe1xuICAgIHRoaXMubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXRcbiAgICB0aGlzLmZsYXNoID0gZmxhc2hcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudFZpZXdcbiAgICB0aGlzLnJvb3QgPSBwYXJlbnRWaWV3ID8gcGFyZW50Vmlldy5yb290IDogdGhpc1xuICAgIHRoaXMuZWwgPSBlbFxuICAgIHRoaXMuaWQgPSB0aGlzLmVsLmlkXG4gICAgdGhpcy5yZWYgPSAwXG4gICAgdGhpcy5jaGlsZEpvaW5zID0gMFxuICAgIHRoaXMubG9hZGVyVGltZXIgPSBudWxsXG4gICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgIHRoaXMucHJ1bmluZ0NJRHMgPSBbXVxuICAgIHRoaXMucmVkaXJlY3QgPSBmYWxzZVxuICAgIHRoaXMuaHJlZiA9IG51bGxcbiAgICB0aGlzLmpvaW5Db3VudCA9IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuam9pbkNvdW50IC0gMSA6IDBcbiAgICB0aGlzLmpvaW5QZW5kaW5nID0gdHJ1ZVxuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcbiAgICB0aGlzLmpvaW5DYWxsYmFjayA9IGZ1bmN0aW9uKG9uRG9uZSl7IG9uRG9uZSAmJiBvbkRvbmUoKSB9XG4gICAgdGhpcy5zdG9wQ2FsbGJhY2sgPSBmdW5jdGlvbigpeyB9XG4gICAgdGhpcy5wZW5kaW5nSm9pbk9wcyA9IHRoaXMucGFyZW50ID8gbnVsbCA6IFtdXG4gICAgdGhpcy52aWV3SG9va3MgPSB7fVxuICAgIHRoaXMudXBsb2FkZXJzID0ge31cbiAgICB0aGlzLmZvcm1TdWJtaXRzID0gW11cbiAgICB0aGlzLmNoaWxkcmVuID0gdGhpcy5wYXJlbnQgPyBudWxsIDoge31cbiAgICB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF0gPSB7fVxuICAgIHRoaXMuY2hhbm5lbCA9IHRoaXMubGl2ZVNvY2tldC5jaGFubmVsKGBsdjoke3RoaXMuaWR9YCwgKCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVkaXJlY3Q6IHRoaXMucmVkaXJlY3QgPyB0aGlzLmhyZWYgOiB1bmRlZmluZWQsXG4gICAgICAgIHVybDogdGhpcy5yZWRpcmVjdCA/IHVuZGVmaW5lZCA6IHRoaXMuaHJlZiB8fCB1bmRlZmluZWQsXG4gICAgICAgIHBhcmFtczogdGhpcy5jb25uZWN0UGFyYW1zKCksXG4gICAgICAgIHNlc3Npb246IHRoaXMuZ2V0U2Vzc2lvbigpLFxuICAgICAgICBzdGF0aWM6IHRoaXMuZ2V0U3RhdGljKCksXG4gICAgICAgIGZsYXNoOiB0aGlzLmZsYXNoXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLnNob3dMb2FkZXIodGhpcy5saXZlU29ja2V0LmxvYWRlclRpbWVvdXQpXG4gICAgdGhpcy5iaW5kQ2hhbm5lbCgpXG4gIH1cblxuICBzZXRIcmVmKGhyZWYpeyB0aGlzLmhyZWYgPSBocmVmIH1cblxuICBzZXRSZWRpcmVjdChocmVmKXtcbiAgICB0aGlzLnJlZGlyZWN0ID0gdHJ1ZVxuICAgIHRoaXMuaHJlZiA9IGhyZWZcbiAgfVxuXG4gIGlzTWFpbigpeyByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX01BSU4pICE9PSBudWxsIH1cblxuICBjb25uZWN0UGFyYW1zKCl7XG4gICAgbGV0IHBhcmFtcyA9IHRoaXMubGl2ZVNvY2tldC5wYXJhbXModGhpcy5lbClcbiAgICBsZXQgbWFuaWZlc3QgPVxuICAgICAgRE9NLmFsbChkb2N1bWVudCwgYFske3RoaXMuYmluZGluZyhQSFhfVFJBQ0tfU1RBVElDKX1dYClcbiAgICAgICAgLm1hcChub2RlID0+IG5vZGUuc3JjIHx8IG5vZGUuaHJlZikuZmlsdGVyKHVybCA9PiB0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpXG5cbiAgICBpZihtYW5pZmVzdC5sZW5ndGggPiAwKXsgcGFyYW1zW1wiX3RyYWNrX3N0YXRpY1wiXSA9IG1hbmlmZXN0IH1cbiAgICBwYXJhbXNbXCJfbW91bnRzXCJdID0gdGhpcy5qb2luQ291bnRcblxuICAgIHJldHVybiBwYXJhbXNcbiAgfVxuXG4gIGlzQ29ubmVjdGVkKCl7IHJldHVybiB0aGlzLmNoYW5uZWwuY2FuUHVzaCgpIH1cblxuICBnZXRTZXNzaW9uKCl7IHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTikgfVxuXG4gIGdldFN0YXRpYygpe1xuICAgIGxldCB2YWwgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfU1RBVElDKVxuICAgIHJldHVybiB2YWwgPT09IFwiXCIgPyBudWxsIDogdmFsXG4gIH1cblxuICBkZXN0cm95KGNhbGxiYWNrID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIHRoaXMuZGVzdHJveUFsbENoaWxkcmVuKClcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcbiAgICBkZWxldGUgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdXG4gICAgaWYodGhpcy5wYXJlbnQpeyBkZWxldGUgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMucGFyZW50LmlkXVt0aGlzLmlkXSB9XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpXG4gICAgbGV0IG9uRmluaXNoZWQgPSAoKSA9PiB7XG4gICAgICBjYWxsYmFjaygpXG4gICAgICBmb3IobGV0IGlkIGluIHRoaXMudmlld0hvb2tzKXtcbiAgICAgICAgdGhpcy5kZXN0cm95SG9vayh0aGlzLnZpZXdIb29rc1tpZF0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgRE9NLm1hcmtQaHhDaGlsZERlc3Ryb3llZCh0aGlzLmVsKVxuXG4gICAgdGhpcy5sb2coXCJkZXN0cm95ZWRcIiwgKCkgPT4gW1widGhlIGNoaWxkIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50XCJdKVxuICAgIHRoaXMuY2hhbm5lbC5sZWF2ZSgpXG4gICAgICAucmVjZWl2ZShcIm9rXCIsIG9uRmluaXNoZWQpXG4gICAgICAucmVjZWl2ZShcImVycm9yXCIsIG9uRmluaXNoZWQpXG4gICAgICAucmVjZWl2ZShcInRpbWVvdXRcIiwgb25GaW5pc2hlZClcbiAgfVxuXG4gIHNldENvbnRhaW5lckNsYXNzZXMoLi4uY2xhc3Nlcyl7XG4gICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgUEhYX0NPTk5FQ1RFRF9DTEFTUyxcbiAgICAgIFBIWF9ESVNDT05ORUNURURfQ0xBU1MsXG4gICAgICBQSFhfRVJST1JfQ0xBU1NcbiAgICApXG4gICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXMpXG4gIH1cblxuICBzaG93TG9hZGVyKHRpbWVvdXQpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmxvYWRlclRpbWVyKVxuICAgIGlmKHRpbWVvdXQpe1xuICAgICAgdGhpcy5sb2FkZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zaG93TG9hZGVyKCksIHRpbWVvdXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcihsZXQgaWQgaW4gdGhpcy52aWV3SG9va3MpeyB0aGlzLnZpZXdIb29rc1tpZF0uX19kaXNjb25uZWN0ZWQoKSB9XG4gICAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUylcbiAgICB9XG4gIH1cblxuICBoaWRlTG9hZGVyKCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpXG4gICAgdGhpcy5zZXRDb250YWluZXJDbGFzc2VzKFBIWF9DT05ORUNURURfQ0xBU1MpXG4gIH1cblxuICB0cmlnZ2VyUmVjb25uZWN0ZWQoKXtcbiAgICBmb3IobGV0IGlkIGluIHRoaXMudmlld0hvb2tzKXsgdGhpcy52aWV3SG9va3NbaWRdLl9fcmVjb25uZWN0ZWQoKSB9XG4gIH1cblxuICBsb2coa2luZCwgbXNnQ2FsbGJhY2spe1xuICAgIHRoaXMubGl2ZVNvY2tldC5sb2codGhpcywga2luZCwgbXNnQ2FsbGJhY2spXG4gIH1cblxuICB0cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSA9IGZ1bmN0aW9uKCl7fSl7XG4gICAgdGhpcy5saXZlU29ja2V0LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKVxuICB9XG5cbiAgd2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsIGNhbGxiYWNrKXtcbiAgICBpZihwaHhUYXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBwaHhUYXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KXtcbiAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQub3duZXIocGh4VGFyZ2V0LCB2aWV3ID0+IGNhbGxiYWNrKHZpZXcsIHBoeFRhcmdldCkpXG4gICAgfVxuXG4gICAgaWYoaXNDaWQocGh4VGFyZ2V0KSl7XG4gICAgICBsZXQgdGFyZ2V0cyA9IERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgcGh4VGFyZ2V0KVxuICAgICAgaWYodGFyZ2V0cy5sZW5ndGggPT09IDApe1xuICAgICAgICBsb2dFcnJvcihgbm8gY29tcG9uZW50IGZvdW5kIG1hdGNoaW5nIHBoeC10YXJnZXQgb2YgJHtwaHhUYXJnZXR9YClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMsIHBhcnNlSW50KHBoeFRhcmdldCkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB0YXJnZXRzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHBoeFRhcmdldCkpXG4gICAgICBpZih0YXJnZXRzLmxlbmd0aCA9PT0gMCl7IGxvZ0Vycm9yKGBub3RoaW5nIGZvdW5kIG1hdGNoaW5nIHRoZSBwaHgtdGFyZ2V0IHNlbGVjdG9yIFwiJHtwaHhUYXJnZXR9XCJgKSB9XG4gICAgICB0YXJnZXRzLmZvckVhY2godGFyZ2V0ID0+IHRoaXMubGl2ZVNvY2tldC5vd25lcih0YXJnZXQsIHZpZXcgPT4gY2FsbGJhY2sodmlldywgdGFyZ2V0KSkpXG4gICAgfVxuICB9XG5cbiAgYXBwbHlEaWZmKHR5cGUsIHJhd0RpZmYsIGNhbGxiYWNrKXtcbiAgICB0aGlzLmxvZyh0eXBlLCAoKSA9PiBbXCJcIiwgY2xvbmUocmF3RGlmZildKVxuICAgIGxldCB7ZGlmZiwgcmVwbHksIGV2ZW50cywgdGl0bGV9ID0gUmVuZGVyZWQuZXh0cmFjdChyYXdEaWZmKVxuICAgIGlmKHRpdGxlKXsgRE9NLnB1dFRpdGxlKHRpdGxlKSB9XG5cbiAgICBjYWxsYmFjayh7ZGlmZiwgcmVwbHksIGV2ZW50c30pXG4gICAgcmV0dXJuIHJlcGx5XG4gIH1cblxuICBvbkpvaW4ocmVzcCl7XG4gICAgbGV0IHtyZW5kZXJlZCwgY29udGFpbmVyfSA9IHJlc3BcbiAgICBpZihjb250YWluZXIpe1xuICAgICAgbGV0IFt0YWcsIGF0dHJzXSA9IGNvbnRhaW5lclxuICAgICAgdGhpcy5lbCA9IERPTS5yZXBsYWNlUm9vdENvbnRhaW5lcih0aGlzLmVsLCB0YWcsIGF0dHJzKVxuICAgIH1cbiAgICB0aGlzLmNoaWxkSm9pbnMgPSAwXG4gICAgdGhpcy5qb2luUGVuZGluZyA9IHRydWVcbiAgICB0aGlzLmZsYXNoID0gbnVsbFxuXG4gICAgQnJvd3Nlci5kcm9wTG9jYWwodGhpcy5saXZlU29ja2V0LmxvY2FsU3RvcmFnZSwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLCBDT05TRUNVVElWRV9SRUxPQURTKVxuICAgIHRoaXMuYXBwbHlEaWZmKFwibW91bnRcIiwgcmVuZGVyZWQsICh7ZGlmZiwgZXZlbnRzfSkgPT4ge1xuICAgICAgdGhpcy5yZW5kZXJlZCA9IG5ldyBSZW5kZXJlZCh0aGlzLmlkLCBkaWZmKVxuICAgICAgbGV0IGh0bWwgPSB0aGlzLnJlbmRlckNvbnRhaW5lcihudWxsLCBcImpvaW5cIilcbiAgICAgIHRoaXMuZHJvcFBlbmRpbmdSZWZzKClcbiAgICAgIGxldCBmb3JtcyA9IHRoaXMuZm9ybXNGb3JSZWNvdmVyeShodG1sKVxuICAgICAgdGhpcy5qb2luQ291bnQrK1xuXG4gICAgICBpZihmb3Jtcy5sZW5ndGggPiAwKXtcbiAgICAgICAgZm9ybXMuZm9yRWFjaCgoW2Zvcm0sIG5ld0Zvcm0sIG5ld0NpZF0sIGkpID0+IHtcbiAgICAgICAgICB0aGlzLnB1c2hGb3JtUmVjb3ZlcnkoZm9ybSwgbmV3Q2lkLCByZXNwID0+IHtcbiAgICAgICAgICAgIGlmKGkgPT09IGZvcm1zLmxlbmd0aCAtIDEpe1xuICAgICAgICAgICAgICB0aGlzLm9uSm9pbkNvbXBsZXRlKHJlc3AsIGh0bWwsIGV2ZW50cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkpvaW5Db21wbGV0ZShyZXNwLCBodG1sLCBldmVudHMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGRyb3BQZW5kaW5nUmVmcygpe1xuICAgIERPTS5hbGwoZG9jdW1lbnQsIGBbJHtQSFhfUkVGX1NSQ309XCIke3RoaXMuaWR9XCJdWyR7UEhYX1JFRn1dYCwgZWwgPT4ge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUYpXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpXG4gICAgfSlcbiAgfVxuXG4gIG9uSm9pbkNvbXBsZXRlKHtsaXZlX3BhdGNofSwgaHRtbCwgZXZlbnRzKXtcbiAgICAvLyBJbiBvcmRlciB0byBwcm92aWRlIGEgYmV0dGVyIGV4cGVyaWVuY2UsIHdlIHdhbnQgdG8gam9pblxuICAgIC8vIGFsbCBMaXZlVmlld3MgZmlyc3QgYW5kIG9ubHkgdGhlbiBhcHBseSB0aGVpciBwYXRjaGVzLlxuICAgIGlmKHRoaXMuam9pbkNvdW50ID4gMSB8fCAodGhpcy5wYXJlbnQgJiYgIXRoaXMucGFyZW50LmlzSm9pblBlbmRpbmcoKSkpe1xuICAgICAgcmV0dXJuIHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgZXZlbnRzKVxuICAgIH1cblxuICAgIC8vIE9uZSBkb3duc2lkZSBvZiB0aGlzIGFwcHJvYWNoIGlzIHRoYXQgd2UgbmVlZCB0byBmaW5kIHBoeENoaWxkcmVuXG4gICAgLy8gaW4gdGhlIGh0bWwgZnJhZ21lbnQsIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIERPTS4gVGhlIGZyYWdtZW50XG4gICAgLy8gYWxzbyBkb2VzIG5vdCBpbmNsdWRlIFBIWF9TVEFUSUMsIHNvIHdlIG5lZWQgdG8gY29weSBpdCBvdmVyIGZyb21cbiAgICAvLyB0aGUgRE9NLlxuICAgIGxldCBuZXdDaGlsZHJlbiA9IERPTS5maW5kUGh4Q2hpbGRyZW5JbkZyYWdtZW50KGh0bWwsIHRoaXMuaWQpLmZpbHRlcih0b0VsID0+IHtcbiAgICAgIGxldCBmcm9tRWwgPSB0b0VsLmlkICYmIHRoaXMuZWwucXVlcnlTZWxlY3RvcihgW2lkPVwiJHt0b0VsLmlkfVwiXWApXG4gICAgICBsZXQgcGh4U3RhdGljID0gZnJvbUVsICYmIGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQylcbiAgICAgIGlmKHBoeFN0YXRpYyl7IHRvRWwuc2V0QXR0cmlidXRlKFBIWF9TVEFUSUMsIHBoeFN0YXRpYykgfVxuICAgICAgcmV0dXJuIHRoaXMuam9pbkNoaWxkKHRvRWwpXG4gICAgfSlcblxuICAgIGlmKG5ld0NoaWxkcmVuLmxlbmd0aCA9PT0gMCl7XG4gICAgICBpZih0aGlzLnBhcmVudCl7XG4gICAgICAgIHRoaXMucm9vdC5wZW5kaW5nSm9pbk9wcy5wdXNoKFt0aGlzLCAoKSA9PiB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIGV2ZW50cyldKVxuICAgICAgICB0aGlzLnBhcmVudC5hY2tKb2luKHRoaXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKClcbiAgICAgICAgdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucm9vdC5wZW5kaW5nSm9pbk9wcy5wdXNoKFt0aGlzLCAoKSA9PiB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIGV2ZW50cyldKVxuICAgIH1cbiAgfVxuXG4gIGF0dGFjaFRydWVEb2NFbCgpe1xuICAgIHRoaXMuZWwgPSBET00uYnlJZCh0aGlzLmlkKVxuICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKFBIWF9ST09UX0lELCB0aGlzLnJvb3QuaWQpXG4gIH1cblxuICBhcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpe1xuICAgIHRoaXMuYXR0YWNoVHJ1ZURvY0VsKClcbiAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgbnVsbClcbiAgICBwYXRjaC5tYXJrUHJ1bmFibGVDb250ZW50Rm9yUmVtb3ZhbCgpXG4gICAgdGhpcy5wZXJmb3JtUGF0Y2gocGF0Y2gsIGZhbHNlKVxuICAgIHRoaXMuam9pbk5ld0NoaWxkcmVuKClcbiAgICBET00uYWxsKHRoaXMuZWwsIGBbJHt0aGlzLmJpbmRpbmcoUEhYX0hPT0spfV0sIFtkYXRhLXBoeC0ke1BIWF9IT09LfV1gLCBob29rRWwgPT4ge1xuICAgICAgbGV0IGhvb2sgPSB0aGlzLmFkZEhvb2soaG9va0VsKVxuICAgICAgaWYoaG9vayl7IGhvb2suX19tb3VudGVkKCkgfVxuICAgIH0pXG5cbiAgICB0aGlzLmpvaW5QZW5kaW5nID0gZmFsc2VcbiAgICB0aGlzLmxpdmVTb2NrZXQuZGlzcGF0Y2hFdmVudHMoZXZlbnRzKVxuICAgIHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpXG5cbiAgICBpZihsaXZlX3BhdGNoKXtcbiAgICAgIGxldCB7a2luZCwgdG99ID0gbGl2ZV9wYXRjaFxuICAgICAgdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlQYXRjaCh0bywga2luZClcbiAgICB9XG4gICAgdGhpcy5oaWRlTG9hZGVyKClcbiAgICBpZih0aGlzLmpvaW5Db3VudCA+IDEpeyB0aGlzLnRyaWdnZXJSZWNvbm5lY3RlZCgpIH1cbiAgICB0aGlzLnN0b3BDYWxsYmFjaygpXG4gIH1cblxuICB0cmlnZ2VyQmVmb3JlVXBkYXRlSG9vayhmcm9tRWwsIHRvRWwpe1xuICAgIHRoaXMubGl2ZVNvY2tldC50cmlnZ2VyRE9NKFwib25CZWZvcmVFbFVwZGF0ZWRcIiwgW2Zyb21FbCwgdG9FbF0pXG4gICAgbGV0IGhvb2sgPSB0aGlzLmdldEhvb2soZnJvbUVsKVxuICAgIGxldCBpc0lnbm9yZWQgPSBob29rICYmIERPTS5pc0lnbm9yZWQoZnJvbUVsLCB0aGlzLmJpbmRpbmcoUEhYX1VQREFURSkpXG4gICAgaWYoaG9vayAmJiAhZnJvbUVsLmlzRXF1YWxOb2RlKHRvRWwpICYmICEoaXNJZ25vcmVkICYmIGlzRXF1YWxPYmooZnJvbUVsLmRhdGFzZXQsIHRvRWwuZGF0YXNldCkpKXtcbiAgICAgIGhvb2suX19iZWZvcmVVcGRhdGUoKVxuICAgICAgcmV0dXJuIGhvb2tcbiAgICB9XG4gIH1cblxuICBwZXJmb3JtUGF0Y2gocGF0Y2gsIHBydW5lQ2lkcyl7XG4gICAgbGV0IHJlbW92ZWRFbHMgPSBbXVxuICAgIGxldCBwaHhDaGlsZHJlbkFkZGVkID0gZmFsc2VcbiAgICBsZXQgdXBkYXRlZEhvb2tJZHMgPSBuZXcgU2V0KClcblxuICAgIHBhdGNoLmFmdGVyKFwiYWRkZWRcIiwgZWwgPT4ge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnRyaWdnZXJET00oXCJvbk5vZGVBZGRlZFwiLCBbZWxdKVxuXG4gICAgICBsZXQgbmV3SG9vayA9IHRoaXMuYWRkSG9vayhlbClcbiAgICAgIGlmKG5ld0hvb2speyBuZXdIb29rLl9fbW91bnRlZCgpIH1cbiAgICB9KVxuXG4gICAgcGF0Y2guYWZ0ZXIoXCJwaHhDaGlsZEFkZGVkXCIsIGVsID0+IHtcbiAgICAgIGlmKERPTS5pc1BoeFN0aWNreShlbCkpe1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQuam9pblJvb3RWaWV3cygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaHhDaGlsZHJlbkFkZGVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5iZWZvcmUoXCJ1cGRhdGVkXCIsIChmcm9tRWwsIHRvRWwpID0+IHtcbiAgICAgIGxldCBob29rID0gdGhpcy50cmlnZ2VyQmVmb3JlVXBkYXRlSG9vayhmcm9tRWwsIHRvRWwpXG4gICAgICBpZihob29rKXsgdXBkYXRlZEhvb2tJZHMuYWRkKGZyb21FbC5pZCkgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5hZnRlcihcInVwZGF0ZWRcIiwgZWwgPT4ge1xuICAgICAgaWYodXBkYXRlZEhvb2tJZHMuaGFzKGVsLmlkKSl7IHRoaXMuZ2V0SG9vayhlbCkuX191cGRhdGVkKCkgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5hZnRlcihcImRpc2NhcmRlZFwiLCAoZWwpID0+IHtcbiAgICAgIGlmKGVsLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSl7IHJlbW92ZWRFbHMucHVzaChlbCkgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5hZnRlcihcInRyYW5zaXRpb25zRGlzY2FyZGVkXCIsIGVscyA9PiB0aGlzLmFmdGVyRWxlbWVudHNSZW1vdmVkKGVscywgcHJ1bmVDaWRzKSlcbiAgICBwYXRjaC5wZXJmb3JtKClcbiAgICB0aGlzLmFmdGVyRWxlbWVudHNSZW1vdmVkKHJlbW92ZWRFbHMsIHBydW5lQ2lkcylcblxuICAgIHJldHVybiBwaHhDaGlsZHJlbkFkZGVkXG4gIH1cblxuICBhZnRlckVsZW1lbnRzUmVtb3ZlZChlbGVtZW50cywgcHJ1bmVDaWRzKXtcbiAgICBsZXQgZGVzdHJveWVkQ0lEcyA9IFtdXG4gICAgZWxlbWVudHMuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgbGV0IGNvbXBvbmVudHMgPSBET00uYWxsKHBhcmVudCwgYFske1BIWF9DT01QT05FTlR9XWApXG4gICAgICBsZXQgaG9va3MgPSBET00uYWxsKHBhcmVudCwgYFske3RoaXMuYmluZGluZyhQSFhfSE9PSyl9XWApXG4gICAgICBjb21wb25lbnRzLmNvbmNhdChwYXJlbnQpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBsZXQgY2lkID0gdGhpcy5jb21wb25lbnRJRChlbClcbiAgICAgICAgaWYoaXNDaWQoY2lkKSAmJiBkZXN0cm95ZWRDSURzLmluZGV4T2YoY2lkKSA9PT0gLTEpeyBkZXN0cm95ZWRDSURzLnB1c2goY2lkKSB9XG4gICAgICB9KVxuICAgICAgaG9va3MuY29uY2F0KHBhcmVudCkuZm9yRWFjaChob29rRWwgPT4ge1xuICAgICAgICBsZXQgaG9vayA9IHRoaXMuZ2V0SG9vayhob29rRWwpXG4gICAgICAgIGhvb2sgJiYgdGhpcy5kZXN0cm95SG9vayhob29rKVxuICAgICAgfSlcbiAgICB9KVxuICAgIC8vIFdlIHNob3VsZCBub3QgcHJ1bmVDaWRzIG9uIGpvaW5zLiBPdGhlcndpc2UsIGluIGNhc2Ugb2ZcbiAgICAvLyByZWpvaW5zLCB3ZSBtYXkgbm90aWZ5IGNpZHMgdGhhdCBubyBsb25nZXIgYmVsb25nIHRvIHRoZVxuICAgIC8vIGN1cnJlbnQgTGl2ZVZpZXcgdG8gYmUgcmVtb3ZlZC5cbiAgICBpZihwcnVuZUNpZHMpe1xuICAgICAgdGhpcy5tYXliZVB1c2hDb21wb25lbnRzRGVzdHJveWVkKGRlc3Ryb3llZENJRHMpXG4gICAgfVxuICB9XG5cbiAgam9pbk5ld0NoaWxkcmVuKCl7XG4gICAgRE9NLmZpbmRQaHhDaGlsZHJlbih0aGlzLmVsLCB0aGlzLmlkKS5mb3JFYWNoKGVsID0+IHRoaXMuam9pbkNoaWxkKGVsKSlcbiAgfVxuXG4gIGdldENoaWxkQnlJZChpZCl7IHJldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1baWRdIH1cblxuICBnZXREZXNjZW5kZW50QnlFbChlbCl7XG4gICAgaWYoZWwuaWQgPT09IHRoaXMuaWQpe1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bZWwuZ2V0QXR0cmlidXRlKFBIWF9QQVJFTlRfSUQpXVtlbC5pZF1cbiAgICB9XG4gIH1cblxuICBkZXN0cm95RGVzY2VuZGVudChpZCl7XG4gICAgZm9yKGxldCBwYXJlbnRJZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW4pe1xuICAgICAgZm9yKGxldCBjaGlsZElkIGluIHRoaXMucm9vdC5jaGlsZHJlbltwYXJlbnRJZF0pe1xuICAgICAgICBpZihjaGlsZElkID09PSBpZCl7IHJldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bcGFyZW50SWRdW2NoaWxkSWRdLmRlc3Ryb3koKSB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgam9pbkNoaWxkKGVsKXtcbiAgICBsZXQgY2hpbGQgPSB0aGlzLmdldENoaWxkQnlJZChlbC5pZClcbiAgICBpZighY2hpbGQpe1xuICAgICAgbGV0IHZpZXcgPSBuZXcgVmlldyhlbCwgdGhpcy5saXZlU29ja2V0LCB0aGlzKVxuICAgICAgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdW3ZpZXcuaWRdID0gdmlld1xuICAgICAgdmlldy5qb2luKClcbiAgICAgIHRoaXMuY2hpbGRKb2lucysrXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGlzSm9pblBlbmRpbmcoKXsgcmV0dXJuIHRoaXMuam9pblBlbmRpbmcgfVxuXG4gIGFja0pvaW4oX2NoaWxkKXtcbiAgICB0aGlzLmNoaWxkSm9pbnMtLVxuXG4gICAgaWYodGhpcy5jaGlsZEpvaW5zID09PSAwKXtcbiAgICAgIGlmKHRoaXMucGFyZW50KXtcbiAgICAgICAgdGhpcy5wYXJlbnQuYWNrSm9pbih0aGlzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkFsbENoaWxkSm9pbnNDb21wbGV0ZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKXtcbiAgICB0aGlzLmpvaW5DYWxsYmFjaygoKSA9PiB7XG4gICAgICB0aGlzLnBlbmRpbmdKb2luT3BzLmZvckVhY2goKFt2aWV3LCBvcF0pID0+IHtcbiAgICAgICAgaWYoIXZpZXcuaXNEZXN0cm95ZWQoKSl7IG9wKCkgfVxuICAgICAgfSlcbiAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMgPSBbXVxuICAgIH0pXG4gIH1cblxuICB1cGRhdGUoZGlmZiwgZXZlbnRzKXtcbiAgICBpZih0aGlzLmlzSm9pblBlbmRpbmcoKSB8fCAodGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkgJiYgIURPTS5pc1BoeFN0aWNreSh0aGlzLmVsKSkpe1xuICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goe2RpZmYsIGV2ZW50c30pXG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlZC5tZXJnZURpZmYoZGlmZilcbiAgICBsZXQgcGh4Q2hpbGRyZW5BZGRlZCA9IGZhbHNlXG5cbiAgICAvLyBXaGVuIHRoZSBkaWZmIG9ubHkgY29udGFpbnMgY29tcG9uZW50IGRpZmZzLCB0aGVuIHdhbGsgY29tcG9uZW50c1xuICAgIC8vIGFuZCBwYXRjaCBvbmx5IHRoZSBwYXJlbnQgY29tcG9uZW50IGNvbnRhaW5lcnMgZm91bmQgaW4gdGhlIGRpZmYuXG4gICAgLy8gT3RoZXJ3aXNlLCBwYXRjaCBlbnRpcmUgTFYgY29udGFpbmVyLlxuICAgIGlmKHRoaXMucmVuZGVyZWQuaXNDb21wb25lbnRPbmx5RGlmZihkaWZmKSl7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudGltZShcImNvbXBvbmVudCBwYXRjaCBjb21wbGV0ZVwiLCAoKSA9PiB7XG4gICAgICAgIGxldCBwYXJlbnRDaWRzID0gRE9NLmZpbmRQYXJlbnRDSURzKHRoaXMuZWwsIHRoaXMucmVuZGVyZWQuY29tcG9uZW50Q0lEcyhkaWZmKSlcbiAgICAgICAgcGFyZW50Q2lkcy5mb3JFYWNoKHBhcmVudENJRCA9PiB7XG4gICAgICAgICAgaWYodGhpcy5jb21wb25lbnRQYXRjaCh0aGlzLnJlbmRlcmVkLmdldENvbXBvbmVudChkaWZmLCBwYXJlbnRDSUQpLCBwYXJlbnRDSUQpKXsgcGh4Q2hpbGRyZW5BZGRlZCA9IHRydWUgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYoIWlzRW1wdHkoZGlmZikpe1xuICAgICAgdGhpcy5saXZlU29ja2V0LnRpbWUoXCJmdWxsIHBhdGNoIGNvbXBsZXRlXCIsICgpID0+IHtcbiAgICAgICAgbGV0IGh0bWwgPSB0aGlzLnJlbmRlckNvbnRhaW5lcihkaWZmLCBcInVwZGF0ZVwiKVxuICAgICAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgbnVsbClcbiAgICAgICAgcGh4Q2hpbGRyZW5BZGRlZCA9IHRoaXMucGVyZm9ybVBhdGNoKHBhdGNoLCB0cnVlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmxpdmVTb2NrZXQuZGlzcGF0Y2hFdmVudHMoZXZlbnRzKVxuICAgIGlmKHBoeENoaWxkcmVuQWRkZWQpeyB0aGlzLmpvaW5OZXdDaGlsZHJlbigpIH1cbiAgfVxuXG4gIHJlbmRlckNvbnRhaW5lcihkaWZmLCBraW5kKXtcbiAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LnRpbWUoYHRvU3RyaW5nIGRpZmYgKCR7a2luZH0pYCwgKCkgPT4ge1xuICAgICAgbGV0IHRhZyA9IHRoaXMuZWwudGFnTmFtZVxuICAgICAgLy8gRG9uJ3Qgc2tpcCBhbnkgY29tcG9uZW50IGluIHRoZSBkaWZmIG5vciBhbnkgbWFya2VkIGFzIHBydW5lZFxuICAgICAgLy8gKGFzIHRoZXkgbWF5IGhhdmUgYmVlbiBhZGRlZCBiYWNrKVxuICAgICAgbGV0IGNpZHMgPSBkaWZmID8gdGhpcy5yZW5kZXJlZC5jb21wb25lbnRDSURzKGRpZmYpLmNvbmNhdCh0aGlzLnBydW5pbmdDSURzKSA6IG51bGxcbiAgICAgIGxldCBodG1sID0gdGhpcy5yZW5kZXJlZC50b1N0cmluZyhjaWRzKVxuICAgICAgcmV0dXJuIGA8JHt0YWd9PiR7aHRtbH08LyR7dGFnfT5gXG4gICAgfSlcbiAgfVxuXG4gIGNvbXBvbmVudFBhdGNoKGRpZmYsIGNpZCl7XG4gICAgaWYoaXNFbXB0eShkaWZmKSkgcmV0dXJuIGZhbHNlXG4gICAgbGV0IGh0bWwgPSB0aGlzLnJlbmRlcmVkLmNvbXBvbmVudFRvU3RyaW5nKGNpZClcbiAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgY2lkKVxuICAgIGxldCBjaGlsZHJlbkFkZGVkID0gdGhpcy5wZXJmb3JtUGF0Y2gocGF0Y2gsIHRydWUpXG4gICAgcmV0dXJuIGNoaWxkcmVuQWRkZWRcbiAgfVxuXG4gIGdldEhvb2soZWwpeyByZXR1cm4gdGhpcy52aWV3SG9va3NbVmlld0hvb2suZWxlbWVudElEKGVsKV0gfVxuXG4gIGFkZEhvb2soZWwpe1xuICAgIGlmKFZpZXdIb29rLmVsZW1lbnRJRChlbCkgfHwgIWVsLmdldEF0dHJpYnV0ZSl7IHJldHVybiB9XG4gICAgbGV0IGhvb2tOYW1lID0gZWwuZ2V0QXR0cmlidXRlKGBkYXRhLXBoeC0ke1BIWF9IT09LfWApIHx8IGVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0hPT0spKVxuICAgIGlmKGhvb2tOYW1lICYmICF0aGlzLm93bnNFbGVtZW50KGVsKSl7IHJldHVybiB9XG4gICAgbGV0IGNhbGxiYWNrcyA9IHRoaXMubGl2ZVNvY2tldC5nZXRIb29rQ2FsbGJhY2tzKGhvb2tOYW1lKVxuXG4gICAgaWYoY2FsbGJhY2tzKXtcbiAgICAgIGlmKCFlbC5pZCl7IGxvZ0Vycm9yKGBubyBET00gSUQgZm9yIGhvb2sgXCIke2hvb2tOYW1lfVwiLiBIb29rcyByZXF1aXJlIGEgdW5pcXVlIElEIG9uIGVhY2ggZWxlbWVudC5gLCBlbCkgfVxuICAgICAgbGV0IGhvb2sgPSBuZXcgVmlld0hvb2sodGhpcywgZWwsIGNhbGxiYWNrcylcbiAgICAgIHRoaXMudmlld0hvb2tzW1ZpZXdIb29rLmVsZW1lbnRJRChob29rLmVsKV0gPSBob29rXG4gICAgICByZXR1cm4gaG9va1xuICAgIH0gZWxzZSBpZihob29rTmFtZSAhPT0gbnVsbCl7XG4gICAgICBsb2dFcnJvcihgdW5rbm93biBob29rIGZvdW5kIGZvciBcIiR7aG9va05hbWV9XCJgLCBlbClcbiAgICB9XG4gIH1cblxuICBkZXN0cm95SG9vayhob29rKXtcbiAgICBob29rLl9fZGVzdHJveWVkKClcbiAgICBob29rLl9fY2xlYW51cF9fKClcbiAgICBkZWxldGUgdGhpcy52aWV3SG9va3NbVmlld0hvb2suZWxlbWVudElEKGhvb2suZWwpXVxuICB9XG5cbiAgYXBwbHlQZW5kaW5nVXBkYXRlcygpe1xuICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goKHtkaWZmLCBldmVudHN9KSA9PiB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpKVxuICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cbiAgfVxuXG4gIG9uQ2hhbm5lbChldmVudCwgY2Ipe1xuICAgIHRoaXMubGl2ZVNvY2tldC5vbkNoYW5uZWwodGhpcy5jaGFubmVsLCBldmVudCwgcmVzcCA9PiB7XG4gICAgICBpZih0aGlzLmlzSm9pblBlbmRpbmcoKSl7XG4gICAgICAgIHRoaXMucm9vdC5wZW5kaW5nSm9pbk9wcy5wdXNoKFt0aGlzLCAoKSA9PiBjYihyZXNwKV0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiBjYihyZXNwKSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgYmluZENoYW5uZWwoKXtcbiAgICAvLyBUaGUgZGlmZiBldmVudCBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGUgcmVndWxhciB1cGRhdGUgb3BlcmF0aW9ucy5cbiAgICAvLyBBbGwgb3RoZXIgb3BlcmF0aW9ucyBhcmUgcXVldWVkIHRvIGJlIGFwcGxpZWQgb25seSBhZnRlciBqb2luLlxuICAgIHRoaXMubGl2ZVNvY2tldC5vbkNoYW5uZWwodGhpcy5jaGFubmVsLCBcImRpZmZcIiwgKHJhd0RpZmYpID0+IHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgdGhpcy5hcHBseURpZmYoXCJ1cGRhdGVcIiwgcmF3RGlmZiwgKHtkaWZmLCBldmVudHN9KSA9PiB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpKVxuICAgICAgfSlcbiAgICB9KVxuICAgIHRoaXMub25DaGFubmVsKFwicmVkaXJlY3RcIiwgKHt0bywgZmxhc2h9KSA9PiB0aGlzLm9uUmVkaXJlY3Qoe3RvLCBmbGFzaH0pKVxuICAgIHRoaXMub25DaGFubmVsKFwibGl2ZV9wYXRjaFwiLCAocmVkaXIpID0+IHRoaXMub25MaXZlUGF0Y2gocmVkaXIpKVxuICAgIHRoaXMub25DaGFubmVsKFwibGl2ZV9yZWRpcmVjdFwiLCAocmVkaXIpID0+IHRoaXMub25MaXZlUmVkaXJlY3QocmVkaXIpKVxuICAgIHRoaXMuY2hhbm5lbC5vbkVycm9yKHJlYXNvbiA9PiB0aGlzLm9uRXJyb3IocmVhc29uKSlcbiAgICB0aGlzLmNoYW5uZWwub25DbG9zZShyZWFzb24gPT4gdGhpcy5vbkNsb3NlKHJlYXNvbikpXG4gIH1cblxuICBkZXN0cm95QWxsQ2hpbGRyZW4oKXtcbiAgICBmb3IobGV0IGlkIGluIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXSl7XG4gICAgICB0aGlzLmdldENoaWxkQnlJZChpZCkuZGVzdHJveSgpXG4gICAgfVxuICB9XG5cbiAgb25MaXZlUmVkaXJlY3QocmVkaXIpe1xuICAgIGxldCB7dG8sIGtpbmQsIGZsYXNofSA9IHJlZGlyXG4gICAgbGV0IHVybCA9IHRoaXMuZXhwYW5kVVJMKHRvKVxuICAgIHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UmVkaXJlY3QodXJsLCBraW5kLCBmbGFzaClcbiAgfVxuXG4gIG9uTGl2ZVBhdGNoKHJlZGlyKXtcbiAgICBsZXQge3RvLCBraW5kfSA9IHJlZGlyXG4gICAgdGhpcy5ocmVmID0gdGhpcy5leHBhbmRVUkwodG8pXG4gICAgdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlQYXRjaCh0bywga2luZClcbiAgfVxuXG4gIGV4cGFuZFVSTCh0byl7XG4gICAgcmV0dXJuIHRvLnN0YXJ0c1dpdGgoXCIvXCIpID8gYCR7d2luZG93LmxvY2F0aW9uLnByb3RvY29sfS8vJHt3aW5kb3cubG9jYXRpb24uaG9zdH0ke3RvfWAgOiB0b1xuICB9XG5cbiAgb25SZWRpcmVjdCh7dG8sIGZsYXNofSl7IHRoaXMubGl2ZVNvY2tldC5yZWRpcmVjdCh0bywgZmxhc2gpIH1cblxuICBpc0Rlc3Ryb3llZCgpeyByZXR1cm4gdGhpcy5kZXN0cm95ZWQgfVxuXG4gIGpvaW4oY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuaXNNYWluKCkpe1xuICAgICAgdGhpcy5zdG9wQ2FsbGJhY2sgPSB0aGlzLmxpdmVTb2NrZXQud2l0aFBhZ2VMb2FkaW5nKHt0bzogdGhpcy5ocmVmLCBraW5kOiBcImluaXRpYWxcIn0pXG4gICAgfVxuICAgIHRoaXMuam9pbkNhbGxiYWNrID0gKG9uRG9uZSkgPT4ge1xuICAgICAgb25Eb25lID0gb25Eb25lIHx8IGZ1bmN0aW9uKCl7fVxuICAgICAgY2FsbGJhY2sgPyBjYWxsYmFjayh0aGlzLmpvaW5Db3VudCwgb25Eb25lKSA6IG9uRG9uZSgpXG4gICAgfVxuICAgIHRoaXMubGl2ZVNvY2tldC53cmFwUHVzaCh0aGlzLCB7dGltZW91dDogZmFsc2V9LCAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFubmVsLmpvaW4oKVxuICAgICAgICAucmVjZWl2ZShcIm9rXCIsIGRhdGEgPT4ge1xuICAgICAgICAgIGlmKCF0aGlzLmlzRGVzdHJveWVkKCkpe1xuICAgICAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4gdGhpcy5vbkpvaW4oZGF0YSkpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAucmVjZWl2ZShcImVycm9yXCIsIHJlc3AgPT4gIXRoaXMuaXNEZXN0cm95ZWQoKSAmJiB0aGlzLm9uSm9pbkVycm9yKHJlc3ApKVxuICAgICAgICAucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4gIXRoaXMuaXNEZXN0cm95ZWQoKSAmJiB0aGlzLm9uSm9pbkVycm9yKHtyZWFzb246IFwidGltZW91dFwifSkpXG4gICAgfSlcbiAgfVxuXG4gIG9uSm9pbkVycm9yKHJlc3Ape1xuICAgIGlmKHJlc3AucmVhc29uID09PSBcInVuYXV0aG9yaXplZFwiIHx8IHJlc3AucmVhc29uID09PSBcInN0YWxlXCIpe1xuICAgICAgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ1bmF1dGhvcml6ZWQgbGl2ZV9yZWRpcmVjdC4gRmFsbGluZyBiYWNrIHRvIHBhZ2UgcmVxdWVzdFwiLCByZXNwXSlcbiAgICAgIHJldHVybiB0aGlzLm9uUmVkaXJlY3Qoe3RvOiB0aGlzLmhyZWZ9KVxuICAgIH1cbiAgICBpZihyZXNwLnJlZGlyZWN0IHx8IHJlc3AubGl2ZV9yZWRpcmVjdCl7XG4gICAgICB0aGlzLmpvaW5QZW5kaW5nID0gZmFsc2VcbiAgICAgIHRoaXMuY2hhbm5lbC5sZWF2ZSgpXG4gICAgfVxuICAgIGlmKHJlc3AucmVkaXJlY3QpeyByZXR1cm4gdGhpcy5vblJlZGlyZWN0KHJlc3AucmVkaXJlY3QpIH1cbiAgICBpZihyZXNwLmxpdmVfcmVkaXJlY3QpeyByZXR1cm4gdGhpcy5vbkxpdmVSZWRpcmVjdChyZXNwLmxpdmVfcmVkaXJlY3QpIH1cbiAgICB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtcInVuYWJsZSB0byBqb2luXCIsIHJlc3BdKVxuICAgIGlmKHRoaXMubGl2ZVNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5saXZlU29ja2V0LnJlbG9hZFdpdGhKaXR0ZXIodGhpcykgfVxuICB9XG5cbiAgb25DbG9zZShyZWFzb24pe1xuICAgIGlmKHRoaXMuaXNEZXN0cm95ZWQoKSl7IHJldHVybiB9XG4gICAgaWYodGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkgJiYgcmVhc29uICE9PSBcImxlYXZlXCIpe1xuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5yZWxvYWRXaXRoSml0dGVyKHRoaXMpXG4gICAgfVxuICAgIHRoaXMuZGVzdHJveUFsbENoaWxkcmVuKClcbiAgICB0aGlzLmxpdmVTb2NrZXQuZHJvcEFjdGl2ZUVsZW1lbnQodGhpcylcbiAgICAvLyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiBiZSBudWxsIGluIEludGVybmV0IEV4cGxvcmVyIDExXG4gICAgaWYoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCl7IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpIH1cbiAgICBpZih0aGlzLmxpdmVTb2NrZXQuaXNVbmxvYWRlZCgpKXtcbiAgICAgIHRoaXMuc2hvd0xvYWRlcihCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VUKVxuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IocmVhc29uKXtcbiAgICB0aGlzLm9uQ2xvc2UocmVhc29uKVxuICAgIGlmKHRoaXMubGl2ZVNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ2aWV3IGNyYXNoZWRcIiwgcmVhc29uXSkgfVxuICAgIGlmKCF0aGlzLmxpdmVTb2NrZXQuaXNVbmxvYWRlZCgpKXsgdGhpcy5kaXNwbGF5RXJyb3IoKSB9XG4gIH1cblxuICBkaXNwbGF5RXJyb3IoKXtcbiAgICBpZih0aGlzLmlzTWFpbigpKXsgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIiwge2RldGFpbDoge3RvOiB0aGlzLmhyZWYsIGtpbmQ6IFwiZXJyb3JcIn19KSB9XG4gICAgdGhpcy5zaG93TG9hZGVyKClcbiAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUywgUEhYX0VSUk9SX0NMQVNTKVxuICB9XG5cbiAgcHVzaFdpdGhSZXBseShyZWZHZW5lcmF0b3IsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5ID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuXG4gICAgbGV0IFtyZWYsIFtlbF0sIG9wdHNdID0gcmVmR2VuZXJhdG9yID8gcmVmR2VuZXJhdG9yKCkgOiBbbnVsbCwgW10sIHt9XVxuICAgIGxldCBvbkxvYWRpbmdEb25lID0gZnVuY3Rpb24oKXsgfVxuICAgIGlmKG9wdHMucGFnZV9sb2FkaW5nIHx8IChlbCAmJiAoZWwuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfUEFHRV9MT0FESU5HKSkgIT09IG51bGwpKSl7XG4gICAgICBvbkxvYWRpbmdEb25lID0gdGhpcy5saXZlU29ja2V0LndpdGhQYWdlTG9hZGluZyh7a2luZDogXCJlbGVtZW50XCIsIHRhcmdldDogZWx9KVxuICAgIH1cblxuICAgIGlmKHR5cGVvZiAocGF5bG9hZC5jaWQpICE9PSBcIm51bWJlclwiKXsgZGVsZXRlIHBheWxvYWQuY2lkIH1cbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5saXZlU29ja2V0LndyYXBQdXNoKHRoaXMsIHt0aW1lb3V0OiB0cnVlfSwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsLnB1c2goZXZlbnQsIHBheWxvYWQsIFBVU0hfVElNRU9VVCkucmVjZWl2ZShcIm9rXCIsIHJlc3AgPT4ge1xuICAgICAgICAgIGlmKHJlZiAhPT0gbnVsbCl7IHRoaXMudW5kb1JlZnMocmVmKSB9XG4gICAgICAgICAgbGV0IGZpbmlzaCA9IChob29rUmVwbHkpID0+IHtcbiAgICAgICAgICAgIGlmKHJlc3AucmVkaXJlY3QpeyB0aGlzLm9uUmVkaXJlY3QocmVzcC5yZWRpcmVjdCkgfVxuICAgICAgICAgICAgaWYocmVzcC5saXZlX3BhdGNoKXsgdGhpcy5vbkxpdmVQYXRjaChyZXNwLmxpdmVfcGF0Y2gpIH1cbiAgICAgICAgICAgIGlmKHJlc3AubGl2ZV9yZWRpcmVjdCl7IHRoaXMub25MaXZlUmVkaXJlY3QocmVzcC5saXZlX3JlZGlyZWN0KSB9XG4gICAgICAgICAgICBvbkxvYWRpbmdEb25lKClcbiAgICAgICAgICAgIG9uUmVwbHkocmVzcCwgaG9va1JlcGx5KVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXNwLmRpZmYpe1xuICAgICAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICBsZXQgaG9va1JlcGx5ID0gdGhpcy5hcHBseURpZmYoXCJ1cGRhdGVcIiwgcmVzcC5kaWZmLCAoe2RpZmYsIGV2ZW50c30pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIGZpbmlzaChob29rUmVwbHkpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaW5pc2gobnVsbClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIHVuZG9SZWZzKHJlZil7XG4gICAgRE9NLmFsbChkb2N1bWVudCwgYFske1BIWF9SRUZfU1JDfT1cIiR7dGhpcy5pZH1cIl1bJHtQSFhfUkVGfT1cIiR7cmVmfVwiXWAsIGVsID0+IHtcbiAgICAgIGxldCBkaXNhYmxlZFZhbCA9IGVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRUQpXG4gICAgICAvLyByZW1vdmUgcmVmc1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUYpXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpXG4gICAgICAvLyByZXN0b3JlIGlucHV0c1xuICAgICAgaWYoZWwuZ2V0QXR0cmlidXRlKFBIWF9SRUFET05MWSkgIT09IG51bGwpe1xuICAgICAgICBlbC5yZWFkT25seSA9IGZhbHNlXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVBRE9OTFkpXG4gICAgICB9XG4gICAgICBpZihkaXNhYmxlZFZhbCAhPT0gbnVsbCl7XG4gICAgICAgIGVsLmRpc2FibGVkID0gZGlzYWJsZWRWYWwgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfRElTQUJMRUQpXG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgY2xhc3Nlc1xuICAgICAgUEhYX0VWRU5UX0NMQVNTRVMuZm9yRWFjaChjbGFzc05hbWUgPT4gRE9NLnJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpKVxuICAgICAgLy8gcmVzdG9yZSBkaXNhYmxlc1xuICAgICAgbGV0IGRpc2FibGVSZXN0b3JlID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSlcbiAgICAgIGlmKGRpc2FibGVSZXN0b3JlICE9PSBudWxsKXtcbiAgICAgICAgZWwuaW5uZXJUZXh0ID0gZGlzYWJsZVJlc3RvcmVcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSlcbiAgICAgIH1cbiAgICAgIGxldCB0b0VsID0gRE9NLnByaXZhdGUoZWwsIFBIWF9SRUYpXG4gICAgICBpZih0b0VsKXtcbiAgICAgICAgbGV0IGhvb2sgPSB0aGlzLnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGVsLCB0b0VsKVxuICAgICAgICBET01QYXRjaC5wYXRjaEVsKGVsLCB0b0VsLCB0aGlzLmxpdmVTb2NrZXQuZ2V0QWN0aXZlRWxlbWVudCgpKVxuICAgICAgICBpZihob29rKXsgaG9vay5fX3VwZGF0ZWQoKSB9XG4gICAgICAgIERPTS5kZWxldGVQcml2YXRlKGVsLCBQSFhfUkVGKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBwdXRSZWYoZWxlbWVudHMsIGV2ZW50LCBvcHRzID0ge30pe1xuICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZisrXG4gICAgbGV0IGRpc2FibGVXaXRoID0gdGhpcy5iaW5kaW5nKFBIWF9ESVNBQkxFX1dJVEgpXG4gICAgaWYob3B0cy5sb2FkaW5nKXsgZWxlbWVudHMgPSBlbGVtZW50cy5jb25jYXQoRE9NLmFsbChkb2N1bWVudCwgb3B0cy5sb2FkaW5nKSl9XG5cbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoYHBoeC0ke2V2ZW50fS1sb2FkaW5nYClcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfUkVGLCBuZXdSZWYpXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRl9TUkMsIHRoaXMuZWwuaWQpXG4gICAgICBsZXQgZGlzYWJsZVRleHQgPSBlbC5nZXRBdHRyaWJ1dGUoZGlzYWJsZVdpdGgpXG4gICAgICBpZihkaXNhYmxlVGV4dCAhPT0gbnVsbCl7XG4gICAgICAgIGlmKCFlbC5nZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFKSl7XG4gICAgICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSwgZWwuaW5uZXJUZXh0KVxuICAgICAgICB9XG4gICAgICAgIGlmKGRpc2FibGVUZXh0ICE9PSBcIlwiKXsgZWwuaW5uZXJUZXh0ID0gZGlzYWJsZVRleHQgfVxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIFtuZXdSZWYsIGVsZW1lbnRzLCBvcHRzXVxuICB9XG5cbiAgY29tcG9uZW50SUQoZWwpe1xuICAgIGxldCBjaWQgPSBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpXG4gICAgcmV0dXJuIGNpZCA/IHBhcnNlSW50KGNpZCkgOiBudWxsXG4gIH1cblxuICB0YXJnZXRDb21wb25lbnRJRCh0YXJnZXQsIHRhcmdldEN0eCwgb3B0cyA9IHt9KXtcbiAgICBpZihpc0NpZCh0YXJnZXRDdHgpKXsgcmV0dXJuIHRhcmdldEN0eCB9XG5cbiAgICBsZXQgY2lkT3JTZWxlY3RvciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwidGFyZ2V0XCIpKVxuICAgIGlmKGlzQ2lkKGNpZE9yU2VsZWN0b3IpKXtcbiAgICAgIHJldHVybiBwYXJzZUludChjaWRPclNlbGVjdG9yKVxuICAgIH0gZWxzZSBpZih0YXJnZXRDdHggJiYgKGNpZE9yU2VsZWN0b3IgIT09IG51bGwgfHwgb3B0cy50YXJnZXQpKXtcbiAgICAgIHJldHVybiB0aGlzLmNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eCl7XG4gICAgaWYoaXNDaWQodGFyZ2V0Q3R4KSl7XG4gICAgICByZXR1cm4gdGFyZ2V0Q3R4XG4gICAgfSBlbHNlIGlmKHRhcmdldEN0eCl7XG4gICAgICByZXR1cm4gbWF5YmUodGFyZ2V0Q3R4LmNsb3Nlc3QoYFske1BIWF9DT01QT05FTlR9XWApLCBlbCA9PiB0aGlzLm93bnNFbGVtZW50KGVsKSAmJiB0aGlzLmNvbXBvbmVudElEKGVsKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBwdXNoSG9va0V2ZW50KHRhcmdldEN0eCwgZXZlbnQsIHBheWxvYWQsIG9uUmVwbHkpe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpe1xuICAgICAgdGhpcy5sb2coXCJob29rXCIsICgpID0+IFtcInVuYWJsZSB0byBwdXNoIGhvb2sgZXZlbnQuIExpdmVWaWV3IG5vdCBjb25uZWN0ZWRcIiwgZXZlbnQsIHBheWxvYWRdKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGxldCBbcmVmLCBlbHMsIG9wdHNdID0gdGhpcy5wdXRSZWYoW10sIFwiaG9va1wiKVxuICAgIHRoaXMucHVzaFdpdGhSZXBseSgoKSA9PiBbcmVmLCBlbHMsIG9wdHNdLCBcImV2ZW50XCIsIHtcbiAgICAgIHR5cGU6IFwiaG9va1wiLFxuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgdmFsdWU6IHBheWxvYWQsXG4gICAgICBjaWQ6IHRoaXMuY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eClcbiAgICB9LCAocmVzcCwgcmVwbHkpID0+IG9uUmVwbHkocmVwbHksIHJlZikpXG5cbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICBleHRyYWN0TWV0YShlbCwgbWV0YSwgdmFsdWUpe1xuICAgIGxldCBwcmVmaXggPSB0aGlzLmJpbmRpbmcoXCJ2YWx1ZS1cIilcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZWwuYXR0cmlidXRlcy5sZW5ndGg7IGkrKyl7XG4gICAgICBpZighbWV0YSl7IG1ldGEgPSB7fSB9XG4gICAgICBsZXQgbmFtZSA9IGVsLmF0dHJpYnV0ZXNbaV0ubmFtZVxuICAgICAgaWYobmFtZS5zdGFydHNXaXRoKHByZWZpeCkpeyBtZXRhW25hbWUucmVwbGFjZShwcmVmaXgsIFwiXCIpXSA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKSB9XG4gICAgfVxuICAgIGlmKGVsLnZhbHVlICE9PSB1bmRlZmluZWQpe1xuICAgICAgaWYoIW1ldGEpeyBtZXRhID0ge30gfVxuICAgICAgbWV0YS52YWx1ZSA9IGVsLnZhbHVlXG5cbiAgICAgIGlmKGVsLnRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiBDSEVDS0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZSkgPj0gMCAmJiAhZWwuY2hlY2tlZCl7XG4gICAgICAgIGRlbGV0ZSBtZXRhLnZhbHVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmKHZhbHVlKXtcbiAgICAgIGlmKCFtZXRhKXsgbWV0YSA9IHt9IH1cbiAgICAgIGZvcihsZXQga2V5IGluIHZhbHVlKXsgbWV0YVtrZXldID0gdmFsdWVba2V5XSB9XG4gICAgfVxuICAgIHJldHVybiBtZXRhXG4gIH1cblxuICBwdXNoRXZlbnQodHlwZSwgZWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIG1ldGEsIG9wdHMgPSB7fSl7XG4gICAgdGhpcy5wdXNoV2l0aFJlcGx5KCgpID0+IHRoaXMucHV0UmVmKFtlbF0sIHR5cGUsIG9wdHMpLCBcImV2ZW50XCIsIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICB2YWx1ZTogdGhpcy5leHRyYWN0TWV0YShlbCwgbWV0YSwgb3B0cy52YWx1ZSksXG4gICAgICBjaWQ6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoZWwsIHRhcmdldEN0eCwgb3B0cylcbiAgICB9KVxuICB9XG5cbiAgcHVzaEZpbGVQcm9ncmVzcyhmaWxlRWwsIGVudHJ5UmVmLCBwcm9ncmVzcywgb25SZXBseSA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICB0aGlzLmxpdmVTb2NrZXQud2l0aGluT3duZXJzKGZpbGVFbC5mb3JtLCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICB2aWV3LnB1c2hXaXRoUmVwbHkobnVsbCwgXCJwcm9ncmVzc1wiLCB7XG4gICAgICAgIGV2ZW50OiBmaWxlRWwuZ2V0QXR0cmlidXRlKHZpZXcuYmluZGluZyhQSFhfUFJPR1JFU1MpKSxcbiAgICAgICAgcmVmOiBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSxcbiAgICAgICAgZW50cnlfcmVmOiBlbnRyeVJlZixcbiAgICAgICAgcHJvZ3Jlc3M6IHByb2dyZXNzLFxuICAgICAgICBjaWQ6IHZpZXcudGFyZ2V0Q29tcG9uZW50SUQoZmlsZUVsLmZvcm0sIHRhcmdldEN0eClcbiAgICAgIH0sIG9uUmVwbHkpXG4gICAgfSlcbiAgfVxuXG4gIHB1c2hJbnB1dChpbnB1dEVsLCB0YXJnZXRDdHgsIGZvcmNlQ2lkLCBwaHhFdmVudCwgb3B0cywgY2FsbGJhY2spe1xuICAgIGxldCB1cGxvYWRzXG4gICAgbGV0IGNpZCA9IGlzQ2lkKGZvcmNlQ2lkKSA/IGZvcmNlQ2lkIDogdGhpcy50YXJnZXRDb21wb25lbnRJRChpbnB1dEVsLmZvcm0sIHRhcmdldEN0eClcbiAgICBsZXQgcmVmR2VuZXJhdG9yID0gKCkgPT4gdGhpcy5wdXRSZWYoW2lucHV0RWwsIGlucHV0RWwuZm9ybV0sIFwiY2hhbmdlXCIsIG9wdHMpXG4gICAgbGV0IGZvcm1EYXRhXG4gICAgaWYoaW5wdXRFbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpKSl7XG4gICAgICBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oaW5wdXRFbC5mb3JtLCB7X3RhcmdldDogb3B0cy5fdGFyZ2V0fSwgW2lucHV0RWwubmFtZV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShpbnB1dEVsLmZvcm0sIHtfdGFyZ2V0OiBvcHRzLl90YXJnZXR9KVxuICAgIH1cbiAgICBpZihET00uaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBpbnB1dEVsLmZpbGVzICYmIGlucHV0RWwuZmlsZXMubGVuZ3RoID4gMCl7XG4gICAgICBMaXZlVXBsb2FkZXIudHJhY2tGaWxlcyhpbnB1dEVsLCBBcnJheS5mcm9tKGlucHV0RWwuZmlsZXMpKVxuICAgIH1cbiAgICB1cGxvYWRzID0gTGl2ZVVwbG9hZGVyLnNlcmlhbGl6ZVVwbG9hZHMoaW5wdXRFbClcbiAgICBsZXQgZXZlbnQgPSB7XG4gICAgICB0eXBlOiBcImZvcm1cIixcbiAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgIHVwbG9hZHM6IHVwbG9hZHMsXG4gICAgICBjaWQ6IGNpZFxuICAgIH1cbiAgICB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuZXJhdG9yLCBcImV2ZW50XCIsIGV2ZW50LCByZXNwID0+IHtcbiAgICAgIERPTS5zaG93RXJyb3IoaW5wdXRFbCwgdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoUEhYX0ZFRURCQUNLX0ZPUikpXG4gICAgICBpZihET00uaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBpbnB1dEVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWF1dG8tdXBsb2FkXCIpICE9PSBudWxsKXtcbiAgICAgICAgaWYoTGl2ZVVwbG9hZGVyLmZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXRFbCkubGVuZ3RoID4gMCl7XG4gICAgICAgICAgbGV0IFtyZWYsIF9lbHNdID0gcmVmR2VuZXJhdG9yKClcbiAgICAgICAgICB0aGlzLnVwbG9hZEZpbGVzKGlucHV0RWwuZm9ybSwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgKF91cGxvYWRzKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwKVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQXdhaXRpbmdTdWJtaXQoaW5wdXRFbC5mb3JtKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3ApXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHRyaWdnZXJBd2FpdGluZ1N1Ym1pdChmb3JtRWwpe1xuICAgIGxldCBhd2FpdGluZ1N1Ym1pdCA9IHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbClcbiAgICBpZihhd2FpdGluZ1N1Ym1pdCl7XG4gICAgICBsZXQgW19lbCwgX3JlZiwgX29wdHMsIGNhbGxiYWNrXSA9IGF3YWl0aW5nU3VibWl0XG4gICAgICB0aGlzLmNhbmNlbFN1Ym1pdChmb3JtRWwpXG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbCl7XG4gICAgcmV0dXJuIHRoaXMuZm9ybVN1Ym1pdHMuZmluZCgoW2VsLCBfcmVmLCBfb3B0cywgX2NhbGxiYWNrXSkgPT4gZWwuaXNTYW1lTm9kZShmb3JtRWwpKVxuICB9XG5cbiAgc2NoZWR1bGVTdWJtaXQoZm9ybUVsLCByZWYsIG9wdHMsIGNhbGxiYWNrKXtcbiAgICBpZih0aGlzLmdldFNjaGVkdWxlZFN1Ym1pdChmb3JtRWwpKXsgcmV0dXJuIHRydWUgfVxuICAgIHRoaXMuZm9ybVN1Ym1pdHMucHVzaChbZm9ybUVsLCByZWYsIG9wdHMsIGNhbGxiYWNrXSlcbiAgfVxuXG4gIGNhbmNlbFN1Ym1pdChmb3JtRWwpe1xuICAgIHRoaXMuZm9ybVN1Ym1pdHMgPSB0aGlzLmZvcm1TdWJtaXRzLmZpbHRlcigoW2VsLCByZWYsIF9jYWxsYmFja10pID0+IHtcbiAgICAgIGlmKGVsLmlzU2FtZU5vZGUoZm9ybUVsKSl7XG4gICAgICAgIHRoaXMudW5kb1JlZnMocmVmKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHB1c2hGb3JtU3VibWl0KGZvcm1FbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgb3B0cywgb25SZXBseSl7XG4gICAgbGV0IGZpbHRlcklnbm9yZWQgPSBlbCA9PiB7XG4gICAgICBsZXQgdXNlcklnbm9yZWQgPSBjbG9zZXN0UGh4QmluZGluZyhlbCwgYCR7dGhpcy5iaW5kaW5nKFBIWF9VUERBVEUpfT1pZ25vcmVgLCBlbC5mb3JtKVxuICAgICAgcmV0dXJuICEodXNlcklnbm9yZWQgfHwgY2xvc2VzdFBoeEJpbmRpbmcoZWwsIFwiZGF0YS1waHgtdXBkYXRlPWlnbm9yZVwiLCBlbC5mb3JtKSlcbiAgICB9XG4gICAgbGV0IGZpbHRlckRpc2FibGVzID0gZWwgPT4ge1xuICAgICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0RJU0FCTEVfV0lUSCkpXG4gICAgfVxuICAgIGxldCBmaWx0ZXJCdXR0b24gPSBlbCA9PiBlbC50YWdOYW1lID09IFwiQlVUVE9OXCJcblxuICAgIGxldCBmaWx0ZXJJbnB1dCA9IGVsID0+IFtcIklOUFVUXCIsIFwiVEVYVEFSRUFcIiwgXCJTRUxFQ1RcIl0uaW5jbHVkZXMoZWwudGFnTmFtZSlcblxuICAgIGxldCByZWZHZW5lcmF0b3IgPSAoKSA9PiB7XG4gICAgICBsZXQgZm9ybUVsZW1lbnRzID0gQXJyYXkuZnJvbShmb3JtRWwuZWxlbWVudHMpXG4gICAgICBsZXQgZGlzYWJsZXMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlckRpc2FibGVzKVxuICAgICAgbGV0IGJ1dHRvbnMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlckJ1dHRvbikuZmlsdGVyKGZpbHRlcklnbm9yZWQpXG4gICAgICBsZXQgaW5wdXRzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJJbnB1dCkuZmlsdGVyKGZpbHRlcklnbm9yZWQpXG5cbiAgICAgIGJ1dHRvbnMuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRCwgYnV0dG9uLmRpc2FibGVkKVxuICAgICAgICBidXR0b24uZGlzYWJsZWQgPSB0cnVlXG4gICAgICB9KVxuICAgICAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX1JFQURPTkxZLCBpbnB1dC5yZWFkT25seSlcbiAgICAgICAgaW5wdXQucmVhZE9ubHkgPSB0cnVlXG4gICAgICAgIGlmKGlucHV0LmZpbGVzKXtcbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBpbnB1dC5kaXNhYmxlZClcbiAgICAgICAgICBpbnB1dC5kaXNhYmxlZCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGZvcm1FbC5zZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9QQUdFX0xPQURJTkcpLCBcIlwiKVxuICAgICAgcmV0dXJuIHRoaXMucHV0UmVmKFtmb3JtRWxdLmNvbmNhdChkaXNhYmxlcykuY29uY2F0KGJ1dHRvbnMpLmNvbmNhdChpbnB1dHMpLCBcInN1Ym1pdFwiLCBvcHRzKVxuICAgIH1cblxuICAgIGxldCBjaWQgPSB0aGlzLnRhcmdldENvbXBvbmVudElEKGZvcm1FbCwgdGFyZ2V0Q3R4KVxuICAgIGlmKExpdmVVcGxvYWRlci5oYXNVcGxvYWRzSW5Qcm9ncmVzcyhmb3JtRWwpKXtcbiAgICAgIGxldCBbcmVmLCBfZWxzXSA9IHJlZkdlbmVyYXRvcigpXG4gICAgICBsZXQgcHVzaCA9ICgpID0+IHRoaXMucHVzaEZvcm1TdWJtaXQoZm9ybUVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzLCBvblJlcGx5KVxuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVTdWJtaXQoZm9ybUVsLCByZWYsIG9wdHMsIHB1c2gpXG4gICAgfSBlbHNlIGlmKExpdmVVcGxvYWRlci5pbnB1dHNBd2FpdGluZ1ByZWZsaWdodChmb3JtRWwpLmxlbmd0aCA+IDApe1xuICAgICAgbGV0IFtyZWYsIGVsc10gPSByZWZHZW5lcmF0b3IoKVxuICAgICAgbGV0IHByb3h5UmVmR2VuID0gKCkgPT4gW3JlZiwgZWxzLCBvcHRzXVxuICAgICAgdGhpcy51cGxvYWRGaWxlcyhmb3JtRWwsIHRhcmdldEN0eCwgcmVmLCBjaWQsIChfdXBsb2FkcykgPT4ge1xuICAgICAgICBsZXQgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGZvcm1FbCwge30pXG4gICAgICAgIHRoaXMucHVzaFdpdGhSZXBseShwcm94eVJlZkdlbiwgXCJldmVudFwiLCB7XG4gICAgICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgICBjaWQ6IGNpZFxuICAgICAgICB9LCBvblJlcGx5KVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShmb3JtRWwsIHt9KVxuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgXCJldmVudFwiLCB7XG4gICAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgY2lkOiBjaWRcbiAgICAgIH0sIG9uUmVwbHkpXG4gICAgfVxuICB9XG5cbiAgdXBsb2FkRmlsZXMoZm9ybUVsLCB0YXJnZXRDdHgsIHJlZiwgY2lkLCBvbkNvbXBsZXRlKXtcbiAgICBsZXQgam9pbkNvdW50QXRVcGxvYWQgPSB0aGlzLmpvaW5Db3VudFxuICAgIGxldCBpbnB1dEVscyA9IExpdmVVcGxvYWRlci5hY3RpdmVGaWxlSW5wdXRzKGZvcm1FbClcbiAgICBsZXQgbnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MgPSBpbnB1dEVscy5sZW5ndGhcblxuICAgIC8vIGdldCBlYWNoIGZpbGUgaW5wdXRcbiAgICBpbnB1dEVscy5mb3JFYWNoKGlucHV0RWwgPT4ge1xuICAgICAgbGV0IHVwbG9hZGVyID0gbmV3IExpdmVVcGxvYWRlcihpbnB1dEVsLCB0aGlzLCAoKSA9PiB7XG4gICAgICAgIG51bUZpbGVJbnB1dHNJblByb2dyZXNzLS1cbiAgICAgICAgaWYobnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MgPT09IDApeyBvbkNvbXBsZXRlKCkgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMudXBsb2FkZXJzW2lucHV0RWxdID0gdXBsb2FkZXJcbiAgICAgIGxldCBlbnRyaWVzID0gdXBsb2FkZXIuZW50cmllcygpLm1hcChlbnRyeSA9PiBlbnRyeS50b1ByZWZsaWdodFBheWxvYWQoKSlcblxuICAgICAgbGV0IHBheWxvYWQgPSB7XG4gICAgICAgIHJlZjogaW5wdXRFbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpLFxuICAgICAgICBlbnRyaWVzOiBlbnRyaWVzLFxuICAgICAgICBjaWQ6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoaW5wdXRFbC5mb3JtLCB0YXJnZXRDdHgpXG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nKFwidXBsb2FkXCIsICgpID0+IFtcInNlbmRpbmcgcHJlZmxpZ2h0IHJlcXVlc3RcIiwgcGF5bG9hZF0pXG5cbiAgICAgIHRoaXMucHVzaFdpdGhSZXBseShudWxsLCBcImFsbG93X3VwbG9hZFwiLCBwYXlsb2FkLCByZXNwID0+IHtcbiAgICAgICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW1wiZ290IHByZWZsaWdodCByZXNwb25zZVwiLCByZXNwXSlcbiAgICAgICAgaWYocmVzcC5lcnJvcil7XG4gICAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYpXG4gICAgICAgICAgbGV0IFtlbnRyeV9yZWYsIHJlYXNvbl0gPSByZXNwLmVycm9yXG4gICAgICAgICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW2BlcnJvciBmb3IgZW50cnkgJHtlbnRyeV9yZWZ9YCwgcmVhc29uXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgb25FcnJvciA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLm9uRXJyb3IoKCkgPT4ge1xuICAgICAgICAgICAgICBpZih0aGlzLmpvaW5Db3VudCA9PT0gam9pbkNvdW50QXRVcGxvYWQpeyBjYWxsYmFjaygpIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIHVwbG9hZGVyLmluaXRBZGFwdGVyVXBsb2FkKHJlc3AsIG9uRXJyb3IsIHRoaXMubGl2ZVNvY2tldClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgZGlzcGF0Y2hVcGxvYWRzKG5hbWUsIGZpbGVzT3JCbG9icyl7XG4gICAgbGV0IGlucHV0cyA9IERPTS5maW5kVXBsb2FkSW5wdXRzKHRoaXMuZWwpLmZpbHRlcihlbCA9PiBlbC5uYW1lID09PSBuYW1lKVxuICAgIGlmKGlucHV0cy5sZW5ndGggPT09IDApeyBsb2dFcnJvcihgbm8gbGl2ZSBmaWxlIGlucHV0cyBmb3VuZCBtYXRjaGluZyB0aGUgbmFtZSBcIiR7bmFtZX1cImApIH1cbiAgICBlbHNlIGlmKGlucHV0cy5sZW5ndGggPiAxKXsgbG9nRXJyb3IoYGR1cGxpY2F0ZSBsaXZlIGZpbGUgaW5wdXRzIGZvdW5kIG1hdGNoaW5nIHRoZSBuYW1lIFwiJHtuYW1lfVwiYCkgfVxuICAgIGVsc2UgeyBET00uZGlzcGF0Y2hFdmVudChpbnB1dHNbMF0sIFBIWF9UUkFDS19VUExPQURTLCB7ZGV0YWlsOiB7ZmlsZXM6IGZpbGVzT3JCbG9ic319KSB9XG4gIH1cblxuICBwdXNoRm9ybVJlY292ZXJ5KGZvcm0sIG5ld0NpZCwgY2FsbGJhY2spe1xuICAgIHRoaXMubGl2ZVNvY2tldC53aXRoaW5Pd25lcnMoZm9ybSwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgbGV0IGlucHV0ID0gZm9ybS5lbGVtZW50c1swXVxuICAgICAgbGV0IHBoeEV2ZW50ID0gZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSB8fCBmb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpXG5cbiAgICAgIEpTLmV4ZWMoXCJjaGFuZ2VcIiwgcGh4RXZlbnQsIHZpZXcsIGlucHV0LCBbXCJwdXNoXCIsIHtfdGFyZ2V0OiBpbnB1dC5uYW1lLCBuZXdDaWQ6IG5ld0NpZCwgY2FsbGJhY2s6IGNhbGxiYWNrfV0pXG4gICAgfSlcbiAgfVxuXG4gIHB1c2hMaW5rUGF0Y2goaHJlZiwgdGFyZ2V0RWwsIGNhbGxiYWNrKXtcbiAgICBsZXQgbGlua1JlZiA9IHRoaXMubGl2ZVNvY2tldC5zZXRQZW5kaW5nTGluayhocmVmKVxuICAgIGxldCByZWZHZW4gPSB0YXJnZXRFbCA/ICgpID0+IHRoaXMucHV0UmVmKFt0YXJnZXRFbF0sIFwiY2xpY2tcIikgOiBudWxsXG4gICAgbGV0IGZhbGxiYWNrID0gKCkgPT4gdGhpcy5saXZlU29ja2V0LnJlZGlyZWN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuXG4gICAgbGV0IHB1c2ggPSB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuLCBcImxpdmVfcGF0Y2hcIiwge3VybDogaHJlZn0sIHJlc3AgPT4ge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBpZihyZXNwLmxpbmtfcmVkaXJlY3Qpe1xuICAgICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXBsYWNlTWFpbihocmVmLCBudWxsLCBjYWxsYmFjaywgbGlua1JlZilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZih0aGlzLmxpdmVTb2NrZXQuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpe1xuICAgICAgICAgICAgdGhpcy5ocmVmID0gaHJlZlxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFwcGx5UGVuZGluZ1VwZGF0ZXMoKVxuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGxpbmtSZWYpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGlmKHB1c2gpe1xuICAgICAgcHVzaC5yZWNlaXZlKFwidGltZW91dFwiLCBmYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgZmFsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIGZvcm1zRm9yUmVjb3ZlcnkoaHRtbCl7XG4gICAgaWYodGhpcy5qb2luQ291bnQgPT09IDApeyByZXR1cm4gW10gfVxuXG4gICAgbGV0IHBoeENoYW5nZSA9IHRoaXMuYmluZGluZyhcImNoYW5nZVwiKVxuICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWxcblxuICAgIHJldHVybiAoXG4gICAgICBET00uYWxsKHRoaXMuZWwsIGBmb3JtWyR7cGh4Q2hhbmdlfV1gKVxuICAgICAgICAuZmlsdGVyKGZvcm0gPT4gZm9ybS5pZCAmJiB0aGlzLm93bnNFbGVtZW50KGZvcm0pKVxuICAgICAgICAuZmlsdGVyKGZvcm0gPT4gZm9ybS5lbGVtZW50cy5sZW5ndGggPiAwKVxuICAgICAgICAuZmlsdGVyKGZvcm0gPT4gZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSAhPT0gXCJpZ25vcmVcIilcbiAgICAgICAgLm1hcChmb3JtID0+IHtcbiAgICAgICAgICBsZXQgbmV3Rm9ybSA9IHRlbXBsYXRlLmNvbnRlbnQucXVlcnlTZWxlY3RvcihgZm9ybVtpZD1cIiR7Zm9ybS5pZH1cIl1bJHtwaHhDaGFuZ2V9PVwiJHtmb3JtLmdldEF0dHJpYnV0ZShwaHhDaGFuZ2UpfVwiXWApXG4gICAgICAgICAgaWYobmV3Rm9ybSl7XG4gICAgICAgICAgICByZXR1cm4gW2Zvcm0sIG5ld0Zvcm0sIHRoaXMudGFyZ2V0Q29tcG9uZW50SUQobmV3Rm9ybSldXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbZm9ybSwgbnVsbCwgbnVsbF1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoKFtmb3JtLCBuZXdGb3JtLCBuZXdDaWRdKSA9PiBuZXdGb3JtKVxuICAgIClcbiAgfVxuXG4gIG1heWJlUHVzaENvbXBvbmVudHNEZXN0cm95ZWQoZGVzdHJveWVkQ0lEcyl7XG4gICAgbGV0IHdpbGxEZXN0cm95Q0lEcyA9IGRlc3Ryb3llZENJRHMuZmlsdGVyKGNpZCA9PiB7XG4gICAgICByZXR1cm4gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLCBjaWQpLmxlbmd0aCA9PT0gMFxuICAgIH0pXG4gICAgaWYod2lsbERlc3Ryb3lDSURzLmxlbmd0aCA+IDApe1xuICAgICAgdGhpcy5wcnVuaW5nQ0lEcy5wdXNoKC4uLndpbGxEZXN0cm95Q0lEcylcblxuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiY2lkc193aWxsX2Rlc3Ryb3lcIiwge2NpZHM6IHdpbGxEZXN0cm95Q0lEc30sICgpID0+IHtcbiAgICAgICAgLy8gVGhlIGNpZHMgYXJlIGVpdGhlciBiYWNrIG9uIHRoZSBwYWdlIG9yIHRoZXkgd2lsbCBiZSBmdWxseSByZW1vdmVkLFxuICAgICAgICAvLyBzbyB3ZSBjYW4gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgcHJ1bmluZ0NJRHMuXG4gICAgICAgIHRoaXMucHJ1bmluZ0NJRHMgPSB0aGlzLnBydW5pbmdDSURzLmZpbHRlcihjaWQgPT4gd2lsbERlc3Ryb3lDSURzLmluZGV4T2YoY2lkKSAhPT0gLTEpXG5cbiAgICAgICAgLy8gU2VlIGlmIGFueSBvZiB0aGUgY2lkcyB3ZSB3YW50ZWQgdG8gZGVzdHJveSB3ZXJlIGFkZGVkIGJhY2ssXG4gICAgICAgIC8vIGlmIHRoZXkgd2VyZSBhZGRlZCBiYWNrLCB3ZSBkb24ndCBhY3R1YWxseSBkZXN0cm95IHRoZW0uXG4gICAgICAgIGxldCBjb21wbGV0ZWx5RGVzdHJveUNJRHMgPSB3aWxsRGVzdHJveUNJRHMuZmlsdGVyKGNpZCA9PiB7XG4gICAgICAgICAgcmV0dXJuIERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgY2lkKS5sZW5ndGggPT09IDBcbiAgICAgICAgfSlcblxuICAgICAgICBpZihjb21wbGV0ZWx5RGVzdHJveUNJRHMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiY2lkc19kZXN0cm95ZWRcIiwge2NpZHM6IGNvbXBsZXRlbHlEZXN0cm95Q0lEc30sIChyZXNwKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVkLnBydW5lQ0lEcyhyZXNwLmNpZHMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBvd25zRWxlbWVudChlbCl7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShQSFhfUEFSRU5UX0lEKSA9PT0gdGhpcy5pZCB8fFxuICAgICAgbWF5YmUoZWwuY2xvc2VzdChQSFhfVklFV19TRUxFQ1RPUiksIG5vZGUgPT4gbm9kZS5pZCkgPT09IHRoaXMuaWRcbiAgfVxuXG4gIHN1Ym1pdEZvcm0oZm9ybSwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgb3B0cyA9IHt9KXtcbiAgICBET00ucHV0UHJpdmF0ZShmb3JtLCBQSFhfSEFTX1NVQk1JVFRFRCwgdHJ1ZSlcbiAgICBsZXQgcGh4RmVlZGJhY2sgPSB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhQSFhfRkVFREJBQ0tfRk9SKVxuICAgIGxldCBpbnB1dHMgPSBBcnJheS5mcm9tKGZvcm0uZWxlbWVudHMpXG4gICAgdGhpcy5saXZlU29ja2V0LmJsdXJBY3RpdmVFbGVtZW50KHRoaXMpXG4gICAgdGhpcy5wdXNoRm9ybVN1Ym1pdChmb3JtLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzLCAoKSA9PiB7XG4gICAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBET00uc2hvd0Vycm9yKGlucHV0LCBwaHhGZWVkYmFjaykpXG4gICAgICB0aGlzLmxpdmVTb2NrZXQucmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1cygpXG4gICAgfSlcbiAgfVxuXG4gIGJpbmRpbmcoa2luZCl7IHJldHVybiB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhraW5kKSB9XG59XG4iLCAiLyoqIEluaXRpYWxpemVzIHRoZSBMaXZlU29ja2V0XG4gKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRQb2ludCAtIFRoZSBzdHJpbmcgV2ViU29ja2V0IGVuZHBvaW50LCBpZSwgYFwid3NzOi8vZXhhbXBsZS5jb20vbGl2ZVwiYCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXCIvbGl2ZVwiYCAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAqIEBwYXJhbSB7UGhvZW5peC5Tb2NrZXR9IHNvY2tldCAtIHRoZSByZXF1aXJlZCBQaG9lbml4IFNvY2tldCBjbGFzcyBpbXBvcnRlZCBmcm9tIFwicGhvZW5peFwiLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbiAqICAgICBpbXBvcnQge0xpdmVTb2NrZXR9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXG4gKiAgICAgbGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwgey4uLn0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24uIE91dHNpZGUgb2Yga2V5cyBsaXN0ZWQgYmVsb3csIGFsbFxuICogY29uZmlndXJhdGlvbiBpcyBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIFBob2VuaXggU29ja2V0IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmRlZmF1bHRzXSAtIFRoZSBvcHRpb25hbCBkZWZhdWx0cyB0byB1c2UgZm9yIHZhcmlvdXMgYmluZGluZ3MsXG4gKiBzdWNoIGFzIGBwaHgtZGVib3VuY2VgLiBTdXBwb3J0cyB0aGUgZm9sbG93aW5nIGtleXM6XG4gKlxuICogICAtIGRlYm91bmNlIC0gdGhlIG1pbGxpc2Vjb25kIHBoeC1kZWJvdW5jZSB0aW1lLiBEZWZhdWx0cyAzMDBcbiAqICAgLSB0aHJvdHRsZSAtIHRoZSBtaWxsaXNlY29uZCBwaHgtdGhyb3R0bGUgdGltZS4gRGVmYXVsdHMgMzAwXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMucGFyYW1zXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3IgcGFzc2luZyBjb25uZWN0IHBhcmFtcy5cbiAqIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBMaXZlVmlldy4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIChlbCkgPT4ge3ZpZXc6IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtbXktdmlldy1uYW1lXCIsIHRva2VuOiB3aW5kb3cubXlUb2tlbn1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmluZGluZ1ByZWZpeF0gLSBUaGUgb3B0aW9uYWwgcHJlZml4IHRvIHVzZSBmb3IgYWxsIHBoeCBET00gYW5ub3RhdGlvbnMuXG4gKiBEZWZhdWx0cyB0byBcInBoeC1cIi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5ob29rc10gLSBUaGUgb3B0aW9uYWwgb2JqZWN0IGZvciByZWZlcmVuY2luZyBMaXZlVmlldyBob29rIGNhbGxiYWNrcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy51cGxvYWRlcnNdIC0gVGhlIG9wdGlvbmFsIG9iamVjdCBmb3IgcmVmZXJlbmNpbmcgTGl2ZVZpZXcgdXBsb2FkZXIgY2FsbGJhY2tzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5sb2FkZXJUaW1lb3V0XSAtIFRoZSBvcHRpb25hbCBkZWxheSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgYXBwbHlcbiAqIGxvYWRpbmcgc3RhdGVzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5tYXhSZWxvYWRzXSAtIFRoZSBtYXhpbXVtIHJlbG9hZHMgYmVmb3JlIGVudGVyaW5nIGZhaWxzYWZlIG1vZGUuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLnJlbG9hZEppdHRlck1pbl0gLSBUaGUgbWluaW11bSB0aW1lIGJldHdlZW4gbm9ybWFsIHJlbG9hZCBhdHRlbXB0cy5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMucmVsb2FkSml0dGVyTWF4XSAtIFRoZSBtYXhpbXVtIHRpbWUgYmV0d2VlbiBub3JtYWwgcmVsb2FkIGF0dGVtcHRzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5mYWlsc2FmZUppdHRlcl0gLSBUaGUgdGltZSBiZXR3ZWVuIHJlbG9hZCBhdHRlbXB0cyBpbiBmYWlsc2FmZSBtb2RlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMudmlld0xvZ2dlcl0gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9nIGRlYnVnIGluZm9ybWF0aW9uLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgKHZpZXcsIGtpbmQsIG1zZywgb2JqKSA9PiBjb25zb2xlLmxvZyhgJHt2aWV3LmlkfSAke2tpbmR9OiAke21zZ30gLSBgLCBvYmopXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLm1ldGFkYXRhXSAtIFRoZSBvcHRpb25hbCBvYmplY3QgbWFwcGluZyBldmVudCBuYW1lcyB0byBmdW5jdGlvbnMgZm9yXG4gKiBwb3B1bGF0aW5nIGV2ZW50IG1ldGFkYXRhLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgbWV0YWRhdGE6IHtcbiAqICAgICAgIGNsaWNrOiAoZSwgZWwpID0+IHtcbiAqICAgICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gKiAgICAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxuICogICAgICAgICAgIGRldGFpbDogZS5kZXRhaWwgfHwgMSxcbiAqICAgICAgICAgfVxuICogICAgICAgfSxcbiAqICAgICAgIGtleWRvd246IChlLCBlbCkgPT4ge1xuICogICAgICAgICByZXR1cm4ge1xuICogICAgICAgICAgIGtleTogZS5rZXksXG4gKiAgICAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICogICAgICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcbiAqICAgICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleVxuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnNlc3Npb25TdG9yYWdlXSAtIEFuIG9wdGlvbmFsIFN0b3JhZ2UgY29tcGF0aWJsZSBvYmplY3RcbiAqIFVzZWZ1bCB3aGVuIExpdmVWaWV3IHdvbid0IGhhdmUgYWNjZXNzIHRvIGBzZXNzaW9uU3RvcmFnZWAuICBGb3IgZXhhbXBsZSwgVGhpcyBjb3VsZFxuICogaGFwcGVuIGlmIGEgc2l0ZSBsb2FkcyBhIGNyb3NzLWRvbWFpbiBMaXZlVmlldyBpbiBhbiBpZnJhbWUuICBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgICBjbGFzcyBJbk1lbW9yeVN0b3JhZ2Uge1xuICogICAgICAgY29uc3RydWN0b3IoKSB7IHRoaXMuc3RvcmFnZSA9IHt9IH1cbiAqICAgICAgIGdldEl0ZW0oa2V5TmFtZSkgeyByZXR1cm4gdGhpcy5zdG9yYWdlW2tleU5hbWVdIH1cbiAqICAgICAgIHJlbW92ZUl0ZW0oa2V5TmFtZSkgeyBkZWxldGUgdGhpcy5zdG9yYWdlW2tleU5hbWVdIH1cbiAqICAgICAgIHNldEl0ZW0oa2V5TmFtZSwga2V5VmFsdWUpIHsgdGhpcy5zdG9yYWdlW2tleU5hbWVdID0ga2V5VmFsdWUgfVxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMubG9jYWxTdG9yYWdlXSAtIEFuIG9wdGlvbmFsIFN0b3JhZ2UgY29tcGF0aWJsZSBvYmplY3RcbiAqIFVzZWZ1bCBmb3Igd2hlbiBMaXZlVmlldyB3b24ndCBoYXZlIGFjY2VzcyB0byBgbG9jYWxTdG9yYWdlYC5cbiAqIFNlZSBgb3B0cy5zZXNzaW9uU3RvcmFnZWAgZm9yIGV4YW1wbGVzLlxuKi9cblxuaW1wb3J0IHtcbiAgQklORElOR19QUkVGSVgsXG4gIENPTlNFQ1VUSVZFX1JFTE9BRFMsXG4gIERFRkFVTFRTLFxuICBGQUlMU0FGRV9KSVRURVIsXG4gIExPQURFUl9USU1FT1VULFxuICBNQVhfUkVMT0FEUyxcbiAgUEhYX0RFQk9VTkNFLFxuICBQSFhfRFJPUF9UQVJHRVQsXG4gIFBIWF9IQVNfRk9DVVNFRCxcbiAgUEhYX0tFWSxcbiAgUEhYX0xJTktfU1RBVEUsXG4gIFBIWF9MSVZFX0xJTkssXG4gIFBIWF9MVl9ERUJVRyxcbiAgUEhYX0xWX0xBVEVOQ1lfU0lNLFxuICBQSFhfTFZfUFJPRklMRSxcbiAgUEhYX01BSU4sXG4gIFBIWF9QQVJFTlRfSUQsXG4gIFBIWF9WSUVXX1NFTEVDVE9SLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1RIUk9UVExFLFxuICBQSFhfVFJBQ0tfVVBMT0FEUyxcbiAgUEhYX1NFU1NJT04sXG4gIFJFTE9BRF9KSVRURVJfTUlOLFxuICBSRUxPQURfSklUVEVSX01BWCxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgY2xvbmUsXG4gIGNsb3Nlc3RQaHhCaW5kaW5nLFxuICBjbG9zdXJlLFxuICBkZWJ1ZyxcbiAgaXNPYmplY3QsXG4gIG1heWJlXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IEJyb3dzZXIgZnJvbSBcIi4vYnJvd3NlclwiXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgSG9va3MgZnJvbSBcIi4vaG9va3NcIlxuaW1wb3J0IExpdmVVcGxvYWRlciBmcm9tIFwiLi9saXZlX3VwbG9hZGVyXCJcbmltcG9ydCBWaWV3IGZyb20gXCIuL3ZpZXdcIlxuaW1wb3J0IEpTIGZyb20gXCIuL2pzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl2ZVNvY2tldCB7XG4gIGNvbnN0cnVjdG9yKHVybCwgcGh4U29ja2V0LCBvcHRzID0ge30pe1xuICAgIHRoaXMudW5sb2FkZWQgPSBmYWxzZVxuICAgIGlmKCFwaHhTb2NrZXQgfHwgcGh4U29ja2V0LmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiT2JqZWN0XCIpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgIGEgcGhvZW5peCBTb2NrZXQgbXVzdCBiZSBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBMaXZlU29ja2V0IGNvbnN0cnVjdG9yLiBGb3IgZXhhbXBsZTpcblxuICAgICAgICAgIGltcG9ydCB7U29ja2V0fSBmcm9tIFwicGhvZW5peFwiXG4gICAgICAgICAgaW1wb3J0IHtMaXZlU29ja2V0fSBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIlxuICAgICAgICAgIGxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHsuLi59KVxuICAgICAgYClcbiAgICB9XG4gICAgdGhpcy5zb2NrZXQgPSBuZXcgcGh4U29ja2V0KHVybCwgb3B0cylcbiAgICB0aGlzLmJpbmRpbmdQcmVmaXggPSBvcHRzLmJpbmRpbmdQcmVmaXggfHwgQklORElOR19QUkVGSVhcbiAgICB0aGlzLm9wdHMgPSBvcHRzXG4gICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKG9wdHMucGFyYW1zIHx8IHt9KVxuICAgIHRoaXMudmlld0xvZ2dlciA9IG9wdHMudmlld0xvZ2dlclxuICAgIHRoaXMubWV0YWRhdGFDYWxsYmFja3MgPSBvcHRzLm1ldGFkYXRhIHx8IHt9XG4gICAgdGhpcy5kZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oY2xvbmUoREVGQVVMVFMpLCBvcHRzLmRlZmF1bHRzIHx8IHt9KVxuICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IG51bGxcbiAgICB0aGlzLnByZXZBY3RpdmUgPSBudWxsXG4gICAgdGhpcy5zaWxlbmNlZCA9IGZhbHNlXG4gICAgdGhpcy5tYWluID0gbnVsbFxuICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSBudWxsXG4gICAgdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCA9IG51bGxcbiAgICB0aGlzLmxpbmtSZWYgPSAxXG4gICAgdGhpcy5yb290cyA9IHt9XG4gICAgdGhpcy5ocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICB0aGlzLnBlbmRpbmdMaW5rID0gbnVsbFxuICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gY2xvbmUod2luZG93LmxvY2F0aW9uKVxuICAgIHRoaXMuaG9va3MgPSBvcHRzLmhvb2tzIHx8IHt9XG4gICAgdGhpcy51cGxvYWRlcnMgPSBvcHRzLnVwbG9hZGVycyB8fCB7fVxuICAgIHRoaXMubG9hZGVyVGltZW91dCA9IG9wdHMubG9hZGVyVGltZW91dCB8fCBMT0FERVJfVElNRU9VVFxuICAgIHRoaXMucmVsb2FkV2l0aEppdHRlclRpbWVyID0gbnVsbFxuICAgIHRoaXMubWF4UmVsb2FkcyA9IG9wdHMubWF4UmVsb2FkcyB8fCBNQVhfUkVMT0FEU1xuICAgIHRoaXMucmVsb2FkSml0dGVyTWluID0gb3B0cy5yZWxvYWRKaXR0ZXJNaW4gfHwgUkVMT0FEX0pJVFRFUl9NSU5cbiAgICB0aGlzLnJlbG9hZEppdHRlck1heCA9IG9wdHMucmVsb2FkSml0dGVyTWF4IHx8IFJFTE9BRF9KSVRURVJfTUFYXG4gICAgdGhpcy5mYWlsc2FmZUppdHRlciA9IG9wdHMuZmFpbHNhZmVKaXR0ZXIgfHwgRkFJTFNBRkVfSklUVEVSXG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSBvcHRzLmxvY2FsU3RvcmFnZSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlXG4gICAgdGhpcy5zZXNzaW9uU3RvcmFnZSA9IG9wdHMuc2Vzc2lvblN0b3JhZ2UgfHwgd2luZG93LnNlc3Npb25TdG9yYWdlXG4gICAgdGhpcy5ib3VuZFRvcExldmVsRXZlbnRzID0gZmFsc2VcbiAgICB0aGlzLmRvbUNhbGxiYWNrcyA9IE9iamVjdC5hc3NpZ24oe29uTm9kZUFkZGVkOiBjbG9zdXJlKCksIG9uQmVmb3JlRWxVcGRhdGVkOiBjbG9zdXJlKCl9LCBvcHRzLmRvbSB8fCB7fSlcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gbmV3IFRyYW5zaXRpb25TZXQoKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX2UgPT4ge1xuICAgICAgdGhpcy51bmxvYWRlZCA9IHRydWVcbiAgICB9KVxuICAgIHRoaXMuc29ja2V0Lm9uT3BlbigoKSA9PiB7XG4gICAgICBpZih0aGlzLmlzVW5sb2FkZWQoKSl7XG4gICAgICAgIC8vIHJlbG9hZCBwYWdlIGlmIGJlaW5nIHJlc3RvcmVkIGZyb20gYmFjay9mb3J3YXJkIGNhY2hlIGFuZCBicm93c2VyIGRvZXMgbm90IGVtaXQgXCJwYWdlc2hvd1wiXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBwdWJsaWNcblxuICBpc1Byb2ZpbGVFbmFibGVkKCl7IHJldHVybiB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX1BST0ZJTEUpID09PSBcInRydWVcIiB9XG5cbiAgaXNEZWJ1Z0VuYWJsZWQoKXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfREVCVUcpID09PSBcInRydWVcIiB9XG5cbiAgaXNEZWJ1Z0Rpc2FibGVkKCl7IHJldHVybiB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX0RFQlVHKSA9PT0gXCJmYWxzZVwiIH1cblxuICBlbmFibGVEZWJ1ZygpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX0RFQlVHLCBcInRydWVcIikgfVxuXG4gIGVuYWJsZVByb2ZpbGluZygpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX1BST0ZJTEUsIFwidHJ1ZVwiKSB9XG5cbiAgZGlzYWJsZURlYnVnKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfREVCVUcsIFwiZmFsc2VcIikgfVxuXG4gIGRpc2FibGVQcm9maWxpbmcoKXsgdGhpcy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFBIWF9MVl9QUk9GSUxFKSB9XG5cbiAgZW5hYmxlTGF0ZW5jeVNpbSh1cHBlckJvdW5kTXMpe1xuICAgIHRoaXMuZW5hYmxlRGVidWcoKVxuICAgIGNvbnNvbGUubG9nKFwibGF0ZW5jeSBzaW11bGF0b3IgZW5hYmxlZCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoaXMgYnJvd3NlciBzZXNzaW9uLiBDYWxsIGRpc2FibGVMYXRlbmN5U2ltKCkgdG8gZGlzYWJsZVwiKVxuICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfTEFURU5DWV9TSU0sIHVwcGVyQm91bmRNcylcbiAgfVxuXG4gIGRpc2FibGVMYXRlbmN5U2ltKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShQSFhfTFZfTEFURU5DWV9TSU0pIH1cblxuICBnZXRMYXRlbmN5U2ltKCl7XG4gICAgbGV0IHN0ciA9IHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfTEFURU5DWV9TSU0pXG4gICAgcmV0dXJuIHN0ciA/IHBhcnNlSW50KHN0cikgOiBudWxsXG4gIH1cblxuICBnZXRTb2NrZXQoKXsgcmV0dXJuIHRoaXMuc29ja2V0IH1cblxuICBjb25uZWN0KCl7XG4gICAgLy8gZW5hYmxlIGRlYnVnIGJ5IGRlZmF1bHQgaWYgb24gbG9jYWxob3N0IGFuZCBub3QgZXhwbGljaXRseSBkaXNhYmxlZFxuICAgIGlmKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PT0gXCJsb2NhbGhvc3RcIiAmJiAhdGhpcy5pc0RlYnVnRGlzYWJsZWQoKSl7IHRoaXMuZW5hYmxlRGVidWcoKSB9XG4gICAgbGV0IGRvQ29ubmVjdCA9ICgpID0+IHtcbiAgICAgIGlmKHRoaXMuam9pblJvb3RWaWV3cygpKXtcbiAgICAgICAgdGhpcy5iaW5kVG9wTGV2ZWxFdmVudHMoKVxuICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KClcbiAgICAgIH0gZWxzZSBpZih0aGlzLm1haW4pe1xuICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoW1wiY29tcGxldGVcIiwgXCJsb2FkZWRcIiwgXCJpbnRlcmFjdGl2ZVwiXS5pbmRleE9mKGRvY3VtZW50LnJlYWR5U3RhdGUpID49IDApe1xuICAgICAgZG9Db25uZWN0KClcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4gZG9Db25uZWN0KCkpXG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdChjYWxsYmFjayl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVsb2FkV2l0aEppdHRlclRpbWVyKVxuICAgIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoY2FsbGJhY2spXG4gIH1cblxuICByZXBsYWNlVHJhbnNwb3J0KHRyYW5zcG9ydCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVsb2FkV2l0aEppdHRlclRpbWVyKVxuICAgIHRoaXMuc29ja2V0LnJlcGxhY2VUcmFuc3BvcnQodHJhbnNwb3J0KVxuICAgIHRoaXMuY29ubmVjdCgpXG4gIH1cblxuICBleGVjSlMoZWwsIGVuY29kZWRKUywgZXZlbnRUeXBlID0gbnVsbCl7XG4gICAgdGhpcy5vd25lcihlbCwgdmlldyA9PiBKUy5leGVjKGV2ZW50VHlwZSwgZW5jb2RlZEpTLCB2aWV3LCBlbCkpXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgdHJpZ2dlckRPTShraW5kLCBhcmdzKXsgdGhpcy5kb21DYWxsYmFja3Nba2luZF0oLi4uYXJncykgfVxuXG4gIHRpbWUobmFtZSwgZnVuYyl7XG4gICAgaWYoIXRoaXMuaXNQcm9maWxlRW5hYmxlZCgpIHx8ICFjb25zb2xlLnRpbWUpeyByZXR1cm4gZnVuYygpIH1cbiAgICBjb25zb2xlLnRpbWUobmFtZSlcbiAgICBsZXQgcmVzdWx0ID0gZnVuYygpXG4gICAgY29uc29sZS50aW1lRW5kKG5hbWUpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgbG9nKHZpZXcsIGtpbmQsIG1zZ0NhbGxiYWNrKXtcbiAgICBpZih0aGlzLnZpZXdMb2dnZXIpe1xuICAgICAgbGV0IFttc2csIG9ial0gPSBtc2dDYWxsYmFjaygpXG4gICAgICB0aGlzLnZpZXdMb2dnZXIodmlldywga2luZCwgbXNnLCBvYmopXG4gICAgfSBlbHNlIGlmKHRoaXMuaXNEZWJ1Z0VuYWJsZWQoKSl7XG4gICAgICBsZXQgW21zZywgb2JqXSA9IG1zZ0NhbGxiYWNrKClcbiAgICAgIGRlYnVnKHZpZXcsIGtpbmQsIG1zZywgb2JqKVxuICAgIH1cbiAgfVxuXG4gIHJlcXVlc3RET01VcGRhdGUoY2FsbGJhY2spe1xuICAgIHRoaXMudHJhbnNpdGlvbnMuYWZ0ZXIoY2FsbGJhY2spXG4gIH1cblxuICB0cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSA9IGZ1bmN0aW9uKCl7fSl7XG4gICAgdGhpcy50cmFuc2l0aW9ucy5hZGRUcmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSlcbiAgfVxuXG4gIG9uQ2hhbm5lbChjaGFubmVsLCBldmVudCwgY2Ipe1xuICAgIGNoYW5uZWwub24oZXZlbnQsIGRhdGEgPT4ge1xuICAgICAgbGV0IGxhdGVuY3kgPSB0aGlzLmdldExhdGVuY3lTaW0oKVxuICAgICAgaWYoIWxhdGVuY3kpe1xuICAgICAgICBjYihkYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coYHNpbXVsYXRpbmcgJHtsYXRlbmN5fW1zIG9mIGxhdGVuY3kgZnJvbSBzZXJ2ZXIgdG8gY2xpZW50YClcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBjYihkYXRhKSwgbGF0ZW5jeSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgd3JhcFB1c2godmlldywgb3B0cywgcHVzaCl7XG4gICAgbGV0IGxhdGVuY3kgPSB0aGlzLmdldExhdGVuY3lTaW0oKVxuICAgIGxldCBvbGRKb2luQ291bnQgPSB2aWV3LmpvaW5Db3VudFxuICAgIGlmKCFsYXRlbmN5KXtcbiAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQoKSAmJiBvcHRzLnRpbWVvdXQpe1xuICAgICAgICByZXR1cm4gcHVzaCgpLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IHtcbiAgICAgICAgICBpZih2aWV3LmpvaW5Db3VudCA9PT0gb2xkSm9pbkNvdW50ICYmICF2aWV3LmlzRGVzdHJveWVkKCkpe1xuICAgICAgICAgICAgdGhpcy5yZWxvYWRXaXRoSml0dGVyKHZpZXcsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5sb2codmlldywgXCJ0aW1lb3V0XCIsICgpID0+IFtcInJlY2VpdmVkIHRpbWVvdXQgd2hpbGUgY29tbXVuaWNhdGluZyB3aXRoIHNlcnZlci4gRmFsbGluZyBiYWNrIHRvIGhhcmQgcmVmcmVzaCBmb3IgcmVjb3ZlcnlcIl0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwdXNoKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgc2ltdWxhdGluZyAke2xhdGVuY3l9bXMgb2YgbGF0ZW5jeSBmcm9tIGNsaWVudCB0byBzZXJ2ZXJgKVxuICAgIGxldCBmYWtlUHVzaCA9IHtcbiAgICAgIHJlY2VpdmVzOiBbXSxcbiAgICAgIHJlY2VpdmUoa2luZCwgY2IpeyB0aGlzLnJlY2VpdmVzLnB1c2goW2tpbmQsIGNiXSkgfVxuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmKHZpZXcuaXNEZXN0cm95ZWQoKSl7IHJldHVybiB9XG4gICAgICBmYWtlUHVzaC5yZWNlaXZlcy5yZWR1Y2UoKGFjYywgW2tpbmQsIGNiXSkgPT4gYWNjLnJlY2VpdmUoa2luZCwgY2IpLCBwdXNoKCkpXG4gICAgfSwgbGF0ZW5jeSlcbiAgICByZXR1cm4gZmFrZVB1c2hcbiAgfVxuXG4gIHJlbG9hZFdpdGhKaXR0ZXIodmlldywgbG9nKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIpXG4gICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICBsZXQgbWluTXMgPSB0aGlzLnJlbG9hZEppdHRlck1pblxuICAgIGxldCBtYXhNcyA9IHRoaXMucmVsb2FkSml0dGVyTWF4XG4gICAgbGV0IGFmdGVyTXMgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4TXMgLSBtaW5NcyArIDEpKSArIG1pbk1zXG4gICAgbGV0IHRyaWVzID0gQnJvd3Nlci51cGRhdGVMb2NhbCh0aGlzLmxvY2FsU3RvcmFnZSwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLCBDT05TRUNVVElWRV9SRUxPQURTLCAwLCBjb3VudCA9PiBjb3VudCArIDEpXG4gICAgaWYodHJpZXMgPiB0aGlzLm1heFJlbG9hZHMpe1xuICAgICAgYWZ0ZXJNcyA9IHRoaXMuZmFpbHNhZmVKaXR0ZXJcbiAgICB9XG4gICAgdGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIGlmIHZpZXcgaGFzIHJlY292ZXJlZCwgc3VjaCBhcyB0cmFuc3BvcnQgcmVwbGFjZWQsIHRoZW4gY2FuY2VsXG4gICAgICBpZih2aWV3LmlzRGVzdHJveWVkKCkgfHwgdmlldy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIH1cbiAgICAgIHZpZXcuZGVzdHJveSgpXG4gICAgICBsb2cgPyBsb2coKSA6IHRoaXMubG9nKHZpZXcsIFwiam9pblwiLCAoKSA9PiBbYGVuY291bnRlcmVkICR7dHJpZXN9IGNvbnNlY3V0aXZlIHJlbG9hZHNgXSlcbiAgICAgIGlmKHRyaWVzID4gdGhpcy5tYXhSZWxvYWRzKXtcbiAgICAgICAgdGhpcy5sb2codmlldywgXCJqb2luXCIsICgpID0+IFtgZXhjZWVkZWQgJHt0aGlzLm1heFJlbG9hZHN9IGNvbnNlY3V0aXZlIHJlbG9hZHMuIEVudGVyaW5nIGZhaWxzYWZlIG1vZGVgXSlcbiAgICAgIH1cbiAgICAgIGlmKHRoaXMuaGFzUGVuZGluZ0xpbmsoKSl7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHRoaXMucGVuZGluZ0xpbmtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuICAgIH0sIGFmdGVyTXMpXG4gIH1cblxuICBnZXRIb29rQ2FsbGJhY2tzKG5hbWUpe1xuICAgIHJldHVybiBuYW1lICYmIG5hbWUuc3RhcnRzV2l0aChcIlBob2VuaXguXCIpID8gSG9va3NbbmFtZS5zcGxpdChcIi5cIilbMV1dIDogdGhpcy5ob29rc1tuYW1lXVxuICB9XG5cbiAgaXNVbmxvYWRlZCgpeyByZXR1cm4gdGhpcy51bmxvYWRlZCB9XG5cbiAgaXNDb25uZWN0ZWQoKXsgcmV0dXJuIHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkgfVxuXG4gIGdldEJpbmRpbmdQcmVmaXgoKXsgcmV0dXJuIHRoaXMuYmluZGluZ1ByZWZpeCB9XG5cbiAgYmluZGluZyhraW5kKXsgcmV0dXJuIGAke3RoaXMuZ2V0QmluZGluZ1ByZWZpeCgpfSR7a2luZH1gIH1cblxuICBjaGFubmVsKHRvcGljLCBwYXJhbXMpeyByZXR1cm4gdGhpcy5zb2NrZXQuY2hhbm5lbCh0b3BpYywgcGFyYW1zKSB9XG5cbiAgam9pblJvb3RWaWV3cygpe1xuICAgIGxldCByb290c0ZvdW5kID0gZmFsc2VcbiAgICBET00uYWxsKGRvY3VtZW50LCBgJHtQSFhfVklFV19TRUxFQ1RPUn06bm90KFske1BIWF9QQVJFTlRfSUR9XSlgLCByb290RWwgPT4ge1xuICAgICAgaWYoIXRoaXMuZ2V0Um9vdEJ5SWQocm9vdEVsLmlkKSl7XG4gICAgICAgIGxldCB2aWV3ID0gdGhpcy5uZXdSb290Vmlldyhyb290RWwpXG4gICAgICAgIHZpZXcuc2V0SHJlZih0aGlzLmdldEhyZWYoKSlcbiAgICAgICAgdmlldy5qb2luKClcbiAgICAgICAgaWYocm9vdEVsLmdldEF0dHJpYnV0ZShQSFhfTUFJTikpeyB0aGlzLm1haW4gPSB2aWV3IH1cbiAgICAgIH1cbiAgICAgIHJvb3RzRm91bmQgPSB0cnVlXG4gICAgfSlcbiAgICByZXR1cm4gcm9vdHNGb3VuZFxuICB9XG5cbiAgcmVkaXJlY3QodG8sIGZsYXNoKXtcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIEJyb3dzZXIucmVkaXJlY3QodG8sIGZsYXNoKVxuICB9XG5cbiAgcmVwbGFjZU1haW4oaHJlZiwgZmxhc2gsIGNhbGxiYWNrID0gbnVsbCwgbGlua1JlZiA9IHRoaXMuc2V0UGVuZGluZ0xpbmsoaHJlZikpe1xuICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSB0aGlzLm91dGdvaW5nTWFpbkVsIHx8IHRoaXMubWFpbi5lbFxuICAgIGxldCBuZXdNYWluRWwgPSBET00uY2xvbmVOb2RlKHRoaXMub3V0Z29pbmdNYWluRWwsIFwiXCIpXG4gICAgdGhpcy5tYWluLnNob3dMb2FkZXIodGhpcy5sb2FkZXJUaW1lb3V0KVxuICAgIHRoaXMubWFpbi5kZXN0cm95KClcblxuICAgIHRoaXMubWFpbiA9IHRoaXMubmV3Um9vdFZpZXcobmV3TWFpbkVsLCBmbGFzaClcbiAgICB0aGlzLm1haW4uc2V0UmVkaXJlY3QoaHJlZilcbiAgICB0aGlzLnRyYW5zaXRpb25SZW1vdmVzKClcbiAgICB0aGlzLm1haW4uam9pbigoam9pbkNvdW50LCBvbkRvbmUpID0+IHtcbiAgICAgIGlmKGpvaW5Db3VudCA9PT0gMSAmJiB0aGlzLmNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpKXtcbiAgICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICBET00uZmluZFBoeFN0aWNreShkb2N1bWVudCkuZm9yRWFjaChlbCA9PiBuZXdNYWluRWwuYXBwZW5kQ2hpbGQoZWwpKVxuICAgICAgICAgIHRoaXMub3V0Z29pbmdNYWluRWwucmVwbGFjZVdpdGgobmV3TWFpbkVsKVxuICAgICAgICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSBudWxsXG4gICAgICAgICAgY2FsbGJhY2sgJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKVxuICAgICAgICAgIG9uRG9uZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHRyYW5zaXRpb25SZW1vdmVzKGVsZW1lbnRzKXtcbiAgICBsZXQgcmVtb3ZlQXR0ciA9IHRoaXMuYmluZGluZyhcInJlbW92ZVwiKVxuICAgIGVsZW1lbnRzID0gZWxlbWVudHMgfHwgRE9NLmFsbChkb2N1bWVudCwgYFske3JlbW92ZUF0dHJ9XWApXG4gICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBpZihkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsKSl7IC8vIHNraXAgY2hpbGRyZW4gYWxyZWFkeSByZW1vdmVkXG4gICAgICAgIHRoaXMuZXhlY0pTKGVsLCBlbC5nZXRBdHRyaWJ1dGUocmVtb3ZlQXR0ciksIFwicmVtb3ZlXCIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGlzUGh4VmlldyhlbCl7IHJldHVybiBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKSAhPT0gbnVsbCB9XG5cbiAgbmV3Um9vdFZpZXcoZWwsIGZsYXNoKXtcbiAgICBsZXQgdmlldyA9IG5ldyBWaWV3KGVsLCB0aGlzLCBudWxsLCBmbGFzaClcbiAgICB0aGlzLnJvb3RzW3ZpZXcuaWRdID0gdmlld1xuICAgIHJldHVybiB2aWV3XG4gIH1cblxuICBvd25lcihjaGlsZEVsLCBjYWxsYmFjayl7XG4gICAgbGV0IHZpZXcgPSBtYXliZShjaGlsZEVsLmNsb3Nlc3QoUEhYX1ZJRVdfU0VMRUNUT1IpLCBlbCA9PiB0aGlzLmdldFZpZXdCeUVsKGVsKSkgfHwgdGhpcy5tYWluXG4gICAgaWYodmlldyl7IGNhbGxiYWNrKHZpZXcpIH1cbiAgfVxuXG4gIHdpdGhpbk93bmVycyhjaGlsZEVsLCBjYWxsYmFjayl7XG4gICAgdGhpcy5vd25lcihjaGlsZEVsLCB2aWV3ID0+IGNhbGxiYWNrKHZpZXcsIGNoaWxkRWwpKVxuICB9XG5cbiAgZ2V0Vmlld0J5RWwoZWwpe1xuICAgIGxldCByb290SWQgPSBlbC5nZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQpXG4gICAgcmV0dXJuIG1heWJlKHRoaXMuZ2V0Um9vdEJ5SWQocm9vdElkKSwgcm9vdCA9PiByb290LmdldERlc2NlbmRlbnRCeUVsKGVsKSlcbiAgfVxuXG4gIGdldFJvb3RCeUlkKGlkKXsgcmV0dXJuIHRoaXMucm9vdHNbaWRdIH1cblxuICBkZXN0cm95QWxsVmlld3MoKXtcbiAgICBmb3IobGV0IGlkIGluIHRoaXMucm9vdHMpe1xuICAgICAgdGhpcy5yb290c1tpZF0uZGVzdHJveSgpXG4gICAgICBkZWxldGUgdGhpcy5yb290c1tpZF1cbiAgICB9XG4gICAgdGhpcy5tYWluID0gbnVsbFxuICB9XG5cbiAgZGVzdHJveVZpZXdCeUVsKGVsKXtcbiAgICBsZXQgcm9vdCA9IHRoaXMuZ2V0Um9vdEJ5SWQoZWwuZ2V0QXR0cmlidXRlKFBIWF9ST09UX0lEKSlcbiAgICBpZihyb290ICYmIHJvb3QuaWQgPT09IGVsLmlkKXtcbiAgICAgIHJvb3QuZGVzdHJveSgpXG4gICAgICBkZWxldGUgdGhpcy5yb290c1tyb290LmlkXVxuICAgIH0gZWxzZSBpZihyb290KXtcbiAgICAgIHJvb3QuZGVzdHJveURlc2NlbmRlbnQoZWwuaWQpXG4gICAgfVxuICB9XG5cbiAgc2V0QWN0aXZlRWxlbWVudCh0YXJnZXQpe1xuICAgIGlmKHRoaXMuYWN0aXZlRWxlbWVudCA9PT0gdGFyZ2V0KXsgcmV0dXJuIH1cbiAgICB0aGlzLmFjdGl2ZUVsZW1lbnQgPSB0YXJnZXRcbiAgICBsZXQgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgaWYodGFyZ2V0ID09PSB0aGlzLmFjdGl2ZUVsZW1lbnQpeyB0aGlzLmFjdGl2ZUVsZW1lbnQgPSBudWxsIH1cbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzKVxuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzKVxuICAgIH1cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgY2FuY2VsKVxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgY2FuY2VsKVxuICB9XG5cbiAgZ2V0QWN0aXZlRWxlbWVudCgpe1xuICAgIGlmKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpe1xuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIGJlIG51bGwgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTFcbiAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmJvZHlcbiAgICB9XG4gIH1cblxuICBkcm9wQWN0aXZlRWxlbWVudCh2aWV3KXtcbiAgICBpZih0aGlzLnByZXZBY3RpdmUgJiYgdmlldy5vd25zRWxlbWVudCh0aGlzLnByZXZBY3RpdmUpKXtcbiAgICAgIHRoaXMucHJldkFjdGl2ZSA9IG51bGxcbiAgICB9XG4gIH1cblxuICByZXN0b3JlUHJldmlvdXNseUFjdGl2ZUZvY3VzKCl7XG4gICAgaWYodGhpcy5wcmV2QWN0aXZlICYmIHRoaXMucHJldkFjdGl2ZSAhPT0gZG9jdW1lbnQuYm9keSl7XG4gICAgICB0aGlzLnByZXZBY3RpdmUuZm9jdXMoKVxuICAgIH1cbiAgfVxuXG4gIGJsdXJBY3RpdmVFbGVtZW50KCl7XG4gICAgdGhpcy5wcmV2QWN0aXZlID0gdGhpcy5nZXRBY3RpdmVFbGVtZW50KClcbiAgICBpZih0aGlzLnByZXZBY3RpdmUgIT09IGRvY3VtZW50LmJvZHkpeyB0aGlzLnByZXZBY3RpdmUuYmx1cigpIH1cbiAgfVxuXG4gIGJpbmRUb3BMZXZlbEV2ZW50cygpe1xuICAgIGlmKHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cyl7IHJldHVybiB9XG5cbiAgICB0aGlzLmJvdW5kVG9wTGV2ZWxFdmVudHMgPSB0cnVlXG4gICAgLy8gZW50ZXIgZmFpbHNhZmUgcmVsb2FkIGlmIHNlcnZlciBoYXMgZ29uZSBhd2F5IGludGVudGlvbmFsbHksIHN1Y2ggYXMgXCJkaXNjb25uZWN0XCIgYnJvYWRjYXN0XG4gICAgdGhpcy5zb2NrZXQub25DbG9zZShldmVudCA9PiB7XG4gICAgICBpZihldmVudCAmJiBldmVudC5jb2RlID09PSAxMDAwICYmIHRoaXMubWFpbil7XG4gICAgICAgIHRoaXMucmVsb2FkV2l0aEppdHRlcih0aGlzLm1haW4pXG4gICAgICB9XG4gICAgfSlcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKXsgfSkgLy8gZW5zdXJlIGFsbCBjbGljayBldmVudHMgYnViYmxlIGZvciBtb2JpbGUgU2FmYXJpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCBlID0+IHtcbiAgICAgIGlmKGUucGVyc2lzdGVkKXsgLy8gcmVsb2FkIHBhZ2UgaWYgYmVpbmcgcmVzdG9yZWQgZnJvbSBiYWNrL2ZvcndhcmQgY2FjaGVcbiAgICAgICAgdGhpcy5nZXRTb2NrZXQoKS5kaXNjb25uZWN0KClcbiAgICAgICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoe3RvOiB3aW5kb3cubG9jYXRpb24uaHJlZiwga2luZDogXCJyZWRpcmVjdFwifSlcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICB9XG4gICAgfSwgdHJ1ZSlcbiAgICB0aGlzLmJpbmROYXYoKVxuICAgIHRoaXMuYmluZENsaWNrcygpXG4gICAgdGhpcy5iaW5kRm9ybXMoKVxuICAgIHRoaXMuYmluZCh7a2V5dXA6IFwia2V5dXBcIiwga2V5ZG93bjogXCJrZXlkb3duXCJ9LCAoZSwgdHlwZSwgdmlldywgdGFyZ2V0RWwsIHBoeEV2ZW50LCBldmVudFRhcmdldCkgPT4ge1xuICAgICAgbGV0IG1hdGNoS2V5ID0gdGFyZ2V0RWwuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfS0VZKSlcbiAgICAgIGxldCBwcmVzc2VkS2V5ID0gZS5rZXkgJiYgZS5rZXkudG9Mb3dlckNhc2UoKSAvLyBjaHJvbWUgY2xpY2tlZCBhdXRvY29tcGxldGVzIHNlbmQgYSBrZXlkb3duIHdpdGhvdXQga2V5XG4gICAgICBpZihtYXRjaEtleSAmJiBtYXRjaEtleS50b0xvd2VyQ2FzZSgpICE9PSBwcmVzc2VkS2V5KXsgcmV0dXJuIH1cblxuICAgICAgbGV0IGRhdGEgPSB7a2V5OiBlLmtleSwgLi4udGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpfVxuICAgICAgSlMuZXhlYyh0eXBlLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0RWwsIFtcInB1c2hcIiwge2RhdGF9XSlcbiAgICB9KVxuICAgIHRoaXMuYmluZCh7Ymx1cjogXCJmb2N1c291dFwiLCBmb2N1czogXCJmb2N1c2luXCJ9LCAoZSwgdHlwZSwgdmlldywgdGFyZ2V0RWwsIHBoeEV2ZW50LCBldmVudFRhcmdldCkgPT4ge1xuICAgICAgaWYoIWV2ZW50VGFyZ2V0KXtcbiAgICAgICAgbGV0IGRhdGEgPSB7a2V5OiBlLmtleSwgLi4udGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpfVxuICAgICAgICBKUy5leGVjKHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7ZGF0YX1dKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5iaW5kKHtibHVyOiBcImJsdXJcIiwgZm9jdXM6IFwiZm9jdXNcIn0sIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgcGh4VGFyZ2V0KSA9PiB7XG4gICAgICAvLyBibHVyIGFuZCBmb2N1cyBhcmUgdHJpZ2dlcmVkIG9uIGRvY3VtZW50IGFuZCB3aW5kb3cuIERpc2NhcmQgb25lIHRvIGF2b2lkIGR1cHNcbiAgICAgIGlmKHBoeFRhcmdldCA9PT0gXCJ3aW5kb3dcIil7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpXG4gICAgICAgIEpTLmV4ZWModHlwZSwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldEVsLCBbXCJwdXNoXCIsIHtkYXRhfV0pXG4gICAgICB9XG4gICAgfSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCBlID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgbGV0IGRyb3BUYXJnZXRJZCA9IG1heWJlKGNsb3Nlc3RQaHhCaW5kaW5nKGUudGFyZ2V0LCB0aGlzLmJpbmRpbmcoUEhYX0RST1BfVEFSR0VUKSksIHRydWVUYXJnZXQgPT4ge1xuICAgICAgICByZXR1cm4gdHJ1ZVRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9EUk9QX1RBUkdFVCkpXG4gICAgICB9KVxuICAgICAgbGV0IGRyb3BUYXJnZXQgPSBkcm9wVGFyZ2V0SWQgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZHJvcFRhcmdldElkKVxuICAgICAgbGV0IGZpbGVzID0gQXJyYXkuZnJvbShlLmRhdGFUcmFuc2Zlci5maWxlcyB8fCBbXSlcbiAgICAgIGlmKCFkcm9wVGFyZ2V0IHx8IGRyb3BUYXJnZXQuZGlzYWJsZWQgfHwgZmlsZXMubGVuZ3RoID09PSAwIHx8ICEoZHJvcFRhcmdldC5maWxlcyBpbnN0YW5jZW9mIEZpbGVMaXN0KSl7IHJldHVybiB9XG5cbiAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKGRyb3BUYXJnZXQsIGZpbGVzKVxuICAgICAgZHJvcFRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIsIHtidWJibGVzOiB0cnVlfSkpXG4gICAgfSlcbiAgICB0aGlzLm9uKFBIWF9UUkFDS19VUExPQURTLCBlID0+IHtcbiAgICAgIGxldCB1cGxvYWRUYXJnZXQgPSBlLnRhcmdldFxuICAgICAgaWYoIURPTS5pc1VwbG9hZElucHV0KHVwbG9hZFRhcmdldCkpeyByZXR1cm4gfVxuICAgICAgbGV0IGZpbGVzID0gQXJyYXkuZnJvbShlLmRldGFpbC5maWxlcyB8fCBbXSkuZmlsdGVyKGYgPT4gZiBpbnN0YW5jZW9mIEZpbGUgfHwgZiBpbnN0YW5jZW9mIEJsb2IpXG4gICAgICBMaXZlVXBsb2FkZXIudHJhY2tGaWxlcyh1cGxvYWRUYXJnZXQsIGZpbGVzKVxuICAgICAgdXBsb2FkVGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIiwge2J1YmJsZXM6IHRydWV9KSlcbiAgICB9KVxuICB9XG5cbiAgZXZlbnRNZXRhKGV2ZW50TmFtZSwgZSwgdGFyZ2V0RWwpe1xuICAgIGxldCBjYWxsYmFjayA9IHRoaXMubWV0YWRhdGFDYWxsYmFja3NbZXZlbnROYW1lXVxuICAgIHJldHVybiBjYWxsYmFjayA/IGNhbGxiYWNrKGUsIHRhcmdldEVsKSA6IHt9XG4gIH1cblxuICBzZXRQZW5kaW5nTGluayhocmVmKXtcbiAgICB0aGlzLmxpbmtSZWYrK1xuICAgIHRoaXMucGVuZGluZ0xpbmsgPSBocmVmXG4gICAgcmV0dXJuIHRoaXMubGlua1JlZlxuICB9XG5cbiAgY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZil7XG4gICAgaWYodGhpcy5saW5rUmVmICE9PSBsaW5rUmVmKXtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhyZWYgPSB0aGlzLnBlbmRpbmdMaW5rXG4gICAgICB0aGlzLnBlbmRpbmdMaW5rID0gbnVsbFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBnZXRIcmVmKCl7IHJldHVybiB0aGlzLmhyZWYgfVxuXG4gIGhhc1BlbmRpbmdMaW5rKCl7IHJldHVybiAhIXRoaXMucGVuZGluZ0xpbmsgfVxuXG4gIGJpbmQoZXZlbnRzLCBjYWxsYmFjayl7XG4gICAgZm9yKGxldCBldmVudCBpbiBldmVudHMpe1xuICAgICAgbGV0IGJyb3dzZXJFdmVudE5hbWUgPSBldmVudHNbZXZlbnRdXG5cbiAgICAgIHRoaXMub24oYnJvd3NlckV2ZW50TmFtZSwgZSA9PiB7XG4gICAgICAgIGxldCBiaW5kaW5nID0gdGhpcy5iaW5kaW5nKGV2ZW50KVxuICAgICAgICBsZXQgd2luZG93QmluZGluZyA9IHRoaXMuYmluZGluZyhgd2luZG93LSR7ZXZlbnR9YClcbiAgICAgICAgbGV0IHRhcmdldFBoeEV2ZW50ID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlICYmIGUudGFyZ2V0LmdldEF0dHJpYnV0ZShiaW5kaW5nKVxuICAgICAgICBpZih0YXJnZXRQaHhFdmVudCl7XG4gICAgICAgICAgdGhpcy5kZWJvdW5jZShlLnRhcmdldCwgZSwgYnJvd3NlckV2ZW50TmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZS50YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICAgICAgICBjYWxsYmFjayhlLCBldmVudCwgdmlldywgZS50YXJnZXQsIHRhcmdldFBoeEV2ZW50LCBudWxsKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIERPTS5hbGwoZG9jdW1lbnQsIGBbJHt3aW5kb3dCaW5kaW5nfV1gLCBlbCA9PiB7XG4gICAgICAgICAgICBsZXQgcGh4RXZlbnQgPSBlbC5nZXRBdHRyaWJ1dGUod2luZG93QmluZGluZylcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2UoZWwsIGUsIGJyb3dzZXJFdmVudE5hbWUsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZWwsIHZpZXcgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGV2ZW50LCB2aWV3LCBlbCwgcGh4RXZlbnQsIFwid2luZG93XCIpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgYmluZENsaWNrcygpe1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGUgPT4gdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCA9IGUudGFyZ2V0KVxuICAgIHRoaXMuYmluZENsaWNrKFwiY2xpY2tcIiwgXCJjbGlja1wiLCBmYWxzZSlcbiAgICB0aGlzLmJpbmRDbGljayhcIm1vdXNlZG93blwiLCBcImNhcHR1cmUtY2xpY2tcIiwgdHJ1ZSlcbiAgfVxuXG4gIGJpbmRDbGljayhldmVudE5hbWUsIGJpbmRpbmdOYW1lLCBjYXB0dXJlKXtcbiAgICBsZXQgY2xpY2sgPSB0aGlzLmJpbmRpbmcoYmluZGluZ05hbWUpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBlID0+IHtcbiAgICAgIGxldCB0YXJnZXQgPSBudWxsXG4gICAgICBpZihjYXB0dXJlKXtcbiAgICAgICAgdGFyZ2V0ID0gZS50YXJnZXQubWF0Y2hlcyhgWyR7Y2xpY2t9XWApID8gZS50YXJnZXQgOiBlLnRhcmdldC5xdWVyeVNlbGVjdG9yKGBbJHtjbGlja31dYClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjbGlja1N0YXJ0ZWRBdFRhcmdldCA9IHRoaXMuY2xpY2tTdGFydGVkQXRUYXJnZXQgfHwgZS50YXJnZXRcbiAgICAgICAgdGFyZ2V0ID0gY2xvc2VzdFBoeEJpbmRpbmcoY2xpY2tTdGFydGVkQXRUYXJnZXQsIGNsaWNrKVxuICAgICAgICB0aGlzLmRpc3BhdGNoQ2xpY2tBd2F5KGUsIGNsaWNrU3RhcnRlZEF0VGFyZ2V0KVxuICAgICAgICB0aGlzLmNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gbnVsbFxuICAgICAgfVxuICAgICAgbGV0IHBoeEV2ZW50ID0gdGFyZ2V0ICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoY2xpY2spXG4gICAgICBpZighcGh4RXZlbnQpeyByZXR1cm4gfVxuICAgICAgaWYodGFyZ2V0LmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiKXsgZS5wcmV2ZW50RGVmYXVsdCgpIH1cblxuICAgICAgdGhpcy5kZWJvdW5jZSh0YXJnZXQsIGUsIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLndpdGhpbk93bmVycyh0YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICAgIEpTLmV4ZWMoXCJjbGlja1wiLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0LCBbXCJwdXNoXCIsIHtkYXRhOiB0aGlzLmV2ZW50TWV0YShcImNsaWNrXCIsIGUsIHRhcmdldCl9XSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSwgY2FwdHVyZSlcbiAgfVxuXG4gIGRpc3BhdGNoQ2xpY2tBd2F5KGUsIGNsaWNrU3RhcnRlZEF0KXtcbiAgICBsZXQgcGh4Q2xpY2tBd2F5ID0gdGhpcy5iaW5kaW5nKFwiY2xpY2stYXdheVwiKVxuICAgIERPTS5hbGwoZG9jdW1lbnQsIGBbJHtwaHhDbGlja0F3YXl9XWAsIGVsID0+IHtcbiAgICAgIGlmKCEoZWwuaXNTYW1lTm9kZShjbGlja1N0YXJ0ZWRBdCkgfHwgZWwuY29udGFpbnMoY2xpY2tTdGFydGVkQXQpKSl7XG4gICAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCB2aWV3ID0+IHtcbiAgICAgICAgICBsZXQgcGh4RXZlbnQgPSBlbC5nZXRBdHRyaWJ1dGUocGh4Q2xpY2tBd2F5KVxuICAgICAgICAgIGlmKEpTLmlzVmlzaWJsZShlbCkpe1xuICAgICAgICAgICAgSlMuZXhlYyhcImNsaWNrXCIsIHBoeEV2ZW50LCB2aWV3LCBlbCwgW1wicHVzaFwiLCB7ZGF0YTogdGhpcy5ldmVudE1ldGEoXCJjbGlja1wiLCBlLCBlLnRhcmdldCl9XSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGJpbmROYXYoKXtcbiAgICBpZighQnJvd3Nlci5jYW5QdXNoU3RhdGUoKSl7IHJldHVybiB9XG4gICAgaWYoaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbil7IGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiIH1cbiAgICBsZXQgc2Nyb2xsVGltZXIgPSBudWxsXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgX2UgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFRpbWVyKVxuICAgICAgc2Nyb2xsVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgQnJvd3Nlci51cGRhdGVDdXJyZW50U3RhdGUoc3RhdGUgPT4gT2JqZWN0LmFzc2lnbihzdGF0ZSwge3Njcm9sbDogd2luZG93LnNjcm9sbFl9KSlcbiAgICAgIH0sIDEwMClcbiAgICB9KVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgZXZlbnQgPT4ge1xuICAgICAgaWYoIXRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pKXsgcmV0dXJuIH1cbiAgICAgIGxldCB7dHlwZSwgaWQsIHJvb3QsIHNjcm9sbH0gPSBldmVudC5zdGF0ZSB8fCB7fVxuICAgICAgbGV0IGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuXG4gICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBpZih0aGlzLm1haW4uaXNDb25uZWN0ZWQoKSAmJiAodHlwZSA9PT0gXCJwYXRjaFwiICYmIGlkID09PSB0aGlzLm1haW4uaWQpKXtcbiAgICAgICAgICB0aGlzLm1haW4ucHVzaExpbmtQYXRjaChocmVmLCBudWxsKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVwbGFjZU1haW4oaHJlZiwgbnVsbCwgKCkgPT4ge1xuICAgICAgICAgICAgaWYocm9vdCl7IHRoaXMucmVwbGFjZVJvb3RIaXN0b3J5KCkgfVxuICAgICAgICAgICAgaWYodHlwZW9mKHNjcm9sbCkgPT09IFwibnVtYmVyXCIpe1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgc2Nyb2xsKVxuICAgICAgICAgICAgICB9LCAwKSAvLyB0aGUgYm9keSBuZWVkcyB0byByZW5kZXIgYmVmb3JlIHdlIHNjcm9sbC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sIGZhbHNlKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XG4gICAgICBsZXQgdGFyZ2V0ID0gY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIFBIWF9MSVZFX0xJTkspXG4gICAgICBsZXQgdHlwZSA9IHRhcmdldCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFBIWF9MSVZFX0xJTkspXG4gICAgICBsZXQgd2FudHNOZXdUYWIgPSBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuYnV0dG9uID09PSAxXG4gICAgICBpZighdHlwZSB8fCAhdGhpcy5pc0Nvbm5lY3RlZCgpIHx8ICF0aGlzLm1haW4gfHwgd2FudHNOZXdUYWIpeyByZXR1cm4gfVxuXG4gICAgICBsZXQgaHJlZiA9IHRhcmdldC5ocmVmXG4gICAgICBsZXQgbGlua1N0YXRlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShQSFhfTElOS19TVEFURSlcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSAvLyBkbyBub3QgYnViYmxlIGNsaWNrIHRvIHJlZ3VsYXIgcGh4LWNsaWNrIGJpbmRpbmdzXG4gICAgICBpZih0aGlzLnBlbmRpbmdMaW5rID09PSBocmVmKXsgcmV0dXJuIH1cblxuICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgaWYodHlwZSA9PT0gXCJwYXRjaFwiKXtcbiAgICAgICAgICB0aGlzLnB1c2hIaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCB0YXJnZXQpXG4gICAgICAgIH0gZWxzZSBpZih0eXBlID09PSBcInJlZGlyZWN0XCIpe1xuICAgICAgICAgIHRoaXMuaGlzdG9yeVJlZGlyZWN0KGhyZWYsIGxpbmtTdGF0ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7UEhYX0xJVkVfTElOS30gdG8gYmUgXCJwYXRjaFwiIG9yIFwicmVkaXJlY3RcIiwgZ290OiAke3R5cGV9YClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LCBmYWxzZSlcbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQsIHBheWxvYWQgPSB7fSl7XG4gICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBgcGh4OiR7ZXZlbnR9YCwge2RldGFpbDogcGF5bG9hZH0pXG4gIH1cblxuICBkaXNwYXRjaEV2ZW50cyhldmVudHMpe1xuICAgIGV2ZW50cy5mb3JFYWNoKChbZXZlbnQsIHBheWxvYWRdKSA9PiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQsIHBheWxvYWQpKVxuICB9XG5cbiAgd2l0aFBhZ2VMb2FkaW5nKGluZm8sIGNhbGxiYWNrKXtcbiAgICBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCB7ZGV0YWlsOiBpbmZvfSlcbiAgICBsZXQgZG9uZSA9ICgpID0+IERPTS5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0b3BcIiwge2RldGFpbDogaW5mb30pXG4gICAgcmV0dXJuIGNhbGxiYWNrID8gY2FsbGJhY2soZG9uZSkgOiBkb25lXG4gIH1cblxuICBwdXNoSGlzdG9yeVBhdGNoKGhyZWYsIGxpbmtTdGF0ZSwgdGFyZ2V0RWwpe1xuICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzogaHJlZiwga2luZDogXCJwYXRjaFwifSwgZG9uZSA9PiB7XG4gICAgICB0aGlzLm1haW4ucHVzaExpbmtQYXRjaChocmVmLCB0YXJnZXRFbCwgbGlua1JlZiA9PiB7XG4gICAgICAgIHRoaXMuaGlzdG9yeVBhdGNoKGhyZWYsIGxpbmtTdGF0ZSwgbGlua1JlZilcbiAgICAgICAgZG9uZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBoaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSl7XG4gICAgaWYoIXRoaXMuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpeyByZXR1cm4gfVxuXG4gICAgQnJvd3Nlci5wdXNoU3RhdGUobGlua1N0YXRlLCB7dHlwZTogXCJwYXRjaFwiLCBpZDogdGhpcy5tYWluLmlkfSwgaHJlZilcbiAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKVxuICB9XG5cbiAgaGlzdG9yeVJlZGlyZWN0KGhyZWYsIGxpbmtTdGF0ZSwgZmxhc2gpe1xuICAgIGxldCBzY3JvbGwgPSB3aW5kb3cuc2Nyb2xsWVxuICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzogaHJlZiwga2luZDogXCJyZWRpcmVjdFwifSwgZG9uZSA9PiB7XG4gICAgICB0aGlzLnJlcGxhY2VNYWluKGhyZWYsIGZsYXNoLCAoKSA9PiB7XG4gICAgICAgIEJyb3dzZXIucHVzaFN0YXRlKGxpbmtTdGF0ZSwge3R5cGU6IFwicmVkaXJlY3RcIiwgaWQ6IHRoaXMubWFpbi5pZCwgc2Nyb2xsOiBzY3JvbGx9LCBocmVmKVxuICAgICAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKVxuICAgICAgICBkb25lKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHJlcGxhY2VSb290SGlzdG9yeSgpe1xuICAgIEJyb3dzZXIucHVzaFN0YXRlKFwicmVwbGFjZVwiLCB7cm9vdDogdHJ1ZSwgdHlwZTogXCJwYXRjaFwiLCBpZDogdGhpcy5tYWluLmlkfSlcbiAgfVxuXG4gIHJlZ2lzdGVyTmV3TG9jYXRpb24obmV3TG9jYXRpb24pe1xuICAgIGxldCB7cGF0aG5hbWUsIHNlYXJjaH0gPSB0aGlzLmN1cnJlbnRMb2NhdGlvblxuICAgIGlmKHBhdGhuYW1lICsgc2VhcmNoID09PSBuZXdMb2NhdGlvbi5wYXRobmFtZSArIG5ld0xvY2F0aW9uLnNlYXJjaCl7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBjbG9uZShuZXdMb2NhdGlvbilcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgYmluZEZvcm1zKCl7XG4gICAgbGV0IGl0ZXJhdGlvbnMgPSAwXG4gICAgdGhpcy5vbihcInN1Ym1pdFwiLCBlID0+IHtcbiAgICAgIGxldCBwaHhFdmVudCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJzdWJtaXRcIikpXG4gICAgICBpZighcGh4RXZlbnQpeyByZXR1cm4gfVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBlLnRhcmdldC5kaXNhYmxlZCA9IHRydWVcbiAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCB2aWV3ID0+IHtcbiAgICAgICAgSlMuZXhlYyhcInN1Ym1pdFwiLCBwaHhFdmVudCwgdmlldywgZS50YXJnZXQsIFtcInB1c2hcIiwge31dKVxuICAgICAgfSlcbiAgICB9LCBmYWxzZSlcblxuICAgIGZvcihsZXQgdHlwZSBvZiBbXCJjaGFuZ2VcIiwgXCJpbnB1dFwiXSl7XG4gICAgICB0aGlzLm9uKHR5cGUsIGUgPT4ge1xuICAgICAgICBsZXQgcGh4Q2hhbmdlID0gdGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpXG4gICAgICAgIGxldCBpbnB1dCA9IGUudGFyZ2V0XG4gICAgICAgIGxldCBpbnB1dEV2ZW50ID0gaW5wdXQuZ2V0QXR0cmlidXRlKHBoeENoYW5nZSlcbiAgICAgICAgbGV0IGZvcm1FdmVudCA9IGlucHV0LmZvcm0gJiYgaW5wdXQuZm9ybS5nZXRBdHRyaWJ1dGUocGh4Q2hhbmdlKVxuICAgICAgICBsZXQgcGh4RXZlbnQgPSBpbnB1dEV2ZW50IHx8IGZvcm1FdmVudFxuICAgICAgICBpZighcGh4RXZlbnQpeyByZXR1cm4gfVxuICAgICAgICBpZihpbnB1dC50eXBlID09PSBcIm51bWJlclwiICYmIGlucHV0LnZhbGlkaXR5ICYmIGlucHV0LnZhbGlkaXR5LmJhZElucHV0KXsgcmV0dXJuIH1cblxuICAgICAgICBsZXQgZGlzcGF0Y2hlciA9IGlucHV0RXZlbnQgPyBpbnB1dCA6IGlucHV0LmZvcm1cbiAgICAgICAgbGV0IGN1cnJlbnRJdGVyYXRpb25zID0gaXRlcmF0aW9uc1xuICAgICAgICBpdGVyYXRpb25zKytcbiAgICAgICAgbGV0IHthdDogYXQsIHR5cGU6IGxhc3RUeXBlfSA9IERPTS5wcml2YXRlKGlucHV0LCBcInByZXYtaXRlcmF0aW9uXCIpIHx8IHt9XG4gICAgICAgIC8vIGRldGVjdCBkdXAgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGRpc3BhdGNoIGJvdGggXCJpbnB1dFwiIGFuZCBcImNoYW5nZVwiXG4gICAgICAgIGlmKGF0ID09PSBjdXJyZW50SXRlcmF0aW9ucyAtIDEgJiYgdHlwZSAhPT0gbGFzdFR5cGUpeyByZXR1cm4gfVxuXG4gICAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0LCBcInByZXYtaXRlcmF0aW9uXCIsIHthdDogY3VycmVudEl0ZXJhdGlvbnMsIHR5cGU6IHR5cGV9KVxuXG4gICAgICAgIHRoaXMuZGVib3VuY2UoaW5wdXQsIGUsIHR5cGUsICgpID0+IHtcbiAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhkaXNwYXRjaGVyLCB2aWV3ID0+IHtcbiAgICAgICAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0LCBQSFhfSEFTX0ZPQ1VTRUQsIHRydWUpXG4gICAgICAgICAgICBpZighRE9NLmlzVGV4dHVhbElucHV0KGlucHV0KSl7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlRWxlbWVudChpbnB1dClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEpTLmV4ZWMoXCJjaGFuZ2VcIiwgcGh4RXZlbnQsIHZpZXcsIGlucHV0LCBbXCJwdXNoXCIsIHtfdGFyZ2V0OiBlLnRhcmdldC5uYW1lLCBkaXNwYXRjaGVyOiBkaXNwYXRjaGVyfV0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0sIGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIGRlYm91bmNlKGVsLCBldmVudCwgZXZlbnRUeXBlLCBjYWxsYmFjayl7XG4gICAgaWYoZXZlbnRUeXBlID09PSBcImJsdXJcIiB8fCBldmVudFR5cGUgPT09IFwiZm9jdXNvdXRcIil7IHJldHVybiBjYWxsYmFjaygpIH1cblxuICAgIGxldCBwaHhEZWJvdW5jZSA9IHRoaXMuYmluZGluZyhQSFhfREVCT1VOQ0UpXG4gICAgbGV0IHBoeFRocm90dGxlID0gdGhpcy5iaW5kaW5nKFBIWF9USFJPVFRMRSlcbiAgICBsZXQgZGVmYXVsdERlYm91bmNlID0gdGhpcy5kZWZhdWx0cy5kZWJvdW5jZS50b1N0cmluZygpXG4gICAgbGV0IGRlZmF1bHRUaHJvdHRsZSA9IHRoaXMuZGVmYXVsdHMudGhyb3R0bGUudG9TdHJpbmcoKVxuXG4gICAgdGhpcy53aXRoaW5Pd25lcnMoZWwsIHZpZXcgPT4ge1xuICAgICAgbGV0IGFzeW5jRmlsdGVyID0gKCkgPT4gIXZpZXcuaXNEZXN0cm95ZWQoKSAmJiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsKVxuICAgICAgRE9NLmRlYm91bmNlKGVsLCBldmVudCwgcGh4RGVib3VuY2UsIGRlZmF1bHREZWJvdW5jZSwgcGh4VGhyb3R0bGUsIGRlZmF1bHRUaHJvdHRsZSwgYXN5bmNGaWx0ZXIsICgpID0+IHtcbiAgICAgICAgY2FsbGJhY2soKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgc2lsZW5jZUV2ZW50cyhjYWxsYmFjayl7XG4gICAgdGhpcy5zaWxlbmNlZCA9IHRydWVcbiAgICBjYWxsYmFjaygpXG4gICAgdGhpcy5zaWxlbmNlZCA9IGZhbHNlXG4gIH1cblxuICBvbihldmVudCwgY2FsbGJhY2spe1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBlID0+IHtcbiAgICAgIGlmKCF0aGlzLnNpbGVuY2VkKXsgY2FsbGJhY2soZSkgfVxuICAgIH0pXG4gIH1cbn1cblxuY2xhc3MgVHJhbnNpdGlvblNldCB7XG4gIGNvbnN0cnVjdG9yKCl7XG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IG5ldyBTZXQoKVxuICAgIHRoaXMucGVuZGluZ09wcyA9IFtdXG4gICAgdGhpcy5yZXNldCgpXG4gIH1cblxuICByZXNldCgpe1xuICAgIHRoaXMudHJhbnNpdGlvbnMuZm9yRWFjaCh0aW1lciA9PiB7XG4gICAgICBjYW5jZWxUaW1lb3V0KHRpbWVyKVxuICAgICAgdGhpcy50cmFuc2l0aW9ucy5kZWxldGUodGltZXIpXG4gICAgfSlcbiAgICB0aGlzLmZsdXNoUGVuZGluZ09wcygpXG4gIH1cblxuICBhZnRlcihjYWxsYmFjayl7XG4gICAgaWYodGhpcy5zaXplKCkgPT09IDApe1xuICAgICAgY2FsbGJhY2soKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hQZW5kaW5nT3AoY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgYWRkVHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpe1xuICAgIG9uU3RhcnQoKVxuICAgIGxldCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2l0aW9ucy5kZWxldGUodGltZXIpXG4gICAgICBvbkRvbmUoKVxuICAgICAgaWYodGhpcy5zaXplKCkgPT09IDApeyB0aGlzLmZsdXNoUGVuZGluZ09wcygpIH1cbiAgICB9LCB0aW1lKVxuICAgIHRoaXMudHJhbnNpdGlvbnMuYWRkKHRpbWVyKVxuICB9XG5cbiAgcHVzaFBlbmRpbmdPcChvcCl7IHRoaXMucGVuZGluZ09wcy5wdXNoKG9wKSB9XG5cbiAgc2l6ZSgpeyByZXR1cm4gdGhpcy50cmFuc2l0aW9ucy5zaXplIH1cblxuICBmbHVzaFBlbmRpbmdPcHMoKXtcbiAgICB0aGlzLnBlbmRpbmdPcHMuZm9yRWFjaChvcCA9PiBvcCgpKVxuICAgIHRoaXMucGVuZGluZ09wcyA9IFtdXG4gIH1cbn1cbiIsICIvLyBXZSBpbXBvcnQgdGhlIENTUyB3aGljaCBpcyBleHRyYWN0ZWQgdG8gaXRzIG93biBmaWxlIGJ5IGVzYnVpbGQuXG4vLyBSZW1vdmUgdGhpcyBsaW5lIGlmIHlvdSBhZGQgYSB5b3VyIG93biBDU1MgYnVpbGQgcGlwZWxpbmUgKGUuZyBwb3N0Y3NzKS5cbmltcG9ydCBcIi4uL2Nzcy9hcHAuY3NzXCJcblxuLy8gSWYgeW91IHdhbnQgdG8gdXNlIFBob2VuaXggY2hhbm5lbHMsIHJ1biBgbWl4IGhlbHAgcGh4Lmdlbi5jaGFubmVsYFxuLy8gdG8gZ2V0IHN0YXJ0ZWQgYW5kIHRoZW4gdW5jb21tZW50IHRoZSBsaW5lIGJlbG93LlxuLy8gaW1wb3J0IFwiLi91c2VyX3NvY2tldC5qc1wiXG5cbi8vIFlvdSBjYW4gaW5jbHVkZSBkZXBlbmRlbmNpZXMgaW4gdHdvIHdheXMuXG4vL1xuLy8gVGhlIHNpbXBsZXN0IG9wdGlvbiBpcyB0byBwdXQgdGhlbSBpbiBhc3NldHMvdmVuZG9yIGFuZFxuLy8gaW1wb3J0IHRoZW0gdXNpbmcgcmVsYXRpdmUgcGF0aHM6XG4vL1xuLy8gICAgIGltcG9ydCBcIi4uL3ZlbmRvci9zb21lLXBhY2thZ2UuanNcIlxuLy9cbi8vIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gYG5wbSBpbnN0YWxsIHNvbWUtcGFja2FnZSAtLXByZWZpeCBhc3NldHNgIGFuZCBpbXBvcnRcbi8vIHRoZW0gdXNpbmcgYSBwYXRoIHN0YXJ0aW5nIHdpdGggdGhlIHBhY2thZ2UgbmFtZTpcbi8vXG4vLyAgICAgaW1wb3J0IFwic29tZS1wYWNrYWdlXCJcbi8vXG5cbi8vIEluY2x1ZGUgcGhvZW5peF9odG1sIHRvIGhhbmRsZSBtZXRob2Q9UFVUL0RFTEVURSBpbiBmb3JtcyBhbmQgYnV0dG9ucy5cbmltcG9ydCBcInBob2VuaXhfaHRtbFwiXG4vLyBFc3RhYmxpc2ggUGhvZW5peCBTb2NrZXQgYW5kIExpdmVWaWV3IGNvbmZpZ3VyYXRpb24uXG5pbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxuaW1wb3J0IHtMaXZlU29ja2V0fSBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIlxuaW1wb3J0IHRvcGJhciBmcm9tIFwiLi4vdmVuZG9yL3RvcGJhclwiXG5pbXBvcnQge0NoYXJ0SG9va30gZnJvbSBcIi4vY2hhcnRcIlxuXG5sZXQgSG9va3MgPSB7XG4gIENoYXJ0OiBDaGFydEhvb2tcbiAgLy8gVGhpcyBuYW1lIChDaGFydCkgbXVzdCBiZSB0aGUgc2FtZSBuYW1lIGFzIGluIHRoZSBwaHggYXR0cmlidXRlLiAoZG9tLWVsZW1lbnQpXG4gIC8vIFdlIGNvdWxkIGFsc28gd3JpdGUgb3VyIGNhbGxiYWNrcyBpbiBoZXJlIG5hdHVyYWxseSBidXQgdGhpcyBpcyBtdWNoIGNsZWFuZXIuXG59XG5sZXQgdGltZXpvbmUgPSBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7XG5sZXQgY3NyZlRva2VuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIm1ldGFbbmFtZT0nY3NyZi10b2tlbiddXCIpLmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIilcbmxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHtob29rczogSG9va3MsIHBhcmFtczogeyBfY3NyZl90b2tlbjogY3NyZlRva2VuLCB0aW1lem9uZTogdGltZXpvbmV9fSlcblxuLy8gU2hvdyBwcm9ncmVzcyBiYXIgb24gbGl2ZSBuYXZpZ2F0aW9uIGFuZCBmb3JtIHN1Ym1pdHNcbnRvcGJhci5jb25maWcoe2JhckNvbG9yczogezA6IFwiIzI5ZFwifSwgc2hhZG93Q29sb3I6IFwicmdiYSgwLCAwLCAwLCAuMylcIn0pXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIiwgaW5mbyA9PiB0b3BiYXIuc2hvdygpKVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6cGFnZS1sb2FkaW5nLXN0b3BcIiwgaW5mbyA9PiB0b3BiYXIuaGlkZSgpKVxuXG4vLyBjb25uZWN0IGlmIHRoZXJlIGFyZSBhbnkgTGl2ZVZpZXdzIG9uIHRoZSBwYWdlXG5saXZlU29ja2V0LmNvbm5lY3QoKVxuXG4vLyBleHBvc2UgbGl2ZVNvY2tldCBvbiB3aW5kb3cgZm9yIHdlYiBjb25zb2xlIGRlYnVnIGxvZ3MgYW5kIGxhdGVuY3kgc2ltdWxhdGlvbjpcbi8vID4+IGxpdmVTb2NrZXQuZW5hYmxlRGVidWcoKVxuLy8gPj4gbGl2ZVNvY2tldC5lbmFibGVMYXRlbmN5U2ltKDEwMDApICAvLyBlbmFibGVkIGZvciBkdXJhdGlvbiBvZiBicm93c2VyIHNlc3Npb25cbi8vID4+IGxpdmVTb2NrZXQuZGlzYWJsZUxhdGVuY3lTaW0oKVxud2luZG93LmxpdmVTb2NrZXQgPSBsaXZlU29ja2V0XG5cbiIsICIvKipcbiogQ29weXJpZ2h0IChjKSAyMDIyLCBMZW9uIFNvcm9raW5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbipcbiogdVBsb3QuanMgKFx1MDNCQ1Bsb3QpXG4qIEEgc21hbGwsIGZhc3QgY2hhcnQgZm9yIHRpbWUgc2VyaWVzLCBsaW5lcywgYXJlYXMsIG9obGMgJiBiYXJzXG4qIGh0dHBzOi8vZ2l0aHViLmNvbS9sZWVvbml5YS91UGxvdCAodjEuNi4yMilcbiovXG5cbmNvbnN0IEZFQVRfVElNRSAgICAgICAgICA9IHRydWU7XG5cbmNvbnN0IHByZSA9IFwidS1cIjtcblxuY29uc3QgVVBMT1QgICAgICAgICAgPSAgICAgICBcInVwbG90XCI7XG5jb25zdCBPUklfSFogICAgICAgICA9IHByZSArIFwiaHpcIjtcbmNvbnN0IE9SSV9WVCAgICAgICAgID0gcHJlICsgXCJ2dFwiO1xuY29uc3QgVElUTEUgICAgICAgICAgPSBwcmUgKyBcInRpdGxlXCI7XG5jb25zdCBXUkFQICAgICAgICAgICA9IHByZSArIFwid3JhcFwiO1xuY29uc3QgVU5ERVIgICAgICAgICAgPSBwcmUgKyBcInVuZGVyXCI7XG5jb25zdCBPVkVSICAgICAgICAgICA9IHByZSArIFwib3ZlclwiO1xuY29uc3QgQVhJUyAgICAgICAgICAgPSBwcmUgKyBcImF4aXNcIjtcbmNvbnN0IE9GRiAgICAgICAgICAgID0gcHJlICsgXCJvZmZcIjtcbmNvbnN0IFNFTEVDVCAgICAgICAgID0gcHJlICsgXCJzZWxlY3RcIjtcbmNvbnN0IENVUlNPUl9YICAgICAgID0gcHJlICsgXCJjdXJzb3IteFwiO1xuY29uc3QgQ1VSU09SX1kgICAgICAgPSBwcmUgKyBcImN1cnNvci15XCI7XG5jb25zdCBDVVJTT1JfUFQgICAgICA9IHByZSArIFwiY3Vyc29yLXB0XCI7XG5jb25zdCBMRUdFTkQgICAgICAgICA9IHByZSArIFwibGVnZW5kXCI7XG5jb25zdCBMRUdFTkRfTElWRSAgICA9IHByZSArIFwibGl2ZVwiO1xuY29uc3QgTEVHRU5EX0lOTElORSAgPSBwcmUgKyBcImlubGluZVwiO1xuY29uc3QgTEVHRU5EX1RIRUFEICAgPSBwcmUgKyBcInRoZWFkXCI7XG5jb25zdCBMRUdFTkRfU0VSSUVTICA9IHByZSArIFwic2VyaWVzXCI7XG5jb25zdCBMRUdFTkRfTUFSS0VSICA9IHByZSArIFwibWFya2VyXCI7XG5jb25zdCBMRUdFTkRfTEFCRUwgICA9IHByZSArIFwibGFiZWxcIjtcbmNvbnN0IExFR0VORF9WQUxVRSAgID0gcHJlICsgXCJ2YWx1ZVwiO1xuXG5jb25zdCBXSURUSCAgICAgICA9IFwid2lkdGhcIjtcbmNvbnN0IEhFSUdIVCAgICAgID0gXCJoZWlnaHRcIjtcbmNvbnN0IFRPUCAgICAgICAgID0gXCJ0b3BcIjtcbmNvbnN0IEJPVFRPTSAgICAgID0gXCJib3R0b21cIjtcbmNvbnN0IExFRlQgICAgICAgID0gXCJsZWZ0XCI7XG5jb25zdCBSSUdIVCAgICAgICA9IFwicmlnaHRcIjtcbmNvbnN0IGhleEJsYWNrICAgID0gXCIjMDAwXCI7XG5jb25zdCB0cmFuc3BhcmVudCA9IGhleEJsYWNrICsgXCIwXCI7XG5cbmNvbnN0IG1vdXNlbW92ZSAgID0gXCJtb3VzZW1vdmVcIjtcbmNvbnN0IG1vdXNlZG93biAgID0gXCJtb3VzZWRvd25cIjtcbmNvbnN0IG1vdXNldXAgICAgID0gXCJtb3VzZXVwXCI7XG5jb25zdCBtb3VzZWVudGVyICA9IFwibW91c2VlbnRlclwiO1xuY29uc3QgbW91c2VsZWF2ZSAgPSBcIm1vdXNlbGVhdmVcIjtcbmNvbnN0IGRibGNsaWNrICAgID0gXCJkYmxjbGlja1wiO1xuY29uc3QgcmVzaXplICAgICAgPSBcInJlc2l6ZVwiO1xuY29uc3Qgc2Nyb2xsICAgICAgPSBcInNjcm9sbFwiO1xuXG5jb25zdCBjaGFuZ2UgICAgICA9IFwiY2hhbmdlXCI7XG5jb25zdCBkcHB4Y2hhbmdlICA9IFwiZHBweGNoYW5nZVwiO1xuXG5jb25zdCBkb21FbnYgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnO1xuXG5jb25zdCBkb2MgPSBkb21FbnYgPyBkb2N1bWVudCAgOiBudWxsO1xuY29uc3Qgd2luID0gZG9tRW52ID8gd2luZG93ICAgIDogbnVsbDtcbmNvbnN0IG5hdiA9IGRvbUVudiA/IG5hdmlnYXRvciA6IG51bGw7XG5cbmxldCBweFJhdGlvO1xuXG5sZXQgcXVlcnk7XG5cbmZ1bmN0aW9uIHNldFB4UmF0aW8oKSB7XG5cdGxldCBfcHhSYXRpbyA9IGRldmljZVBpeGVsUmF0aW87XG5cblx0Ly8gZHVyaW5nIHByaW50IHByZXZpZXcsIENocm9tZSBmaXJlcyBvZmYgdGhlc2UgZHBweCBxdWVyaWVzIGV2ZW4gd2l0aG91dCBjaGFuZ2VzXG5cdGlmIChweFJhdGlvICE9IF9weFJhdGlvKSB7XG5cdFx0cHhSYXRpbyA9IF9weFJhdGlvO1xuXG5cdFx0cXVlcnkgJiYgb2ZmKGNoYW5nZSwgcXVlcnksIHNldFB4UmF0aW8pO1xuXHRcdHF1ZXJ5ID0gbWF0Y2hNZWRpYShgKG1pbi1yZXNvbHV0aW9uOiAke3B4UmF0aW8gLSAwLjAwMX1kcHB4KSBhbmQgKG1heC1yZXNvbHV0aW9uOiAke3B4UmF0aW8gKyAwLjAwMX1kcHB4KWApO1xuXHRcdG9uKGNoYW5nZSwgcXVlcnksIHNldFB4UmF0aW8pO1xuXG5cdFx0d2luLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGRwcHhjaGFuZ2UpKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhZGRDbGFzcyhlbCwgYykge1xuXHRpZiAoYyAhPSBudWxsKSB7XG5cdFx0bGV0IGNsID0gZWwuY2xhc3NMaXN0O1xuXHRcdCFjbC5jb250YWlucyhjKSAmJiBjbC5hZGQoYyk7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtQ2xhc3MoZWwsIGMpIHtcblx0bGV0IGNsID0gZWwuY2xhc3NMaXN0O1xuXHRjbC5jb250YWlucyhjKSAmJiBjbC5yZW1vdmUoYyk7XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlUHgoZWwsIG5hbWUsIHZhbHVlKSB7XG5cdGVsLnN0eWxlW25hbWVdID0gdmFsdWUgKyBcInB4XCI7XG59XG5cbmZ1bmN0aW9uIHBsYWNlVGFnKHRhZywgY2xzLCB0YXJnLCByZWZFbCkge1xuXHRsZXQgZWwgPSBkb2MuY3JlYXRlRWxlbWVudCh0YWcpO1xuXG5cdGlmIChjbHMgIT0gbnVsbClcblx0XHRhZGRDbGFzcyhlbCwgY2xzKTtcblxuXHRpZiAodGFyZyAhPSBudWxsKVxuXHRcdHRhcmcuaW5zZXJ0QmVmb3JlKGVsLCByZWZFbCk7XG5cblx0cmV0dXJuIGVsO1xufVxuXG5mdW5jdGlvbiBwbGFjZURpdihjbHMsIHRhcmcpIHtcblx0cmV0dXJuIHBsYWNlVGFnKFwiZGl2XCIsIGNscywgdGFyZyk7XG59XG5cbmNvbnN0IHhmb3JtQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG5mdW5jdGlvbiBlbFRyYW5zKGVsLCB4UG9zLCB5UG9zLCB4TWF4LCB5TWF4KSB7XG5cdGxldCB4Zm9ybSA9IFwidHJhbnNsYXRlKFwiICsgeFBvcyArIFwicHgsXCIgKyB5UG9zICsgXCJweClcIjtcblx0bGV0IHhmb3JtT2xkID0geGZvcm1DYWNoZS5nZXQoZWwpO1xuXG5cdGlmICh4Zm9ybSAhPSB4Zm9ybU9sZCkge1xuXHRcdGVsLnN0eWxlLnRyYW5zZm9ybSA9IHhmb3JtO1xuXHRcdHhmb3JtQ2FjaGUuc2V0KGVsLCB4Zm9ybSk7XG5cblx0XHRpZiAoeFBvcyA8IDAgfHwgeVBvcyA8IDAgfHwgeFBvcyA+IHhNYXggfHwgeVBvcyA+IHlNYXgpXG5cdFx0XHRhZGRDbGFzcyhlbCwgT0ZGKTtcblx0XHRlbHNlXG5cdFx0XHRyZW1DbGFzcyhlbCwgT0ZGKTtcblx0fVxufVxuXG5jb25zdCBjb2xvckNhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gZWxDb2xvcihlbCwgYmFja2dyb3VuZCwgYm9yZGVyQ29sb3IpIHtcblx0bGV0IG5ld0NvbG9yID0gYmFja2dyb3VuZCArIGJvcmRlckNvbG9yO1xuXHRsZXQgb2xkQ29sb3IgPSBjb2xvckNhY2hlLmdldChlbCk7XG5cblx0aWYgKG5ld0NvbG9yICE9IG9sZENvbG9yKSB7XG5cdFx0Y29sb3JDYWNoZS5zZXQoZWwsIG5ld0NvbG9yKTtcblx0XHRlbC5zdHlsZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcblx0XHRlbC5zdHlsZS5ib3JkZXJDb2xvciA9IGJvcmRlckNvbG9yO1xuXHR9XG59XG5cbmNvbnN0IHNpemVDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbmZ1bmN0aW9uIGVsU2l6ZShlbCwgbmV3V2lkLCBuZXdIZ3QsIGNlbnRlcmVkKSB7XG5cdGxldCBuZXdTaXplID0gbmV3V2lkICsgXCJcIiArIG5ld0hndDtcblx0bGV0IG9sZFNpemUgPSBzaXplQ2FjaGUuZ2V0KGVsKTtcblxuXHRpZiAobmV3U2l6ZSAhPSBvbGRTaXplKSB7XG5cdFx0c2l6ZUNhY2hlLnNldChlbCwgbmV3U2l6ZSk7XG5cdFx0ZWwuc3R5bGUuaGVpZ2h0ID0gbmV3SGd0ICsgXCJweFwiO1xuXHRcdGVsLnN0eWxlLndpZHRoID0gbmV3V2lkICsgXCJweFwiO1xuXHRcdGVsLnN0eWxlLm1hcmdpbkxlZnQgPSBjZW50ZXJlZCA/IC1uZXdXaWQvMiArIFwicHhcIiA6IDA7XG5cdFx0ZWwuc3R5bGUubWFyZ2luVG9wID0gY2VudGVyZWQgPyAtbmV3SGd0LzIgKyBcInB4XCIgOiAwO1xuXHR9XG59XG5cbmNvbnN0IGV2T3B0cyA9IHtwYXNzaXZlOiB0cnVlfTtcbmNvbnN0IGV2T3B0czIgPSB7Li4uZXZPcHRzLCBjYXB0dXJlOiB0cnVlfTtcblxuZnVuY3Rpb24gb24oZXYsIGVsLCBjYiwgY2FwdCkge1xuXHRlbC5hZGRFdmVudExpc3RlbmVyKGV2LCBjYiwgY2FwdCA/IGV2T3B0czIgOiBldk9wdHMpO1xufVxuXG5mdW5jdGlvbiBvZmYoZXYsIGVsLCBjYiwgY2FwdCkge1xuXHRlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2LCBjYiwgY2FwdCA/IGV2T3B0czIgOiBldk9wdHMpO1xufVxuXG5kb21FbnYgJiYgc2V0UHhSYXRpbygpO1xuXG4vLyBiaW5hcnkgc2VhcmNoIGZvciBpbmRleCBvZiBjbG9zZXN0IHZhbHVlXG5mdW5jdGlvbiBjbG9zZXN0SWR4KG51bSwgYXJyLCBsbywgaGkpIHtcblx0bGV0IG1pZDtcblx0bG8gPSBsbyB8fCAwO1xuXHRoaSA9IGhpIHx8IGFyci5sZW5ndGggLSAxO1xuXHRsZXQgYml0d2lzZSA9IGhpIDw9IDIxNDc0ODM2NDc7XG5cblx0d2hpbGUgKGhpIC0gbG8gPiAxKSB7XG5cdFx0bWlkID0gYml0d2lzZSA/IChsbyArIGhpKSA+PiAxIDogZmxvb3IoKGxvICsgaGkpIC8gMik7XG5cblx0XHRpZiAoYXJyW21pZF0gPCBudW0pXG5cdFx0XHRsbyA9IG1pZDtcblx0XHRlbHNlXG5cdFx0XHRoaSA9IG1pZDtcblx0fVxuXG5cdGlmIChudW0gLSBhcnJbbG9dIDw9IGFycltoaV0gLSBudW0pXG5cdFx0cmV0dXJuIGxvO1xuXG5cdHJldHVybiBoaTtcbn1cblxuZnVuY3Rpb24gbm9uTnVsbElkeChkYXRhLCBfaTAsIF9pMSwgZGlyKSB7XG5cdGZvciAobGV0IGkgPSBkaXIgPT0gMSA/IF9pMCA6IF9pMTsgaSA+PSBfaTAgJiYgaSA8PSBfaTE7IGkgKz0gZGlyKSB7XG5cdFx0aWYgKGRhdGFbaV0gIT0gbnVsbClcblx0XHRcdHJldHVybiBpO1xuXHR9XG5cblx0cmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBnZXRNaW5NYXgoZGF0YSwgX2kwLCBfaTEsIHNvcnRlZCkge1xuLy9cdGNvbnNvbGUubG9nKFwiZ2V0TWluTWF4KClcIik7XG5cblx0bGV0IF9taW4gPSBpbmY7XG5cdGxldCBfbWF4ID0gLWluZjtcblxuXHRpZiAoc29ydGVkID09IDEpIHtcblx0XHRfbWluID0gZGF0YVtfaTBdO1xuXHRcdF9tYXggPSBkYXRhW19pMV07XG5cdH1cblx0ZWxzZSBpZiAoc29ydGVkID09IC0xKSB7XG5cdFx0X21pbiA9IGRhdGFbX2kxXTtcblx0XHRfbWF4ID0gZGF0YVtfaTBdO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGZvciAobGV0IGkgPSBfaTA7IGkgPD0gX2kxOyBpKyspIHtcblx0XHRcdGlmIChkYXRhW2ldICE9IG51bGwpIHtcblx0XHRcdFx0X21pbiA9IG1pbihfbWluLCBkYXRhW2ldKTtcblx0XHRcdFx0X21heCA9IG1heChfbWF4LCBkYXRhW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gW19taW4sIF9tYXhdO1xufVxuXG5mdW5jdGlvbiBnZXRNaW5NYXhMb2coZGF0YSwgX2kwLCBfaTEpIHtcbi8vXHRjb25zb2xlLmxvZyhcImdldE1pbk1heCgpXCIpO1xuXG5cdGxldCBfbWluID0gaW5mO1xuXHRsZXQgX21heCA9IC1pbmY7XG5cblx0Zm9yIChsZXQgaSA9IF9pMDsgaSA8PSBfaTE7IGkrKykge1xuXHRcdGlmIChkYXRhW2ldID4gMCkge1xuXHRcdFx0X21pbiA9IG1pbihfbWluLCBkYXRhW2ldKTtcblx0XHRcdF9tYXggPSBtYXgoX21heCwgZGF0YVtpXSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFtcblx0XHRfbWluID09ICBpbmYgPyAgMSA6IF9taW4sXG5cdFx0X21heCA9PSAtaW5mID8gMTAgOiBfbWF4LFxuXHRdO1xufVxuXG5jb25zdCBfZml4ZWRUdXBsZSA9IFswLCAwXTtcblxuZnVuY3Rpb24gZml4SW5jcihtaW5JbmNyLCBtYXhJbmNyLCBtaW5FeHAsIG1heEV4cCkge1xuXHRfZml4ZWRUdXBsZVswXSA9IG1pbkV4cCA8IDAgPyByb3VuZERlYyhtaW5JbmNyLCAtbWluRXhwKSA6IG1pbkluY3I7XG5cdF9maXhlZFR1cGxlWzFdID0gbWF4RXhwIDwgMCA/IHJvdW5kRGVjKG1heEluY3IsIC1tYXhFeHApIDogbWF4SW5jcjtcblx0cmV0dXJuIF9maXhlZFR1cGxlO1xufVxuXG5mdW5jdGlvbiByYW5nZUxvZyhtaW4sIG1heCwgYmFzZSwgZnVsbE1hZ3MpIHtcblx0bGV0IG1pblNpZ24gPSBzaWduKG1pbik7XG5cblx0bGV0IGxvZ0ZuID0gYmFzZSA9PSAxMCA/IGxvZzEwIDogbG9nMjtcblxuXHRpZiAobWluID09IG1heCkge1xuXHRcdGlmIChtaW5TaWduID09IC0xKSB7XG5cdFx0XHRtaW4gKj0gYmFzZTtcblx0XHRcdG1heCAvPSBiYXNlO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG1pbiAvPSBiYXNlO1xuXHRcdFx0bWF4ICo9IGJhc2U7XG5cdFx0fVxuXHR9XG5cblx0bGV0IG1pbkV4cCwgbWF4RXhwLCBtaW5NYXhJbmNycztcblxuXHRpZiAoZnVsbE1hZ3MpIHtcblx0XHRtaW5FeHAgPSBmbG9vcihsb2dGbihtaW4pKTtcblx0XHRtYXhFeHAgPSAgY2VpbChsb2dGbihtYXgpKTtcblxuXHRcdG1pbk1heEluY3JzID0gZml4SW5jcihwb3coYmFzZSwgbWluRXhwKSwgcG93KGJhc2UsIG1heEV4cCksIG1pbkV4cCwgbWF4RXhwKTtcblxuXHRcdG1pbiA9IG1pbk1heEluY3JzWzBdO1xuXHRcdG1heCA9IG1pbk1heEluY3JzWzFdO1xuXHR9XG5cdGVsc2Uge1xuXHRcdG1pbkV4cCA9IGZsb29yKGxvZ0ZuKGFicyhtaW4pKSk7XG5cdFx0bWF4RXhwID0gZmxvb3IobG9nRm4oYWJzKG1heCkpKTtcblxuXHRcdG1pbk1heEluY3JzID0gZml4SW5jcihwb3coYmFzZSwgbWluRXhwKSwgcG93KGJhc2UsIG1heEV4cCksIG1pbkV4cCwgbWF4RXhwKTtcblxuXHRcdG1pbiA9IGluY3JSb3VuZERuKG1pbiwgbWluTWF4SW5jcnNbMF0pO1xuXHRcdG1heCA9IGluY3JSb3VuZFVwKG1heCwgbWluTWF4SW5jcnNbMV0pO1xuXHR9XG5cblx0cmV0dXJuIFttaW4sIG1heF07XG59XG5cbmZ1bmN0aW9uIHJhbmdlQXNpbmgobWluLCBtYXgsIGJhc2UsIGZ1bGxNYWdzKSB7XG5cdGxldCBtaW5NYXggPSByYW5nZUxvZyhtaW4sIG1heCwgYmFzZSwgZnVsbE1hZ3MpO1xuXG5cdGlmIChtaW4gPT0gMClcblx0XHRtaW5NYXhbMF0gPSAwO1xuXG5cdGlmIChtYXggPT0gMClcblx0XHRtaW5NYXhbMV0gPSAwO1xuXG5cdHJldHVybiBtaW5NYXg7XG59XG5cbmNvbnN0IHJhbmdlUGFkID0gMC4xO1xuXG5jb25zdCBhdXRvUmFuZ2VQYXJ0ID0ge1xuXHRtb2RlOiAzLFxuXHRwYWQ6IHJhbmdlUGFkLFxufTtcblxuY29uc3QgX2VxUmFuZ2VQYXJ0ID0ge1xuXHRwYWQ6ICAwLFxuXHRzb2Z0OiBudWxsLFxuXHRtb2RlOiAwLFxufTtcblxuY29uc3QgX2VxUmFuZ2UgPSB7XG5cdG1pbjogX2VxUmFuZ2VQYXJ0LFxuXHRtYXg6IF9lcVJhbmdlUGFydCxcbn07XG5cbi8vIHRoaXMgZW5zdXJlcyB0aGF0IG5vbi10ZW1wb3JhbC9udW1lcmljIHktYXhlcyBnZXQgbXVsdGlwbGUtc25hcHBlZCBwYWRkaW5nIGFkZGVkIGFib3ZlL2JlbG93XG4vLyBUT0RPOiBhbHNvIGFjY291bnQgZm9yIGluY3JzIHdoZW4gc25hcHBpbmcgdG8gZW5zdXJlIHRvcCBvZiBheGlzIGdldHMgYSB0aWNrICYgdmFsdWVcbmZ1bmN0aW9uIHJhbmdlTnVtKF9taW4sIF9tYXgsIG11bHQsIGV4dHJhKSB7XG5cdGlmIChpc09iaihtdWx0KSlcblx0XHRyZXR1cm4gX3JhbmdlTnVtKF9taW4sIF9tYXgsIG11bHQpO1xuXG5cdF9lcVJhbmdlUGFydC5wYWQgID0gbXVsdDtcblx0X2VxUmFuZ2VQYXJ0LnNvZnQgPSBleHRyYSA/IDAgOiBudWxsO1xuXHRfZXFSYW5nZVBhcnQubW9kZSA9IGV4dHJhID8gMyA6IDA7XG5cblx0cmV0dXJuIF9yYW5nZU51bShfbWluLCBfbWF4LCBfZXFSYW5nZSk7XG59XG5cbi8vIG51bGxpc2ggY29hbGVzY2VcbmZ1bmN0aW9uIGlmTnVsbChsaCwgcmgpIHtcblx0cmV0dXJuIGxoID09IG51bGwgPyByaCA6IGxoO1xufVxuXG4vLyBjaGVja3MgaWYgZ2l2ZW4gaW5kZXggcmFuZ2UgaW4gYW4gYXJyYXkgY29udGFpbnMgYSBub24tbnVsbCB2YWx1ZVxuLy8gYWthIGEgcmFuZ2UtYm91bmRlZCBBcnJheS5zb21lKClcbmZ1bmN0aW9uIGhhc0RhdGEoZGF0YSwgaWR4MCwgaWR4MSkge1xuXHRpZHgwID0gaWZOdWxsKGlkeDAsIDApO1xuXHRpZHgxID0gaWZOdWxsKGlkeDEsIGRhdGEubGVuZ3RoIC0gMSk7XG5cblx0d2hpbGUgKGlkeDAgPD0gaWR4MSkge1xuXHRcdGlmIChkYXRhW2lkeDBdICE9IG51bGwpXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRpZHgwKys7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF9yYW5nZU51bShfbWluLCBfbWF4LCBjZmcpIHtcblx0bGV0IGNtaW4gPSBjZmcubWluO1xuXHRsZXQgY21heCA9IGNmZy5tYXg7XG5cblx0bGV0IHBhZE1pbiA9IGlmTnVsbChjbWluLnBhZCwgMCk7XG5cdGxldCBwYWRNYXggPSBpZk51bGwoY21heC5wYWQsIDApO1xuXG5cdGxldCBoYXJkTWluID0gaWZOdWxsKGNtaW4uaGFyZCwgLWluZik7XG5cdGxldCBoYXJkTWF4ID0gaWZOdWxsKGNtYXguaGFyZCwgIGluZik7XG5cblx0bGV0IHNvZnRNaW4gPSBpZk51bGwoY21pbi5zb2Z0LCAgaW5mKTtcblx0bGV0IHNvZnRNYXggPSBpZk51bGwoY21heC5zb2Z0LCAtaW5mKTtcblxuXHRsZXQgc29mdE1pbk1vZGUgPSBpZk51bGwoY21pbi5tb2RlLCAwKTtcblx0bGV0IHNvZnRNYXhNb2RlID0gaWZOdWxsKGNtYXgubW9kZSwgMCk7XG5cblx0bGV0IGRlbHRhICAgICAgICA9IF9tYXggLSBfbWluO1xuXG5cdC8vIHRoaXMgaGFuZGxlcyBzaXR1YXRpb25zIGxpa2UgODkuNywgODkuNjk5OTk5OTk5OTk5OTlcblx0Ly8gYnkgYXNzdW1pbmcgMC4wMDF4IGRlbHRhcyBhcmUgcHJlY2lzaW9uIGVycm9yc1xuLy9cdGlmIChkZWx0YSA+IDAgJiYgZGVsdGEgPCBhYnMoX21heCkgLyAxZTMpXG4vL1x0XHRkZWx0YSA9IDA7XG5cblx0Ly8gdHJlYXQgZGF0YSBhcyBmbGF0IGlmIGRlbHRhIGlzIGxlc3MgdGhhbiAxIGJpbGxpb250aFxuXHRpZiAoZGVsdGEgPCAxZS05KSB7XG5cdFx0ZGVsdGEgPSAwO1xuXG5cdFx0Ly8gaWYgc29mdCBtb2RlIGlzIDIgYW5kIGFsbCB2YWxzIGFyZSBmbGF0IGF0IDAsIGF2b2lkIHRoZSAwLjEgKiAxZTMgZmFsbGJhY2tcblx0XHQvLyB0aGlzIHByZXZlbnRzIDAsMCwwIGZyb20gcmFuZ2luZyB0byAtMTAwLDEwMCB3aGVuIHNvZnRNaW4vc29mdE1heCBhcmUgLTEsMVxuXHRcdGlmIChfbWluID09IDAgfHwgX21heCA9PSAwKSB7XG5cdFx0XHRkZWx0YSA9IDFlLTk7XG5cblx0XHRcdGlmIChzb2Z0TWluTW9kZSA9PSAyICYmIHNvZnRNaW4gIT0gaW5mKVxuXHRcdFx0XHRwYWRNaW4gPSAwO1xuXG5cdFx0XHRpZiAoc29mdE1heE1vZGUgPT0gMiAmJiBzb2Z0TWF4ICE9IC1pbmYpXG5cdFx0XHRcdHBhZE1heCA9IDA7XG5cdFx0fVxuXHR9XG5cblx0bGV0IG5vblplcm9EZWx0YSA9IGRlbHRhIHx8IGFicyhfbWF4KSB8fCAxZTM7XG5cdGxldCBtYWcgICAgICAgICAgPSBsb2cxMChub25aZXJvRGVsdGEpO1xuXHRsZXQgYmFzZSAgICAgICAgID0gcG93KDEwLCBmbG9vcihtYWcpKTtcblxuXHRsZXQgX3BhZE1pbiAgPSBub25aZXJvRGVsdGEgKiAoZGVsdGEgPT0gMCA/IChfbWluID09IDAgPyAuMSA6IDEpIDogcGFkTWluKTtcblx0bGV0IF9uZXdNaW4gID0gcm91bmREZWMoaW5jclJvdW5kRG4oX21pbiAtIF9wYWRNaW4sIGJhc2UvMTApLCA5KTtcblx0bGV0IF9zb2Z0TWluID0gX21pbiA+PSBzb2Z0TWluICYmIChzb2Z0TWluTW9kZSA9PSAxIHx8IHNvZnRNaW5Nb2RlID09IDMgJiYgX25ld01pbiA8PSBzb2Z0TWluIHx8IHNvZnRNaW5Nb2RlID09IDIgJiYgX25ld01pbiA+PSBzb2Z0TWluKSA/IHNvZnRNaW4gOiBpbmY7XG5cdGxldCBtaW5MaW0gICA9IG1heChoYXJkTWluLCBfbmV3TWluIDwgX3NvZnRNaW4gJiYgX21pbiA+PSBfc29mdE1pbiA/IF9zb2Z0TWluIDogbWluKF9zb2Z0TWluLCBfbmV3TWluKSk7XG5cblx0bGV0IF9wYWRNYXggID0gbm9uWmVyb0RlbHRhICogKGRlbHRhID09IDAgPyAoX21heCA9PSAwID8gLjEgOiAxKSA6IHBhZE1heCk7XG5cdGxldCBfbmV3TWF4ICA9IHJvdW5kRGVjKGluY3JSb3VuZFVwKF9tYXggKyBfcGFkTWF4LCBiYXNlLzEwKSwgOSk7XG5cdGxldCBfc29mdE1heCA9IF9tYXggPD0gc29mdE1heCAmJiAoc29mdE1heE1vZGUgPT0gMSB8fCBzb2Z0TWF4TW9kZSA9PSAzICYmIF9uZXdNYXggPj0gc29mdE1heCB8fCBzb2Z0TWF4TW9kZSA9PSAyICYmIF9uZXdNYXggPD0gc29mdE1heCkgPyBzb2Z0TWF4IDogLWluZjtcblx0bGV0IG1heExpbSAgID0gbWluKGhhcmRNYXgsIF9uZXdNYXggPiBfc29mdE1heCAmJiBfbWF4IDw9IF9zb2Z0TWF4ID8gX3NvZnRNYXggOiBtYXgoX3NvZnRNYXgsIF9uZXdNYXgpKTtcblxuXHRpZiAobWluTGltID09IG1heExpbSAmJiBtaW5MaW0gPT0gMClcblx0XHRtYXhMaW0gPSAxMDA7XG5cblx0cmV0dXJuIFttaW5MaW0sIG1heExpbV07XG59XG5cbi8vIGFsdGVybmF0aXZlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI1NDg5NlxuY29uc3QgbnVtRm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGRvbUVudiA/IG5hdi5sYW5ndWFnZSA6ICdlbi1VUycpO1xuY29uc3QgZm10TnVtID0gdmFsID0+IG51bUZvcm1hdHRlci5mb3JtYXQodmFsKTtcblxuY29uc3QgTSA9IE1hdGg7XG5cbmNvbnN0IFBJID0gTS5QSTtcbmNvbnN0IGFicyA9IE0uYWJzO1xuY29uc3QgZmxvb3IgPSBNLmZsb29yO1xuY29uc3Qgcm91bmQgPSBNLnJvdW5kO1xuY29uc3QgY2VpbCA9IE0uY2VpbDtcbmNvbnN0IG1pbiA9IE0ubWluO1xuY29uc3QgbWF4ID0gTS5tYXg7XG5jb25zdCBwb3cgPSBNLnBvdztcbmNvbnN0IHNpZ24gPSBNLnNpZ247XG5jb25zdCBsb2cxMCA9IE0ubG9nMTA7XG5jb25zdCBsb2cyID0gTS5sb2cyO1xuLy8gVE9ETzogc2VlbXMgbGlrZSB0aGlzIG5lZWRzIHRvIG1hdGNoIGFzaW5oIGltcGwgaWYgdGhlIHBhc3NlZCB2IGlzIHR3ZWFrZWQ/XG5jb25zdCBzaW5oID0gICh2LCBsaW50aHJlc2ggPSAxKSA9PiBNLnNpbmgodikgKiBsaW50aHJlc2g7XG5jb25zdCBhc2luaCA9ICh2LCBsaW50aHJlc2ggPSAxKSA9PiBNLmFzaW5oKHYgLyBsaW50aHJlc2gpO1xuXG5jb25zdCBpbmYgPSBJbmZpbml0eTtcblxuZnVuY3Rpb24gbnVtSW50RGlnaXRzKHgpIHtcblx0cmV0dXJuIChsb2cxMCgoeCBeICh4ID4+IDMxKSkgLSAoeCA+PiAzMSkpIHwgMCkgKyAxO1xufVxuXG5mdW5jdGlvbiBpbmNyUm91bmQobnVtLCBpbmNyKSB7XG5cdHJldHVybiByb3VuZChudW0vaW5jcikqaW5jcjtcbn1cblxuZnVuY3Rpb24gY2xhbXAobnVtLCBfbWluLCBfbWF4KSB7XG5cdHJldHVybiBtaW4obWF4KG51bSwgX21pbiksIF9tYXgpO1xufVxuXG5mdW5jdGlvbiBmbk9yU2VsZih2KSB7XG5cdHJldHVybiB0eXBlb2YgdiA9PSBcImZ1bmN0aW9uXCIgPyB2IDogKCkgPT4gdjtcbn1cblxuY29uc3QgcmV0QXJnMCA9IF8wID0+IF8wO1xuXG5jb25zdCByZXRBcmcxID0gKF8wLCBfMSkgPT4gXzE7XG5cbmNvbnN0IHJldE51bGwgPSBfID0+IG51bGw7XG5cbmNvbnN0IHJldFRydWUgPSBfID0+IHRydWU7XG5cbmNvbnN0IHJldEVxID0gKGEsIGIpID0+IGEgPT0gYjtcblxuZnVuY3Rpb24gaW5jclJvdW5kVXAobnVtLCBpbmNyKSB7XG5cdHJldHVybiBjZWlsKG51bS9pbmNyKSppbmNyO1xufVxuXG5mdW5jdGlvbiBpbmNyUm91bmREbihudW0sIGluY3IpIHtcblx0cmV0dXJuIGZsb29yKG51bS9pbmNyKSppbmNyO1xufVxuXG5mdW5jdGlvbiByb3VuZERlYyh2YWwsIGRlYykge1xuXHRyZXR1cm4gcm91bmQodmFsICogKGRlYyA9IDEwKipkZWMpKSAvIGRlYztcbn1cblxuY29uc3QgZml4ZWREZWMgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIGd1ZXNzRGVjKG51bSkge1xuXHRyZXR1cm4gKChcIlwiK251bSkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gZ2VuSW5jcnMoYmFzZSwgbWluRXhwLCBtYXhFeHAsIG11bHRzKSB7XG5cdGxldCBpbmNycyA9IFtdO1xuXG5cdGxldCBtdWx0RGVjID0gbXVsdHMubWFwKGd1ZXNzRGVjKTtcblxuXHRmb3IgKGxldCBleHAgPSBtaW5FeHA7IGV4cCA8IG1heEV4cDsgZXhwKyspIHtcblx0XHRsZXQgZXhwYSA9IGFicyhleHApO1xuXHRcdGxldCBtYWcgPSByb3VuZERlYyhwb3coYmFzZSwgZXhwKSwgZXhwYSk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG11bHRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgX2luY3IgPSBtdWx0c1tpXSAqIG1hZztcblx0XHRcdGxldCBkZWMgPSAoX2luY3IgPj0gMCAmJiBleHAgPj0gMCA/IDAgOiBleHBhKSArIChleHAgPj0gbXVsdERlY1tpXSA/IDAgOiBtdWx0RGVjW2ldKTtcblx0XHRcdGxldCBpbmNyID0gcm91bmREZWMoX2luY3IsIGRlYyk7XG5cdFx0XHRpbmNycy5wdXNoKGluY3IpO1xuXHRcdFx0Zml4ZWREZWMuc2V0KGluY3IsIGRlYyk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGluY3JzO1xufVxuXG4vL2V4cG9ydCBjb25zdCBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG5jb25zdCBFTVBUWV9PQkogPSB7fTtcbmNvbnN0IEVNUFRZX0FSUiA9IFtdO1xuXG5jb25zdCBudWxsTnVsbFR1cGxlID0gW251bGwsIG51bGxdO1xuXG5jb25zdCBpc0FyciA9IEFycmF5LmlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzU3RyKHYpIHtcblx0cmV0dXJuIHR5cGVvZiB2ID09ICdzdHJpbmcnO1xufVxuXG5mdW5jdGlvbiBpc09iaih2KSB7XG5cdGxldCBpcyA9IGZhbHNlO1xuXG5cdGlmICh2ICE9IG51bGwpIHtcblx0XHRsZXQgYyA9IHYuY29uc3RydWN0b3I7XG5cdFx0aXMgPSBjID09IG51bGwgfHwgYyA9PSBPYmplY3Q7XG5cdH1cblxuXHRyZXR1cm4gaXM7XG59XG5cbmZ1bmN0aW9uIGZhc3RJc09iaih2KSB7XG5cdHJldHVybiB2ICE9IG51bGwgJiYgdHlwZW9mIHYgPT0gJ29iamVjdCc7XG59XG5cbmNvbnN0IFR5cGVkQXJyYXkgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheSk7XG5cbmZ1bmN0aW9uIGNvcHkobywgX2lzT2JqID0gaXNPYmopIHtcblx0bGV0IG91dDtcblxuXHRpZiAoaXNBcnIobykpIHtcblx0XHRsZXQgdmFsID0gby5maW5kKHYgPT4gdiAhPSBudWxsKTtcblxuXHRcdGlmIChpc0Fycih2YWwpIHx8IF9pc09iaih2YWwpKSB7XG5cdFx0XHRvdXQgPSBBcnJheShvLmxlbmd0aCk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspXG5cdFx0XHRcdG91dFtpXSA9IGNvcHkob1tpXSwgX2lzT2JqKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdFx0b3V0ID0gby5zbGljZSgpO1xuXHR9XG5cdGVsc2UgaWYgKG8gaW5zdGFuY2VvZiBUeXBlZEFycmF5KSAvLyBhbHNvIChBcnJheUJ1ZmZlci5pc1ZpZXcobykgJiYgIShvIGluc3RhbmNlb2YgRGF0YVZpZXcpKVxuXHRcdG91dCA9IG8uc2xpY2UoKTtcblx0ZWxzZSBpZiAoX2lzT2JqKG8pKSB7XG5cdFx0b3V0ID0ge307XG5cdFx0Zm9yIChsZXQgayBpbiBvKVxuXHRcdFx0b3V0W2tdID0gY29weShvW2tdLCBfaXNPYmopO1xuXHR9XG5cdGVsc2Vcblx0XHRvdXQgPSBvO1xuXG5cdHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbih0YXJnKSB7XG5cdGxldCBhcmdzID0gYXJndW1lbnRzO1xuXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuXHRcdGxldCBzcmMgPSBhcmdzW2ldO1xuXG5cdFx0Zm9yIChsZXQga2V5IGluIHNyYykge1xuXHRcdFx0aWYgKGlzT2JqKHRhcmdba2V5XSkpXG5cdFx0XHRcdGFzc2lnbih0YXJnW2tleV0sIGNvcHkoc3JjW2tleV0pKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGFyZ1trZXldID0gY29weShzcmNba2V5XSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRhcmc7XG59XG5cbi8vIG51bGxNb2Rlc1xuY29uc3QgTlVMTF9SRU1PVkUgPSAwOyAgLy8gbnVsbHMgYXJlIGNvbnZlcnRlZCB0byB1bmRlZmluZWQgKGUuZy4gZm9yIHNwYW5HYXBzOiB0cnVlKVxuY29uc3QgTlVMTF9SRVRBSU4gPSAxOyAgLy8gbnVsbHMgYXJlIHJldGFpbmVkLCB3aXRoIGFsaWdubWVudCBhcnRpZmFjdHMgc2V0IHRvIHVuZGVmaW5lZCAoZGVmYXVsdClcbmNvbnN0IE5VTExfRVhQQU5EID0gMjsgIC8vIG51bGxzIGFyZSBleHBhbmRlZCB0byBpbmNsdWRlIGFueSBhZGphY2VudCBhbGlnbm1lbnQgYXJ0aWZhY3RzXG5cbi8vIHNldHMgdW5kZWZpbmVkIHZhbHVlcyB0byBudWxscyB3aGVuIGFkamFjZW50IHRvIGV4aXN0aW5nIG51bGxzIChtaW5lc3dlZXBlcilcbmZ1bmN0aW9uIG51bGxFeHBhbmQoeVZhbHMsIG51bGxJZHhzLCBhbGlnbmVkTGVuKSB7XG5cdGZvciAobGV0IGkgPSAwLCB4aSwgbGFzdE51bGxJZHggPSAtMTsgaSA8IG51bGxJZHhzLmxlbmd0aDsgaSsrKSB7XG5cdFx0bGV0IG51bGxJZHggPSBudWxsSWR4c1tpXTtcblxuXHRcdGlmIChudWxsSWR4ID4gbGFzdE51bGxJZHgpIHtcblx0XHRcdHhpID0gbnVsbElkeCAtIDE7XG5cdFx0XHR3aGlsZSAoeGkgPj0gMCAmJiB5VmFsc1t4aV0gPT0gbnVsbClcblx0XHRcdFx0eVZhbHNbeGktLV0gPSBudWxsO1xuXG5cdFx0XHR4aSA9IG51bGxJZHggKyAxO1xuXHRcdFx0d2hpbGUgKHhpIDwgYWxpZ25lZExlbiAmJiB5VmFsc1t4aV0gPT0gbnVsbClcblx0XHRcdFx0eVZhbHNbbGFzdE51bGxJZHggPSB4aSsrXSA9IG51bGw7XG5cdFx0fVxuXHR9XG59XG5cbi8vIG51bGxNb2RlcyBpcyBhIHRhYmxlcy1tYXRjaGVkIGFycmF5IGluZGljYXRpbmcgaG93IHRvIHRyZWF0IG51bGxzIGluIGVhY2ggc2VyaWVzXG4vLyBvdXRwdXQgaXMgc29ydGVkIEFTQyBvbiB0aGUgam9pbmVkIGZpZWxkICh0YWJsZVswXSkgYW5kIGR1cGxpY2F0ZSBqb2luIHZhbHVlcyBhcmUgY29sbGFwc2VkXG5mdW5jdGlvbiBqb2luKHRhYmxlcywgbnVsbE1vZGVzKSB7XG5cdGxldCB4VmFscyA9IG5ldyBTZXQoKTtcblxuXHRmb3IgKGxldCB0aSA9IDA7IHRpIDwgdGFibGVzLmxlbmd0aDsgdGkrKykge1xuXHRcdGxldCB0ID0gdGFibGVzW3RpXTtcblx0XHRsZXQgeHMgPSB0WzBdO1xuXHRcdGxldCBsZW4gPSB4cy5sZW5ndGg7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuXHRcdFx0eFZhbHMuYWRkKHhzW2ldKTtcblx0fVxuXG5cdGxldCBkYXRhID0gW0FycmF5LmZyb20oeFZhbHMpLnNvcnQoKGEsIGIpID0+IGEgLSBiKV07XG5cblx0bGV0IGFsaWduZWRMZW4gPSBkYXRhWzBdLmxlbmd0aDtcblxuXHRsZXQgeElkeHMgPSBuZXcgTWFwKCk7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhbGlnbmVkTGVuOyBpKyspXG5cdFx0eElkeHMuc2V0KGRhdGFbMF1baV0sIGkpO1xuXG5cdGZvciAobGV0IHRpID0gMDsgdGkgPCB0YWJsZXMubGVuZ3RoOyB0aSsrKSB7XG5cdFx0bGV0IHQgPSB0YWJsZXNbdGldO1xuXHRcdGxldCB4cyA9IHRbMF07XG5cblx0XHRmb3IgKGxldCBzaSA9IDE7IHNpIDwgdC5sZW5ndGg7IHNpKyspIHtcblx0XHRcdGxldCB5cyA9IHRbc2ldO1xuXG5cdFx0XHRsZXQgeVZhbHMgPSBBcnJheShhbGlnbmVkTGVuKS5maWxsKHVuZGVmaW5lZCk7XG5cblx0XHRcdGxldCBudWxsTW9kZSA9IG51bGxNb2RlcyA/IG51bGxNb2Rlc1t0aV1bc2ldIDogTlVMTF9SRVRBSU47XG5cblx0XHRcdGxldCBudWxsSWR4cyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGxldCB5VmFsID0geXNbaV07XG5cdFx0XHRcdGxldCBhbGlnbmVkSWR4ID0geElkeHMuZ2V0KHhzW2ldKTtcblxuXHRcdFx0XHRpZiAoeVZhbCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChudWxsTW9kZSAhPSBOVUxMX1JFTU9WRSkge1xuXHRcdFx0XHRcdFx0eVZhbHNbYWxpZ25lZElkeF0gPSB5VmFsO1xuXG5cdFx0XHRcdFx0XHRpZiAobnVsbE1vZGUgPT0gTlVMTF9FWFBBTkQpXG5cdFx0XHRcdFx0XHRcdG51bGxJZHhzLnB1c2goYWxpZ25lZElkeCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR5VmFsc1thbGlnbmVkSWR4XSA9IHlWYWw7XG5cdFx0XHR9XG5cblx0XHRcdG51bGxFeHBhbmQoeVZhbHMsIG51bGxJZHhzLCBhbGlnbmVkTGVuKTtcblxuXHRcdFx0ZGF0YS5wdXNoKHlWYWxzKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuY29uc3QgbWljcm9UYXNrID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09IFwidW5kZWZpbmVkXCIgPyBmbiA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZuKSA6IHF1ZXVlTWljcm90YXNrO1xuXG5jb25zdCBtb250aHMgPSBbXG5cdFwiSmFudWFyeVwiLFxuXHRcIkZlYnJ1YXJ5XCIsXG5cdFwiTWFyY2hcIixcblx0XCJBcHJpbFwiLFxuXHRcIk1heVwiLFxuXHRcIkp1bmVcIixcblx0XCJKdWx5XCIsXG5cdFwiQXVndXN0XCIsXG5cdFwiU2VwdGVtYmVyXCIsXG5cdFwiT2N0b2JlclwiLFxuXHRcIk5vdmVtYmVyXCIsXG5cdFwiRGVjZW1iZXJcIixcbl07XG5cbmNvbnN0IGRheXMgPSBbXG5cdFwiU3VuZGF5XCIsXG5cdFwiTW9uZGF5XCIsXG5cdFwiVHVlc2RheVwiLFxuXHRcIldlZG5lc2RheVwiLFxuXHRcIlRodXJzZGF5XCIsXG5cdFwiRnJpZGF5XCIsXG5cdFwiU2F0dXJkYXlcIixcbl07XG5cbmZ1bmN0aW9uIHNsaWNlMyhzdHIpIHtcblx0cmV0dXJuIHN0ci5zbGljZSgwLCAzKTtcbn1cblxuY29uc3QgZGF5czMgPSBkYXlzLm1hcChzbGljZTMpO1xuXG5jb25zdCBtb250aHMzID0gbW9udGhzLm1hcChzbGljZTMpO1xuXG5jb25zdCBlbmdOYW1lcyA9IHtcblx0TU1NTTogbW9udGhzLFxuXHRNTU06ICBtb250aHMzLFxuXHRXV1dXOiBkYXlzLFxuXHRXV1c6ICBkYXlzMyxcbn07XG5cbmZ1bmN0aW9uIHplcm9QYWQyKGludCkge1xuXHRyZXR1cm4gKGludCA8IDEwID8gJzAnIDogJycpICsgaW50O1xufVxuXG5mdW5jdGlvbiB6ZXJvUGFkMyhpbnQpIHtcblx0cmV0dXJuIChpbnQgPCAxMCA/ICcwMCcgOiBpbnQgPCAxMDAgPyAnMCcgOiAnJykgKyBpbnQ7XG59XG5cbi8qXG5mdW5jdGlvbiBzdWZmaXgoaW50KSB7XG5cdGxldCBtb2QxMCA9IGludCAlIDEwO1xuXG5cdHJldHVybiBpbnQgKyAoXG5cdFx0bW9kMTAgPT0gMSAmJiBpbnQgIT0gMTEgPyBcInN0XCIgOlxuXHRcdG1vZDEwID09IDIgJiYgaW50ICE9IDEyID8gXCJuZFwiIDpcblx0XHRtb2QxMCA9PSAzICYmIGludCAhPSAxMyA/IFwicmRcIiA6IFwidGhcIlxuXHQpO1xufVxuKi9cblxuY29uc3Qgc3VicyA9IHtcblx0Ly8gMjAxOVxuXHRZWVlZOlx0ZCA9PiBkLmdldEZ1bGxZZWFyKCksXG5cdC8vIDE5XG5cdFlZOlx0XHRkID0+IChkLmdldEZ1bGxZZWFyKCkrJycpLnNsaWNlKDIpLFxuXHQvLyBKdWx5XG5cdE1NTU06XHQoZCwgbmFtZXMpID0+IG5hbWVzLk1NTU1bZC5nZXRNb250aCgpXSxcblx0Ly8gSnVsXG5cdE1NTTpcdChkLCBuYW1lcykgPT4gbmFtZXMuTU1NW2QuZ2V0TW9udGgoKV0sXG5cdC8vIDA3XG5cdE1NOlx0XHRkID0+IHplcm9QYWQyKGQuZ2V0TW9udGgoKSsxKSxcblx0Ly8gN1xuXHRNOlx0XHRkID0+IGQuZ2V0TW9udGgoKSsxLFxuXHQvLyAwOVxuXHRERDpcdFx0ZCA9PiB6ZXJvUGFkMihkLmdldERhdGUoKSksXG5cdC8vIDlcblx0RDpcdFx0ZCA9PiBkLmdldERhdGUoKSxcblx0Ly8gTW9uZGF5XG5cdFdXV1c6XHQoZCwgbmFtZXMpID0+IG5hbWVzLldXV1dbZC5nZXREYXkoKV0sXG5cdC8vIE1vblxuXHRXV1c6XHQoZCwgbmFtZXMpID0+IG5hbWVzLldXV1tkLmdldERheSgpXSxcblx0Ly8gMDNcblx0SEg6XHRcdGQgPT4gemVyb1BhZDIoZC5nZXRIb3VycygpKSxcblx0Ly8gM1xuXHRIOlx0XHRkID0+IGQuZ2V0SG91cnMoKSxcblx0Ly8gOSAoMTJociwgdW5wYWRkZWQpXG5cdGg6XHRcdGQgPT4ge2xldCBoID0gZC5nZXRIb3VycygpOyByZXR1cm4gaCA9PSAwID8gMTIgOiBoID4gMTIgPyBoIC0gMTIgOiBoO30sXG5cdC8vIEFNXG5cdEFBOlx0XHRkID0+IGQuZ2V0SG91cnMoKSA+PSAxMiA/ICdQTScgOiAnQU0nLFxuXHQvLyBhbVxuXHRhYTpcdFx0ZCA9PiBkLmdldEhvdXJzKCkgPj0gMTIgPyAncG0nIDogJ2FtJyxcblx0Ly8gYVxuXHRhOlx0XHRkID0+IGQuZ2V0SG91cnMoKSA+PSAxMiA/ICdwJyA6ICdhJyxcblx0Ly8gMDlcblx0bW06XHRcdGQgPT4gemVyb1BhZDIoZC5nZXRNaW51dGVzKCkpLFxuXHQvLyA5XG5cdG06XHRcdGQgPT4gZC5nZXRNaW51dGVzKCksXG5cdC8vIDA5XG5cdHNzOlx0XHRkID0+IHplcm9QYWQyKGQuZ2V0U2Vjb25kcygpKSxcblx0Ly8gOVxuXHRzOlx0XHRkID0+IGQuZ2V0U2Vjb25kcygpLFxuXHQvLyAzNzRcblx0ZmZmOlx0ZCA9PiB6ZXJvUGFkMyhkLmdldE1pbGxpc2Vjb25kcygpKSxcbn07XG5cbmZ1bmN0aW9uIGZtdERhdGUodHBsLCBuYW1lcykge1xuXHRuYW1lcyA9IG5hbWVzIHx8IGVuZ05hbWVzO1xuXHRsZXQgcGFydHMgPSBbXTtcblxuXHRsZXQgUiA9IC9cXHsoW2Etel0rKVxcfXxbXntdKy9naSwgbTtcblxuXHR3aGlsZSAobSA9IFIuZXhlYyh0cGwpKVxuXHRcdHBhcnRzLnB1c2gobVswXVswXSA9PSAneycgPyBzdWJzW21bMV1dIDogbVswXSk7XG5cblx0cmV0dXJuIGQgPT4ge1xuXHRcdGxldCBvdXQgPSAnJztcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspXG5cdFx0XHRvdXQgKz0gdHlwZW9mIHBhcnRzW2ldID09IFwic3RyaW5nXCIgPyBwYXJ0c1tpXSA6IHBhcnRzW2ldKGQsIG5hbWVzKTtcblxuXHRcdHJldHVybiBvdXQ7XG5cdH1cbn1cblxuY29uc3QgbG9jYWxUeiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7XG5cbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE1MTQxNzYyL2hvdy10by1pbml0aWFsaXplLWEtamF2YXNjcmlwdC1kYXRlLXRvLWEtcGFydGljdWxhci10aW1lLXpvbmUvNTM2NTIxMzEjNTM2NTIxMzFcbmZ1bmN0aW9uIHR6RGF0ZShkYXRlLCB0eikge1xuXHRsZXQgZGF0ZTI7XG5cblx0Ly8gcGVyZiBvcHRpbWl6YXRpb25cblx0aWYgKHR6ID09ICdVVEMnIHx8IHR6ID09ICdFdGMvVVRDJylcblx0XHRkYXRlMiA9IG5ldyBEYXRlKCtkYXRlICsgZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNmU0KTtcblx0ZWxzZSBpZiAodHogPT0gbG9jYWxUeilcblx0XHRkYXRlMiA9IGRhdGU7XG5cdGVsc2Uge1xuXHRcdGRhdGUyID0gbmV3IERhdGUoZGF0ZS50b0xvY2FsZVN0cmluZygnZW4tVVMnLCB7dGltZVpvbmU6IHR6fSkpO1xuXHRcdGRhdGUyLnNldE1pbGxpc2Vjb25kcyhkYXRlLmdldE1pbGxpc2Vjb25kcygpKTtcblx0fVxuXG5cdHJldHVybiBkYXRlMjtcbn1cblxuLy9leHBvcnQgY29uc3Qgc2VyaWVzID0gW107XG5cbi8vIGRlZmF1bHQgZm9ybWF0dGVyczpcblxuY29uc3Qgb25seVdob2xlID0gdiA9PiB2ICUgMSA9PSAwO1xuXG5jb25zdCBhbGxNdWx0cyA9IFsxLDIsMi41LDVdO1xuXG4vLyAuLi4wLjAxLCAwLjAyLCAwLjAyNSwgMC4wNSwgMC4xLCAwLjIsIDAuMjUsIDAuNVxuY29uc3QgZGVjSW5jcnMgPSBnZW5JbmNycygxMCwgLTE2LCAwLCBhbGxNdWx0cyk7XG5cbi8vIDEsIDIsIDIuNSwgNSwgMTAsIDIwLCAyNSwgNTAuLi5cbmNvbnN0IG9uZUluY3JzID0gZ2VuSW5jcnMoMTAsIDAsIDE2LCBhbGxNdWx0cyk7XG5cbi8vIDEsIDIsICAgICAgNSwgMTAsIDIwLCAyNSwgNTAuLi5cbmNvbnN0IHdob2xlSW5jcnMgPSBvbmVJbmNycy5maWx0ZXIob25seVdob2xlKTtcblxuY29uc3QgbnVtSW5jcnMgPSBkZWNJbmNycy5jb25jYXQob25lSW5jcnMpO1xuXG5jb25zdCBOTCA9IFwiXFxuXCI7XG5cbmNvbnN0IHl5eXkgICAgPSBcIntZWVlZfVwiO1xuY29uc3QgTkx5eXl5ICA9IE5MICsgeXl5eTtcbmNvbnN0IG1kICAgICAgPSBcIntNfS97RH1cIjtcbmNvbnN0IE5MbWQgICAgPSBOTCArIG1kO1xuY29uc3QgTkxtZHl5ICA9IE5MbWQgKyBcIi97WVl9XCI7XG5cbmNvbnN0IGFhICAgICAgPSBcInthYX1cIjtcbmNvbnN0IGhtbSAgICAgPSBcIntofTp7bW19XCI7XG5jb25zdCBobW1hYSAgID0gaG1tICsgYWE7XG5jb25zdCBOTGhtbWFhID0gTkwgKyBobW1hYTtcbmNvbnN0IHNzICAgICAgPSBcIjp7c3N9XCI7XG5cbmNvbnN0IF8gPSBudWxsO1xuXG5mdW5jdGlvbiBnZW5UaW1lU3R1ZmZzKG1zKSB7XG5cdGxldFx0cyAgPSBtcyAqIDFlMyxcblx0XHRtICA9IHMgICogNjAsXG5cdFx0aCAgPSBtICAqIDYwLFxuXHRcdGQgID0gaCAgKiAyNCxcblx0XHRtbyA9IGQgICogMzAsXG5cdFx0eSAgPSBkICAqIDM2NTtcblxuXHQvLyBtaW4gb2YgMWUtMyBwcmV2ZW50cyBzZXR0aW5nIGEgdGVtcG9yYWwgeCB0aWNrcyB0b28gc21hbGwgc2luY2UgRGF0ZSBvYmplY3RzIGNhbm5vdCBhZHZhbmNlIHRpY2tzIHNtYWxsZXIgdGhhbiAxbXNcblx0bGV0IHN1YlNlY0luY3JzID0gbXMgPT0gMSA/IGdlbkluY3JzKDEwLCAwLCAzLCBhbGxNdWx0cykuZmlsdGVyKG9ubHlXaG9sZSkgOiBnZW5JbmNycygxMCwgLTMsIDAsIGFsbE11bHRzKTtcblxuXHRsZXQgdGltZUluY3JzID0gc3ViU2VjSW5jcnMuY29uY2F0KFtcblx0XHQvLyBtaW51dGUgZGl2aXNvcnMgKCMgb2Ygc2Vjcylcblx0XHRzLFxuXHRcdHMgKiA1LFxuXHRcdHMgKiAxMCxcblx0XHRzICogMTUsXG5cdFx0cyAqIDMwLFxuXHRcdC8vIGhvdXIgZGl2aXNvcnMgKCMgb2YgbWlucylcblx0XHRtLFxuXHRcdG0gKiA1LFxuXHRcdG0gKiAxMCxcblx0XHRtICogMTUsXG5cdFx0bSAqIDMwLFxuXHRcdC8vIGRheSBkaXZpc29ycyAoIyBvZiBocnMpXG5cdFx0aCxcblx0XHRoICogMixcblx0XHRoICogMyxcblx0XHRoICogNCxcblx0XHRoICogNixcblx0XHRoICogOCxcblx0XHRoICogMTIsXG5cdFx0Ly8gbW9udGggZGl2aXNvcnMgVE9ETzogbmVlZCBtb3JlP1xuXHRcdGQsXG5cdFx0ZCAqIDIsXG5cdFx0ZCAqIDMsXG5cdFx0ZCAqIDQsXG5cdFx0ZCAqIDUsXG5cdFx0ZCAqIDYsXG5cdFx0ZCAqIDcsXG5cdFx0ZCAqIDgsXG5cdFx0ZCAqIDksXG5cdFx0ZCAqIDEwLFxuXHRcdGQgKiAxNSxcblx0XHQvLyB5ZWFyIGRpdmlzb3JzICgjIG1vbnRocywgYXBwcm94KVxuXHRcdG1vLFxuXHRcdG1vICogMixcblx0XHRtbyAqIDMsXG5cdFx0bW8gKiA0LFxuXHRcdG1vICogNixcblx0XHQvLyBjZW50dXJ5IGRpdmlzb3JzXG5cdFx0eSxcblx0XHR5ICogMixcblx0XHR5ICogNSxcblx0XHR5ICogMTAsXG5cdFx0eSAqIDI1LFxuXHRcdHkgKiA1MCxcblx0XHR5ICogMTAwLFxuXHRdKTtcblxuXHQvLyBbMF06ICAgbWluaW11bSBudW0gc2VjcyBpbiB0aGUgdGljayBpbmNyXG5cdC8vIFsxXTogICBkZWZhdWx0IHRpY2sgZm9ybWF0XG5cdC8vIFsyLTddOiByb2xsb3ZlciB0aWNrIGZvcm1hdHNcblx0Ly8gWzhdOiAgIG1vZGU6IDA6IHJlcGxhY2UgWzFdIC0+IFsyLTddLCAxOiBjb25jYXQgWzFdICsgWzItN11cblx0Y29uc3QgX3RpbWVBeGlzU3RhbXBzID0gW1xuXHQvLyAgIHRpY2sgaW5jciAgICBkZWZhdWx0ICAgICAgICAgIHllYXIgICAgICAgICAgICAgICAgICAgIG1vbnRoICAgZGF5ICAgICAgICAgICAgICAgICAgIGhvdXIgICAgbWluICAgICAgIHNlYyAgIG1vZGVcblx0XHRbeSwgICAgICAgICAgIHl5eXksICAgICAgICAgICAgXywgICAgICAgICAgICAgICAgICAgICAgXywgICAgICBfLCAgICAgICAgICAgICAgICAgICAgXywgICAgICBfLCAgICAgICAgXywgICAgICAgMV0sXG5cdFx0W2QgKiAyOCwgICAgICBcIntNTU19XCIsICAgICAgICAgTkx5eXl5LCAgICAgICAgICAgICAgICAgXywgICAgICBfLCAgICAgICAgICAgICAgICAgICAgXywgICAgICBfLCAgICAgICAgXywgICAgICAgMV0sXG5cdFx0W2QsICAgICAgICAgICBtZCwgICAgICAgICAgICAgIE5MeXl5eSwgICAgICAgICAgICAgICAgIF8sICAgICAgXywgICAgICAgICAgICAgICAgICAgIF8sICAgICAgXywgICAgICAgIF8sICAgICAgIDFdLFxuXHRcdFtoLCAgICAgICAgICAgXCJ7aH1cIiArIGFhLCAgICAgIE5MbWR5eSwgICAgICAgICAgICAgICAgIF8sICAgICAgTkxtZCwgICAgICAgICAgICAgICAgIF8sICAgICAgXywgICAgICAgIF8sICAgICAgIDFdLFxuXHRcdFttLCAgICAgICAgICAgaG1tYWEsICAgICAgICAgICBOTG1keXksICAgICAgICAgICAgICAgICBfLCAgICAgIE5MbWQsICAgICAgICAgICAgICAgICBfLCAgICAgIF8sICAgICAgICBfLCAgICAgICAxXSxcblx0XHRbcywgICAgICAgICAgIHNzLCAgICAgICAgICAgICAgTkxtZHl5ICsgXCIgXCIgKyBobW1hYSwgICBfLCAgICAgIE5MbWQgKyBcIiBcIiArIGhtbWFhLCAgIF8sICAgICAgTkxobW1hYSwgIF8sICAgICAgIDFdLFxuXHRcdFttcywgICAgICAgICAgc3MgKyBcIi57ZmZmfVwiLCAgIE5MbWR5eSArIFwiIFwiICsgaG1tYWEsICAgXywgICAgICBOTG1kICsgXCIgXCIgKyBobW1hYSwgICBfLCAgICAgIE5MaG1tYWEsICBfLCAgICAgICAxXSxcblx0XTtcblxuXHQvLyB0aGUgZW5zdXJlcyB0aGF0IGF4aXMgdGlja3MsIHZhbHVlcyAmIGdyaWQgYXJlIGFsaWduZWQgdG8gbG9naWNhbCB0ZW1wb3JhbCBicmVha3BvaW50cyBhbmQgbm90IGFuIGFyYml0cmFyeSB0aW1lc3RhbXBcblx0Ly8gaHR0cHM6Ly93d3cudGltZWFuZGRhdGUuY29tL3RpbWUvZHN0L1xuXHQvLyBodHRwczovL3d3dy50aW1lYW5kZGF0ZS5jb20vdGltZS9kc3QvMjAxOS5odG1sXG5cdC8vIGh0dHBzOi8vd3d3LmVwb2NoY29udmVydGVyLmNvbS90aW1lem9uZXNcblx0ZnVuY3Rpb24gdGltZUF4aXNTcGxpdHModHpEYXRlKSB7XG5cdFx0cmV0dXJuIChzZWxmLCBheGlzSWR4LCBzY2FsZU1pbiwgc2NhbGVNYXgsIGZvdW5kSW5jciwgZm91bmRTcGFjZSkgPT4ge1xuXHRcdFx0bGV0IHNwbGl0cyA9IFtdO1xuXHRcdFx0bGV0IGlzWXIgPSBmb3VuZEluY3IgPj0geTtcblx0XHRcdGxldCBpc01vID0gZm91bmRJbmNyID49IG1vICYmIGZvdW5kSW5jciA8IHk7XG5cblx0XHRcdC8vIGdldCB0aGUgdGltZXpvbmUtYWRqdXN0ZWQgZGF0ZVxuXHRcdFx0bGV0IG1pbkRhdGUgPSB0ekRhdGUoc2NhbGVNaW4pO1xuXHRcdFx0bGV0IG1pbkRhdGVUcyA9IHJvdW5kRGVjKG1pbkRhdGUgKiBtcywgMyk7XG5cblx0XHRcdC8vIGdldCB0cyBvZiAxMmFtICh0aGlzIGxhbmRzIHVzIGF0IG9yIGJlZm9yZSB0aGUgb3JpZ2luYWwgc2NhbGVNaW4pXG5cdFx0XHRsZXQgbWluTWluID0gbWtEYXRlKG1pbkRhdGUuZ2V0RnVsbFllYXIoKSwgaXNZciA/IDAgOiBtaW5EYXRlLmdldE1vbnRoKCksIGlzTW8gfHwgaXNZciA/IDEgOiBtaW5EYXRlLmdldERhdGUoKSk7XG5cdFx0XHRsZXQgbWluTWluVHMgPSByb3VuZERlYyhtaW5NaW4gKiBtcywgMyk7XG5cblx0XHRcdGlmIChpc01vIHx8IGlzWXIpIHtcblx0XHRcdFx0bGV0IG1vSW5jciA9IGlzTW8gPyBmb3VuZEluY3IgLyBtbyA6IDA7XG5cdFx0XHRcdGxldCB5ckluY3IgPSBpc1lyID8gZm91bmRJbmNyIC8geSAgOiAwO1xuXHRcdFx0Ly9cdGxldCB0ek9mZnNldCA9IHNjYWxlTWluIC0gbWluRGF0ZVRzO1x0XHQvLyBuZWVkZWQ/XG5cdFx0XHRcdGxldCBzcGxpdCA9IG1pbkRhdGVUcyA9PSBtaW5NaW5UcyA/IG1pbkRhdGVUcyA6IHJvdW5kRGVjKG1rRGF0ZShtaW5NaW4uZ2V0RnVsbFllYXIoKSArIHlySW5jciwgbWluTWluLmdldE1vbnRoKCkgKyBtb0luY3IsIDEpICogbXMsIDMpO1xuXHRcdFx0XHRsZXQgc3BsaXREYXRlID0gbmV3IERhdGUocm91bmQoc3BsaXQgLyBtcykpO1xuXHRcdFx0XHRsZXQgYmFzZVllYXIgPSBzcGxpdERhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0bGV0IGJhc2VNb250aCA9IHNwbGl0RGF0ZS5nZXRNb250aCgpO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBzcGxpdCA8PSBzY2FsZU1heDsgaSsrKSB7XG5cdFx0XHRcdFx0bGV0IG5leHQgPSBta0RhdGUoYmFzZVllYXIgKyB5ckluY3IgKiBpLCBiYXNlTW9udGggKyBtb0luY3IgKiBpLCAxKTtcblx0XHRcdFx0XHRsZXQgb2ZmcyA9IG5leHQgLSB0ekRhdGUocm91bmREZWMobmV4dCAqIG1zLCAzKSk7XG5cblx0XHRcdFx0XHRzcGxpdCA9IHJvdW5kRGVjKCgrbmV4dCArIG9mZnMpICogbXMsIDMpO1xuXG5cdFx0XHRcdFx0aWYgKHNwbGl0IDw9IHNjYWxlTWF4KVxuXHRcdFx0XHRcdFx0c3BsaXRzLnB1c2goc3BsaXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bGV0IGluY3IwID0gZm91bmRJbmNyID49IGQgPyBkIDogZm91bmRJbmNyO1xuXHRcdFx0XHRsZXQgdHpPZmZzZXQgPSBmbG9vcihzY2FsZU1pbikgLSBmbG9vcihtaW5EYXRlVHMpO1xuXHRcdFx0XHRsZXQgc3BsaXQgPSBtaW5NaW5UcyArIHR6T2Zmc2V0ICsgaW5jclJvdW5kVXAobWluRGF0ZVRzIC0gbWluTWluVHMsIGluY3IwKTtcblx0XHRcdFx0c3BsaXRzLnB1c2goc3BsaXQpO1xuXG5cdFx0XHRcdGxldCBkYXRlMCA9IHR6RGF0ZShzcGxpdCk7XG5cblx0XHRcdFx0bGV0IHByZXZIb3VyID0gZGF0ZTAuZ2V0SG91cnMoKSArIChkYXRlMC5nZXRNaW51dGVzKCkgLyBtKSArIChkYXRlMC5nZXRTZWNvbmRzKCkgLyBoKTtcblx0XHRcdFx0bGV0IGluY3JIb3VycyA9IGZvdW5kSW5jciAvIGg7XG5cblx0XHRcdFx0bGV0IG1pblNwYWNlID0gc2VsZi5heGVzW2F4aXNJZHhdLl9zcGFjZTtcblx0XHRcdFx0bGV0IHBjdFNwYWNlID0gZm91bmRTcGFjZSAvIG1pblNwYWNlO1xuXG5cdFx0XHRcdHdoaWxlICgxKSB7XG5cdFx0XHRcdFx0c3BsaXQgPSByb3VuZERlYyhzcGxpdCArIGZvdW5kSW5jciwgbXMgPT0gMSA/IDAgOiAzKTtcblxuXHRcdFx0XHRcdGlmIChzcGxpdCA+IHNjYWxlTWF4KVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRpZiAoaW5jckhvdXJzID4gMSkge1xuXHRcdFx0XHRcdFx0bGV0IGV4cGVjdGVkSG91ciA9IGZsb29yKHJvdW5kRGVjKHByZXZIb3VyICsgaW5jckhvdXJzLCA2KSkgJSAyNDtcblx0XHRcdFx0XHRcdGxldCBzcGxpdERhdGUgPSB0ekRhdGUoc3BsaXQpO1xuXHRcdFx0XHRcdFx0bGV0IGFjdHVhbEhvdXIgPSBzcGxpdERhdGUuZ2V0SG91cnMoKTtcblxuXHRcdFx0XHRcdFx0bGV0IGRzdFNoaWZ0ID0gYWN0dWFsSG91ciAtIGV4cGVjdGVkSG91cjtcblxuXHRcdFx0XHRcdFx0aWYgKGRzdFNoaWZ0ID4gMSlcblx0XHRcdFx0XHRcdFx0ZHN0U2hpZnQgPSAtMTtcblxuXHRcdFx0XHRcdFx0c3BsaXQgLT0gZHN0U2hpZnQgKiBoO1xuXG5cdFx0XHRcdFx0XHRwcmV2SG91ciA9IChwcmV2SG91ciArIGluY3JIb3VycykgJSAyNDtcblxuXHRcdFx0XHRcdFx0Ly8gYWRkIGEgdGljayBvbmx5IGlmIGl0J3MgZnVydGhlciB0aGFuIDcwJSBvZiB0aGUgbWluIGFsbG93ZWQgbGFiZWwgc3BhY2luZ1xuXHRcdFx0XHRcdFx0bGV0IHByZXZTcGxpdCA9IHNwbGl0c1tzcGxpdHMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0XHRsZXQgcGN0SW5jciA9IHJvdW5kRGVjKChzcGxpdCAtIHByZXZTcGxpdCkgLyBmb3VuZEluY3IsIDMpO1xuXG5cdFx0XHRcdFx0XHRpZiAocGN0SW5jciAqIHBjdFNwYWNlID49IC43KVxuXHRcdFx0XHRcdFx0XHRzcGxpdHMucHVzaChzcGxpdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHNwbGl0cy5wdXNoKHNwbGl0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc3BsaXRzO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBbXG5cdFx0dGltZUluY3JzLFxuXHRcdF90aW1lQXhpc1N0YW1wcyxcblx0XHR0aW1lQXhpc1NwbGl0cyxcblx0XTtcbn1cblxuY29uc3QgWyB0aW1lSW5jcnNNcywgX3RpbWVBeGlzU3RhbXBzTXMsIHRpbWVBeGlzU3BsaXRzTXMgXSA9IGdlblRpbWVTdHVmZnMoMSk7XG5jb25zdCBbIHRpbWVJbmNyc1MsICBfdGltZUF4aXNTdGFtcHNTLCAgdGltZUF4aXNTcGxpdHNTICBdID0gZ2VuVGltZVN0dWZmcygxZS0zKTtcblxuLy8gYmFzZSAyXG5nZW5JbmNycygyLCAtNTMsIDUzLCBbMV0pO1xuXG4vKlxuY29uc29sZS5sb2coe1xuXHRkZWNJbmNycyxcblx0b25lSW5jcnMsXG5cdHdob2xlSW5jcnMsXG5cdG51bUluY3JzLFxuXHR0aW1lSW5jcnMsXG5cdGZpeGVkRGVjLFxufSk7XG4qL1xuXG5mdW5jdGlvbiB0aW1lQXhpc1N0YW1wcyhzdGFtcENmZywgZm10RGF0ZSkge1xuXHRyZXR1cm4gc3RhbXBDZmcubWFwKHMgPT4gcy5tYXAoKHYsIGkpID0+XG5cdFx0aSA9PSAwIHx8IGkgPT0gOCB8fCB2ID09IG51bGwgPyB2IDogZm10RGF0ZShpID09IDEgfHwgc1s4XSA9PSAwID8gdiA6IHNbMV0gKyB2KVxuXHQpKTtcbn1cblxuLy8gVE9ETzogd2lsbCBuZWVkIHRvIGFjY2VwdCBzcGFjZXNbXSBhbmQgcHVsbCBpbmNyIGludG8gdGhlIGxvb3Agd2hlbiBncmlkIHdpbGwgYmUgbm9uLXVuaWZvcm0sIGVnIGZvciBsb2cgc2NhbGVzLlxuLy8gY3VycmVudGx5IHdlIGlnbm9yZSB0aGlzIGZvciBtb250aHMgc2luY2UgdGhleSdyZSAqbmVhcmx5KiB1bmlmb3JtIGFuZCB0aGUgYWRkZWQgY29tcGxleGl0eSBpcyBub3Qgd29ydGggaXRcbmZ1bmN0aW9uIHRpbWVBeGlzVmFscyh0ekRhdGUsIHN0YW1wcykge1xuXHRyZXR1cm4gKHNlbGYsIHNwbGl0cywgYXhpc0lkeCwgZm91bmRTcGFjZSwgZm91bmRJbmNyKSA9PiB7XG5cdFx0bGV0IHMgPSBzdGFtcHMuZmluZChzID0+IGZvdW5kSW5jciA+PSBzWzBdKSB8fCBzdGFtcHNbc3RhbXBzLmxlbmd0aCAtIDFdO1xuXG5cdFx0Ly8gdGhlc2UgdHJhY2sgYm91bmRhcmllcyB3aGVuIGEgZnVsbCBsYWJlbCBpcyBuZWVkZWQgYWdhaW5cblx0XHRsZXQgcHJldlllYXI7XG5cdFx0bGV0IHByZXZNbnRoO1xuXHRcdGxldCBwcmV2RGF0ZTtcblx0XHRsZXQgcHJldkhvdXI7XG5cdFx0bGV0IHByZXZNaW5zO1xuXHRcdGxldCBwcmV2U2VjcztcblxuXHRcdHJldHVybiBzcGxpdHMubWFwKHNwbGl0ID0+IHtcblx0XHRcdGxldCBkYXRlID0gdHpEYXRlKHNwbGl0KTtcblxuXHRcdFx0bGV0IG5ld1llYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRsZXQgbmV3TW50aCA9IGRhdGUuZ2V0TW9udGgoKTtcblx0XHRcdGxldCBuZXdEYXRlID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0XHRsZXQgbmV3SG91ciA9IGRhdGUuZ2V0SG91cnMoKTtcblx0XHRcdGxldCBuZXdNaW5zID0gZGF0ZS5nZXRNaW51dGVzKCk7XG5cdFx0XHRsZXQgbmV3U2VjcyA9IGRhdGUuZ2V0U2Vjb25kcygpO1xuXG5cdFx0XHRsZXQgc3RhbXAgPSAoXG5cdFx0XHRcdG5ld1llYXIgIT0gcHJldlllYXIgJiYgc1syXSB8fFxuXHRcdFx0XHRuZXdNbnRoICE9IHByZXZNbnRoICYmIHNbM10gfHxcblx0XHRcdFx0bmV3RGF0ZSAhPSBwcmV2RGF0ZSAmJiBzWzRdIHx8XG5cdFx0XHRcdG5ld0hvdXIgIT0gcHJldkhvdXIgJiYgc1s1XSB8fFxuXHRcdFx0XHRuZXdNaW5zICE9IHByZXZNaW5zICYmIHNbNl0gfHxcblx0XHRcdFx0bmV3U2VjcyAhPSBwcmV2U2VjcyAmJiBzWzddIHx8XG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgc1sxXVxuXHRcdFx0KTtcblxuXHRcdFx0cHJldlllYXIgPSBuZXdZZWFyO1xuXHRcdFx0cHJldk1udGggPSBuZXdNbnRoO1xuXHRcdFx0cHJldkRhdGUgPSBuZXdEYXRlO1xuXHRcdFx0cHJldkhvdXIgPSBuZXdIb3VyO1xuXHRcdFx0cHJldk1pbnMgPSBuZXdNaW5zO1xuXHRcdFx0cHJldlNlY3MgPSBuZXdTZWNzO1xuXG5cdFx0XHRyZXR1cm4gc3RhbXAoZGF0ZSk7XG5cdFx0fSk7XG5cdH1cbn1cblxuLy8gZm9yIHdoZW4gYXhpcy52YWx1ZXMgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBmbXREYXRlIHRlbXBsYXRlIHN0cmluZ1xuZnVuY3Rpb24gdGltZUF4aXNWYWwodHpEYXRlLCBkYXRlVHBsKSB7XG5cdGxldCBzdGFtcCA9IGZtdERhdGUoZGF0ZVRwbCk7XG5cdHJldHVybiAoc2VsZiwgc3BsaXRzLCBheGlzSWR4LCBmb3VuZFNwYWNlLCBmb3VuZEluY3IpID0+IHNwbGl0cy5tYXAoc3BsaXQgPT4gc3RhbXAodHpEYXRlKHNwbGl0KSkpO1xufVxuXG5mdW5jdGlvbiBta0RhdGUoeSwgbSwgZCkge1xuXHRyZXR1cm4gbmV3IERhdGUoeSwgbSwgZCk7XG59XG5cbmZ1bmN0aW9uIHRpbWVTZXJpZXNTdGFtcChzdGFtcENmZywgZm10RGF0ZSkge1xuXHRyZXR1cm4gZm10RGF0ZShzdGFtcENmZyk7XG59XG5jb25zdCBfdGltZVNlcmllc1N0YW1wID0gJ3tZWVlZfS17TU19LXtERH0ge2h9OnttbX17YWF9JztcblxuZnVuY3Rpb24gdGltZVNlcmllc1ZhbCh0ekRhdGUsIHN0YW1wKSB7XG5cdHJldHVybiAoc2VsZiwgdmFsKSA9PiBzdGFtcCh0ekRhdGUodmFsKSk7XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZFN0cm9rZShzZWxmLCBzZXJpZXNJZHgpIHtcblx0bGV0IHMgPSBzZWxmLnNlcmllc1tzZXJpZXNJZHhdO1xuXHRyZXR1cm4gcy53aWR0aCA/IHMuc3Ryb2tlKHNlbGYsIHNlcmllc0lkeCkgOiBzLnBvaW50cy53aWR0aCA/IHMucG9pbnRzLnN0cm9rZShzZWxmLCBzZXJpZXNJZHgpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gbGVnZW5kRmlsbChzZWxmLCBzZXJpZXNJZHgpIHtcblx0cmV0dXJuIHNlbGYuc2VyaWVzW3Nlcmllc0lkeF0uZmlsbChzZWxmLCBzZXJpZXNJZHgpO1xufVxuXG5jb25zdCBsZWdlbmRPcHRzID0ge1xuXHRzaG93OiB0cnVlLFxuXHRsaXZlOiB0cnVlLFxuXHRpc29sYXRlOiBmYWxzZSxcblx0bWFya2Vyczoge1xuXHRcdHNob3c6IHRydWUsXG5cdFx0d2lkdGg6IDIsXG5cdFx0c3Ryb2tlOiBsZWdlbmRTdHJva2UsXG5cdFx0ZmlsbDogbGVnZW5kRmlsbCxcblx0XHRkYXNoOiBcInNvbGlkXCIsXG5cdH0sXG5cdGlkeDogbnVsbCxcblx0aWR4czogbnVsbCxcblx0dmFsdWVzOiBbXSxcbn07XG5cbmZ1bmN0aW9uIGN1cnNvclBvaW50U2hvdyhzZWxmLCBzaSkge1xuXHRsZXQgbyA9IHNlbGYuY3Vyc29yLnBvaW50cztcblxuXHRsZXQgcHQgPSBwbGFjZURpdigpO1xuXG5cdGxldCBzaXplID0gby5zaXplKHNlbGYsIHNpKTtcblx0c2V0U3R5bGVQeChwdCwgV0lEVEgsIHNpemUpO1xuXHRzZXRTdHlsZVB4KHB0LCBIRUlHSFQsIHNpemUpO1xuXG5cdGxldCBtYXIgPSBzaXplIC8gLTI7XG5cdHNldFN0eWxlUHgocHQsIFwibWFyZ2luTGVmdFwiLCBtYXIpO1xuXHRzZXRTdHlsZVB4KHB0LCBcIm1hcmdpblRvcFwiLCBtYXIpO1xuXG5cdGxldCB3aWR0aCA9IG8ud2lkdGgoc2VsZiwgc2ksIHNpemUpO1xuXHR3aWR0aCAmJiBzZXRTdHlsZVB4KHB0LCBcImJvcmRlcldpZHRoXCIsIHdpZHRoKTtcblxuXHRyZXR1cm4gcHQ7XG59XG5cbmZ1bmN0aW9uIGN1cnNvclBvaW50RmlsbChzZWxmLCBzaSkge1xuXHRsZXQgc3AgPSBzZWxmLnNlcmllc1tzaV0ucG9pbnRzO1xuXHRyZXR1cm4gc3AuX2ZpbGwgfHwgc3AuX3N0cm9rZTtcbn1cblxuZnVuY3Rpb24gY3Vyc29yUG9pbnRTdHJva2Uoc2VsZiwgc2kpIHtcblx0bGV0IHNwID0gc2VsZi5zZXJpZXNbc2ldLnBvaW50cztcblx0cmV0dXJuIHNwLl9zdHJva2UgfHwgc3AuX2ZpbGw7XG59XG5cbmZ1bmN0aW9uIGN1cnNvclBvaW50U2l6ZShzZWxmLCBzaSkge1xuXHRsZXQgc3AgPSBzZWxmLnNlcmllc1tzaV0ucG9pbnRzO1xuXHRyZXR1cm4gcHREaWEoc3Aud2lkdGgsIDEpO1xufVxuXG5mdW5jdGlvbiBkYXRhSWR4KHNlbGYsIHNlcmllc0lkeCwgY3Vyc29ySWR4KSB7XG5cdHJldHVybiBjdXJzb3JJZHg7XG59XG5cbmNvbnN0IG1vdmVUdXBsZSA9IFswLDBdO1xuXG5mdW5jdGlvbiBjdXJzb3JNb3ZlKHNlbGYsIG1vdXNlTGVmdDEsIG1vdXNlVG9wMSkge1xuXHRtb3ZlVHVwbGVbMF0gPSBtb3VzZUxlZnQxO1xuXHRtb3ZlVHVwbGVbMV0gPSBtb3VzZVRvcDE7XG5cdHJldHVybiBtb3ZlVHVwbGU7XG59XG5cbmZ1bmN0aW9uIGZpbHRCdG4wKHNlbGYsIHRhcmcsIGhhbmRsZSkge1xuXHRyZXR1cm4gZSA9PiB7XG5cdFx0ZS5idXR0b24gPT0gMCAmJiBoYW5kbGUoZSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIHBhc3NUaHJ1KHNlbGYsIHRhcmcsIGhhbmRsZSkge1xuXHRyZXR1cm4gaGFuZGxlO1xufVxuXG5jb25zdCBjdXJzb3JPcHRzID0ge1xuXHRzaG93OiB0cnVlLFxuXHR4OiB0cnVlLFxuXHR5OiB0cnVlLFxuXHRsb2NrOiBmYWxzZSxcblx0bW92ZTogY3Vyc29yTW92ZSxcblx0cG9pbnRzOiB7XG5cdFx0c2hvdzogICBjdXJzb3JQb2ludFNob3csXG5cdFx0c2l6ZTogICBjdXJzb3JQb2ludFNpemUsXG5cdFx0d2lkdGg6ICAwLFxuXHRcdHN0cm9rZTogY3Vyc29yUG9pbnRTdHJva2UsXG5cdFx0ZmlsbDogICBjdXJzb3JQb2ludEZpbGwsXG5cdH0sXG5cblx0YmluZDoge1xuXHRcdG1vdXNlZG93bjogICBmaWx0QnRuMCxcblx0XHRtb3VzZXVwOiAgICAgZmlsdEJ0bjAsXG5cdFx0Y2xpY2s6ICAgICAgIGZpbHRCdG4wLFxuXHRcdGRibGNsaWNrOiAgICBmaWx0QnRuMCxcblxuXHRcdG1vdXNlbW92ZTogICBwYXNzVGhydSxcblx0XHRtb3VzZWxlYXZlOiAgcGFzc1RocnUsXG5cdFx0bW91c2VlbnRlcjogIHBhc3NUaHJ1LFxuXHR9LFxuXG5cdGRyYWc6IHtcblx0XHRzZXRTY2FsZTogdHJ1ZSxcblx0XHR4OiB0cnVlLFxuXHRcdHk6IGZhbHNlLFxuXHRcdGRpc3Q6IDAsXG5cdFx0dW5pOiBudWxsLFxuXHRcdF94OiBmYWxzZSxcblx0XHRfeTogZmFsc2UsXG5cdH0sXG5cblx0Zm9jdXM6IHtcblx0XHRwcm94OiAtMSxcblx0fSxcblxuXHRsZWZ0OiAtMTAsXG5cdHRvcDogLTEwLFxuXHRpZHg6IG51bGwsXG5cdGRhdGFJZHgsXG5cdGlkeHM6IG51bGwsXG59O1xuXG5jb25zdCBheGlzTGluZXMgPSB7XG5cdHNob3c6IHRydWUsXG5cdHN0cm9rZTogXCJyZ2JhKDAsMCwwLDAuMDcpXCIsXG5cdHdpZHRoOiAyLFxuLy9cdGRhc2g6IFtdLFxufTtcblxuY29uc3QgZ3JpZCA9IGFzc2lnbih7fSwgYXhpc0xpbmVzLCB7XG5cdGZpbHRlcjogcmV0QXJnMSxcbn0pO1xuXG5jb25zdCB0aWNrcyA9IGFzc2lnbih7fSwgZ3JpZCwge1xuXHRzaXplOiAxMCxcbn0pO1xuXG5jb25zdCBib3JkZXIgPSBhc3NpZ24oe30sIGF4aXNMaW5lcywge1xuXHRzaG93OiBmYWxzZSxcbn0pO1xuXG5jb25zdCBmb250ICAgICAgPSAnMTJweCBzeXN0ZW0tdWksIC1hcHBsZS1zeXN0ZW0sIFwiU2Vnb2UgVUlcIiwgUm9ib3RvLCBcIkhlbHZldGljYSBOZXVlXCIsIEFyaWFsLCBcIk5vdG8gU2Fuc1wiLCBzYW5zLXNlcmlmLCBcIkFwcGxlIENvbG9yIEVtb2ppXCIsIFwiU2Vnb2UgVUkgRW1vamlcIiwgXCJTZWdvZSBVSSBTeW1ib2xcIiwgXCJOb3RvIENvbG9yIEVtb2ppXCInO1xuY29uc3QgbGFiZWxGb250ID0gXCJib2xkIFwiICsgZm9udDtcbmNvbnN0IGxpbmVNdWx0ID0gMS41O1x0XHQvLyBmb250LXNpemUgbXVsdGlwbGllclxuXG5jb25zdCB4QXhpc09wdHMgPSB7XG5cdHNob3c6IHRydWUsXG5cdHNjYWxlOiBcInhcIixcblx0c3Ryb2tlOiBoZXhCbGFjayxcblx0c3BhY2U6IDUwLFxuXHRnYXA6IDUsXG5cdHNpemU6IDUwLFxuXHRsYWJlbEdhcDogMCxcblx0bGFiZWxTaXplOiAzMCxcblx0bGFiZWxGb250LFxuXHRzaWRlOiAyLFxuLy9cdGNsYXNzOiBcIngtdmFsc1wiLFxuLy9cdGluY3JzOiB0aW1lSW5jcnMsXG4vL1x0dmFsdWVzOiB0aW1lVmFscyxcbi8vXHRmaWx0ZXI6IHJldEFyZzEsXG5cdGdyaWQsXG5cdHRpY2tzLFxuXHRib3JkZXIsXG5cdGZvbnQsXG5cdHJvdGF0ZTogMCxcbn07XG5cbmNvbnN0IG51bVNlcmllc0xhYmVsID0gXCJWYWx1ZVwiO1xuY29uc3QgdGltZVNlcmllc0xhYmVsID0gXCJUaW1lXCI7XG5cbmNvbnN0IHhTZXJpZXNPcHRzID0ge1xuXHRzaG93OiB0cnVlLFxuXHRzY2FsZTogXCJ4XCIsXG5cdGF1dG86IGZhbHNlLFxuXHRzb3J0ZWQ6IDEsXG4vL1x0bGFiZWw6IFwiVGltZVwiLFxuLy9cdHZhbHVlOiB2ID0+IHN0YW1wKG5ldyBEYXRlKHYgKiAxZTMpKSxcblxuXHQvLyBpbnRlcm5hbCBjYWNoZXNcblx0bWluOiBpbmYsXG5cdG1heDogLWluZixcblx0aWR4czogW10sXG59O1xuXG5mdW5jdGlvbiBudW1BeGlzVmFscyhzZWxmLCBzcGxpdHMsIGF4aXNJZHgsIGZvdW5kU3BhY2UsIGZvdW5kSW5jcikge1xuXHRyZXR1cm4gc3BsaXRzLm1hcCh2ID0+IHYgPT0gbnVsbCA/IFwiXCIgOiBmbXROdW0odikpO1xufVxuXG5mdW5jdGlvbiBudW1BeGlzU3BsaXRzKHNlbGYsIGF4aXNJZHgsIHNjYWxlTWluLCBzY2FsZU1heCwgZm91bmRJbmNyLCBmb3VuZFNwYWNlLCBmb3JjZU1pbikge1xuXHRsZXQgc3BsaXRzID0gW107XG5cblx0bGV0IG51bURlYyA9IGZpeGVkRGVjLmdldChmb3VuZEluY3IpIHx8IDA7XG5cblx0c2NhbGVNaW4gPSBmb3JjZU1pbiA/IHNjYWxlTWluIDogcm91bmREZWMoaW5jclJvdW5kVXAoc2NhbGVNaW4sIGZvdW5kSW5jciksIG51bURlYyk7XG5cblx0Zm9yIChsZXQgdmFsID0gc2NhbGVNaW47IHZhbCA8PSBzY2FsZU1heDsgdmFsID0gcm91bmREZWModmFsICsgZm91bmRJbmNyLCBudW1EZWMpKVxuXHRcdHNwbGl0cy5wdXNoKE9iamVjdC5pcyh2YWwsIC0wKSA/IDAgOiB2YWwpO1x0XHQvLyBjb2FsZXNjZXMgLTBcblxuXHRyZXR1cm4gc3BsaXRzO1xufVxuXG4vLyB0aGlzIGRvZXNudCB3b3JrIGZvciBzaW4sIHdoaWNoIG5lZWRzIHRvIGNvbWUgb2ZmIGZyb20gMCBpbmRlcGVuZGVudGx5IGluIHBvcyBhbmQgbmVnIGRpcnNcbmZ1bmN0aW9uIGxvZ0F4aXNTcGxpdHMoc2VsZiwgYXhpc0lkeCwgc2NhbGVNaW4sIHNjYWxlTWF4LCBmb3VuZEluY3IsIGZvdW5kU3BhY2UsIGZvcmNlTWluKSB7XG5cdGNvbnN0IHNwbGl0cyA9IFtdO1xuXG5cdGNvbnN0IGxvZ0Jhc2UgPSBzZWxmLnNjYWxlc1tzZWxmLmF4ZXNbYXhpc0lkeF0uc2NhbGVdLmxvZztcblxuXHRjb25zdCBsb2dGbiA9IGxvZ0Jhc2UgPT0gMTAgPyBsb2cxMCA6IGxvZzI7XG5cblx0Y29uc3QgZXhwID0gZmxvb3IobG9nRm4oc2NhbGVNaW4pKTtcblxuXHRmb3VuZEluY3IgPSBwb3cobG9nQmFzZSwgZXhwKTtcblxuXHRpZiAoZXhwIDwgMClcblx0XHRmb3VuZEluY3IgPSByb3VuZERlYyhmb3VuZEluY3IsIC1leHApO1xuXG5cdGxldCBzcGxpdCA9IHNjYWxlTWluO1xuXG5cdGRvIHtcblx0XHRzcGxpdHMucHVzaChzcGxpdCk7XG5cdFx0c3BsaXQgPSByb3VuZERlYyhzcGxpdCArIGZvdW5kSW5jciwgZml4ZWREZWMuZ2V0KGZvdW5kSW5jcikpO1xuXG5cdFx0aWYgKHNwbGl0ID49IGZvdW5kSW5jciAqIGxvZ0Jhc2UpXG5cdFx0XHRmb3VuZEluY3IgPSBzcGxpdDtcblxuXHR9IHdoaWxlIChzcGxpdCA8PSBzY2FsZU1heCk7XG5cblx0cmV0dXJuIHNwbGl0cztcbn1cblxuZnVuY3Rpb24gYXNpbmhBeGlzU3BsaXRzKHNlbGYsIGF4aXNJZHgsIHNjYWxlTWluLCBzY2FsZU1heCwgZm91bmRJbmNyLCBmb3VuZFNwYWNlLCBmb3JjZU1pbikge1xuXHRsZXQgc2MgPSBzZWxmLnNjYWxlc1tzZWxmLmF4ZXNbYXhpc0lkeF0uc2NhbGVdO1xuXG5cdGxldCBsaW50aHJlc2ggPSBzYy5hc2luaDtcblxuXHRsZXQgcG9zU3BsaXRzID0gc2NhbGVNYXggPiBsaW50aHJlc2ggPyBsb2dBeGlzU3BsaXRzKHNlbGYsIGF4aXNJZHgsIG1heChsaW50aHJlc2gsIHNjYWxlTWluKSwgc2NhbGVNYXgsIGZvdW5kSW5jcikgOiBbbGludGhyZXNoXTtcblx0bGV0IHplcm8gPSBzY2FsZU1heCA+PSAwICYmIHNjYWxlTWluIDw9IDAgPyBbMF0gOiBbXTtcblx0bGV0IG5lZ1NwbGl0cyA9IHNjYWxlTWluIDwgLWxpbnRocmVzaCA/IGxvZ0F4aXNTcGxpdHMoc2VsZiwgYXhpc0lkeCwgbWF4KGxpbnRocmVzaCwgLXNjYWxlTWF4KSwgLXNjYWxlTWluLCBmb3VuZEluY3IpOiBbbGludGhyZXNoXTtcblxuXHRyZXR1cm4gbmVnU3BsaXRzLnJldmVyc2UoKS5tYXAodiA9PiAtdikuY29uY2F0KHplcm8sIHBvc1NwbGl0cyk7XG59XG5cbmNvbnN0IFJFX0FMTCAgID0gLy4vO1xuY29uc3QgUkVfMTIzNTcgPSAvWzEyMzU3XS87XG5jb25zdCBSRV8xMjUgICA9IC9bMTI1XS87XG5jb25zdCBSRV8xICAgICA9IC8xLztcblxuZnVuY3Rpb24gbG9nQXhpc1ZhbHNGaWx0KHNlbGYsIHNwbGl0cywgYXhpc0lkeCwgZm91bmRTcGFjZSwgZm91bmRJbmNyKSB7XG5cdGxldCBheGlzID0gc2VsZi5heGVzW2F4aXNJZHhdO1xuXHRsZXQgc2NhbGVLZXkgPSBheGlzLnNjYWxlO1xuXHRsZXQgc2MgPSBzZWxmLnNjYWxlc1tzY2FsZUtleV07XG5cblx0aWYgKHNjLmRpc3RyID09IDMgJiYgc2MubG9nID09IDIpXG5cdFx0cmV0dXJuIHNwbGl0cztcblxuXHRsZXQgdmFsVG9Qb3MgPSBzZWxmLnZhbFRvUG9zO1xuXG5cdGxldCBtaW5TcGFjZSA9IGF4aXMuX3NwYWNlO1xuXG5cdGxldCBfMTAgPSB2YWxUb1BvcygxMCwgc2NhbGVLZXkpO1xuXG5cdGxldCByZSA9IChcblx0XHR2YWxUb1Bvcyg5LCBzY2FsZUtleSkgLSBfMTAgPj0gbWluU3BhY2UgPyBSRV9BTEwgOlxuXHRcdHZhbFRvUG9zKDcsIHNjYWxlS2V5KSAtIF8xMCA+PSBtaW5TcGFjZSA/IFJFXzEyMzU3IDpcblx0XHR2YWxUb1Bvcyg1LCBzY2FsZUtleSkgLSBfMTAgPj0gbWluU3BhY2UgPyBSRV8xMjUgOlxuXHRcdFJFXzFcblx0KTtcblxuXHRyZXR1cm4gc3BsaXRzLm1hcCh2ID0+ICgoc2MuZGlzdHIgPT0gNCAmJiB2ID09IDApIHx8IHJlLnRlc3QodikpID8gdiA6IG51bGwpO1xufVxuXG5mdW5jdGlvbiBudW1TZXJpZXNWYWwoc2VsZiwgdmFsKSB7XG5cdHJldHVybiB2YWwgPT0gbnVsbCA/IFwiXCIgOiBmbXROdW0odmFsKTtcbn1cblxuY29uc3QgeUF4aXNPcHRzID0ge1xuXHRzaG93OiB0cnVlLFxuXHRzY2FsZTogXCJ5XCIsXG5cdHN0cm9rZTogaGV4QmxhY2ssXG5cdHNwYWNlOiAzMCxcblx0Z2FwOiA1LFxuXHRzaXplOiA1MCxcblx0bGFiZWxHYXA6IDAsXG5cdGxhYmVsU2l6ZTogMzAsXG5cdGxhYmVsRm9udCxcblx0c2lkZTogMyxcbi8vXHRjbGFzczogXCJ5LXZhbHNcIixcbi8vXHRpbmNyczogbnVtSW5jcnMsXG4vL1x0dmFsdWVzOiAodmFscywgc3BhY2UpID0+IHZhbHMsXG4vL1x0ZmlsdGVyOiByZXRBcmcxLFxuXHRncmlkLFxuXHR0aWNrcyxcblx0Ym9yZGVyLFxuXHRmb250LFxuXHRyb3RhdGU6IDAsXG59O1xuXG4vLyB0YWtlcyBzdHJva2Ugd2lkdGhcbmZ1bmN0aW9uIHB0RGlhKHdpZHRoLCBtdWx0KSB7XG5cdGxldCBkaWEgPSAzICsgKHdpZHRoIHx8IDEpICogMjtcblx0cmV0dXJuIHJvdW5kRGVjKGRpYSAqIG11bHQsIDMpO1xufVxuXG5mdW5jdGlvbiBzZXJpZXNQb2ludHNTaG93KHNlbGYsIHNpKSB7XG5cdGxldCB7IHNjYWxlLCBpZHhzIH0gPSBzZWxmLnNlcmllc1swXTtcblx0bGV0IHhEYXRhID0gc2VsZi5fZGF0YVswXTtcblx0bGV0IHAwID0gc2VsZi52YWxUb1Bvcyh4RGF0YVtpZHhzWzBdXSwgc2NhbGUsIHRydWUpO1xuXHRsZXQgcDEgPSBzZWxmLnZhbFRvUG9zKHhEYXRhW2lkeHNbMV1dLCBzY2FsZSwgdHJ1ZSk7XG5cdGxldCBkaW0gPSBhYnMocDEgLSBwMCk7XG5cblx0bGV0IHMgPSBzZWxmLnNlcmllc1tzaV07XG4vL1x0Y29uc3QgZGlhID0gcHREaWEocy53aWR0aCwgcHhSYXRpbyk7XG5cdGxldCBtYXhQdHMgPSBkaW0gLyAocy5wb2ludHMuc3BhY2UgKiBweFJhdGlvKTtcblx0cmV0dXJuIGlkeHNbMV0gLSBpZHhzWzBdIDw9IG1heFB0cztcbn1cblxuY29uc3QgZmFjZXQgPSB7XG5cdHNjYWxlOiBudWxsLFxuXHRhdXRvOiB0cnVlLFxuXHRzb3J0ZWQ6IDAsXG5cblx0Ly8gaW50ZXJuYWwgY2FjaGVzXG5cdG1pbjogaW5mLFxuXHRtYXg6IC1pbmYsXG59O1xuXG5jb25zdCB4eVNlcmllc09wdHMgPSB7XG5cdHNob3c6IHRydWUsXG5cdGF1dG86IHRydWUsXG5cdHNvcnRlZDogMCxcblx0YWxwaGE6IDEsXG5cdGZhY2V0czogW1xuXHRcdGFzc2lnbih7fSwgZmFjZXQsIHtzY2FsZTogJ3gnfSksXG5cdFx0YXNzaWduKHt9LCBmYWNldCwge3NjYWxlOiAneSd9KSxcblx0XSxcbn07XG5cbmNvbnN0IHlTZXJpZXNPcHRzID0ge1xuXHRzY2FsZTogXCJ5XCIsXG5cdGF1dG86IHRydWUsXG5cdHNvcnRlZDogMCxcblx0c2hvdzogdHJ1ZSxcblx0c3BhbkdhcHM6IGZhbHNlLFxuXHRnYXBzOiAoc2VsZiwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBudWxsR2FwcykgPT4gbnVsbEdhcHMsXG5cdGFscGhhOiAxLFxuXHRwb2ludHM6IHtcblx0XHRzaG93OiBzZXJpZXNQb2ludHNTaG93LFxuXHRcdGZpbHRlcjogbnVsbCxcblx0Ly8gIHBhdGhzOlxuXHQvL1x0c3Ryb2tlOiBcIiMwMDBcIixcblx0Ly9cdGZpbGw6IFwiI2ZmZlwiLFxuXHQvL1x0d2lkdGg6IDEsXG5cdC8vXHRzaXplOiAxMCxcblx0fSxcbi8vXHRsYWJlbDogXCJWYWx1ZVwiLFxuLy9cdHZhbHVlOiB2ID0+IHYsXG5cdHZhbHVlczogbnVsbCxcblxuXHQvLyBpbnRlcm5hbCBjYWNoZXNcblx0bWluOiBpbmYsXG5cdG1heDogLWluZixcblx0aWR4czogW10sXG5cblx0cGF0aDogbnVsbCxcblx0Y2xpcDogbnVsbCxcbn07XG5cbmZ1bmN0aW9uIGNsYW1wU2NhbGUoc2VsZiwgdmFsLCBzY2FsZU1pbiwgc2NhbGVNYXgsIHNjYWxlS2V5KSB7XG4vKlxuXHRpZiAodmFsIDwgMCkge1xuXHRcdGxldCBjc3NIZ3QgPSBzZWxmLmJib3guaGVpZ2h0IC8gcHhSYXRpbztcblx0XHRsZXQgYWJzUG9zID0gc2VsZi52YWxUb1BvcyhhYnModmFsKSwgc2NhbGVLZXkpO1xuXHRcdGxldCBmcm9tQnRtID0gY3NzSGd0IC0gYWJzUG9zO1xuXHRcdHJldHVybiBzZWxmLnBvc1RvVmFsKGNzc0hndCArIGZyb21CdG0sIHNjYWxlS2V5KTtcblx0fVxuKi9cblx0cmV0dXJuIHNjYWxlTWluIC8gMTA7XG59XG5cbmNvbnN0IHhTY2FsZU9wdHMgPSB7XG5cdHRpbWU6IEZFQVRfVElNRSxcblx0YXV0bzogdHJ1ZSxcblx0ZGlzdHI6IDEsXG5cdGxvZzogMTAsXG5cdGFzaW5oOiAxLFxuXHRtaW46IG51bGwsXG5cdG1heDogbnVsbCxcblx0ZGlyOiAxLFxuXHRvcmk6IDAsXG59O1xuXG5jb25zdCB5U2NhbGVPcHRzID0gYXNzaWduKHt9LCB4U2NhbGVPcHRzLCB7XG5cdHRpbWU6IGZhbHNlLFxuXHRvcmk6IDEsXG59KTtcblxuY29uc3Qgc3luY3MgPSB7fTtcblxuZnVuY3Rpb24gX3N5bmMoa2V5LCBvcHRzKSB7XG5cdGxldCBzID0gc3luY3Nba2V5XTtcblxuXHRpZiAoIXMpIHtcblx0XHRzID0ge1xuXHRcdFx0a2V5LFxuXHRcdFx0cGxvdHM6IFtdLFxuXHRcdFx0c3ViKHBsb3QpIHtcblx0XHRcdFx0cy5wbG90cy5wdXNoKHBsb3QpO1xuXHRcdFx0fSxcblx0XHRcdHVuc3ViKHBsb3QpIHtcblx0XHRcdFx0cy5wbG90cyA9IHMucGxvdHMuZmlsdGVyKGMgPT4gYyAhPSBwbG90KTtcblx0XHRcdH0sXG5cdFx0XHRwdWIodHlwZSwgc2VsZiwgeCwgeSwgdywgaCwgaSkge1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHMucGxvdHMubGVuZ3RoOyBqKyspXG5cdFx0XHRcdFx0cy5wbG90c1tqXSAhPSBzZWxmICYmIHMucGxvdHNbal0ucHViKHR5cGUsIHNlbGYsIHgsIHksIHcsIGgsIGkpO1xuXHRcdFx0fSxcblx0XHR9O1xuXG5cdFx0aWYgKGtleSAhPSBudWxsKVxuXHRcdFx0c3luY3Nba2V5XSA9IHM7XG5cdH1cblxuXHRyZXR1cm4gcztcbn1cblxuY29uc3QgQkFORF9DTElQX0ZJTEwgICA9IDEgPDwgMDtcbmNvbnN0IEJBTkRfQ0xJUF9TVFJPS0UgPSAxIDw8IDE7XG5cbmZ1bmN0aW9uIG9yaWVudCh1LCBzZXJpZXNJZHgsIGNiKSB7XG5cdGNvbnN0IHNlcmllcyA9IHUuc2VyaWVzW3Nlcmllc0lkeF07XG5cdGNvbnN0IHNjYWxlcyA9IHUuc2NhbGVzO1xuXHRjb25zdCBiYm94ICAgPSB1LmJib3g7XG5cdGNvbnN0IHNjYWxlWCA9IHUubW9kZSA9PSAyID8gc2NhbGVzW3Nlcmllcy5mYWNldHNbMF0uc2NhbGVdIDogc2NhbGVzW3Uuc2VyaWVzWzBdLnNjYWxlXTtcblxuXHRsZXQgZHggPSB1Ll9kYXRhWzBdLFxuXHRcdGR5ID0gdS5fZGF0YVtzZXJpZXNJZHhdLFxuXHRcdHN4ID0gc2NhbGVYLFxuXHRcdHN5ID0gdS5tb2RlID09IDIgPyBzY2FsZXNbc2VyaWVzLmZhY2V0c1sxXS5zY2FsZV0gOiBzY2FsZXNbc2VyaWVzLnNjYWxlXSxcblx0XHRsID0gYmJveC5sZWZ0LFxuXHRcdHQgPSBiYm94LnRvcCxcblx0XHR3ID0gYmJveC53aWR0aCxcblx0XHRoID0gYmJveC5oZWlnaHQsXG5cdFx0SCA9IHUudmFsVG9Qb3NILFxuXHRcdFYgPSB1LnZhbFRvUG9zVjtcblxuXHRyZXR1cm4gKHN4Lm9yaSA9PSAwXG5cdFx0PyBjYihcblx0XHRcdHNlcmllcyxcblx0XHRcdGR4LFxuXHRcdFx0ZHksXG5cdFx0XHRzeCxcblx0XHRcdHN5LFxuXHRcdFx0SCxcblx0XHRcdFYsXG5cdFx0XHRsLFxuXHRcdFx0dCxcblx0XHRcdHcsXG5cdFx0XHRoLFxuXHRcdFx0bW92ZVRvSCxcblx0XHRcdGxpbmVUb0gsXG5cdFx0XHRyZWN0SCxcblx0XHRcdGFyY0gsXG5cdFx0XHRiZXppZXJDdXJ2ZVRvSCxcblx0XHQpXG5cdFx0OiBjYihcblx0XHRcdHNlcmllcyxcblx0XHRcdGR4LFxuXHRcdFx0ZHksXG5cdFx0XHRzeCxcblx0XHRcdHN5LFxuXHRcdFx0Vixcblx0XHRcdEgsXG5cdFx0XHR0LFxuXHRcdFx0bCxcblx0XHRcdGgsXG5cdFx0XHR3LFxuXHRcdFx0bW92ZVRvVixcblx0XHRcdGxpbmVUb1YsXG5cdFx0XHRyZWN0Vixcblx0XHRcdGFyY1YsXG5cdFx0XHRiZXppZXJDdXJ2ZVRvVixcblx0XHQpXG5cdCk7XG59XG5cbmZ1bmN0aW9uIGJhbmRGaWxsQ2xpcERpcnMoc2VsZiwgc2VyaWVzSWR4KSB7XG5cdGxldCBmaWxsRGlyID0gMDtcblxuXHQvLyAyIGJpdHMsIC0xIHwgMVxuXHRsZXQgY2xpcERpcnMgPSAwO1xuXG5cdGxldCBiYW5kcyA9IGlmTnVsbChzZWxmLmJhbmRzLCBFTVBUWV9BUlIpO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgYmFuZHMubGVuZ3RoOyBpKyspIHtcblx0XHRsZXQgYiA9IGJhbmRzW2ldO1xuXG5cdFx0Ly8gaXMgYSBcImZyb21cIiBiYW5kIGVkZ2Vcblx0XHRpZiAoYi5zZXJpZXNbMF0gPT0gc2VyaWVzSWR4KVxuXHRcdFx0ZmlsbERpciA9IGIuZGlyO1xuXHRcdC8vIGlzIGEgXCJ0b1wiIGJhbmQgZWRnZVxuXHRcdGVsc2UgaWYgKGIuc2VyaWVzWzFdID09IHNlcmllc0lkeCkge1xuXHRcdFx0aWYgKGIuZGlyID09IDEpXG5cdFx0XHRcdGNsaXBEaXJzIHw9IDE7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGNsaXBEaXJzIHw9IDI7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFtcblx0XHRmaWxsRGlyLFxuXHRcdChcblx0XHRcdGNsaXBEaXJzID09IDEgPyAtMSA6IC8vIG5lZyBvbmx5XG5cdFx0XHRjbGlwRGlycyA9PSAyID8gIDEgOiAvLyBwb3Mgb25seVxuXHRcdFx0Y2xpcERpcnMgPT0gMyA/ICAyIDogLy8gYm90aFxuXHRcdFx0ICAgICAgICAgICAgICAgICAwICAgLy8gbmVpdGhlclxuXHRcdClcblx0XTtcbn1cblxuZnVuY3Rpb24gc2VyaWVzRmlsbFRvKHNlbGYsIHNlcmllc0lkeCwgZGF0YU1pbiwgZGF0YU1heCwgYmFuZEZpbGxEaXIpIHtcblx0bGV0IHNjYWxlID0gc2VsZi5zY2FsZXNbc2VsZi5zZXJpZXNbc2VyaWVzSWR4XS5zY2FsZV07XG5cblx0cmV0dXJuIChcblx0XHRiYW5kRmlsbERpciA9PSAtMSA/IHNjYWxlLm1pbiA6XG5cdFx0YmFuZEZpbGxEaXIgPT0gIDEgPyBzY2FsZS5tYXggOlxuXHRcdHNjYWxlLmRpc3RyID09ICAzID8gKFxuXHRcdFx0c2NhbGUuZGlyID09IDEgPyBzY2FsZS5taW4gOlxuXHRcdFx0c2NhbGUubWF4XG5cdFx0KSA6IDBcblx0KTtcbn1cblxuLy8gY3JlYXRlcyBpbnZlcnRlZCBiYW5kIGNsaXAgcGF0aCAoZnJvbSBzdHJva2UgcGF0aCAtPiB5TWF4IHx8IHlNaW4pXG4vLyBjbGlwRGlyIGlzIGFsd2F5cyBpbnZlcnNlIG9mIGZpbGxEaXJcbi8vIGRlZmF1bHQgY2xpcCBkaXIgaXMgdXB3YXJkcyAoMSksIHNpbmNlIGRlZmF1bHQgYmFuZCBmaWxsIGlzIGRvd253YXJkcy9maWxsQmVsb3dUbyAoLTEpIChoaWdoSWR4IC0+IGxvd0lkeClcbmZ1bmN0aW9uIGNsaXBCYW5kTGluZShzZWxmLCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEsIHN0cm9rZVBhdGgsIGNsaXBEaXIpIHtcblx0cmV0dXJuIG9yaWVudChzZWxmLCBzZXJpZXNJZHgsIChzZXJpZXMsIGRhdGFYLCBkYXRhWSwgc2NhbGVYLCBzY2FsZVksIHZhbFRvUG9zWCwgdmFsVG9Qb3NZLCB4T2ZmLCB5T2ZmLCB4RGltLCB5RGltKSA9PiB7XG5cdFx0bGV0IHB4Um91bmQgPSBzZXJpZXMucHhSb3VuZDtcblxuXHRcdGNvbnN0IGRpciA9IHNjYWxlWC5kaXIgKiAoc2NhbGVYLm9yaSA9PSAwID8gMSA6IC0xKTtcblx0XHRjb25zdCBsaW5lVG8gPSBzY2FsZVgub3JpID09IDAgPyBsaW5lVG9IIDogbGluZVRvVjtcblxuXHRcdGxldCBmcklkeCwgdG9JZHg7XG5cblx0XHRpZiAoZGlyID09IDEpIHtcblx0XHRcdGZySWR4ID0gaWR4MDtcblx0XHRcdHRvSWR4ID0gaWR4MTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRmcklkeCA9IGlkeDE7XG5cdFx0XHR0b0lkeCA9IGlkeDA7XG5cdFx0fVxuXG5cdFx0Ly8gcGF0aCBzdGFydFxuXHRcdGxldCB4MCA9IHB4Um91bmQodmFsVG9Qb3NYKGRhdGFYW2ZySWR4XSwgc2NhbGVYLCB4RGltLCB4T2ZmKSk7XG5cdFx0bGV0IHkwID0gcHhSb3VuZCh2YWxUb1Bvc1koZGF0YVlbZnJJZHhdLCBzY2FsZVksIHlEaW0sIHlPZmYpKTtcblx0XHQvLyBwYXRoIGVuZCB4XG5cdFx0bGV0IHgxID0gcHhSb3VuZCh2YWxUb1Bvc1goZGF0YVhbdG9JZHhdLCBzY2FsZVgsIHhEaW0sIHhPZmYpKTtcblx0XHQvLyB1cHBlciBvciBsb3dlciB5IGxpbWl0XG5cdFx0bGV0IHlMaW1pdCA9IHB4Um91bmQodmFsVG9Qb3NZKGNsaXBEaXIgPT0gMSA/IHNjYWxlWS5tYXggOiBzY2FsZVkubWluLCBzY2FsZVksIHlEaW0sIHlPZmYpKTtcblxuXHRcdGxldCBjbGlwID0gbmV3IFBhdGgyRChzdHJva2VQYXRoKTtcblxuXHRcdGxpbmVUbyhjbGlwLCB4MSwgeUxpbWl0KTtcblx0XHRsaW5lVG8oY2xpcCwgeDAsIHlMaW1pdCk7XG5cdFx0bGluZVRvKGNsaXAsIHgwLCB5MCk7XG5cblx0XHRyZXR1cm4gY2xpcDtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGNsaXBHYXBzKGdhcHMsIG9yaSwgcGxvdExmdCwgcGxvdFRvcCwgcGxvdFdpZCwgcGxvdEhndCkge1xuXHRsZXQgY2xpcCA9IG51bGw7XG5cblx0Ly8gY3JlYXRlIGNsaXAgcGF0aCAoaW52ZXJ0IGdhcHMgYW5kIG5vbi1nYXBzKVxuXHRpZiAoZ2Fwcy5sZW5ndGggPiAwKSB7XG5cdFx0Y2xpcCA9IG5ldyBQYXRoMkQoKTtcblxuXHRcdGNvbnN0IHJlY3QgPSBvcmkgPT0gMCA/IHJlY3RIIDogcmVjdFY7XG5cblx0XHRsZXQgcHJldkdhcEVuZCA9IHBsb3RMZnQ7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGdhcHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBnID0gZ2Fwc1tpXTtcblxuXHRcdFx0aWYgKGdbMV0gPiBnWzBdKSB7XG5cdFx0XHRcdGxldCB3ID0gZ1swXSAtIHByZXZHYXBFbmQ7XG5cblx0XHRcdFx0dyA+IDAgJiYgcmVjdChjbGlwLCBwcmV2R2FwRW5kLCBwbG90VG9wLCB3LCBwbG90VG9wICsgcGxvdEhndCk7XG5cblx0XHRcdFx0cHJldkdhcEVuZCA9IGdbMV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHcgPSBwbG90TGZ0ICsgcGxvdFdpZCAtIHByZXZHYXBFbmQ7XG5cblx0XHR3ID4gMCAmJiByZWN0KGNsaXAsIHByZXZHYXBFbmQsIHBsb3RUb3AsIHcsIHBsb3RUb3AgKyBwbG90SGd0KTtcblx0fVxuXG5cdHJldHVybiBjbGlwO1xufVxuXG5mdW5jdGlvbiBhZGRHYXAoZ2FwcywgZnJvbVgsIHRvWCkge1xuXHRsZXQgcHJldkdhcCA9IGdhcHNbZ2Fwcy5sZW5ndGggLSAxXTtcblxuXHRpZiAocHJldkdhcCAmJiBwcmV2R2FwWzBdID09IGZyb21YKVx0XHRcdC8vIFRPRE86IGdhcHMgbXVzdCBiZSBlbmNvZGVkIGF0IHN0cm9rZSB3aWR0aHM/XG5cdFx0cHJldkdhcFsxXSA9IHRvWDtcblx0ZWxzZVxuXHRcdGdhcHMucHVzaChbZnJvbVgsIHRvWF0pO1xufVxuXG5mdW5jdGlvbiBmaW5kR2Fwcyh4cywgeXMsIGlkeDAsIGlkeDEsIGRpciwgcGl4ZWxGb3JYLCBhbGlnbikge1xuXHRsZXQgZ2FwcyA9IFtdO1xuXG5cdGZvciAobGV0IGkgPSBkaXIgPT0gMSA/IGlkeDAgOiBpZHgxOyBpID49IGlkeDAgJiYgaSA8PSBpZHgxOyBpICs9IGRpcikge1xuXHRcdGxldCB5VmFsID0geXNbaV07XG5cblx0XHRpZiAoeVZhbCA9PT0gbnVsbCkge1xuXHRcdFx0bGV0IGZyID0gaSwgdG8gPSBpO1xuXG5cdFx0XHRpZiAoZGlyID09IDEpIHtcblx0XHRcdFx0d2hpbGUgKCsraSA8PSBpZHgxICYmIHlzW2ldID09PSBudWxsKVxuXHRcdFx0XHRcdHRvID0gaTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoLS1pID49IGlkeDAgJiYgeXNbaV0gPT09IG51bGwpXG5cdFx0XHRcdFx0dG8gPSBpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgZnJQeCA9IHBpeGVsRm9yWCh4c1tmcl0pO1xuXHRcdFx0bGV0IHRvUHggPSB0byA9PSBmciA/IGZyUHggOiBwaXhlbEZvclgoeHNbdG9dKTtcblxuXHRcdFx0Ly8gaWYgdmFsdWUgYWRqYWNlbnQgdG8gZWRnZSBudWxsIGlzIHNhbWUgcGl4ZWwsIHRoZW4gaXQncyBwYXJ0aWFsbHlcblx0XHRcdC8vIGZpbGxlZCBhbmQgZ2FwIHNob3VsZCBzdGFydCBhdCBuZXh0IHBpeGVsXG5cdFx0XHRsZXQgZnJQeDIgPSBhbGlnbiA8PSAwID8gcGl4ZWxGb3JYKHhzW2ZyLWRpcl0pIDogZnJQeDtcblx0XHQvL1x0aWYgKGZyUHgyID09IGZyUHgpXG5cdFx0Ly9cdFx0ZnJQeCsrO1xuXHRcdC8vXHRlbHNlXG5cdFx0XHRcdGZyUHggPSBmclB4MjtcblxuXHRcdFx0bGV0IHRvUHgyID0gYWxpZ24gPj0gMCA/IHBpeGVsRm9yWCh4c1t0bytkaXJdKSA6IHRvUHg7XG5cdFx0Ly9cdGlmICh0b1B4MiA9PSB0b1B4KVxuXHRcdC8vXHRcdHRvUHgtLTtcblx0XHQvL1x0ZWxzZVxuXHRcdFx0XHR0b1B4ID0gdG9QeDI7XG5cblx0XHRcdGlmICh0b1B4ID49IGZyUHgpXG5cdFx0XHRcdGdhcHMucHVzaChbZnJQeCwgdG9QeF0pOyAvLyBhZGRHYXBcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZ2Fwcztcbn1cblxuZnVuY3Rpb24gcHhSb3VuZEdlbihweEFsaWduKSB7XG5cdHJldHVybiBweEFsaWduID09IDAgPyByZXRBcmcwIDogcHhBbGlnbiA9PSAxID8gcm91bmQgOiB2ID0+IGluY3JSb3VuZCh2LCBweEFsaWduKTtcbn1cblxuZnVuY3Rpb24gcmVjdChvcmkpIHtcblx0bGV0IG1vdmVUbyA9IG9yaSA9PSAwID9cblx0XHRtb3ZlVG9IIDpcblx0XHRtb3ZlVG9WO1xuXG5cdGxldCBhcmNUbyA9IG9yaSA9PSAwID9cblx0XHQocCwgeDEsIHkxLCB4MiwgeTIsIHIpID0+IHsgcC5hcmNUbyh4MSwgeTEsIHgyLCB5Miwgcik7IH0gOlxuXHRcdChwLCB5MSwgeDEsIHkyLCB4MiwgcikgPT4geyBwLmFyY1RvKHgxLCB5MSwgeDIsIHkyLCByKTsgfTtcblxuXHRsZXQgcmVjdCA9IG9yaSA9PSAwID9cblx0XHQocCwgeCwgeSwgdywgaCkgPT4geyBwLnJlY3QoeCwgeSwgdywgaCk7IH0gOlxuXHRcdChwLCB5LCB4LCBoLCB3KSA9PiB7IHAucmVjdCh4LCB5LCB3LCBoKTsgfTtcblxuXHRyZXR1cm4gKHAsIHgsIHksIHcsIGgsIHIgPSAwKSA9PiB7XG5cdFx0aWYgKHIgPT0gMClcblx0XHRcdHJlY3QocCwgeCwgeSwgdywgaCk7XG5cdFx0ZWxzZSB7XG5cdFx0XHRyID0gbWluKHIsIHcgLyAyLCBoIC8gMik7XG5cblx0XHRcdC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjU1NTEyL2hvdy10by1kcmF3LWEtcm91bmRlZC1yZWN0YW5nbGUtdXNpbmctaHRtbC1jYW52YXMvNzgzODg3MSM3ODM4ODcxXG5cdFx0XHRtb3ZlVG8ocCwgeCArIHIsIHkpO1xuXHRcdFx0YXJjVG8ocCwgeCArIHcsIHksIHggKyB3LCB5ICsgaCwgcik7XG5cdFx0XHRhcmNUbyhwLCB4ICsgdywgeSArIGgsIHgsIHkgKyBoLCByKTtcblx0XHRcdGFyY1RvKHAsIHgsIHkgKyBoLCB4LCB5LCByKTtcblx0XHRcdGFyY1RvKHAsIHgsIHksIHggKyB3LCB5LCByKTtcblx0XHRcdHAuY2xvc2VQYXRoKCk7XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBvcmllbnRhdGlvbi1pbnZlcnRpbmcgY2FudmFzIGZ1bmN0aW9uc1xuY29uc3QgbW92ZVRvSCA9IChwLCB4LCB5KSA9PiB7IHAubW92ZVRvKHgsIHkpOyB9O1xuY29uc3QgbW92ZVRvViA9IChwLCB5LCB4KSA9PiB7IHAubW92ZVRvKHgsIHkpOyB9O1xuY29uc3QgbGluZVRvSCA9IChwLCB4LCB5KSA9PiB7IHAubGluZVRvKHgsIHkpOyB9O1xuY29uc3QgbGluZVRvViA9IChwLCB5LCB4KSA9PiB7IHAubGluZVRvKHgsIHkpOyB9O1xuY29uc3QgcmVjdEggPSByZWN0KDApO1xuY29uc3QgcmVjdFYgPSByZWN0KDEpO1xuY29uc3QgYXJjSCA9IChwLCB4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkgPT4geyBwLmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7IH07XG5jb25zdCBhcmNWID0gKHAsIHksIHgsIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSA9PiB7IHAuYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTsgfTtcbmNvbnN0IGJlemllckN1cnZlVG9IID0gKHAsIGJwMXgsIGJwMXksIGJwMngsIGJwMnksIHAyeCwgcDJ5KSA9PiB7IHAuYmV6aWVyQ3VydmVUbyhicDF4LCBicDF5LCBicDJ4LCBicDJ5LCBwMngsIHAyeSk7IH07XG5jb25zdCBiZXppZXJDdXJ2ZVRvViA9IChwLCBicDF5LCBicDF4LCBicDJ5LCBicDJ4LCBwMnksIHAyeCkgPT4geyBwLmJlemllckN1cnZlVG8oYnAxeCwgYnAxeSwgYnAyeCwgYnAyeSwgcDJ4LCBwMnkpOyB9O1xuXG4vLyBUT0RPOiBkcmF3V3JhcChzZXJpZXNJZHgsIGRyYXdQb2ludHMpIChzYXZlLCByZXN0b3JlLCB0cmFuc2xhdGUsIGNsaXApXG5mdW5jdGlvbiBwb2ludHMob3B0cykge1xuXHRyZXR1cm4gKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSwgZmlsdElkeHMpID0+IHtcblx0Ly9cdGxvZyhcImRyYXdQb2ludHMoKVwiLCBhcmd1bWVudHMpO1xuXG5cdFx0cmV0dXJuIG9yaWVudCh1LCBzZXJpZXNJZHgsIChzZXJpZXMsIGRhdGFYLCBkYXRhWSwgc2NhbGVYLCBzY2FsZVksIHZhbFRvUG9zWCwgdmFsVG9Qb3NZLCB4T2ZmLCB5T2ZmLCB4RGltLCB5RGltKSA9PiB7XG5cdFx0XHRsZXQgeyBweFJvdW5kLCBwb2ludHMgfSA9IHNlcmllcztcblxuXHRcdFx0bGV0IG1vdmVUbywgYXJjO1xuXG5cdFx0XHRpZiAoc2NhbGVYLm9yaSA9PSAwKSB7XG5cdFx0XHRcdG1vdmVUbyA9IG1vdmVUb0g7XG5cdFx0XHRcdGFyYyA9IGFyY0g7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bW92ZVRvID0gbW92ZVRvVjtcblx0XHRcdFx0YXJjID0gYXJjVjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgd2lkdGggPSByb3VuZERlYyhwb2ludHMud2lkdGggKiBweFJhdGlvLCAzKTtcblxuXHRcdFx0bGV0IHJhZCA9IChwb2ludHMuc2l6ZSAtIHBvaW50cy53aWR0aCkgLyAyICogcHhSYXRpbztcblx0XHRcdGxldCBkaWEgPSByb3VuZERlYyhyYWQgKiAyLCAzKTtcblxuXHRcdFx0bGV0IGZpbGwgPSBuZXcgUGF0aDJEKCk7XG5cdFx0XHRsZXQgY2xpcCA9IG5ldyBQYXRoMkQoKTtcblxuXHRcdFx0bGV0IHsgbGVmdDogbGZ0LCB0b3A6IHRvcCwgd2lkdGg6IHdpZCwgaGVpZ2h0OiBoZ3QgfSA9IHUuYmJveDtcblxuXHRcdFx0cmVjdEgoY2xpcCxcblx0XHRcdFx0bGZ0IC0gZGlhLFxuXHRcdFx0XHR0b3AgLSBkaWEsXG5cdFx0XHRcdHdpZCArIGRpYSAqIDIsXG5cdFx0XHRcdGhndCArIGRpYSAqIDIsXG5cdFx0XHQpO1xuXG5cdFx0XHRjb25zdCBkcmF3UG9pbnQgPSBwaSA9PiB7XG5cdFx0XHRcdGlmIChkYXRhWVtwaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGxldCB4ID0gcHhSb3VuZCh2YWxUb1Bvc1goZGF0YVhbcGldLCBzY2FsZVgsIHhEaW0sIHhPZmYpKTtcblx0XHRcdFx0XHRsZXQgeSA9IHB4Um91bmQodmFsVG9Qb3NZKGRhdGFZW3BpXSwgc2NhbGVZLCB5RGltLCB5T2ZmKSk7XG5cblx0XHRcdFx0XHRtb3ZlVG8oZmlsbCwgeCArIHJhZCwgeSk7XG5cdFx0XHRcdFx0YXJjKGZpbGwsIHgsIHksIHJhZCwgMCwgUEkgKiAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKGZpbHRJZHhzKVxuXHRcdFx0XHRmaWx0SWR4cy5mb3JFYWNoKGRyYXdQb2ludCk7XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Zm9yIChsZXQgcGkgPSBpZHgwOyBwaSA8PSBpZHgxOyBwaSsrKVxuXHRcdFx0XHRcdGRyYXdQb2ludChwaSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHN0cm9rZTogd2lkdGggPiAwID8gZmlsbCA6IG51bGwsXG5cdFx0XHRcdGZpbGwsXG5cdFx0XHRcdGNsaXAsXG5cdFx0XHRcdGZsYWdzOiBCQU5EX0NMSVBfRklMTCB8IEJBTkRfQ0xJUF9TVFJPS0UsXG5cdFx0XHR9O1xuXHRcdH0pO1xuXHR9O1xufVxuXG5mdW5jdGlvbiBfZHJhd0FjYyhsaW5lVG8pIHtcblx0cmV0dXJuIChzdHJva2UsIGFjY1gsIG1pblksIG1heFksIGluWSwgb3V0WSkgPT4ge1xuXHRcdGlmIChtaW5ZICE9IG1heFkpIHtcblx0XHRcdGlmIChpblkgIT0gbWluWSAmJiBvdXRZICE9IG1pblkpXG5cdFx0XHRcdGxpbmVUbyhzdHJva2UsIGFjY1gsIG1pblkpO1xuXHRcdFx0aWYgKGluWSAhPSBtYXhZICYmIG91dFkgIT0gbWF4WSlcblx0XHRcdFx0bGluZVRvKHN0cm9rZSwgYWNjWCwgbWF4WSk7XG5cblx0XHRcdGxpbmVUbyhzdHJva2UsIGFjY1gsIG91dFkpO1xuXHRcdH1cblx0fTtcbn1cblxuY29uc3QgZHJhd0FjY0ggPSBfZHJhd0FjYyhsaW5lVG9IKTtcbmNvbnN0IGRyYXdBY2NWID0gX2RyYXdBY2MobGluZVRvVik7XG5cbmZ1bmN0aW9uIGxpbmVhcihvcHRzKSB7XG5cdGNvbnN0IGFsaWduR2FwcyA9IGlmTnVsbChvcHRzPy5hbGlnbkdhcHMsIDApO1xuXG5cdHJldHVybiAodSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxKSA9PiB7XG5cdFx0cmV0dXJuIG9yaWVudCh1LCBzZXJpZXNJZHgsIChzZXJpZXMsIGRhdGFYLCBkYXRhWSwgc2NhbGVYLCBzY2FsZVksIHZhbFRvUG9zWCwgdmFsVG9Qb3NZLCB4T2ZmLCB5T2ZmLCB4RGltLCB5RGltKSA9PiB7XG5cdFx0XHRsZXQgcHhSb3VuZCA9IHNlcmllcy5weFJvdW5kO1xuXG5cdFx0XHRsZXQgcGl4ZWxGb3JYID0gdmFsID0+IHB4Um91bmQodmFsVG9Qb3NYKHZhbCwgc2NhbGVYLCB4RGltLCB4T2ZmKSk7XG5cdFx0XHRsZXQgcGl4ZWxGb3JZID0gdmFsID0+IHB4Um91bmQodmFsVG9Qb3NZKHZhbCwgc2NhbGVZLCB5RGltLCB5T2ZmKSk7XG5cblx0XHRcdGxldCBsaW5lVG8sIGRyYXdBY2M7XG5cblx0XHRcdGlmIChzY2FsZVgub3JpID09IDApIHtcblx0XHRcdFx0bGluZVRvID0gbGluZVRvSDtcblx0XHRcdFx0ZHJhd0FjYyA9IGRyYXdBY2NIO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxpbmVUbyA9IGxpbmVUb1Y7XG5cdFx0XHRcdGRyYXdBY2MgPSBkcmF3QWNjVjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZGlyID0gc2NhbGVYLmRpciAqIChzY2FsZVgub3JpID09IDAgPyAxIDogLTEpO1xuXG5cdFx0XHRjb25zdCBfcGF0aHMgPSB7c3Ryb2tlOiBuZXcgUGF0aDJEKCksIGZpbGw6IG51bGwsIGNsaXA6IG51bGwsIGJhbmQ6IG51bGwsIGdhcHM6IG51bGwsIGZsYWdzOiBCQU5EX0NMSVBfRklMTH07XG5cdFx0XHRjb25zdCBzdHJva2UgPSBfcGF0aHMuc3Ryb2tlO1xuXG5cdFx0XHRsZXQgbWluWSA9IGluZixcblx0XHRcdFx0bWF4WSA9IC1pbmYsXG5cdFx0XHRcdGluWSwgb3V0WSwgZHJhd25BdFg7XG5cblx0XHRcdGxldCBhY2NYID0gcGl4ZWxGb3JYKGRhdGFYW2RpciA9PSAxID8gaWR4MCA6IGlkeDFdKTtcblxuXHRcdFx0Ly8gZGF0YSBlZGdlc1xuXHRcdFx0bGV0IGxmdElkeCA9IG5vbk51bGxJZHgoZGF0YVksIGlkeDAsIGlkeDEsICAxICogZGlyKTtcblx0XHRcdGxldCByZ3RJZHggPSBub25OdWxsSWR4KGRhdGFZLCBpZHgwLCBpZHgxLCAtMSAqIGRpcik7XG5cdFx0XHRsZXQgbGZ0WCAgID0gIHBpeGVsRm9yWChkYXRhWFtsZnRJZHhdKTtcblx0XHRcdGxldCByZ3RYICAgPSAgcGl4ZWxGb3JYKGRhdGFYW3JndElkeF0pO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gZGlyID09IDEgPyBpZHgwIDogaWR4MTsgaSA+PSBpZHgwICYmIGkgPD0gaWR4MTsgaSArPSBkaXIpIHtcblx0XHRcdFx0bGV0IHggPSBwaXhlbEZvclgoZGF0YVhbaV0pO1xuXG5cdFx0XHRcdGlmICh4ID09IGFjY1gpIHtcblx0XHRcdFx0XHRpZiAoZGF0YVlbaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0b3V0WSA9IHBpeGVsRm9yWShkYXRhWVtpXSk7XG5cblx0XHRcdFx0XHRcdGlmIChtaW5ZID09IGluZikge1xuXHRcdFx0XHRcdFx0XHRsaW5lVG8oc3Ryb2tlLCB4LCBvdXRZKTtcblx0XHRcdFx0XHRcdFx0aW5ZID0gb3V0WTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bWluWSA9IG1pbihvdXRZLCBtaW5ZKTtcblx0XHRcdFx0XHRcdG1heFkgPSBtYXgob3V0WSwgbWF4WSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmIChtaW5ZICE9IGluZikge1xuXHRcdFx0XHRcdFx0ZHJhd0FjYyhzdHJva2UsIGFjY1gsIG1pblksIG1heFksIGluWSwgb3V0WSk7XG5cdFx0XHRcdFx0XHRkcmF3bkF0WCA9IGFjY1g7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGRhdGFZW2ldICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdG91dFkgPSBwaXhlbEZvclkoZGF0YVlbaV0pO1xuXHRcdFx0XHRcdFx0bGluZVRvKHN0cm9rZSwgeCwgb3V0WSk7XG5cdFx0XHRcdFx0XHRtaW5ZID0gbWF4WSA9IGluWSA9IG91dFk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0bWluWSA9IGluZjtcblx0XHRcdFx0XHRcdG1heFkgPSAtaW5mO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGFjY1ggPSB4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtaW5ZICE9IGluZiAmJiBtaW5ZICE9IG1heFkgJiYgZHJhd25BdFggIT0gYWNjWClcblx0XHRcdFx0ZHJhd0FjYyhzdHJva2UsIGFjY1gsIG1pblksIG1heFksIGluWSwgb3V0WSk7XG5cblx0XHRcdGxldCBbIGJhbmRGaWxsRGlyLCBiYW5kQ2xpcERpciBdID0gYmFuZEZpbGxDbGlwRGlycyh1LCBzZXJpZXNJZHgpO1xuXG5cdFx0XHRpZiAoc2VyaWVzLmZpbGwgIT0gbnVsbCB8fCBiYW5kRmlsbERpciAhPSAwKSB7XG5cdFx0XHRcdGxldCBmaWxsID0gX3BhdGhzLmZpbGwgPSBuZXcgUGF0aDJEKHN0cm9rZSk7XG5cblx0XHRcdFx0bGV0IGZpbGxUb1ZhbCA9IHNlcmllcy5maWxsVG8odSwgc2VyaWVzSWR4LCBzZXJpZXMubWluLCBzZXJpZXMubWF4LCBiYW5kRmlsbERpcik7XG5cdFx0XHRcdGxldCBmaWxsVG9ZID0gcGl4ZWxGb3JZKGZpbGxUb1ZhbCk7XG5cblx0XHRcdFx0bGluZVRvKGZpbGwsIHJndFgsIGZpbGxUb1kpO1xuXHRcdFx0XHRsaW5lVG8oZmlsbCwgbGZ0WCwgZmlsbFRvWSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghc2VyaWVzLnNwYW5HYXBzKSB7XG5cdFx0XHQvL1x0Y29uc29sZS50aW1lKCdnYXBzJyk7XG5cdFx0XHRcdGxldCBnYXBzID0gW107XG5cblx0XHRcdFx0Z2Fwcy5wdXNoKC4uLmZpbmRHYXBzKGRhdGFYLCBkYXRhWSwgaWR4MCwgaWR4MSwgZGlyLCBwaXhlbEZvclgsIGFsaWduR2FwcykpO1xuXG5cdFx0XHQvL1x0Y29uc29sZS50aW1lRW5kKCdnYXBzJyk7XG5cblx0XHRcdC8vXHRjb25zb2xlLmxvZygnZ2FwcycsIEpTT04uc3RyaW5naWZ5KGdhcHMpKTtcblxuXHRcdFx0XHRfcGF0aHMuZ2FwcyA9IGdhcHMgPSBzZXJpZXMuZ2Fwcyh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEsIGdhcHMpO1xuXG5cdFx0XHRcdF9wYXRocy5jbGlwID0gY2xpcEdhcHMoZ2Fwcywgc2NhbGVYLm9yaSwgeE9mZiwgeU9mZiwgeERpbSwgeURpbSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChiYW5kQ2xpcERpciAhPSAwKSB7XG5cdFx0XHRcdF9wYXRocy5iYW5kID0gYmFuZENsaXBEaXIgPT0gMiA/IFtcblx0XHRcdFx0XHRjbGlwQmFuZExpbmUodSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBzdHJva2UsIC0xKSxcblx0XHRcdFx0XHRjbGlwQmFuZExpbmUodSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBzdHJva2UsICAxKSxcblx0XHRcdFx0XSA6IGNsaXBCYW5kTGluZSh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEsIHN0cm9rZSwgYmFuZENsaXBEaXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gX3BhdGhzO1xuXHRcdH0pO1xuXHR9O1xufVxuXG5mdW5jdGlvbiBzdGVwcGVkKG9wdHMpIHtcblx0Y29uc3QgYWxpZ24gPSBpZk51bGwob3B0cy5hbGlnbiwgMSk7XG5cdC8vIHdoZXRoZXIgdG8gZHJhdyBhc2NlbmRlcnMvZGVzY2VuZGVycyBhdCBudWxsL2dhcCBib25kYXJpZXNcblx0Y29uc3QgYXNjRGVzYyA9IGlmTnVsbChvcHRzLmFzY0Rlc2MsIGZhbHNlKTtcblxuXHRjb25zdCBhbGlnbkdhcHMgPSBpZk51bGwob3B0cy5hbGlnbkdhcHMsIDApO1xuXG5cdHJldHVybiAodSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxKSA9PiB7XG5cdFx0cmV0dXJuIG9yaWVudCh1LCBzZXJpZXNJZHgsIChzZXJpZXMsIGRhdGFYLCBkYXRhWSwgc2NhbGVYLCBzY2FsZVksIHZhbFRvUG9zWCwgdmFsVG9Qb3NZLCB4T2ZmLCB5T2ZmLCB4RGltLCB5RGltKSA9PiB7XG5cdFx0XHRsZXQgcHhSb3VuZCA9IHNlcmllcy5weFJvdW5kO1xuXG5cdFx0XHRsZXQgcGl4ZWxGb3JYID0gdmFsID0+IHB4Um91bmQodmFsVG9Qb3NYKHZhbCwgc2NhbGVYLCB4RGltLCB4T2ZmKSk7XG5cdFx0XHRsZXQgcGl4ZWxGb3JZID0gdmFsID0+IHB4Um91bmQodmFsVG9Qb3NZKHZhbCwgc2NhbGVZLCB5RGltLCB5T2ZmKSk7XG5cblx0XHRcdGxldCBsaW5lVG8gPSBzY2FsZVgub3JpID09IDAgPyBsaW5lVG9IIDogbGluZVRvVjtcblxuXHRcdFx0Y29uc3QgX3BhdGhzID0ge3N0cm9rZTogbmV3IFBhdGgyRCgpLCBmaWxsOiBudWxsLCBjbGlwOiBudWxsLCBiYW5kOiBudWxsLCBnYXBzOiBudWxsLCBmbGFnczogQkFORF9DTElQX0ZJTEx9O1xuXHRcdFx0Y29uc3Qgc3Ryb2tlID0gX3BhdGhzLnN0cm9rZTtcblxuXHRcdFx0Y29uc3QgZGlyID0gc2NhbGVYLmRpciAqIChzY2FsZVgub3JpID09IDAgPyAxIDogLTEpO1xuXG5cdFx0XHRpZHgwID0gbm9uTnVsbElkeChkYXRhWSwgaWR4MCwgaWR4MSwgIDEpO1xuXHRcdFx0aWR4MSA9IG5vbk51bGxJZHgoZGF0YVksIGlkeDAsIGlkeDEsIC0xKTtcblxuXHRcdFx0bGV0IHByZXZZUG9zICA9IHBpeGVsRm9yWShkYXRhWVtkaXIgPT0gMSA/IGlkeDAgOiBpZHgxXSk7XG5cdFx0XHRsZXQgZmlyc3RYUG9zID0gcGl4ZWxGb3JYKGRhdGFYW2RpciA9PSAxID8gaWR4MCA6IGlkeDFdKTtcblx0XHRcdGxldCBwcmV2WFBvcyA9IGZpcnN0WFBvcztcblxuXHRcdFx0bGluZVRvKHN0cm9rZSwgZmlyc3RYUG9zLCBwcmV2WVBvcyk7XG5cblx0XHRcdGZvciAobGV0IGkgPSBkaXIgPT0gMSA/IGlkeDAgOiBpZHgxOyBpID49IGlkeDAgJiYgaSA8PSBpZHgxOyBpICs9IGRpcikge1xuXHRcdFx0XHRsZXQgeVZhbDEgPSBkYXRhWVtpXTtcblxuXHRcdFx0XHRpZiAoeVZhbDEgPT0gbnVsbClcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRsZXQgeDEgPSBwaXhlbEZvclgoZGF0YVhbaV0pO1xuXHRcdFx0XHRsZXQgeTEgPSBwaXhlbEZvclkoeVZhbDEpO1xuXG5cdFx0XHRcdGlmIChhbGlnbiA9PSAxKVxuXHRcdFx0XHRcdGxpbmVUbyhzdHJva2UsIHgxLCBwcmV2WVBvcyk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRsaW5lVG8oc3Ryb2tlLCBwcmV2WFBvcywgeTEpO1xuXG5cdFx0XHRcdGxpbmVUbyhzdHJva2UsIHgxLCB5MSk7XG5cblx0XHRcdFx0cHJldllQb3MgPSB5MTtcblx0XHRcdFx0cHJldlhQb3MgPSB4MTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IFsgYmFuZEZpbGxEaXIsIGJhbmRDbGlwRGlyIF0gPSBiYW5kRmlsbENsaXBEaXJzKHUsIHNlcmllc0lkeCk7XG5cblx0XHRcdGlmIChzZXJpZXMuZmlsbCAhPSBudWxsIHx8IGJhbmRGaWxsRGlyICE9IDApIHtcblx0XHRcdFx0bGV0IGZpbGwgPSBfcGF0aHMuZmlsbCA9IG5ldyBQYXRoMkQoc3Ryb2tlKTtcblxuXHRcdFx0XHRsZXQgZmlsbFRvID0gc2VyaWVzLmZpbGxUbyh1LCBzZXJpZXNJZHgsIHNlcmllcy5taW4sIHNlcmllcy5tYXgsIGJhbmRGaWxsRGlyKTtcblx0XHRcdFx0bGV0IGZpbGxUb1kgPSBwaXhlbEZvclkoZmlsbFRvKTtcblxuXHRcdFx0XHRsaW5lVG8oZmlsbCwgcHJldlhQb3MsIGZpbGxUb1kpO1xuXHRcdFx0XHRsaW5lVG8oZmlsbCwgZmlyc3RYUG9zLCBmaWxsVG9ZKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFzZXJpZXMuc3BhbkdhcHMpIHtcblx0XHRcdC8vXHRjb25zb2xlLnRpbWUoJ2dhcHMnKTtcblx0XHRcdFx0bGV0IGdhcHMgPSBbXTtcblxuXHRcdFx0XHRnYXBzLnB1c2goLi4uZmluZEdhcHMoZGF0YVgsIGRhdGFZLCBpZHgwLCBpZHgxLCBkaXIsIHBpeGVsRm9yWCwgYWxpZ25HYXBzKSk7XG5cblx0XHRcdC8vXHRjb25zb2xlLnRpbWVFbmQoJ2dhcHMnKTtcblxuXHRcdFx0Ly9cdGNvbnNvbGUubG9nKCdnYXBzJywgSlNPTi5zdHJpbmdpZnkoZ2FwcykpO1xuXG5cdFx0XHRcdC8vIGV4cGFuZC9jb250cmFjdCBjbGlwcyBmb3IgYXNjZW5kZXJzL2Rlc2NlbmRlcnNcblx0XHRcdFx0bGV0IGhhbGZTdHJva2UgPSAoc2VyaWVzLndpZHRoICogcHhSYXRpbykgLyAyO1xuXHRcdFx0XHRsZXQgc3RhcnRzT2Zmc2V0ID0gKGFzY0Rlc2MgfHwgYWxpZ24gPT0gIDEpID8gIGhhbGZTdHJva2UgOiAtaGFsZlN0cm9rZTtcblx0XHRcdFx0bGV0IGVuZHNPZmZzZXQgICA9IChhc2NEZXNjIHx8IGFsaWduID09IC0xKSA/IC1oYWxmU3Ryb2tlIDogIGhhbGZTdHJva2U7XG5cblx0XHRcdFx0Z2Fwcy5mb3JFYWNoKGcgPT4ge1xuXHRcdFx0XHRcdGdbMF0gKz0gc3RhcnRzT2Zmc2V0O1xuXHRcdFx0XHRcdGdbMV0gKz0gZW5kc09mZnNldDtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0X3BhdGhzLmdhcHMgPSBnYXBzID0gc2VyaWVzLmdhcHModSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBnYXBzKTtcblxuXHRcdFx0XHRfcGF0aHMuY2xpcCA9IGNsaXBHYXBzKGdhcHMsIHNjYWxlWC5vcmksIHhPZmYsIHlPZmYsIHhEaW0sIHlEaW0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYmFuZENsaXBEaXIgIT0gMCkge1xuXHRcdFx0XHRfcGF0aHMuYmFuZCA9IGJhbmRDbGlwRGlyID09IDIgPyBbXG5cdFx0XHRcdFx0Y2xpcEJhbmRMaW5lKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSwgc3Ryb2tlLCAtMSksXG5cdFx0XHRcdFx0Y2xpcEJhbmRMaW5lKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSwgc3Ryb2tlLCAgMSksXG5cdFx0XHRcdF0gOiBjbGlwQmFuZExpbmUodSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBzdHJva2UsIGJhbmRDbGlwRGlyKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIF9wYXRocztcblx0XHR9KTtcblx0fTtcbn1cblxuZnVuY3Rpb24gYmFycyhvcHRzKSB7XG5cdG9wdHMgPSBvcHRzIHx8IEVNUFRZX09CSjtcblx0Y29uc3Qgc2l6ZSA9IGlmTnVsbChvcHRzLnNpemUsIFswLjYsIGluZiwgMV0pO1xuXHRjb25zdCBhbGlnbiA9IG9wdHMuYWxpZ24gfHwgMDtcblx0Y29uc3QgZXh0cmFHYXAgPSAob3B0cy5nYXAgfHwgMCkgKiBweFJhdGlvO1xuXG5cdGNvbnN0IHJhZGl1cyA9IGlmTnVsbChvcHRzLnJhZGl1cywgMCk7XG5cblx0Y29uc3QgZ2FwRmFjdG9yID0gMSAtIHNpemVbMF07XG5cdGNvbnN0IG1heFdpZHRoICA9IGlmTnVsbChzaXplWzFdLCBpbmYpICogcHhSYXRpbztcblx0Y29uc3QgbWluV2lkdGggID0gaWZOdWxsKHNpemVbMl0sIDEpICogcHhSYXRpbztcblxuXHRjb25zdCBkaXNwID0gaWZOdWxsKG9wdHMuZGlzcCwgRU1QVFlfT0JKKTtcblx0Y29uc3QgX2VhY2ggPSBpZk51bGwob3B0cy5lYWNoLCBfID0+IHt9KTtcblxuXHRjb25zdCB7IGZpbGw6IGRpc3BGaWxscywgc3Ryb2tlOiBkaXNwU3Ryb2tlcyB9ID0gZGlzcDtcblxuXHRyZXR1cm4gKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSkgPT4ge1xuXHRcdHJldHVybiBvcmllbnQodSwgc2VyaWVzSWR4LCAoc2VyaWVzLCBkYXRhWCwgZGF0YVksIHNjYWxlWCwgc2NhbGVZLCB2YWxUb1Bvc1gsIHZhbFRvUG9zWSwgeE9mZiwgeU9mZiwgeERpbSwgeURpbSkgPT4ge1xuXHRcdFx0bGV0IHB4Um91bmQgPSBzZXJpZXMucHhSb3VuZDtcblxuXHRcdFx0Y29uc3QgX2RpclggPSBzY2FsZVguZGlyICogKHNjYWxlWC5vcmkgPT0gMCA/IDEgOiAtMSk7XG5cdFx0XHRjb25zdCBfZGlyWSA9IHNjYWxlWS5kaXIgKiAoc2NhbGVZLm9yaSA9PSAxID8gMSA6IC0xKTtcblxuXHRcdFx0bGV0IHJlY3QgPSBzY2FsZVgub3JpID09IDAgPyByZWN0SCA6IHJlY3RWO1xuXG5cdFx0XHRsZXQgZWFjaCA9IHNjYWxlWC5vcmkgPT0gMCA/IF9lYWNoIDogKHUsIHNlcmllc0lkeCwgaSwgdG9wLCBsZnQsIGhndCwgd2lkKSA9PiB7XG5cdFx0XHRcdF9lYWNoKHUsIHNlcmllc0lkeCwgaSwgbGZ0LCB0b3AsIHdpZCwgaGd0KTtcblx0XHRcdH07XG5cblx0XHRcdGxldCBbIGJhbmRGaWxsRGlyLCBiYW5kQ2xpcERpciBdID0gYmFuZEZpbGxDbGlwRGlycyh1LCBzZXJpZXNJZHgpO1xuXG5cdFx0Ly9cdGxldCBmaWxsVG9ZID0gc2VyaWVzLmZpbGxUbyh1LCBzZXJpZXNJZHgsIHNlcmllcy5taW4sIHNlcmllcy5tYXgsIGJhbmRGaWxsRGlyKTtcblx0XHRcdGxldCBmaWxsVG9ZID0gc2NhbGVZLmRpc3RyID09IDMgPyAoYmFuZEZpbGxEaXIgPT0gMSA/IHNjYWxlWS5tYXggOiBzY2FsZVkubWluKSA6IDA7XG5cblx0XHRcdGxldCB5MFBvcyA9IHZhbFRvUG9zWShmaWxsVG9ZLCBzY2FsZVksIHlEaW0sIHlPZmYpO1xuXG5cdFx0XHQvLyBiYXJXaWQgaXMgdG8gY2VudGVyIG9mIHN0cm9rZVxuXHRcdFx0bGV0IHhTaGlmdCwgYmFyV2lkO1xuXG5cdFx0XHRsZXQgc3Ryb2tlV2lkdGggPSBweFJvdW5kKHNlcmllcy53aWR0aCAqIHB4UmF0aW8pO1xuXG5cdFx0XHRsZXQgbXVsdGlQYXRoID0gZmFsc2U7XG5cblx0XHRcdGxldCBmaWxsQ29sb3JzID0gbnVsbDtcblx0XHRcdGxldCBmaWxsUGF0aHMgPSBudWxsO1xuXHRcdFx0bGV0IHN0cm9rZUNvbG9ycyA9IG51bGw7XG5cdFx0XHRsZXQgc3Ryb2tlUGF0aHMgPSBudWxsO1xuXG5cdFx0XHRpZiAoZGlzcEZpbGxzICE9IG51bGwgJiYgKHN0cm9rZVdpZHRoID09IDAgfHwgZGlzcFN0cm9rZXMgIT0gbnVsbCkpIHtcblx0XHRcdFx0bXVsdGlQYXRoID0gdHJ1ZTtcblxuXHRcdFx0XHRmaWxsQ29sb3JzID0gZGlzcEZpbGxzLnZhbHVlcyh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEpO1xuXHRcdFx0XHRmaWxsUGF0aHMgPSBuZXcgTWFwKCk7XG5cdFx0XHRcdChuZXcgU2V0KGZpbGxDb2xvcnMpKS5mb3JFYWNoKGNvbG9yID0+IHtcblx0XHRcdFx0XHRpZiAoY29sb3IgIT0gbnVsbClcblx0XHRcdFx0XHRcdGZpbGxQYXRocy5zZXQoY29sb3IsIG5ldyBQYXRoMkQoKSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChzdHJva2VXaWR0aCA+IDApIHtcblx0XHRcdFx0XHRzdHJva2VDb2xvcnMgPSBkaXNwU3Ryb2tlcy52YWx1ZXModSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxKTtcblx0XHRcdFx0XHRzdHJva2VQYXRocyA9IG5ldyBNYXAoKTtcblx0XHRcdFx0XHQobmV3IFNldChzdHJva2VDb2xvcnMpKS5mb3JFYWNoKGNvbG9yID0+IHtcblx0XHRcdFx0XHRcdGlmIChjb2xvciAhPSBudWxsKVxuXHRcdFx0XHRcdFx0XHRzdHJva2VQYXRocy5zZXQoY29sb3IsIG5ldyBQYXRoMkQoKSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bGV0IHsgeDAsIHNpemUgfSA9IGRpc3A7XG5cblx0XHRcdGlmICh4MCAhPSBudWxsICYmIHNpemUgIT0gbnVsbCkge1xuXHRcdFx0XHRkYXRhWCA9IHgwLnZhbHVlcyh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEpO1xuXG5cdFx0XHRcdGlmICh4MC51bml0ID09IDIpXG5cdFx0XHRcdFx0ZGF0YVggPSBkYXRhWC5tYXAocGN0ID0+IHUucG9zVG9WYWwoeE9mZiArIHBjdCAqIHhEaW0sIHNjYWxlWC5rZXksIHRydWUpKTtcblxuXHRcdFx0XHQvLyBhc3N1bWVzIHVuaWZvcm0gc2l6ZXMsIGZvciBub3dcblx0XHRcdFx0bGV0IHNpemVzID0gc2l6ZS52YWx1ZXModSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxKTtcblxuXHRcdFx0XHRpZiAoc2l6ZS51bml0ID09IDIpXG5cdFx0XHRcdFx0YmFyV2lkID0gc2l6ZXNbMF0gKiB4RGltO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0YmFyV2lkID0gdmFsVG9Qb3NYKHNpemVzWzBdLCBzY2FsZVgsIHhEaW0sIHhPZmYpIC0gdmFsVG9Qb3NYKDAsIHNjYWxlWCwgeERpbSwgeE9mZik7IC8vIGFzc3VtZXMgbGluZWFyIHNjYWxlIChkZWx0YSBmcm9tIDApXG5cblx0XHRcdFx0YmFyV2lkID0gcHhSb3VuZChiYXJXaWQgLSBzdHJva2VXaWR0aCk7XG5cblx0XHRcdFx0eFNoaWZ0ID0gKF9kaXJYID09IDEgPyAtc3Ryb2tlV2lkdGggLyAyIDogYmFyV2lkICsgc3Ryb2tlV2lkdGggLyAyKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsZXQgY29sV2lkID0geERpbTtcblxuXHRcdFx0XHRpZiAoZGF0YVgubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdC8vIHByaW9yIGluZGV4IHdpdGggbm9uLXVuZGVmaW5lZCB5IGRhdGFcblx0XHRcdFx0XHRsZXQgcHJldklkeCA9IG51bGw7XG5cblx0XHRcdFx0XHQvLyBzY2FuIGZ1bGwgZGF0YXNldCBmb3Igc21hbGxlc3QgYWRqYWNlbnQgZGVsdGFcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCB3b3JrIHByb3Blcmx5IGZvciBub24tbGluZWFyIHggc2NhbGVzLCBzaW5jZSBkb2VzIG5vdCBkbyBleHBlbnNpdmUgdmFsVG9Qb3NYIGNhbGNzIHRpbGwgZW5kXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIG1pbkRlbHRhID0gSW5maW5pdHk7IGkgPCBkYXRhWC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKGRhdGFZW2ldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHByZXZJZHggIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBkZWx0YSA9IGFicyhkYXRhWFtpXSAtIGRhdGFYW3ByZXZJZHhdKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChkZWx0YSA8IG1pbkRlbHRhKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtaW5EZWx0YSA9IGRlbHRhO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29sV2lkID0gYWJzKHZhbFRvUG9zWChkYXRhWFtpXSwgc2NhbGVYLCB4RGltLCB4T2ZmKSAtIHZhbFRvUG9zWChkYXRhWFtwcmV2SWR4XSwgc2NhbGVYLCB4RGltLCB4T2ZmKSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0cHJldklkeCA9IGk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IGdhcFdpZCA9IGNvbFdpZCAqIGdhcEZhY3RvcjtcblxuXHRcdFx0XHRiYXJXaWQgPSBweFJvdW5kKG1pbihtYXhXaWR0aCwgbWF4KG1pbldpZHRoLCBjb2xXaWQgLSBnYXBXaWQpKSAtIHN0cm9rZVdpZHRoIC0gZXh0cmFHYXApO1xuXG5cdFx0XHRcdHhTaGlmdCA9IChhbGlnbiA9PSAwID8gYmFyV2lkIC8gMiA6IGFsaWduID09IF9kaXJYID8gMCA6IGJhcldpZCkgLSBhbGlnbiAqIF9kaXJYICogZXh0cmFHYXAgLyAyO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBfcGF0aHMgPSB7c3Ryb2tlOiBudWxsLCBmaWxsOiBudWxsLCBjbGlwOiBudWxsLCBiYW5kOiBudWxsLCBnYXBzOiBudWxsLCBmbGFnczogQkFORF9DTElQX0ZJTEwgfCBCQU5EX0NMSVBfU1RST0tFfTsgIC8vIGRpc3AsIGdlb21cblxuXHRcdFx0bGV0IHlMaW1pdDtcblxuXHRcdFx0aWYgKGJhbmRDbGlwRGlyICE9IDApIHtcblx0XHRcdFx0X3BhdGhzLmJhbmQgPSBuZXcgUGF0aDJEKCk7XG5cdFx0XHRcdHlMaW1pdCA9IHB4Um91bmQodmFsVG9Qb3NZKGJhbmRDbGlwRGlyID09IDEgPyBzY2FsZVkubWF4IDogc2NhbGVZLm1pbiwgc2NhbGVZLCB5RGltLCB5T2ZmKSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHN0cm9rZSA9IG11bHRpUGF0aCA/IG51bGwgOiBuZXcgUGF0aDJEKCk7XG5cdFx0XHRjb25zdCBiYW5kID0gX3BhdGhzLmJhbmQ7XG5cblx0XHRcdGxldCB7IHkwLCB5MSB9ID0gZGlzcDtcblxuXHRcdFx0bGV0IGRhdGFZMCA9IG51bGw7XG5cblx0XHRcdGlmICh5MCAhPSBudWxsICYmIHkxICE9IG51bGwpIHtcblx0XHRcdFx0ZGF0YVkgPSB5MS52YWx1ZXModSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxKTtcblx0XHRcdFx0ZGF0YVkwID0geTAudmFsdWVzKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAobGV0IGkgPSBfZGlyWCA9PSAxID8gaWR4MCA6IGlkeDE7IGkgPj0gaWR4MCAmJiBpIDw9IGlkeDE7IGkgKz0gX2RpclgpIHtcblx0XHRcdFx0bGV0IHlWYWwgPSBkYXRhWVtpXTtcblxuXHRcdFx0XHQvLyB3ZSBjYW4gc2tpcCBib3RoLCBkcmF3aW5nIGFuZCBiYW5kIGNsaXBwaW5nIGZvciBhbGlnbm1lbnQgYXJ0aWZhY3RzXG5cdFx0XHRcdGlmICh5VmFsID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdC8qXG5cdFx0XHRcdC8vIGludGVycG9sYXRlIHVwd2FyZHMgYmFuZCBjbGlwc1xuXHRcdFx0XHRpZiAoeVZhbCA9PSBudWxsKSB7XG5cdFx0XHRcdC8vXHRpZiAoaGFzQmFuZHMpXG5cdFx0XHRcdC8vXHRcdHlWYWwgPSBjb3N0bHlMZXJwKGksIGlkeDAsIGlkeDEsIF9kaXJYLCBkYXRhWSk7XG5cdFx0XHRcdC8vXHRlbHNlXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0Ki9cblxuXHRcdFx0XHRsZXQgeFZhbCA9IHNjYWxlWC5kaXN0ciAhPSAyIHx8IGRpc3AgIT0gbnVsbCA/IGRhdGFYW2ldIDogaTtcblxuXHRcdFx0XHQvLyBUT0RPOiBhbGwgeFBvcyBjYW4gYmUgcHJlLWNvbXB1dGVkIG9uY2UgZm9yIGFsbCBzZXJpZXMgaW4gYWxpZ25lZCBzZXRcblx0XHRcdFx0bGV0IHhQb3MgPSB2YWxUb1Bvc1goeFZhbCwgc2NhbGVYLCB4RGltLCB4T2ZmKTtcblx0XHRcdFx0bGV0IHlQb3MgPSB2YWxUb1Bvc1koaWZOdWxsKHlWYWwsIGZpbGxUb1kpLCBzY2FsZVksIHlEaW0sIHlPZmYpO1xuXG5cdFx0XHRcdGlmIChkYXRhWTAgIT0gbnVsbCAmJiB5VmFsICE9IG51bGwpXG5cdFx0XHRcdFx0eTBQb3MgPSB2YWxUb1Bvc1koZGF0YVkwW2ldLCBzY2FsZVksIHlEaW0sIHlPZmYpO1xuXG5cdFx0XHRcdGxldCBsZnQgPSBweFJvdW5kKHhQb3MgLSB4U2hpZnQpO1xuXHRcdFx0XHRsZXQgYnRtID0gcHhSb3VuZChtYXgoeVBvcywgeTBQb3MpKTtcblx0XHRcdFx0bGV0IHRvcCA9IHB4Um91bmQobWluKHlQb3MsIHkwUG9zKSk7XG5cdFx0XHRcdC8vIHRoaXMgaW5jbHVkZXMgdGhlIHN0cm9rZVxuXHRcdFx0XHRsZXQgYmFySGd0ID0gYnRtIC0gdG9wO1xuXG5cdFx0XHRcdGxldCByID0gcmFkaXVzICogYmFyV2lkO1xuXG5cdFx0XHRcdGlmICh5VmFsICE9IG51bGwpIHsgIC8vICYmIHlWYWwgIT0gZmlsbFRvWSAoMCBoZWlnaHQgYmFyKVxuXHRcdFx0XHRcdGlmIChtdWx0aVBhdGgpIHtcblx0XHRcdFx0XHRcdGlmIChzdHJva2VXaWR0aCA+IDAgJiYgc3Ryb2tlQ29sb3JzW2ldICE9IG51bGwpXG5cdFx0XHRcdFx0XHRcdHJlY3Qoc3Ryb2tlUGF0aHMuZ2V0KHN0cm9rZUNvbG9yc1tpXSksIGxmdCwgdG9wICsgZmxvb3Ioc3Ryb2tlV2lkdGggLyAyKSwgYmFyV2lkLCBtYXgoMCwgYmFySGd0IC0gc3Ryb2tlV2lkdGgpLCByKTtcblxuXHRcdFx0XHRcdFx0aWYgKGZpbGxDb2xvcnNbaV0gIT0gbnVsbClcblx0XHRcdFx0XHRcdFx0cmVjdChmaWxsUGF0aHMuZ2V0KGZpbGxDb2xvcnNbaV0pLCBsZnQsIHRvcCArIGZsb29yKHN0cm9rZVdpZHRoIC8gMiksIGJhcldpZCwgbWF4KDAsIGJhckhndCAtIHN0cm9rZVdpZHRoKSwgcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHJlY3Qoc3Ryb2tlLCBsZnQsIHRvcCArIGZsb29yKHN0cm9rZVdpZHRoIC8gMiksIGJhcldpZCwgbWF4KDAsIGJhckhndCAtIHN0cm9rZVdpZHRoKSwgcik7XG5cblx0XHRcdFx0XHRlYWNoKHUsIHNlcmllc0lkeCwgaSxcblx0XHRcdFx0XHRcdGxmdCAgICAtIHN0cm9rZVdpZHRoIC8gMixcblx0XHRcdFx0XHRcdHRvcCxcblx0XHRcdFx0XHRcdGJhcldpZCArIHN0cm9rZVdpZHRoLFxuXHRcdFx0XHRcdFx0YmFySGd0LFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYmFuZENsaXBEaXIgIT0gMCkge1xuXHRcdFx0XHRcdGlmIChfZGlyWSAqIGJhbmRDbGlwRGlyID09IDEpIHtcblx0XHRcdFx0XHRcdGJ0bSA9IHRvcDtcblx0XHRcdFx0XHRcdHRvcCA9IHlMaW1pdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR0b3AgPSBidG07XG5cdFx0XHRcdFx0XHRidG0gPSB5TGltaXQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YmFySGd0ID0gYnRtIC0gdG9wO1xuXG5cdFx0XHRcdFx0cmVjdChiYW5kLCBsZnQgLSBzdHJva2VXaWR0aCAvIDIsIHRvcCwgYmFyV2lkICsgc3Ryb2tlV2lkdGgsIG1heCgwLCBiYXJIZ3QpLCAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc3Ryb2tlV2lkdGggPiAwKVxuXHRcdFx0XHRfcGF0aHMuc3Ryb2tlID0gbXVsdGlQYXRoID8gc3Ryb2tlUGF0aHMgOiBzdHJva2U7XG5cblx0XHRcdF9wYXRocy5maWxsID0gbXVsdGlQYXRoID8gZmlsbFBhdGhzIDogc3Ryb2tlO1xuXG5cdFx0XHRyZXR1cm4gX3BhdGhzO1xuXHRcdH0pO1xuXHR9O1xufVxuXG5mdW5jdGlvbiBzcGxpbmVJbnRlcnAoaW50ZXJwLCBvcHRzKSB7XG5cdGNvbnN0IGFsaWduR2FwcyA9IGlmTnVsbChvcHRzPy5hbGlnbkdhcHMsIDApO1xuXG5cdHJldHVybiAodSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxKSA9PiB7XG5cdFx0cmV0dXJuIG9yaWVudCh1LCBzZXJpZXNJZHgsIChzZXJpZXMsIGRhdGFYLCBkYXRhWSwgc2NhbGVYLCBzY2FsZVksIHZhbFRvUG9zWCwgdmFsVG9Qb3NZLCB4T2ZmLCB5T2ZmLCB4RGltLCB5RGltKSA9PiB7XG5cdFx0XHRsZXQgcHhSb3VuZCA9IHNlcmllcy5weFJvdW5kO1xuXG5cdFx0XHRsZXQgcGl4ZWxGb3JYID0gdmFsID0+IHB4Um91bmQodmFsVG9Qb3NYKHZhbCwgc2NhbGVYLCB4RGltLCB4T2ZmKSk7XG5cdFx0XHRsZXQgcGl4ZWxGb3JZID0gdmFsID0+IHB4Um91bmQodmFsVG9Qb3NZKHZhbCwgc2NhbGVZLCB5RGltLCB5T2ZmKSk7XG5cblx0XHRcdGxldCBtb3ZlVG8sIGJlemllckN1cnZlVG8sIGxpbmVUbztcblxuXHRcdFx0aWYgKHNjYWxlWC5vcmkgPT0gMCkge1xuXHRcdFx0XHRtb3ZlVG8gPSBtb3ZlVG9IO1xuXHRcdFx0XHRsaW5lVG8gPSBsaW5lVG9IO1xuXHRcdFx0XHRiZXppZXJDdXJ2ZVRvID0gYmV6aWVyQ3VydmVUb0g7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bW92ZVRvID0gbW92ZVRvVjtcblx0XHRcdFx0bGluZVRvID0gbGluZVRvVjtcblx0XHRcdFx0YmV6aWVyQ3VydmVUbyA9IGJlemllckN1cnZlVG9WO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkaXIgPSBzY2FsZVguZGlyICogKHNjYWxlWC5vcmkgPT0gMCA/IDEgOiAtMSk7XG5cblx0XHRcdGlkeDAgPSBub25OdWxsSWR4KGRhdGFZLCBpZHgwLCBpZHgxLCAgMSk7XG5cdFx0XHRpZHgxID0gbm9uTnVsbElkeChkYXRhWSwgaWR4MCwgaWR4MSwgLTEpO1xuXG5cdFx0XHRsZXQgZmlyc3RYUG9zID0gcGl4ZWxGb3JYKGRhdGFYW2RpciA9PSAxID8gaWR4MCA6IGlkeDFdKTtcblx0XHRcdGxldCBwcmV2WFBvcyA9IGZpcnN0WFBvcztcblxuXHRcdFx0bGV0IHhDb29yZHMgPSBbXTtcblx0XHRcdGxldCB5Q29vcmRzID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSBkaXIgPT0gMSA/IGlkeDAgOiBpZHgxOyBpID49IGlkeDAgJiYgaSA8PSBpZHgxOyBpICs9IGRpcikge1xuXHRcdFx0XHRsZXQgeVZhbCA9IGRhdGFZW2ldO1xuXG5cdFx0XHRcdGlmICh5VmFsICE9IG51bGwpIHtcblx0XHRcdFx0XHRsZXQgeFZhbCA9IGRhdGFYW2ldO1xuXHRcdFx0XHRcdGxldCB4UG9zID0gcGl4ZWxGb3JYKHhWYWwpO1xuXG5cdFx0XHRcdFx0eENvb3Jkcy5wdXNoKHByZXZYUG9zID0geFBvcyk7XG5cdFx0XHRcdFx0eUNvb3Jkcy5wdXNoKHBpeGVsRm9yWShkYXRhWVtpXSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IF9wYXRocyA9IHtzdHJva2U6IGludGVycCh4Q29vcmRzLCB5Q29vcmRzLCBtb3ZlVG8sIGxpbmVUbywgYmV6aWVyQ3VydmVUbywgcHhSb3VuZCksIGZpbGw6IG51bGwsIGNsaXA6IG51bGwsIGJhbmQ6IG51bGwsIGdhcHM6IG51bGwsIGZsYWdzOiBCQU5EX0NMSVBfRklMTH07XG5cdFx0XHRjb25zdCBzdHJva2UgPSBfcGF0aHMuc3Ryb2tlO1xuXG5cdFx0XHRsZXQgWyBiYW5kRmlsbERpciwgYmFuZENsaXBEaXIgXSA9IGJhbmRGaWxsQ2xpcERpcnModSwgc2VyaWVzSWR4KTtcblxuXHRcdFx0aWYgKHNlcmllcy5maWxsICE9IG51bGwgfHwgYmFuZEZpbGxEaXIgIT0gMCkge1xuXHRcdFx0XHRsZXQgZmlsbCA9IF9wYXRocy5maWxsID0gbmV3IFBhdGgyRChzdHJva2UpO1xuXG5cdFx0XHRcdGxldCBmaWxsVG8gPSBzZXJpZXMuZmlsbFRvKHUsIHNlcmllc0lkeCwgc2VyaWVzLm1pbiwgc2VyaWVzLm1heCwgYmFuZEZpbGxEaXIpO1xuXHRcdFx0XHRsZXQgZmlsbFRvWSA9IHBpeGVsRm9yWShmaWxsVG8pO1xuXG5cdFx0XHRcdGxpbmVUbyhmaWxsLCBwcmV2WFBvcywgZmlsbFRvWSk7XG5cdFx0XHRcdGxpbmVUbyhmaWxsLCBmaXJzdFhQb3MsIGZpbGxUb1kpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXNlcmllcy5zcGFuR2Fwcykge1xuXHRcdFx0Ly9cdGNvbnNvbGUudGltZSgnZ2FwcycpO1xuXHRcdFx0XHRsZXQgZ2FwcyA9IFtdO1xuXG5cdFx0XHRcdGdhcHMucHVzaCguLi5maW5kR2FwcyhkYXRhWCwgZGF0YVksIGlkeDAsIGlkeDEsIGRpciwgcGl4ZWxGb3JYLCBhbGlnbkdhcHMpKTtcblxuXHRcdFx0Ly9cdGNvbnNvbGUudGltZUVuZCgnZ2FwcycpO1xuXG5cdFx0XHQvL1x0Y29uc29sZS5sb2coJ2dhcHMnLCBKU09OLnN0cmluZ2lmeShnYXBzKSk7XG5cblx0XHRcdFx0X3BhdGhzLmdhcHMgPSBnYXBzID0gc2VyaWVzLmdhcHModSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBnYXBzKTtcblxuXHRcdFx0XHRfcGF0aHMuY2xpcCA9IGNsaXBHYXBzKGdhcHMsIHNjYWxlWC5vcmksIHhPZmYsIHlPZmYsIHhEaW0sIHlEaW0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYmFuZENsaXBEaXIgIT0gMCkge1xuXHRcdFx0XHRfcGF0aHMuYmFuZCA9IGJhbmRDbGlwRGlyID09IDIgPyBbXG5cdFx0XHRcdFx0Y2xpcEJhbmRMaW5lKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSwgc3Ryb2tlLCAtMSksXG5cdFx0XHRcdFx0Y2xpcEJhbmRMaW5lKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSwgc3Ryb2tlLCAgMSksXG5cdFx0XHRcdF0gOiBjbGlwQmFuZExpbmUodSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBzdHJva2UsIGJhbmRDbGlwRGlyKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIF9wYXRocztcblxuXHRcdFx0Ly8gIGlmIEZFQVRfUEFUSFM6IGZhbHNlIGluIHJvbGx1cC5jb25maWcuanNcblx0XHRcdC8vXHR1LmN0eC5zYXZlKCk7XG5cdFx0XHQvL1x0dS5jdHguYmVnaW5QYXRoKCk7XG5cdFx0XHQvL1x0dS5jdHgucmVjdCh1LmJib3gubGVmdCwgdS5iYm94LnRvcCwgdS5iYm94LndpZHRoLCB1LmJib3guaGVpZ2h0KTtcblx0XHRcdC8vXHR1LmN0eC5jbGlwKCk7XG5cdFx0XHQvL1x0dS5jdHguc3Ryb2tlU3R5bGUgPSB1LnNlcmllc1tzaWR4XS5zdHJva2U7XG5cdFx0XHQvL1x0dS5jdHguc3Ryb2tlKHN0cm9rZSk7XG5cdFx0XHQvL1x0dS5jdHguZmlsbFN0eWxlID0gdS5zZXJpZXNbc2lkeF0uZmlsbDtcblx0XHRcdC8vXHR1LmN0eC5maWxsKGZpbGwpO1xuXHRcdFx0Ly9cdHUuY3R4LnJlc3RvcmUoKTtcblx0XHRcdC8vXHRyZXR1cm4gbnVsbDtcblx0XHR9KTtcblx0fTtcbn1cblxuZnVuY3Rpb24gbW9ub3RvbmVDdWJpYyhvcHRzKSB7XG5cdHJldHVybiBzcGxpbmVJbnRlcnAoX21vbm90b25lQ3ViaWMsIG9wdHMpO1xufVxuXG4vLyBNb25vdG9uZSBDdWJpYyBTcGxpbmUgaW50ZXJwb2xhdGlvbiwgYWRhcHRlZCBmcm9tIHRoZSBDaGFydGlzdC5qcyBpbXBsZW1lbnRhdGlvbjpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naW9ua3Vuei9jaGFydGlzdC1qcy9ibG9iL2U3ZTc4MjAxYmZmZTk2MDk5MTVlNWU1M2NmYWZhMjlhNWQ2YzQ5Zjkvc3JjL3NjcmlwdHMvaW50ZXJwb2xhdGlvbi5qcyNMMjQwLUwzNjlcbmZ1bmN0aW9uIF9tb25vdG9uZUN1YmljKHhzLCB5cywgbW92ZVRvLCBsaW5lVG8sIGJlemllckN1cnZlVG8sIHB4Um91bmQpIHtcblx0Y29uc3QgbiA9IHhzLmxlbmd0aDtcblxuXHRpZiAobiA8IDIpXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0Y29uc3QgcGF0aCA9IG5ldyBQYXRoMkQoKTtcblxuXHRtb3ZlVG8ocGF0aCwgeHNbMF0sIHlzWzBdKTtcblxuXHRpZiAobiA9PSAyKVxuXHRcdGxpbmVUbyhwYXRoLCB4c1sxXSwgeXNbMV0pO1xuXHRlbHNlIHtcblx0XHRsZXQgbXMgID0gQXJyYXkobiksXG5cdFx0XHRkcyAgPSBBcnJheShuIC0gMSksXG5cdFx0XHRkeXMgPSBBcnJheShuIC0gMSksXG5cdFx0XHRkeHMgPSBBcnJheShuIC0gMSk7XG5cblx0XHQvLyBjYWxjIGRlbHRhcyBhbmQgZGVyaXZhdGl2ZVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xuXHRcdFx0ZHlzW2ldID0geXNbaSArIDFdIC0geXNbaV07XG5cdFx0XHRkeHNbaV0gPSB4c1tpICsgMV0gLSB4c1tpXTtcblx0XHRcdGRzW2ldICA9IGR5c1tpXSAvIGR4c1tpXTtcblx0XHR9XG5cblx0XHQvLyBkZXRlcm1pbmUgZGVzaXJlZCBzbG9wZSAobSkgYXQgZWFjaCBwb2ludCB1c2luZyBGcml0c2NoLUNhcmxzb24gbWV0aG9kXG5cdFx0Ly8gaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzQ1MjE4L2ltcGxlbWVudGF0aW9uLW9mLW1vbm90b25lLWN1YmljLWludGVycG9sYXRpb25cblx0XHRtc1swXSA9IGRzWzBdO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBuIC0gMTsgaSsrKSB7XG5cdFx0XHRpZiAoZHNbaV0gPT09IDAgfHwgZHNbaSAtIDFdID09PSAwIHx8IChkc1tpIC0gMV0gPiAwKSAhPT0gKGRzW2ldID4gMCkpXG5cdFx0XHRcdG1zW2ldID0gMDtcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRtc1tpXSA9IDMgKiAoZHhzW2kgLSAxXSArIGR4c1tpXSkgLyAoXG5cdFx0XHRcdFx0KDIgKiBkeHNbaV0gKyBkeHNbaSAtIDFdKSAvIGRzW2kgLSAxXSArXG5cdFx0XHRcdFx0KGR4c1tpXSArIDIgKiBkeHNbaSAtIDFdKSAvIGRzW2ldXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKCFpc0Zpbml0ZShtc1tpXSkpXG5cdFx0XHRcdFx0bXNbaV0gPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1zW24gLSAxXSA9IGRzW24gLSAyXTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xuXHRcdFx0YmV6aWVyQ3VydmVUbyhcblx0XHRcdFx0cGF0aCxcblx0XHRcdFx0eHNbaV0gKyBkeHNbaV0gLyAzLFxuXHRcdFx0XHR5c1tpXSArIG1zW2ldICogZHhzW2ldIC8gMyxcblx0XHRcdFx0eHNbaSArIDFdIC0gZHhzW2ldIC8gMyxcblx0XHRcdFx0eXNbaSArIDFdIC0gbXNbaSArIDFdICogZHhzW2ldIC8gMyxcblx0XHRcdFx0eHNbaSArIDFdLFxuXHRcdFx0XHR5c1tpICsgMV0sXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBwYXRoO1xufVxuXG5jb25zdCBjdXJzb3JQbG90cyA9IG5ldyBTZXQoKTtcblxuZnVuY3Rpb24gaW52YWxpZGF0ZVJlY3RzKCkge1xuXHRjdXJzb3JQbG90cy5mb3JFYWNoKHUgPT4ge1xuXHRcdHUuc3luY1JlY3QodHJ1ZSk7XG5cdH0pO1xufVxuXG5pZiAoZG9tRW52KSB7XG5cdG9uKHJlc2l6ZSwgd2luLCBpbnZhbGlkYXRlUmVjdHMpO1xuXHRvbihzY3JvbGwsIHdpbiwgaW52YWxpZGF0ZVJlY3RzLCB0cnVlKTtcblx0b24oZHBweGNoYW5nZSwgd2luLCAoKSA9PiB7IHVQbG90LnB4UmF0aW8gPSBweFJhdGlvOyB9KTtcbn1cblxuY29uc3QgbGluZWFyUGF0aCA9IGxpbmVhcigpIDtcbmNvbnN0IHBvaW50c1BhdGggPSBwb2ludHMoKSA7XG5cbmZ1bmN0aW9uIHNldERlZmF1bHRzKGQsIHhvLCB5bywgaW5pdFkpIHtcblx0bGV0IGQyID0gaW5pdFkgPyBbZFswXSwgZFsxXV0uY29uY2F0KGQuc2xpY2UoMikpIDogW2RbMF1dLmNvbmNhdChkLnNsaWNlKDEpKTtcblx0cmV0dXJuIGQyLm1hcCgobywgaSkgPT4gc2V0RGVmYXVsdChvLCBpLCB4bywgeW8pKTtcbn1cblxuZnVuY3Rpb24gc2V0RGVmYXVsdHMyKGQsIHh5bykge1xuXHRyZXR1cm4gZC5tYXAoKG8sIGkpID0+IGkgPT0gMCA/IG51bGwgOiBhc3NpZ24oe30sIHh5bywgbykpOyAgLy8gdG9kbzogYXNzaWduKCkgd2lsbCBub3QgbWVyZ2UgZmFjZXQgYXJyYXlzXG59XG5cbmZ1bmN0aW9uIHNldERlZmF1bHQobywgaSwgeG8sIHlvKSB7XG5cdHJldHVybiBhc3NpZ24oe30sIChpID09IDAgPyB4byA6IHlvKSwgbyk7XG59XG5cbmZ1bmN0aW9uIHNuYXBOdW1YKHNlbGYsIGRhdGFNaW4sIGRhdGFNYXgpIHtcblx0cmV0dXJuIGRhdGFNaW4gPT0gbnVsbCA/IG51bGxOdWxsVHVwbGUgOiBbZGF0YU1pbiwgZGF0YU1heF07XG59XG5cbmNvbnN0IHNuYXBUaW1lWCA9IHNuYXBOdW1YO1xuXG4vLyB0aGlzIGVuc3VyZXMgdGhhdCBub24tdGVtcG9yYWwvbnVtZXJpYyB5LWF4ZXMgZ2V0IG11bHRpcGxlLXNuYXBwZWQgcGFkZGluZyBhZGRlZCBhYm92ZS9iZWxvd1xuLy8gVE9ETzogYWxzbyBhY2NvdW50IGZvciBpbmNycyB3aGVuIHNuYXBwaW5nIHRvIGVuc3VyZSB0b3Agb2YgYXhpcyBnZXRzIGEgdGljayAmIHZhbHVlXG5mdW5jdGlvbiBzbmFwTnVtWShzZWxmLCBkYXRhTWluLCBkYXRhTWF4KSB7XG5cdHJldHVybiBkYXRhTWluID09IG51bGwgPyBudWxsTnVsbFR1cGxlIDogcmFuZ2VOdW0oZGF0YU1pbiwgZGF0YU1heCwgcmFuZ2VQYWQsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBzbmFwTG9nWShzZWxmLCBkYXRhTWluLCBkYXRhTWF4LCBzY2FsZSkge1xuXHRyZXR1cm4gZGF0YU1pbiA9PSBudWxsID8gbnVsbE51bGxUdXBsZSA6IHJhbmdlTG9nKGRhdGFNaW4sIGRhdGFNYXgsIHNlbGYuc2NhbGVzW3NjYWxlXS5sb2csIGZhbHNlKTtcbn1cblxuY29uc3Qgc25hcExvZ1ggPSBzbmFwTG9nWTtcblxuZnVuY3Rpb24gc25hcEFzaW5oWShzZWxmLCBkYXRhTWluLCBkYXRhTWF4LCBzY2FsZSkge1xuXHRyZXR1cm4gZGF0YU1pbiA9PSBudWxsID8gbnVsbE51bGxUdXBsZSA6IHJhbmdlQXNpbmgoZGF0YU1pbiwgZGF0YU1heCwgc2VsZi5zY2FsZXNbc2NhbGVdLmxvZywgZmFsc2UpO1xufVxuXG5jb25zdCBzbmFwQXNpbmhYID0gc25hcEFzaW5oWTtcblxuLy8gZGltIGlzIGxvZ2ljYWwgKGdldENsaWVudEJvdW5kaW5nUmVjdCkgcGl4ZWxzLCBub3QgY2FudmFzIHBpeGVsc1xuZnVuY3Rpb24gZmluZEluY3IobWluVmFsLCBtYXhWYWwsIGluY3JzLCBkaW0sIG1pblNwYWNlKSB7XG5cdGxldCBpbnREaWdpdHMgPSBtYXgobnVtSW50RGlnaXRzKG1pblZhbCksIG51bUludERpZ2l0cyhtYXhWYWwpKTtcblxuXHRsZXQgZGVsdGEgPSBtYXhWYWwgLSBtaW5WYWw7XG5cblx0bGV0IGluY3JJZHggPSBjbG9zZXN0SWR4KChtaW5TcGFjZSAvIGRpbSkgKiBkZWx0YSwgaW5jcnMpO1xuXG5cdGRvIHtcblx0XHRsZXQgZm91bmRJbmNyID0gaW5jcnNbaW5jcklkeF07XG5cdFx0bGV0IGZvdW5kU3BhY2UgPSBkaW0gKiBmb3VuZEluY3IgLyBkZWx0YTtcblxuXHRcdGlmIChmb3VuZFNwYWNlID49IG1pblNwYWNlICYmIGludERpZ2l0cyArIChmb3VuZEluY3IgPCA1ID8gZml4ZWREZWMuZ2V0KGZvdW5kSW5jcikgOiAwKSA8PSAxNylcblx0XHRcdHJldHVybiBbZm91bmRJbmNyLCBmb3VuZFNwYWNlXTtcblx0fSB3aGlsZSAoKytpbmNySWR4IDwgaW5jcnMubGVuZ3RoKTtcblxuXHRyZXR1cm4gWzAsIDBdO1xufVxuXG5mdW5jdGlvbiBweFJhdGlvRm9udChmb250KSB7XG5cdGxldCBmb250U2l6ZSwgZm9udFNpemVDc3M7XG5cdGZvbnQgPSBmb250LnJlcGxhY2UoLyhcXGQrKXB4LywgKG0sIHAxKSA9PiAoZm9udFNpemUgPSByb3VuZCgoZm9udFNpemVDc3MgPSArcDEpICogcHhSYXRpbykpICsgJ3B4Jyk7XG5cdHJldHVybiBbZm9udCwgZm9udFNpemUsIGZvbnRTaXplQ3NzXTtcbn1cblxuZnVuY3Rpb24gc3luY0ZvbnRTaXplKGF4aXMpIHtcblx0aWYgKGF4aXMuc2hvdykge1xuXHRcdFtheGlzLmZvbnQsIGF4aXMubGFiZWxGb250XS5mb3JFYWNoKGYgPT4ge1xuXHRcdFx0bGV0IHNpemUgPSByb3VuZERlYyhmWzJdICogcHhSYXRpbywgMSk7XG5cdFx0XHRmWzBdID0gZlswXS5yZXBsYWNlKC9bMC05Ll0rcHgvLCBzaXplICsgJ3B4Jyk7XG5cdFx0XHRmWzFdID0gc2l6ZTtcblx0XHR9KTtcblx0fVxufVxuXG5mdW5jdGlvbiB1UGxvdChvcHRzLCBkYXRhLCB0aGVuKSB7XG5cdGNvbnN0IHNlbGYgPSB7XG5cdFx0bW9kZTogaWZOdWxsKG9wdHMubW9kZSwgMSksXG5cdH07XG5cblx0Y29uc3QgbW9kZSA9IHNlbGYubW9kZTtcblxuXHQvLyBUT0RPOiBjYWNoZSBkZW5vbXMgJiBtaW5zIHNjYWxlLmNhY2hlID0ge3IsIG1pbiwgfVxuXHRmdW5jdGlvbiBnZXRWYWxQY3QodmFsLCBzY2FsZSkge1xuXHRcdGxldCBfdmFsID0gKFxuXHRcdFx0c2NhbGUuZGlzdHIgPT0gMyA/IGxvZzEwKHZhbCA+IDAgPyB2YWwgOiBzY2FsZS5jbGFtcChzZWxmLCB2YWwsIHNjYWxlLm1pbiwgc2NhbGUubWF4LCBzY2FsZS5rZXkpKSA6XG5cdFx0XHRzY2FsZS5kaXN0ciA9PSA0ID8gYXNpbmgodmFsLCBzY2FsZS5hc2luaCkgOlxuXHRcdFx0dmFsXG5cdFx0KTtcblxuXHRcdHJldHVybiAoX3ZhbCAtIHNjYWxlLl9taW4pIC8gKHNjYWxlLl9tYXggLSBzY2FsZS5fbWluKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEhQb3ModmFsLCBzY2FsZSwgZGltLCBvZmYpIHtcblx0XHRsZXQgcGN0ID0gZ2V0VmFsUGN0KHZhbCwgc2NhbGUpO1xuXHRcdHJldHVybiBvZmYgKyBkaW0gKiAoc2NhbGUuZGlyID09IC0xID8gKDEgLSBwY3QpIDogcGN0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFZQb3ModmFsLCBzY2FsZSwgZGltLCBvZmYpIHtcblx0XHRsZXQgcGN0ID0gZ2V0VmFsUGN0KHZhbCwgc2NhbGUpO1xuXHRcdHJldHVybiBvZmYgKyBkaW0gKiAoc2NhbGUuZGlyID09IC0xID8gcGN0IDogKDEgLSBwY3QpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFBvcyh2YWwsIHNjYWxlLCBkaW0sIG9mZikge1xuXHRcdHJldHVybiBzY2FsZS5vcmkgPT0gMCA/IGdldEhQb3ModmFsLCBzY2FsZSwgZGltLCBvZmYpIDogZ2V0VlBvcyh2YWwsIHNjYWxlLCBkaW0sIG9mZik7XG5cdH1cblxuXHRzZWxmLnZhbFRvUG9zSCA9IGdldEhQb3M7XG5cdHNlbGYudmFsVG9Qb3NWID0gZ2V0VlBvcztcblxuXHRsZXQgcmVhZHkgPSBmYWxzZTtcblx0c2VsZi5zdGF0dXMgPSAwO1xuXG5cdGNvbnN0IHJvb3QgPSBzZWxmLnJvb3QgPSBwbGFjZURpdihVUExPVCk7XG5cblx0aWYgKG9wdHMuaWQgIT0gbnVsbClcblx0XHRyb290LmlkID0gb3B0cy5pZDtcblxuXHRhZGRDbGFzcyhyb290LCBvcHRzLmNsYXNzKTtcblxuXHRpZiAob3B0cy50aXRsZSkge1xuXHRcdGxldCB0aXRsZSA9IHBsYWNlRGl2KFRJVExFLCByb290KTtcblx0XHR0aXRsZS50ZXh0Q29udGVudCA9IG9wdHMudGl0bGU7XG5cdH1cblxuXHRjb25zdCBjYW4gPSBwbGFjZVRhZyhcImNhbnZhc1wiKTtcblx0Y29uc3QgY3R4ID0gc2VsZi5jdHggPSBjYW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuXG5cdGNvbnN0IHdyYXAgPSBwbGFjZURpdihXUkFQLCByb290KTtcblx0Y29uc3QgdW5kZXIgPSBzZWxmLnVuZGVyID0gcGxhY2VEaXYoVU5ERVIsIHdyYXApO1xuXHR3cmFwLmFwcGVuZENoaWxkKGNhbik7XG5cdGNvbnN0IG92ZXIgPSBzZWxmLm92ZXIgPSBwbGFjZURpdihPVkVSLCB3cmFwKTtcblxuXHRvcHRzID0gY29weShvcHRzKTtcblxuXHRjb25zdCBweEFsaWduID0gK2lmTnVsbChvcHRzLnB4QWxpZ24sIDEpO1xuXG5cdGNvbnN0IHB4Um91bmQgPSBweFJvdW5kR2VuKHB4QWxpZ24pO1xuXG5cdChvcHRzLnBsdWdpbnMgfHwgW10pLmZvckVhY2gocCA9PiB7XG5cdFx0aWYgKHAub3B0cylcblx0XHRcdG9wdHMgPSBwLm9wdHMoc2VsZiwgb3B0cykgfHwgb3B0cztcblx0fSk7XG5cblx0Y29uc3QgbXMgPSBvcHRzLm1zIHx8IDFlLTM7XG5cblx0Y29uc3Qgc2VyaWVzICA9IHNlbGYuc2VyaWVzID0gbW9kZSA9PSAxID9cblx0XHRzZXREZWZhdWx0cyhvcHRzLnNlcmllcyB8fCBbXSwgeFNlcmllc09wdHMsIHlTZXJpZXNPcHRzLCBmYWxzZSkgOlxuXHRcdHNldERlZmF1bHRzMihvcHRzLnNlcmllcyB8fCBbbnVsbF0sIHh5U2VyaWVzT3B0cyk7XG5cdGNvbnN0IGF4ZXMgICAgPSBzZWxmLmF4ZXMgICA9IHNldERlZmF1bHRzKG9wdHMuYXhlcyAgIHx8IFtdLCB4QXhpc09wdHMsICAgeUF4aXNPcHRzLCAgICB0cnVlKTtcblx0Y29uc3Qgc2NhbGVzICA9IHNlbGYuc2NhbGVzID0ge307XG5cdGNvbnN0IGJhbmRzICAgPSBzZWxmLmJhbmRzICA9IG9wdHMuYmFuZHMgfHwgW107XG5cblx0YmFuZHMuZm9yRWFjaChiID0+IHtcblx0XHRiLmZpbGwgPSBmbk9yU2VsZihiLmZpbGwgfHwgbnVsbCk7XG5cdFx0Yi5kaXIgPSBpZk51bGwoYi5kaXIsIC0xKTtcblx0fSk7XG5cblx0Y29uc3QgeFNjYWxlS2V5ID0gbW9kZSA9PSAyID8gc2VyaWVzWzFdLmZhY2V0c1swXS5zY2FsZSA6IHNlcmllc1swXS5zY2FsZTtcblxuXHRjb25zdCBkcmF3T3JkZXJNYXAgPSB7XG5cdFx0YXhlczogZHJhd0F4ZXNHcmlkLFxuXHRcdHNlcmllczogZHJhd1Nlcmllcyxcblx0fTtcblxuXHRjb25zdCBkcmF3T3JkZXIgPSAob3B0cy5kcmF3T3JkZXIgfHwgW1wiYXhlc1wiLCBcInNlcmllc1wiXSkubWFwKGtleSA9PiBkcmF3T3JkZXJNYXBba2V5XSk7XG5cblx0ZnVuY3Rpb24gaW5pdFNjYWxlKHNjYWxlS2V5KSB7XG5cdFx0bGV0IHNjID0gc2NhbGVzW3NjYWxlS2V5XTtcblxuXHRcdGlmIChzYyA9PSBudWxsKSB7XG5cdFx0XHRsZXQgc2NhbGVPcHRzID0gKG9wdHMuc2NhbGVzIHx8IEVNUFRZX09CSilbc2NhbGVLZXldIHx8IEVNUFRZX09CSjtcblxuXHRcdFx0aWYgKHNjYWxlT3B0cy5mcm9tICE9IG51bGwpIHtcblx0XHRcdFx0Ly8gZW5zdXJlIHBhcmVudCBpcyBpbml0aWFsaXplZFxuXHRcdFx0XHRpbml0U2NhbGUoc2NhbGVPcHRzLmZyb20pO1xuXHRcdFx0XHQvLyBkZXBlbmRlbnQgc2NhbGVzIGluaGVyaXRcblx0XHRcdFx0c2NhbGVzW3NjYWxlS2V5XSA9IGFzc2lnbih7fSwgc2NhbGVzW3NjYWxlT3B0cy5mcm9tXSwgc2NhbGVPcHRzLCB7a2V5OiBzY2FsZUtleX0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNjID0gc2NhbGVzW3NjYWxlS2V5XSA9IGFzc2lnbih7fSwgKHNjYWxlS2V5ID09IHhTY2FsZUtleSA/IHhTY2FsZU9wdHMgOiB5U2NhbGVPcHRzKSwgc2NhbGVPcHRzKTtcblxuXHRcdFx0XHRzYy5rZXkgPSBzY2FsZUtleTtcblxuXHRcdFx0XHRsZXQgaXNUaW1lID0gc2MudGltZTtcblxuXHRcdFx0XHRsZXQgcm4gPSBzYy5yYW5nZTtcblxuXHRcdFx0XHRsZXQgcmFuZ2VJc0FyciA9IGlzQXJyKHJuKTtcblxuXHRcdFx0XHRpZiAoc2NhbGVLZXkgIT0geFNjYWxlS2V5IHx8IChtb2RlID09IDIgJiYgIWlzVGltZSkpIHtcblx0XHRcdFx0XHQvLyBpZiByYW5nZSBhcnJheSBoYXMgbnVsbCBsaW1pdHMsIGl0IHNob3VsZCBiZSBhdXRvXG5cdFx0XHRcdFx0aWYgKHJhbmdlSXNBcnIgJiYgKHJuWzBdID09IG51bGwgfHwgcm5bMV0gPT0gbnVsbCkpIHtcblx0XHRcdFx0XHRcdHJuID0ge1xuXHRcdFx0XHRcdFx0XHRtaW46IHJuWzBdID09IG51bGwgPyBhdXRvUmFuZ2VQYXJ0IDoge1xuXHRcdFx0XHRcdFx0XHRcdG1vZGU6IDEsXG5cdFx0XHRcdFx0XHRcdFx0aGFyZDogcm5bMF0sXG5cdFx0XHRcdFx0XHRcdFx0c29mdDogcm5bMF0sXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG1heDogcm5bMV0gPT0gbnVsbCA/IGF1dG9SYW5nZVBhcnQgOiB7XG5cdFx0XHRcdFx0XHRcdFx0bW9kZTogMSxcblx0XHRcdFx0XHRcdFx0XHRoYXJkOiByblsxXSxcblx0XHRcdFx0XHRcdFx0XHRzb2Z0OiByblsxXSxcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyYW5nZUlzQXJyID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCFyYW5nZUlzQXJyICYmIGlzT2JqKHJuKSkge1xuXHRcdFx0XHRcdFx0bGV0IGNmZyA9IHJuO1xuXHRcdFx0XHRcdFx0Ly8gdGhpcyBpcyBzaW1pbGFyIHRvIHNuYXBOdW1ZXG5cdFx0XHRcdFx0XHRybiA9IChzZWxmLCBkYXRhTWluLCBkYXRhTWF4KSA9PiBkYXRhTWluID09IG51bGwgPyBudWxsTnVsbFR1cGxlIDogcmFuZ2VOdW0oZGF0YU1pbiwgZGF0YU1heCwgY2ZnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzYy5yYW5nZSA9IGZuT3JTZWxmKHJuIHx8IChpc1RpbWUgPyBzbmFwVGltZVggOiBzY2FsZUtleSA9PSB4U2NhbGVLZXkgP1xuXHRcdFx0XHRcdChzYy5kaXN0ciA9PSAzID8gc25hcExvZ1ggOiBzYy5kaXN0ciA9PSA0ID8gc25hcEFzaW5oWCA6IHNuYXBOdW1YKSA6XG5cdFx0XHRcdFx0KHNjLmRpc3RyID09IDMgPyBzbmFwTG9nWSA6IHNjLmRpc3RyID09IDQgPyBzbmFwQXNpbmhZIDogc25hcE51bVkpXG5cdFx0XHRcdCkpO1xuXG5cdFx0XHRcdHNjLmF1dG8gPSBmbk9yU2VsZihyYW5nZUlzQXJyID8gZmFsc2UgOiBzYy5hdXRvKTtcblxuXHRcdFx0XHRzYy5jbGFtcCA9IGZuT3JTZWxmKHNjLmNsYW1wIHx8IGNsYW1wU2NhbGUpO1xuXG5cdFx0XHRcdC8vIGNhY2hlcyBmb3IgZXhwZW5zaXZlIG9wcyBsaWtlIGFzaW5oKCkgJiBsb2coKVxuXHRcdFx0XHRzYy5fbWluID0gc2MuX21heCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aW5pdFNjYWxlKFwieFwiKTtcblx0aW5pdFNjYWxlKFwieVwiKTtcblxuXHQvLyBUT0RPOiBpbml0IHNjYWxlcyBmcm9tIGZhY2V0cyBpbiBtb2RlOiAyXG5cdGlmIChtb2RlID09IDEpIHtcblx0XHRzZXJpZXMuZm9yRWFjaChzID0+IHtcblx0XHRcdGluaXRTY2FsZShzLnNjYWxlKTtcblx0XHR9KTtcblx0fVxuXG5cdGF4ZXMuZm9yRWFjaChhID0+IHtcblx0XHRpbml0U2NhbGUoYS5zY2FsZSk7XG5cdH0pO1xuXG5cdGZvciAobGV0IGsgaW4gb3B0cy5zY2FsZXMpXG5cdFx0aW5pdFNjYWxlKGspO1xuXG5cdGNvbnN0IHNjYWxlWCA9IHNjYWxlc1t4U2NhbGVLZXldO1xuXG5cdGNvbnN0IHhTY2FsZURpc3RyID0gc2NhbGVYLmRpc3RyO1xuXG5cdGxldCB2YWxUb1Bvc1gsIHZhbFRvUG9zWTtcblxuXHRpZiAoc2NhbGVYLm9yaSA9PSAwKSB7XG5cdFx0YWRkQ2xhc3Mocm9vdCwgT1JJX0haKTtcblx0XHR2YWxUb1Bvc1ggPSBnZXRIUG9zO1xuXHRcdHZhbFRvUG9zWSA9IGdldFZQb3M7XG5cdFx0Lypcblx0XHR1cGRPcmlEaW1zID0gKCkgPT4ge1xuXHRcdFx0eERpbUNhbiA9IHBsb3RXaWQ7XG5cdFx0XHR4T2ZmQ2FuID0gcGxvdExmdDtcblx0XHRcdHlEaW1DYW4gPSBwbG90SGd0O1xuXHRcdFx0eU9mZkNhbiA9IHBsb3RUb3A7XG5cblx0XHRcdHhEaW1Dc3MgPSBwbG90V2lkQ3NzO1xuXHRcdFx0eE9mZkNzcyA9IHBsb3RMZnRDc3M7XG5cdFx0XHR5RGltQ3NzID0gcGxvdEhndENzcztcblx0XHRcdHlPZmZDc3MgPSBwbG90VG9wQ3NzO1xuXHRcdH07XG5cdFx0Ki9cblx0fVxuXHRlbHNlIHtcblx0XHRhZGRDbGFzcyhyb290LCBPUklfVlQpO1xuXHRcdHZhbFRvUG9zWCA9IGdldFZQb3M7XG5cdFx0dmFsVG9Qb3NZID0gZ2V0SFBvcztcblx0XHQvKlxuXHRcdHVwZE9yaURpbXMgPSAoKSA9PiB7XG5cdFx0XHR4RGltQ2FuID0gcGxvdEhndDtcblx0XHRcdHhPZmZDYW4gPSBwbG90VG9wO1xuXHRcdFx0eURpbUNhbiA9IHBsb3RXaWQ7XG5cdFx0XHR5T2ZmQ2FuID0gcGxvdExmdDtcblxuXHRcdFx0eERpbUNzcyA9IHBsb3RIZ3RDc3M7XG5cdFx0XHR4T2ZmQ3NzID0gcGxvdFRvcENzcztcblx0XHRcdHlEaW1Dc3MgPSBwbG90V2lkQ3NzO1xuXHRcdFx0eU9mZkNzcyA9IHBsb3RMZnRDc3M7XG5cdFx0fTtcblx0XHQqL1xuXHR9XG5cblx0Y29uc3QgcGVuZFNjYWxlcyA9IHt9O1xuXG5cdC8vIGV4cGxpY2l0bHktc2V0IGluaXRpYWwgc2NhbGVzXG5cdGZvciAobGV0IGsgaW4gc2NhbGVzKSB7XG5cdFx0bGV0IHNjID0gc2NhbGVzW2tdO1xuXG5cdFx0aWYgKHNjLm1pbiAhPSBudWxsIHx8IHNjLm1heCAhPSBudWxsKSB7XG5cdFx0XHRwZW5kU2NhbGVzW2tdID0ge21pbjogc2MubWluLCBtYXg6IHNjLm1heH07XG5cdFx0XHRzYy5taW4gPSBzYy5tYXggPSBudWxsO1xuXHRcdH1cblx0fVxuXG4vL1x0c2VsZi50eiA9IG9wdHMudHogfHwgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xuXHRjb25zdCBfdHpEYXRlICA9IChvcHRzLnR6RGF0ZSB8fCAodHMgPT4gbmV3IERhdGUocm91bmQodHMgLyBtcykpKSk7XG5cdGNvbnN0IF9mbXREYXRlID0gKG9wdHMuZm10RGF0ZSB8fCBmbXREYXRlKTtcblxuXHRjb25zdCBfdGltZUF4aXNTcGxpdHMgPSAobXMgPT0gMSA/IHRpbWVBeGlzU3BsaXRzTXMoX3R6RGF0ZSkgOiB0aW1lQXhpc1NwbGl0c1MoX3R6RGF0ZSkpO1xuXHRjb25zdCBfdGltZUF4aXNWYWxzICAgPSB0aW1lQXhpc1ZhbHMoX3R6RGF0ZSwgdGltZUF4aXNTdGFtcHMoKG1zID09IDEgPyBfdGltZUF4aXNTdGFtcHNNcyA6IF90aW1lQXhpc1N0YW1wc1MpLCBfZm10RGF0ZSkpO1xuXHRjb25zdCBfdGltZVNlcmllc1ZhbCAgPSB0aW1lU2VyaWVzVmFsKF90ekRhdGUsIHRpbWVTZXJpZXNTdGFtcChfdGltZVNlcmllc1N0YW1wLCBfZm10RGF0ZSkpO1xuXG5cdGNvbnN0IGFjdGl2ZUlkeHMgPSBbXTtcblxuXHRjb25zdCBsZWdlbmQgICAgID0gKHNlbGYubGVnZW5kID0gYXNzaWduKHt9LCBsZWdlbmRPcHRzLCBvcHRzLmxlZ2VuZCkpO1xuXHRjb25zdCBzaG93TGVnZW5kID0gbGVnZW5kLnNob3c7XG5cdGNvbnN0IG1hcmtlcnMgICAgPSBsZWdlbmQubWFya2VycztcblxuXHR7XG5cdFx0bGVnZW5kLmlkeHMgPSBhY3RpdmVJZHhzO1xuXG5cdFx0bWFya2Vycy53aWR0aCAgPSBmbk9yU2VsZihtYXJrZXJzLndpZHRoKTtcblx0XHRtYXJrZXJzLmRhc2ggICA9IGZuT3JTZWxmKG1hcmtlcnMuZGFzaCk7XG5cdFx0bWFya2Vycy5zdHJva2UgPSBmbk9yU2VsZihtYXJrZXJzLnN0cm9rZSk7XG5cdFx0bWFya2Vycy5maWxsICAgPSBmbk9yU2VsZihtYXJrZXJzLmZpbGwpO1xuXHR9XG5cblx0bGV0IGxlZ2VuZEVsO1xuXHRsZXQgbGVnZW5kUm93cyA9IFtdO1xuXHRsZXQgbGVnZW5kQ2VsbHMgPSBbXTtcblx0bGV0IGxlZ2VuZENvbHM7XG5cdGxldCBtdWx0aVZhbExlZ2VuZCA9IGZhbHNlO1xuXHRsZXQgTlVMTF9MRUdFTkRfVkFMVUVTID0ge307XG5cblx0aWYgKGxlZ2VuZC5saXZlKSB7XG5cdFx0Y29uc3QgZ2V0TXVsdGlWYWxzID0gc2VyaWVzWzFdID8gc2VyaWVzWzFdLnZhbHVlcyA6IG51bGw7XG5cdFx0bXVsdGlWYWxMZWdlbmQgPSBnZXRNdWx0aVZhbHMgIT0gbnVsbDtcblx0XHRsZWdlbmRDb2xzID0gbXVsdGlWYWxMZWdlbmQgPyBnZXRNdWx0aVZhbHMoc2VsZiwgMSwgMCkgOiB7XzogMH07XG5cblx0XHRmb3IgKGxldCBrIGluIGxlZ2VuZENvbHMpXG5cdFx0XHROVUxMX0xFR0VORF9WQUxVRVNba10gPSBcIi0tXCI7XG5cdH1cblxuXHRpZiAoc2hvd0xlZ2VuZCkge1xuXHRcdGxlZ2VuZEVsID0gcGxhY2VUYWcoXCJ0YWJsZVwiLCBMRUdFTkQsIHJvb3QpO1xuXG5cdFx0aWYgKG11bHRpVmFsTGVnZW5kKSB7XG5cdFx0XHRsZXQgaGVhZCA9IHBsYWNlVGFnKFwidHJcIiwgTEVHRU5EX1RIRUFELCBsZWdlbmRFbCk7XG5cdFx0XHRwbGFjZVRhZyhcInRoXCIsIG51bGwsIGhlYWQpO1xuXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gbGVnZW5kQ29scylcblx0XHRcdFx0cGxhY2VUYWcoXCJ0aFwiLCBMRUdFTkRfTEFCRUwsIGhlYWQpLnRleHRDb250ZW50ID0ga2V5O1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGFkZENsYXNzKGxlZ2VuZEVsLCBMRUdFTkRfSU5MSU5FKTtcblx0XHRcdGxlZ2VuZC5saXZlICYmIGFkZENsYXNzKGxlZ2VuZEVsLCBMRUdFTkRfTElWRSk7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3Qgc29uICA9IHtzaG93OiB0cnVlfTtcblx0Y29uc3Qgc29mZiA9IHtzaG93OiBmYWxzZX07XG5cblx0ZnVuY3Rpb24gaW5pdExlZ2VuZFJvdyhzLCBpKSB7XG5cdFx0aWYgKGkgPT0gMCAmJiAobXVsdGlWYWxMZWdlbmQgfHwgIWxlZ2VuZC5saXZlIHx8IG1vZGUgPT0gMikpXG5cdFx0XHRyZXR1cm4gbnVsbE51bGxUdXBsZTtcblxuXHRcdGxldCBjZWxscyA9IFtdO1xuXG5cdFx0bGV0IHJvdyA9IHBsYWNlVGFnKFwidHJcIiwgTEVHRU5EX1NFUklFUywgbGVnZW5kRWwsIGxlZ2VuZEVsLmNoaWxkTm9kZXNbaV0pO1xuXG5cdFx0YWRkQ2xhc3Mocm93LCBzLmNsYXNzKTtcblxuXHRcdGlmICghcy5zaG93KVxuXHRcdFx0YWRkQ2xhc3Mocm93LCBPRkYpO1xuXG5cdFx0bGV0IGxhYmVsID0gcGxhY2VUYWcoXCJ0aFwiLCBudWxsLCByb3cpO1xuXG5cdFx0aWYgKG1hcmtlcnMuc2hvdykge1xuXHRcdFx0bGV0IGluZGljID0gcGxhY2VEaXYoTEVHRU5EX01BUktFUiwgbGFiZWwpO1xuXG5cdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0bGV0IHdpZHRoICA9IG1hcmtlcnMud2lkdGgoc2VsZiwgaSk7XG5cblx0XHRcdFx0aWYgKHdpZHRoKVxuXHRcdFx0XHRcdGluZGljLnN0eWxlLmJvcmRlciA9IHdpZHRoICsgXCJweCBcIiArIG1hcmtlcnMuZGFzaChzZWxmLCBpKSArIFwiIFwiICsgbWFya2Vycy5zdHJva2Uoc2VsZiwgaSk7XG5cblx0XHRcdFx0aW5kaWMuc3R5bGUuYmFja2dyb3VuZCA9IG1hcmtlcnMuZmlsbChzZWxmLCBpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsZXQgdGV4dCA9IHBsYWNlRGl2KExFR0VORF9MQUJFTCwgbGFiZWwpO1xuXHRcdHRleHQudGV4dENvbnRlbnQgPSBzLmxhYmVsO1xuXG5cdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRpZiAoIW1hcmtlcnMuc2hvdylcblx0XHRcdFx0dGV4dC5zdHlsZS5jb2xvciA9IHMud2lkdGggPiAwID8gbWFya2Vycy5zdHJva2Uoc2VsZiwgaSkgOiBtYXJrZXJzLmZpbGwoc2VsZiwgaSk7XG5cblx0XHRcdG9uTW91c2UoXCJjbGlja1wiLCBsYWJlbCwgZSA9PiB7XG5cdFx0XHRcdGlmIChjdXJzb3IuX2xvY2spXG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdGxldCBzZXJpZXNJZHggPSBzZXJpZXMuaW5kZXhPZihzKTtcblxuXHRcdFx0XHRpZiAoKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpICE9IGxlZ2VuZC5pc29sYXRlKSB7XG5cdFx0XHRcdFx0Ly8gaWYgYW55IG90aGVyIHNlcmllcyBpcyBzaG93biwgaXNvbGF0ZSB0aGlzIG9uZS4gZWxzZSBzaG93IGFsbFxuXHRcdFx0XHRcdGxldCBpc29sYXRlID0gc2VyaWVzLnNvbWUoKHMsIGkpID0+IGkgPiAwICYmIGkgIT0gc2VyaWVzSWR4ICYmIHMuc2hvdyk7XG5cblx0XHRcdFx0XHRzZXJpZXMuZm9yRWFjaCgocywgaSkgPT4ge1xuXHRcdFx0XHRcdFx0aSA+IDAgJiYgc2V0U2VyaWVzKGksIGlzb2xhdGUgPyAoaSA9PSBzZXJpZXNJZHggPyBzb24gOiBzb2ZmKSA6IHNvbiwgdHJ1ZSwgc3luY09wdHMuc2V0U2VyaWVzKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0c2V0U2VyaWVzKHNlcmllc0lkeCwge3Nob3c6ICFzLnNob3d9LCB0cnVlLCBzeW5jT3B0cy5zZXRTZXJpZXMpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChjdXJzb3JGb2N1cykge1xuXHRcdFx0XHRvbk1vdXNlKG1vdXNlZW50ZXIsIGxhYmVsLCBlID0+IHtcblx0XHRcdFx0XHRpZiAoY3Vyc29yLl9sb2NrKVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0c2V0U2VyaWVzKHNlcmllcy5pbmRleE9mKHMpLCBGT0NVU19UUlVFLCB0cnVlLCBzeW5jT3B0cy5zZXRTZXJpZXMpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gbGVnZW5kQ29scykge1xuXHRcdFx0bGV0IHYgPSBwbGFjZVRhZyhcInRkXCIsIExFR0VORF9WQUxVRSwgcm93KTtcblx0XHRcdHYudGV4dENvbnRlbnQgPSBcIi0tXCI7XG5cdFx0XHRjZWxscy5wdXNoKHYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBbcm93LCBjZWxsc107XG5cdH1cblxuXHRjb25zdCBtb3VzZUxpc3RlbmVycyA9IG5ldyBNYXAoKTtcblxuXHRmdW5jdGlvbiBvbk1vdXNlKGV2LCB0YXJnLCBmbikge1xuXHRcdGNvbnN0IHRhcmdMaXN0ZW5lcnMgPSBtb3VzZUxpc3RlbmVycy5nZXQodGFyZykgfHwge307XG5cdFx0Y29uc3QgbGlzdGVuZXIgPSBjdXJzb3IuYmluZFtldl0oc2VsZiwgdGFyZywgZm4pO1xuXG5cdFx0aWYgKGxpc3RlbmVyKSB7XG5cdFx0XHRvbihldiwgdGFyZywgdGFyZ0xpc3RlbmVyc1tldl0gPSBsaXN0ZW5lcik7XG5cdFx0XHRtb3VzZUxpc3RlbmVycy5zZXQodGFyZywgdGFyZ0xpc3RlbmVycyk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gb2ZmTW91c2UoZXYsIHRhcmcsIGZuKSB7XG5cdFx0Y29uc3QgdGFyZ0xpc3RlbmVycyA9IG1vdXNlTGlzdGVuZXJzLmdldCh0YXJnKSB8fCB7fTtcblxuXHRcdGZvciAobGV0IGsgaW4gdGFyZ0xpc3RlbmVycykge1xuXHRcdFx0aWYgKGV2ID09IG51bGwgfHwgayA9PSBldikge1xuXHRcdFx0XHRvZmYoaywgdGFyZywgdGFyZ0xpc3RlbmVyc1trXSk7XG5cdFx0XHRcdGRlbGV0ZSB0YXJnTGlzdGVuZXJzW2tdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChldiA9PSBudWxsKVxuXHRcdFx0bW91c2VMaXN0ZW5lcnMuZGVsZXRlKHRhcmcpO1xuXHR9XG5cblx0bGV0IGZ1bGxXaWRDc3MgPSAwO1xuXHRsZXQgZnVsbEhndENzcyA9IDA7XG5cblx0bGV0IHBsb3RXaWRDc3MgPSAwO1xuXHRsZXQgcGxvdEhndENzcyA9IDA7XG5cblx0Ly8gcGxvdCBtYXJnaW5zIHRvIGFjY291bnQgZm9yIGF4ZXNcblx0bGV0IHBsb3RMZnRDc3MgPSAwO1xuXHRsZXQgcGxvdFRvcENzcyA9IDA7XG5cblx0bGV0IHBsb3RMZnQgPSAwO1xuXHRsZXQgcGxvdFRvcCA9IDA7XG5cdGxldCBwbG90V2lkID0gMDtcblx0bGV0IHBsb3RIZ3QgPSAwO1xuXG5cdHNlbGYuYmJveCA9IHt9O1xuXG5cdGxldCBzaG91bGRTZXRTY2FsZXMgPSBmYWxzZTtcblx0bGV0IHNob3VsZFNldFNpemUgPSBmYWxzZTtcblx0bGV0IHNob3VsZENvbnZlcmdlU2l6ZSA9IGZhbHNlO1xuXHRsZXQgc2hvdWxkU2V0Q3Vyc29yID0gZmFsc2U7XG5cdGxldCBzaG91bGRTZXRMZWdlbmQgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBfc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCBmb3JjZSkge1xuXHRcdGlmIChmb3JjZSB8fCAod2lkdGggIT0gc2VsZi53aWR0aCB8fCBoZWlnaHQgIT0gc2VsZi5oZWlnaHQpKVxuXHRcdFx0Y2FsY1NpemUod2lkdGgsIGhlaWdodCk7XG5cblx0XHRyZXNldFlTZXJpZXMoZmFsc2UpO1xuXG5cdFx0c2hvdWxkQ29udmVyZ2VTaXplID0gdHJ1ZTtcblx0XHRzaG91bGRTZXRTaXplID0gdHJ1ZTtcblx0XHRzaG91bGRTZXRDdXJzb3IgPSBzaG91bGRTZXRMZWdlbmQgPSBjdXJzb3IubGVmdCA+PSAwO1xuXHRcdGNvbW1pdCgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FsY1NpemUod2lkdGgsIGhlaWdodCkge1xuXHQvL1x0bG9nKFwiY2FsY1NpemUoKVwiLCBhcmd1bWVudHMpO1xuXG5cdFx0c2VsZi53aWR0aCAgPSBmdWxsV2lkQ3NzID0gcGxvdFdpZENzcyA9IHdpZHRoO1xuXHRcdHNlbGYuaGVpZ2h0ID0gZnVsbEhndENzcyA9IHBsb3RIZ3RDc3MgPSBoZWlnaHQ7XG5cdFx0cGxvdExmdENzcyAgPSBwbG90VG9wQ3NzID0gMDtcblxuXHRcdGNhbGNQbG90UmVjdCgpO1xuXHRcdGNhbGNBeGVzUmVjdHMoKTtcblxuXHRcdGxldCBiYiA9IHNlbGYuYmJveDtcblxuXHRcdHBsb3RMZnQgPSBiYi5sZWZ0ICAgPSBpbmNyUm91bmQocGxvdExmdENzcyAqIHB4UmF0aW8sIDAuNSk7XG5cdFx0cGxvdFRvcCA9IGJiLnRvcCAgICA9IGluY3JSb3VuZChwbG90VG9wQ3NzICogcHhSYXRpbywgMC41KTtcblx0XHRwbG90V2lkID0gYmIud2lkdGggID0gaW5jclJvdW5kKHBsb3RXaWRDc3MgKiBweFJhdGlvLCAwLjUpO1xuXHRcdHBsb3RIZ3QgPSBiYi5oZWlnaHQgPSBpbmNyUm91bmQocGxvdEhndENzcyAqIHB4UmF0aW8sIDAuNSk7XG5cblx0Ly9cdHVwZE9yaURpbXMoKTtcblx0fVxuXG5cdC8vIGVuc3VyZXMgc2l6ZSBjYWxjIGNvbnZlcmdlbmNlXG5cdGNvbnN0IENZQ0xFX0xJTUlUID0gMztcblxuXHRmdW5jdGlvbiBjb252ZXJnZVNpemUoKSB7XG5cdFx0bGV0IGNvbnZlcmdlZCA9IGZhbHNlO1xuXG5cdFx0bGV0IGN5Y2xlTnVtID0gMDtcblxuXHRcdHdoaWxlICghY29udmVyZ2VkKSB7XG5cdFx0XHRjeWNsZU51bSsrO1xuXG5cdFx0XHRsZXQgYXhlc0NvbnZlcmdlZCA9IGF4ZXNDYWxjKGN5Y2xlTnVtKTtcblx0XHRcdGxldCBwYWRkaW5nQ29udmVyZ2VkID0gcGFkZGluZ0NhbGMoY3ljbGVOdW0pO1xuXG5cdFx0XHRjb252ZXJnZWQgPSBjeWNsZU51bSA9PSBDWUNMRV9MSU1JVCB8fCAoYXhlc0NvbnZlcmdlZCAmJiBwYWRkaW5nQ29udmVyZ2VkKTtcblxuXHRcdFx0aWYgKCFjb252ZXJnZWQpIHtcblx0XHRcdFx0Y2FsY1NpemUoc2VsZi53aWR0aCwgc2VsZi5oZWlnaHQpO1xuXHRcdFx0XHRzaG91bGRTZXRTaXplID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTaXplKHt3aWR0aCwgaGVpZ2h0fSkge1xuXHRcdF9zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuXHR9XG5cblx0c2VsZi5zZXRTaXplID0gc2V0U2l6ZTtcblxuXHQvLyBhY2N1bXVsYXRlIGF4aXMgb2Zmc2V0cywgcmVkdWNlIGNhbnZhcyB3aWR0aFxuXHRmdW5jdGlvbiBjYWxjUGxvdFJlY3QoKSB7XG5cdFx0Ly8gZWFzZW1lbnRzIGZvciBlZGdlIGxhYmVsc1xuXHRcdGxldCBoYXNUb3BBeGlzID0gZmFsc2U7XG5cdFx0bGV0IGhhc0J0bUF4aXMgPSBmYWxzZTtcblx0XHRsZXQgaGFzUmd0QXhpcyA9IGZhbHNlO1xuXHRcdGxldCBoYXNMZnRBeGlzID0gZmFsc2U7XG5cblx0XHRheGVzLmZvckVhY2goKGF4aXMsIGkpID0+IHtcblx0XHRcdGlmIChheGlzLnNob3cgJiYgYXhpcy5fc2hvdykge1xuXHRcdFx0XHRsZXQge3NpZGUsIF9zaXplfSA9IGF4aXM7XG5cdFx0XHRcdGxldCBpc1Z0ID0gc2lkZSAlIDI7XG5cdFx0XHRcdGxldCBsYWJlbFNpemUgPSBheGlzLmxhYmVsICE9IG51bGwgPyBheGlzLmxhYmVsU2l6ZSA6IDA7XG5cblx0XHRcdFx0bGV0IGZ1bGxTaXplID0gX3NpemUgKyBsYWJlbFNpemU7XG5cblx0XHRcdFx0aWYgKGZ1bGxTaXplID4gMCkge1xuXHRcdFx0XHRcdGlmIChpc1Z0KSB7XG5cdFx0XHRcdFx0XHRwbG90V2lkQ3NzIC09IGZ1bGxTaXplO1xuXG5cdFx0XHRcdFx0XHRpZiAoc2lkZSA9PSAzKSB7XG5cdFx0XHRcdFx0XHRcdHBsb3RMZnRDc3MgKz0gZnVsbFNpemU7XG5cdFx0XHRcdFx0XHRcdGhhc0xmdEF4aXMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRoYXNSZ3RBeGlzID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRwbG90SGd0Q3NzIC09IGZ1bGxTaXplO1xuXG5cdFx0XHRcdFx0XHRpZiAoc2lkZSA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHBsb3RUb3BDc3MgKz0gZnVsbFNpemU7XG5cdFx0XHRcdFx0XHRcdGhhc1RvcEF4aXMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRoYXNCdG1BeGlzID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHNpZGVzV2l0aEF4ZXNbMF0gPSBoYXNUb3BBeGlzO1xuXHRcdHNpZGVzV2l0aEF4ZXNbMV0gPSBoYXNSZ3RBeGlzO1xuXHRcdHNpZGVzV2l0aEF4ZXNbMl0gPSBoYXNCdG1BeGlzO1xuXHRcdHNpZGVzV2l0aEF4ZXNbM10gPSBoYXNMZnRBeGlzO1xuXG5cdFx0Ly8gaHogcGFkZGluZ1xuXHRcdHBsb3RXaWRDc3MgLT0gX3BhZGRpbmdbMV0gKyBfcGFkZGluZ1szXTtcblx0XHRwbG90TGZ0Q3NzICs9IF9wYWRkaW5nWzNdO1xuXG5cdFx0Ly8gdnQgcGFkZGluZ1xuXHRcdHBsb3RIZ3RDc3MgLT0gX3BhZGRpbmdbMl0gKyBfcGFkZGluZ1swXTtcblx0XHRwbG90VG9wQ3NzICs9IF9wYWRkaW5nWzBdO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FsY0F4ZXNSZWN0cygpIHtcblx0XHQvLyB3aWxsIGFjY3VtICtcblx0XHRsZXQgb2ZmMSA9IHBsb3RMZnRDc3MgKyBwbG90V2lkQ3NzO1xuXHRcdGxldCBvZmYyID0gcGxvdFRvcENzcyArIHBsb3RIZ3RDc3M7XG5cdFx0Ly8gd2lsbCBhY2N1bSAtXG5cdFx0bGV0IG9mZjMgPSBwbG90TGZ0Q3NzO1xuXHRcdGxldCBvZmYwID0gcGxvdFRvcENzcztcblxuXHRcdGZ1bmN0aW9uIGluY3JPZmZzZXQoc2lkZSwgc2l6ZSkge1xuXHRcdFx0c3dpdGNoIChzaWRlKSB7XG5cdFx0XHRcdGNhc2UgMTogb2ZmMSArPSBzaXplOyByZXR1cm4gb2ZmMSAtIHNpemU7XG5cdFx0XHRcdGNhc2UgMjogb2ZmMiArPSBzaXplOyByZXR1cm4gb2ZmMiAtIHNpemU7XG5cdFx0XHRcdGNhc2UgMzogb2ZmMyAtPSBzaXplOyByZXR1cm4gb2ZmMyArIHNpemU7XG5cdFx0XHRcdGNhc2UgMDogb2ZmMCAtPSBzaXplOyByZXR1cm4gb2ZmMCArIHNpemU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YXhlcy5mb3JFYWNoKChheGlzLCBpKSA9PiB7XG5cdFx0XHRpZiAoYXhpcy5zaG93ICYmIGF4aXMuX3Nob3cpIHtcblx0XHRcdFx0bGV0IHNpZGUgPSBheGlzLnNpZGU7XG5cblx0XHRcdFx0YXhpcy5fcG9zID0gaW5jck9mZnNldChzaWRlLCBheGlzLl9zaXplKTtcblxuXHRcdFx0XHRpZiAoYXhpcy5sYWJlbCAhPSBudWxsKVxuXHRcdFx0XHRcdGF4aXMuX2xwb3MgPSBpbmNyT2Zmc2V0KHNpZGUsIGF4aXMubGFiZWxTaXplKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGNvbnN0IGN1cnNvciA9IChzZWxmLmN1cnNvciA9IGFzc2lnbih7fSwgY3Vyc29yT3B0cywge2RyYWc6IHt5OiBtb2RlID09IDJ9fSwgb3B0cy5jdXJzb3IpKTtcblxuXHR7XG5cdFx0Y3Vyc29yLmlkeHMgPSBhY3RpdmVJZHhzO1xuXG5cdFx0Y3Vyc29yLl9sb2NrID0gZmFsc2U7XG5cblx0XHRsZXQgcG9pbnRzID0gY3Vyc29yLnBvaW50cztcblxuXHRcdHBvaW50cy5zaG93ICAgPSBmbk9yU2VsZihwb2ludHMuc2hvdyk7XG5cdFx0cG9pbnRzLnNpemUgICA9IGZuT3JTZWxmKHBvaW50cy5zaXplKTtcblx0XHRwb2ludHMuc3Ryb2tlID0gZm5PclNlbGYocG9pbnRzLnN0cm9rZSk7XG5cdFx0cG9pbnRzLndpZHRoICA9IGZuT3JTZWxmKHBvaW50cy53aWR0aCk7XG5cdFx0cG9pbnRzLmZpbGwgICA9IGZuT3JTZWxmKHBvaW50cy5maWxsKTtcblx0fVxuXG5cdGNvbnN0IGZvY3VzID0gc2VsZi5mb2N1cyA9IGFzc2lnbih7fSwgb3B0cy5mb2N1cyB8fCB7YWxwaGE6IDAuM30sIGN1cnNvci5mb2N1cyk7XG5cdGNvbnN0IGN1cnNvckZvY3VzID0gZm9jdXMucHJveCA+PSAwO1xuXG5cdC8vIHNlcmllcy1pbnRlcnNlY3Rpb24gbWFya2Vyc1xuXHRsZXQgY3Vyc29yUHRzID0gW251bGxdO1xuXG5cdGZ1bmN0aW9uIGluaXRDdXJzb3JQdChzLCBzaSkge1xuXHRcdGlmIChzaSA+IDApIHtcblx0XHRcdGxldCBwdCA9IGN1cnNvci5wb2ludHMuc2hvdyhzZWxmLCBzaSk7XG5cblx0XHRcdGlmIChwdCkge1xuXHRcdFx0XHRhZGRDbGFzcyhwdCwgQ1VSU09SX1BUKTtcblx0XHRcdFx0YWRkQ2xhc3MocHQsIHMuY2xhc3MpO1xuXHRcdFx0XHRlbFRyYW5zKHB0LCAtMTAsIC0xMCwgcGxvdFdpZENzcywgcGxvdEhndENzcyk7XG5cdFx0XHRcdG92ZXIuaW5zZXJ0QmVmb3JlKHB0LCBjdXJzb3JQdHNbc2ldKTtcblxuXHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdFNlcmllcyhzLCBpKSB7XG5cdFx0aWYgKG1vZGUgPT0gMSB8fCBpID4gMCkge1xuXHRcdFx0bGV0IGlzVGltZSA9IG1vZGUgPT0gMSAmJiBzY2FsZXNbcy5zY2FsZV0udGltZTtcblxuXHRcdFx0bGV0IHN2ID0gcy52YWx1ZTtcblx0XHRcdHMudmFsdWUgPSBpc1RpbWUgPyAoaXNTdHIoc3YpID8gdGltZVNlcmllc1ZhbChfdHpEYXRlLCB0aW1lU2VyaWVzU3RhbXAoc3YsIF9mbXREYXRlKSkgOiBzdiB8fCBfdGltZVNlcmllc1ZhbCkgOiBzdiB8fCBudW1TZXJpZXNWYWw7XG5cdFx0XHRzLmxhYmVsID0gcy5sYWJlbCB8fCAoaXNUaW1lID8gdGltZVNlcmllc0xhYmVsIDogbnVtU2VyaWVzTGFiZWwpO1xuXHRcdH1cblxuXHRcdGlmIChpID4gMCkge1xuXHRcdFx0cy53aWR0aCAgPSBzLndpZHRoID09IG51bGwgPyAxIDogcy53aWR0aDtcblx0XHRcdHMucGF0aHMgID0gcy5wYXRocyB8fCBsaW5lYXJQYXRoIHx8IHJldE51bGw7XG5cdFx0XHRzLmZpbGxUbyA9IGZuT3JTZWxmKHMuZmlsbFRvIHx8IHNlcmllc0ZpbGxUbyk7XG5cdFx0XHRzLnB4QWxpZ24gPSAraWZOdWxsKHMucHhBbGlnbiwgcHhBbGlnbik7XG5cdFx0XHRzLnB4Um91bmQgPSBweFJvdW5kR2VuKHMucHhBbGlnbik7XG5cblx0XHRcdHMuc3Ryb2tlID0gZm5PclNlbGYocy5zdHJva2UgfHwgbnVsbCk7XG5cdFx0XHRzLmZpbGwgICA9IGZuT3JTZWxmKHMuZmlsbCB8fCBudWxsKTtcblx0XHRcdHMuX3N0cm9rZSA9IHMuX2ZpbGwgPSBzLl9wYXRocyA9IHMuX2ZvY3VzID0gbnVsbDtcblxuXHRcdFx0bGV0IF9wdERpYSA9IHB0RGlhKHMud2lkdGgsIDEpO1xuXHRcdFx0bGV0IHBvaW50cyA9IHMucG9pbnRzID0gYXNzaWduKHt9LCB7XG5cdFx0XHRcdHNpemU6IF9wdERpYSxcblx0XHRcdFx0d2lkdGg6IG1heCgxLCBfcHREaWEgKiAuMiksXG5cdFx0XHRcdHN0cm9rZTogcy5zdHJva2UsXG5cdFx0XHRcdHNwYWNlOiBfcHREaWEgKiAyLFxuXHRcdFx0XHRwYXRoczogcG9pbnRzUGF0aCxcblx0XHRcdFx0X3N0cm9rZTogbnVsbCxcblx0XHRcdFx0X2ZpbGw6IG51bGwsXG5cdFx0XHR9LCBzLnBvaW50cyk7XG5cdFx0XHRwb2ludHMuc2hvdyAgID0gZm5PclNlbGYocG9pbnRzLnNob3cpO1xuXHRcdFx0cG9pbnRzLmZpbHRlciA9IGZuT3JTZWxmKHBvaW50cy5maWx0ZXIpO1xuXHRcdFx0cG9pbnRzLmZpbGwgICA9IGZuT3JTZWxmKHBvaW50cy5maWxsKTtcblx0XHRcdHBvaW50cy5zdHJva2UgPSBmbk9yU2VsZihwb2ludHMuc3Ryb2tlKTtcblx0XHRcdHBvaW50cy5wYXRocyAgPSBmbk9yU2VsZihwb2ludHMucGF0aHMpO1xuXHRcdFx0cG9pbnRzLnB4QWxpZ24gPSBzLnB4QWxpZ247XG5cdFx0fVxuXG5cdFx0aWYgKHNob3dMZWdlbmQpIHtcblx0XHRcdGxldCByb3dDZWxscyA9IGluaXRMZWdlbmRSb3cocywgaSk7XG5cdFx0XHRsZWdlbmRSb3dzLnNwbGljZShpLCAwLCByb3dDZWxsc1swXSk7XG5cdFx0XHRsZWdlbmRDZWxscy5zcGxpY2UoaSwgMCwgcm93Q2VsbHNbMV0pO1xuXHRcdFx0bGVnZW5kLnZhbHVlcy5wdXNoKG51bGwpO1x0Ly8gTlVMTF9MRUdFTkRfVkFMUyBub3QgeWV0IGF2aWwgaGVyZSA6KFxuXHRcdH1cblxuXHRcdGlmIChjdXJzb3Iuc2hvdykge1xuXHRcdFx0YWN0aXZlSWR4cy5zcGxpY2UoaSwgMCwgbnVsbCk7XG5cblx0XHRcdGxldCBwdCA9IGluaXRDdXJzb3JQdChzLCBpKTtcblx0XHRcdHB0ICYmIGN1cnNvclB0cy5zcGxpY2UoaSwgMCwgcHQpO1xuXHRcdH1cblxuXHRcdGZpcmUoXCJhZGRTZXJpZXNcIiwgaSk7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRTZXJpZXMob3B0cywgc2kpIHtcblx0XHRzaSA9IHNpID09IG51bGwgPyBzZXJpZXMubGVuZ3RoIDogc2k7XG5cblx0XHRvcHRzID0gc2V0RGVmYXVsdChvcHRzLCBzaSwgeFNlcmllc09wdHMsIHlTZXJpZXNPcHRzKTtcblx0XHRzZXJpZXMuc3BsaWNlKHNpLCAwLCBvcHRzKTtcblx0XHRpbml0U2VyaWVzKHNlcmllc1tzaV0sIHNpKTtcblx0fVxuXG5cdHNlbGYuYWRkU2VyaWVzID0gYWRkU2VyaWVzO1xuXG5cdGZ1bmN0aW9uIGRlbFNlcmllcyhpKSB7XG5cdFx0c2VyaWVzLnNwbGljZShpLCAxKTtcblxuXHRcdGlmIChzaG93TGVnZW5kKSB7XG5cdFx0XHRsZWdlbmQudmFsdWVzLnNwbGljZShpLCAxKTtcblxuXHRcdFx0bGVnZW5kQ2VsbHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0bGV0IHRyID0gbGVnZW5kUm93cy5zcGxpY2UoaSwgMSlbMF07XG5cdFx0XHRvZmZNb3VzZShudWxsLCB0ci5maXJzdENoaWxkKTtcblx0XHRcdHRyLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdGlmIChjdXJzb3Iuc2hvdykge1xuXHRcdFx0YWN0aXZlSWR4cy5zcGxpY2UoaSwgMSk7XG5cblx0XHRcdGN1cnNvclB0cy5sZW5ndGggPiAxICYmIGN1cnNvclB0cy5zcGxpY2UoaSwgMSlbMF0ucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogZGUtaW5pdCBuby1sb25nZXItbmVlZGVkIHNjYWxlcz9cblxuXHRcdGZpcmUoXCJkZWxTZXJpZXNcIiwgaSk7XG5cdH1cblxuXHRzZWxmLmRlbFNlcmllcyA9IGRlbFNlcmllcztcblxuXHRjb25zdCBzaWRlc1dpdGhBeGVzID0gW2ZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlXTtcblxuXHRmdW5jdGlvbiBpbml0QXhpcyhheGlzLCBpKSB7XG5cdFx0YXhpcy5fc2hvdyA9IGF4aXMuc2hvdztcblxuXHRcdGlmIChheGlzLnNob3cpIHtcblx0XHRcdGxldCBpc1Z0ID0gYXhpcy5zaWRlICUgMjtcblxuXHRcdFx0bGV0IHNjID0gc2NhbGVzW2F4aXMuc2NhbGVdO1xuXG5cdFx0XHQvLyB0aGlzIGNhbiBvY2N1ciBpZiBhbGwgc2VyaWVzIHNwZWNpZnkgbm9uLWRlZmF1bHQgc2NhbGVzXG5cdFx0XHRpZiAoc2MgPT0gbnVsbCkge1xuXHRcdFx0XHRheGlzLnNjYWxlID0gaXNWdCA/IHNlcmllc1sxXS5zY2FsZSA6IHhTY2FsZUtleTtcblx0XHRcdFx0c2MgPSBzY2FsZXNbYXhpcy5zY2FsZV07XG5cdFx0XHR9XG5cblx0XHRcdC8vIGFsc28gc2V0IGRlZmF1bHRzIGZvciBpbmNycyAmIHZhbHVlcyBiYXNlZCBvbiBheGlzIGRpc3RyXG5cdFx0XHRsZXQgaXNUaW1lID0gc2MudGltZTtcblxuXHRcdFx0YXhpcy5zaXplICAgPSBmbk9yU2VsZihheGlzLnNpemUpO1xuXHRcdFx0YXhpcy5zcGFjZSAgPSBmbk9yU2VsZihheGlzLnNwYWNlKTtcblx0XHRcdGF4aXMucm90YXRlID0gZm5PclNlbGYoYXhpcy5yb3RhdGUpO1xuXHRcdFx0YXhpcy5pbmNycyAgPSBmbk9yU2VsZihheGlzLmluY3JzICB8fCAoICAgICAgICAgIHNjLmRpc3RyID09IDIgPyB3aG9sZUluY3JzIDogKGlzVGltZSA/IChtcyA9PSAxID8gdGltZUluY3JzTXMgOiB0aW1lSW5jcnNTKSA6IG51bUluY3JzKSkpO1xuXHRcdFx0YXhpcy5zcGxpdHMgPSBmbk9yU2VsZihheGlzLnNwbGl0cyB8fCAoaXNUaW1lICYmIHNjLmRpc3RyID09IDEgPyBfdGltZUF4aXNTcGxpdHMgOiBzYy5kaXN0ciA9PSAzID8gbG9nQXhpc1NwbGl0cyA6IHNjLmRpc3RyID09IDQgPyBhc2luaEF4aXNTcGxpdHMgOiBudW1BeGlzU3BsaXRzKSk7XG5cblx0XHRcdGF4aXMuc3Ryb2tlICAgICAgICA9IGZuT3JTZWxmKGF4aXMuc3Ryb2tlKTtcblx0XHRcdGF4aXMuZ3JpZC5zdHJva2UgICA9IGZuT3JTZWxmKGF4aXMuZ3JpZC5zdHJva2UpO1xuXHRcdFx0YXhpcy50aWNrcy5zdHJva2UgID0gZm5PclNlbGYoYXhpcy50aWNrcy5zdHJva2UpO1xuXHRcdFx0YXhpcy5ib3JkZXIuc3Ryb2tlID0gZm5PclNlbGYoYXhpcy5ib3JkZXIuc3Ryb2tlKTtcblxuXHRcdFx0bGV0IGF2ID0gYXhpcy52YWx1ZXM7XG5cblx0XHRcdGF4aXMudmFsdWVzID0gKFxuXHRcdFx0XHQvLyBzdGF0aWMgYXJyYXkgb2YgdGljayB2YWx1ZXNcblx0XHRcdFx0aXNBcnIoYXYpICYmICFpc0FycihhdlswXSkgPyBmbk9yU2VsZihhdikgOlxuXHRcdFx0XHQvLyB0ZW1wb3JhbFxuXHRcdFx0XHRpc1RpbWUgPyAoXG5cdFx0XHRcdFx0Ly8gY29uZmlnIGFycmF5IG9mIGZtdERhdGUgc3RyaW5nIHRwbHNcblx0XHRcdFx0XHRpc0FycihhdikgP1xuXHRcdFx0XHRcdFx0dGltZUF4aXNWYWxzKF90ekRhdGUsIHRpbWVBeGlzU3RhbXBzKGF2LCBfZm10RGF0ZSkpIDpcblx0XHRcdFx0XHQvLyBmbXREYXRlIHN0cmluZyB0cGxcblx0XHRcdFx0XHRpc1N0cihhdikgP1xuXHRcdFx0XHRcdFx0dGltZUF4aXNWYWwoX3R6RGF0ZSwgYXYpIDpcblx0XHRcdFx0XHRhdiB8fCBfdGltZUF4aXNWYWxzXG5cdFx0XHRcdCkgOiBhdiB8fCBudW1BeGlzVmFsc1xuXHRcdFx0KTtcblxuXHRcdFx0YXhpcy5maWx0ZXIgPSBmbk9yU2VsZihheGlzLmZpbHRlciB8fCAoICAgICAgICAgIHNjLmRpc3RyID49IDMgPyBsb2dBeGlzVmFsc0ZpbHQgOiByZXRBcmcxKSk7XG5cblx0XHRcdGF4aXMuZm9udCAgICAgID0gcHhSYXRpb0ZvbnQoYXhpcy5mb250KTtcblx0XHRcdGF4aXMubGFiZWxGb250ID0gcHhSYXRpb0ZvbnQoYXhpcy5sYWJlbEZvbnQpO1xuXG5cdFx0XHRheGlzLl9zaXplICAgPSBheGlzLnNpemUoc2VsZiwgbnVsbCwgaSwgMCk7XG5cblx0XHRcdGF4aXMuX3NwYWNlICA9XG5cdFx0XHRheGlzLl9yb3RhdGUgPVxuXHRcdFx0YXhpcy5faW5jcnMgID1cblx0XHRcdGF4aXMuX2ZvdW5kICA9XHQvLyBmb3VuZEluY3JTcGFjZVxuXHRcdFx0YXhpcy5fc3BsaXRzID1cblx0XHRcdGF4aXMuX3ZhbHVlcyA9IG51bGw7XG5cblx0XHRcdGlmIChheGlzLl9zaXplID4gMCkge1xuXHRcdFx0XHRzaWRlc1dpdGhBeGVzW2ldID0gdHJ1ZTtcblx0XHRcdFx0YXhpcy5fZWwgPSBwbGFjZURpdihBWElTLCB3cmFwKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZGVidWdcblx0XHQvL1x0YXhpcy5fZWwuc3R5bGUuYmFja2dyb3VuZCA9IFwiI1wiICArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoxNjc3NzIxNSkudG9TdHJpbmcoMTYpICsgJzgwJztcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhdXRvUGFkU2lkZShzZWxmLCBzaWRlLCBzaWRlc1dpdGhBeGVzLCBjeWNsZU51bSkge1xuXHRcdGxldCBbaGFzVG9wQXhpcywgaGFzUmd0QXhpcywgaGFzQnRtQXhpcywgaGFzTGZ0QXhpc10gPSBzaWRlc1dpdGhBeGVzO1xuXG5cdFx0bGV0IG9yaSA9IHNpZGUgJSAyO1xuXHRcdGxldCBzaXplID0gMDtcblxuXHRcdGlmIChvcmkgPT0gMCAmJiAoaGFzTGZ0QXhpcyB8fCBoYXNSZ3RBeGlzKSlcblx0XHRcdHNpemUgPSAoc2lkZSA9PSAwICYmICFoYXNUb3BBeGlzIHx8IHNpZGUgPT0gMiAmJiAhaGFzQnRtQXhpcyA/IHJvdW5kKHhBeGlzT3B0cy5zaXplIC8gMykgOiAwKTtcblx0XHRpZiAob3JpID09IDEgJiYgKGhhc1RvcEF4aXMgfHwgaGFzQnRtQXhpcykpXG5cdFx0XHRzaXplID0gKHNpZGUgPT0gMSAmJiAhaGFzUmd0QXhpcyB8fCBzaWRlID09IDMgJiYgIWhhc0xmdEF4aXMgPyByb3VuZCh5QXhpc09wdHMuc2l6ZSAvIDIpIDogMCk7XG5cblx0XHRyZXR1cm4gc2l6ZTtcblx0fVxuXG5cdGNvbnN0IHBhZGRpbmcgPSBzZWxmLnBhZGRpbmcgPSAob3B0cy5wYWRkaW5nIHx8IFthdXRvUGFkU2lkZSxhdXRvUGFkU2lkZSxhdXRvUGFkU2lkZSxhdXRvUGFkU2lkZV0pLm1hcChwID0+IGZuT3JTZWxmKGlmTnVsbChwLCBhdXRvUGFkU2lkZSkpKTtcblx0Y29uc3QgX3BhZGRpbmcgPSBzZWxmLl9wYWRkaW5nID0gcGFkZGluZy5tYXAoKHAsIGkpID0+IHAoc2VsZiwgaSwgc2lkZXNXaXRoQXhlcywgMCkpO1xuXG5cdGxldCBkYXRhTGVuO1xuXG5cdC8vIHJlbmRlcmVkIGRhdGEgd2luZG93XG5cdGxldCBpMCA9IG51bGw7XG5cdGxldCBpMSA9IG51bGw7XG5cdGNvbnN0IGlkeHMgPSBtb2RlID09IDEgPyBzZXJpZXNbMF0uaWR4cyA6IG51bGw7XG5cblx0bGV0IGRhdGEwID0gbnVsbDtcblxuXHRsZXQgdmlhQXV0b1NjYWxlWCA9IGZhbHNlO1xuXG5cdGZ1bmN0aW9uIHNldERhdGEoX2RhdGEsIF9yZXNldFNjYWxlcykge1xuXHRcdGRhdGEgPSBfZGF0YSA9PSBudWxsID8gW10gOiBjb3B5KF9kYXRhLCBmYXN0SXNPYmopO1xuXG5cdFx0aWYgKG1vZGUgPT0gMikge1xuXHRcdFx0ZGF0YUxlbiA9IDA7XG5cdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKylcblx0XHRcdFx0ZGF0YUxlbiArPSBkYXRhW2ldWzBdLmxlbmd0aDtcblx0XHRcdHNlbGYuZGF0YSA9IGRhdGEgPSBfZGF0YTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAoZGF0YVswXSA9PSBudWxsKVxuXHRcdFx0XHRkYXRhWzBdID0gW107XG5cblx0XHRcdHNlbGYuZGF0YSA9IGRhdGEuc2xpY2UoKTtcblxuXHRcdFx0ZGF0YTAgPSBkYXRhWzBdO1xuXHRcdFx0ZGF0YUxlbiA9IGRhdGEwLmxlbmd0aDtcblxuXHRcdFx0aWYgKHhTY2FsZURpc3RyID09IDIpIHtcblx0XHRcdFx0ZGF0YVswXSA9IEFycmF5KGRhdGFMZW4pO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFMZW47IGkrKylcblx0XHRcdFx0XHRkYXRhWzBdW2ldID0gaTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZWxmLl9kYXRhID0gZGF0YTtcblxuXHRcdHJlc2V0WVNlcmllcyh0cnVlKTtcblxuXHRcdGZpcmUoXCJzZXREYXRhXCIpO1xuXG5cdFx0Ly8gZm9yY2VzIHggYXhpcyB0aWNrIHZhbHVlcyB0byByZS1nZW5lcmF0ZSB3aGVuIG5laXRoZXIgeCBzY2FsZSBub3IgeSBzY2FsZSBjaGFuZ2VzXG5cdFx0Ly8gaW4gb3JkaW5hbCBtb2RlLCBzY2FsZSByYW5nZSBpcyBieSBpbmRleCwgc28gd2lsbCBub3QgY2hhbmdlIGlmIG5ldyBkYXRhIGhhcyBzYW1lIGxlbmd0aCwgYnV0IHRpY2sgdmFsdWVzIGFyZSBmcm9tIGRhdGFcblx0XHRpZiAoeFNjYWxlRGlzdHIgPT0gMikge1xuXHRcdFx0c2hvdWxkQ29udmVyZ2VTaXplID0gdHJ1ZTtcblxuXHRcdFx0Lyogb3Igc29tZXdoYXQgY2hlYXBlciwgYW5kIHVnbGllcjpcblx0XHRcdGlmIChyZWFkeSkge1xuXHRcdFx0XHQvLyBsb2dpYyBleHRyYWN0ZWQgZnJvbSBheGVzQ2FsYygpXG5cdFx0XHRcdGxldCBpID0gMDtcblx0XHRcdFx0bGV0IGF4aXMgPSBheGVzW2ldO1xuXHRcdFx0XHRsZXQgX3NwbGl0cyA9IGF4aXMuX3NwbGl0cy5tYXAoaSA9PiBkYXRhMFtpXSk7XG5cdFx0XHRcdGxldCBbX2luY3IsIF9zcGFjZV0gPSBheGlzLl9mb3VuZDtcblx0XHRcdFx0bGV0IGluY3IgPSBkYXRhMFtfc3BsaXRzWzFdXSAtIGRhdGEwW19zcGxpdHNbMF1dO1xuXHRcdFx0XHRheGlzLl92YWx1ZXMgPSBheGlzLnZhbHVlcyhzZWxmLCBheGlzLmZpbHRlcihzZWxmLCBfc3BsaXRzLCBpLCBfc3BhY2UsIGluY3IpLCBpLCBfc3BhY2UsIGluY3IpO1xuXHRcdFx0fVxuXHRcdFx0Ki9cblx0XHR9XG5cblx0XHRpZiAoX3Jlc2V0U2NhbGVzICE9PSBmYWxzZSkge1xuXHRcdFx0bGV0IHhzYyA9IHNjYWxlWDtcblxuXHRcdFx0aWYgKHhzYy5hdXRvKHNlbGYsIHZpYUF1dG9TY2FsZVgpKVxuXHRcdFx0XHRhdXRvU2NhbGVYKCk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdF9zZXRTY2FsZSh4U2NhbGVLZXksIHhzYy5taW4sIHhzYy5tYXgpO1xuXG5cdFx0XHRzaG91bGRTZXRDdXJzb3IgPSBjdXJzb3IubGVmdCA+PSAwO1xuXHRcdFx0c2hvdWxkU2V0TGVnZW5kID0gdHJ1ZTtcblx0XHRcdGNvbW1pdCgpO1xuXHRcdH1cblx0fVxuXG5cdHNlbGYuc2V0RGF0YSA9IHNldERhdGE7XG5cblx0ZnVuY3Rpb24gYXV0b1NjYWxlWCgpIHtcblx0XHR2aWFBdXRvU2NhbGVYID0gdHJ1ZTtcblxuXHRcdGxldCBfbWluLCBfbWF4O1xuXG5cdFx0aWYgKG1vZGUgPT0gMSkge1xuXHRcdFx0aWYgKGRhdGFMZW4gPiAwKSB7XG5cdFx0XHRcdGkwID0gaWR4c1swXSA9IDA7XG5cdFx0XHRcdGkxID0gaWR4c1sxXSA9IGRhdGFMZW4gLSAxO1xuXG5cdFx0XHRcdF9taW4gPSBkYXRhWzBdW2kwXTtcblx0XHRcdFx0X21heCA9IGRhdGFbMF1baTFdO1xuXG5cdFx0XHRcdGlmICh4U2NhbGVEaXN0ciA9PSAyKSB7XG5cdFx0XHRcdFx0X21pbiA9IGkwO1xuXHRcdFx0XHRcdF9tYXggPSBpMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChkYXRhTGVuID09IDEpIHtcblx0XHRcdFx0XHRpZiAoeFNjYWxlRGlzdHIgPT0gMylcblx0XHRcdFx0XHRcdFtfbWluLCBfbWF4XSA9IHJhbmdlTG9nKF9taW4sIF9taW4sIHNjYWxlWC5sb2csIGZhbHNlKTtcblx0XHRcdFx0XHRlbHNlIGlmICh4U2NhbGVEaXN0ciA9PSA0KVxuXHRcdFx0XHRcdFx0W19taW4sIF9tYXhdID0gcmFuZ2VBc2luaChfbWluLCBfbWluLCBzY2FsZVgubG9nLCBmYWxzZSk7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoc2NhbGVYLnRpbWUpXG5cdFx0XHRcdFx0XHRfbWF4ID0gX21pbiArIHJvdW5kKDg2NDAwIC8gbXMpO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFtfbWluLCBfbWF4XSA9IHJhbmdlTnVtKF9taW4sIF9tYXgsIHJhbmdlUGFkLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGkwID0gaWR4c1swXSA9IF9taW4gPSBudWxsO1xuXHRcdFx0XHRpMSA9IGlkeHNbMV0gPSBfbWF4ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRfc2V0U2NhbGUoeFNjYWxlS2V5LCBfbWluLCBfbWF4KTtcblx0fVxuXG5cdGxldCBjdHhTdHJva2UsIGN0eEZpbGwsIGN0eFdpZHRoLCBjdHhEYXNoLCBjdHhKb2luLCBjdHhDYXAsIGN0eEZvbnQsIGN0eEFsaWduLCBjdHhCYXNlbGluZTtcblx0bGV0IGN0eEFscGhhO1xuXG5cdGZ1bmN0aW9uIHNldEN0eFN0eWxlKHN0cm9rZSA9IHRyYW5zcGFyZW50LCB3aWR0aCwgZGFzaCA9IEVNUFRZX0FSUiwgY2FwID0gXCJidXR0XCIsIGZpbGwgPSB0cmFuc3BhcmVudCwgam9pbiA9IFwicm91bmRcIikge1xuXHRcdGlmIChzdHJva2UgIT0gY3R4U3Ryb2tlKVxuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY3R4U3Ryb2tlID0gc3Ryb2tlO1xuXHRcdGlmIChmaWxsICE9IGN0eEZpbGwpXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gY3R4RmlsbCA9IGZpbGw7XG5cdFx0aWYgKHdpZHRoICE9IGN0eFdpZHRoKVxuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IGN0eFdpZHRoID0gd2lkdGg7XG5cdFx0aWYgKGpvaW4gIT0gY3R4Sm9pbilcblx0XHRcdGN0eC5saW5lSm9pbiA9IGN0eEpvaW4gPSBqb2luO1xuXHRcdGlmIChjYXAgIT0gY3R4Q2FwKVxuXHRcdFx0Y3R4LmxpbmVDYXAgPSBjdHhDYXAgPSBjYXA7IC8vIChcdTIwM0Z8XHUyMDNGKVxuXHRcdGlmIChkYXNoICE9IGN0eERhc2gpXG5cdFx0XHRjdHguc2V0TGluZURhc2goY3R4RGFzaCA9IGRhc2gpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0Rm9udFN0eWxlKGZvbnQsIGZpbGwsIGFsaWduLCBiYXNlbGluZSkge1xuXHRcdGlmIChmaWxsICE9IGN0eEZpbGwpXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gY3R4RmlsbCA9IGZpbGw7XG5cdFx0aWYgKGZvbnQgIT0gY3R4Rm9udClcblx0XHRcdGN0eC5mb250ID0gY3R4Rm9udCA9IGZvbnQ7XG5cdFx0aWYgKGFsaWduICE9IGN0eEFsaWduKVxuXHRcdFx0Y3R4LnRleHRBbGlnbiA9IGN0eEFsaWduID0gYWxpZ247XG5cdFx0aWYgKGJhc2VsaW5lICE9IGN0eEJhc2VsaW5lKVxuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IGN0eEJhc2VsaW5lID0gYmFzZWxpbmU7XG5cdH1cblxuXHRmdW5jdGlvbiBhY2NTY2FsZSh3c2MsIHBzYywgZmFjZXQsIGRhdGEsIHNvcnRlZCA9IDApIHtcblx0XHRpZiAoZGF0YS5sZW5ndGggPiAwICYmIHdzYy5hdXRvKHNlbGYsIHZpYUF1dG9TY2FsZVgpICYmIChwc2MgPT0gbnVsbCB8fCBwc2MubWluID09IG51bGwpKSB7XG5cdFx0XHRsZXQgX2kwID0gaWZOdWxsKGkwLCAwKTtcblx0XHRcdGxldCBfaTEgPSBpZk51bGwoaTEsIGRhdGEubGVuZ3RoIC0gMSk7XG5cblx0XHRcdC8vIG9ubHkgcnVuIGdldE1pbk1heCgpIGZvciBpbnZhbGlkYXRlZCBzZXJpZXMgZGF0YSwgZWxzZSByZXVzZVxuXHRcdFx0bGV0IG1pbk1heCA9IGZhY2V0Lm1pbiA9PSBudWxsID8gKHdzYy5kaXN0ciA9PSAzID8gZ2V0TWluTWF4TG9nKGRhdGEsIF9pMCwgX2kxKSA6IGdldE1pbk1heChkYXRhLCBfaTAsIF9pMSwgc29ydGVkKSkgOiBbZmFjZXQubWluLCBmYWNldC5tYXhdO1xuXG5cdFx0XHQvLyBpbml0aWFsIG1pbi9tYXhcblx0XHRcdHdzYy5taW4gPSBtaW4od3NjLm1pbiwgZmFjZXQubWluID0gbWluTWF4WzBdKTtcblx0XHRcdHdzYy5tYXggPSBtYXgod3NjLm1heCwgZmFjZXQubWF4ID0gbWluTWF4WzFdKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTY2FsZXMoKSB7XG5cdC8vXHRsb2coXCJzZXRTY2FsZXMoKVwiLCBhcmd1bWVudHMpO1xuXG5cdFx0Ly8gd2lwIHNjYWxlc1xuXHRcdGxldCB3aXBTY2FsZXMgPSBjb3B5KHNjYWxlcywgZmFzdElzT2JqKTtcblxuXHRcdGZvciAobGV0IGsgaW4gd2lwU2NhbGVzKSB7XG5cdFx0XHRsZXQgd3NjID0gd2lwU2NhbGVzW2tdO1xuXHRcdFx0bGV0IHBzYyA9IHBlbmRTY2FsZXNba107XG5cblx0XHRcdGlmIChwc2MgIT0gbnVsbCAmJiBwc2MubWluICE9IG51bGwpIHtcblx0XHRcdFx0YXNzaWduKHdzYywgcHNjKTtcblxuXHRcdFx0XHQvLyBleHBsaWNpdGx5IHNldHRpbmcgdGhlIHgtc2NhbGUgaW52YWxpZGF0ZXMgZXZlcnl0aGluZyAoYWN0cyBhcyByZWRyYXcpXG5cdFx0XHRcdGlmIChrID09IHhTY2FsZUtleSlcblx0XHRcdFx0XHRyZXNldFlTZXJpZXModHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChrICE9IHhTY2FsZUtleSB8fCBtb2RlID09IDIpIHtcblx0XHRcdFx0aWYgKGRhdGFMZW4gPT0gMCAmJiB3c2MuZnJvbSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0bGV0IG1pbk1heCA9IHdzYy5yYW5nZShzZWxmLCBudWxsLCBudWxsLCBrKTtcblx0XHRcdFx0XHR3c2MubWluID0gbWluTWF4WzBdO1xuXHRcdFx0XHRcdHdzYy5tYXggPSBtaW5NYXhbMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0d3NjLm1pbiA9IGluZjtcblx0XHRcdFx0XHR3c2MubWF4ID0gLWluZjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChkYXRhTGVuID4gMCkge1xuXHRcdFx0Ly8gcHJlLXJhbmdlIHktc2NhbGVzIGZyb20geSBzZXJpZXMnIGRhdGEgdmFsdWVzXG5cdFx0XHRzZXJpZXMuZm9yRWFjaCgocywgaSkgPT4ge1xuXHRcdFx0XHRpZiAobW9kZSA9PSAxKSB7XG5cdFx0XHRcdFx0bGV0IGsgPSBzLnNjYWxlO1xuXHRcdFx0XHRcdGxldCB3c2MgPSB3aXBTY2FsZXNba107XG5cdFx0XHRcdFx0bGV0IHBzYyA9IHBlbmRTY2FsZXNba107XG5cblx0XHRcdFx0XHRpZiAoaSA9PSAwKSB7XG5cdFx0XHRcdFx0XHRsZXQgbWluTWF4ID0gd3NjLnJhbmdlKHNlbGYsIHdzYy5taW4sIHdzYy5tYXgsIGspO1xuXG5cdFx0XHRcdFx0XHR3c2MubWluID0gbWluTWF4WzBdO1xuXHRcdFx0XHRcdFx0d3NjLm1heCA9IG1pbk1heFsxXTtcblxuXHRcdFx0XHRcdFx0aTAgPSBjbG9zZXN0SWR4KHdzYy5taW4sIGRhdGFbMF0pO1xuXHRcdFx0XHRcdFx0aTEgPSBjbG9zZXN0SWR4KHdzYy5tYXgsIGRhdGFbMF0pO1xuXG5cdFx0XHRcdFx0XHQvLyBjbG9zZXN0IGluZGljZXMgY2FuIGJlIG91dHNpZGUgb2Ygdmlld1xuXHRcdFx0XHRcdFx0aWYgKGRhdGFbMF1baTBdIDwgd3NjLm1pbilcblx0XHRcdFx0XHRcdFx0aTArKztcblx0XHRcdFx0XHRcdGlmIChkYXRhWzBdW2kxXSA+IHdzYy5tYXgpXG5cdFx0XHRcdFx0XHRcdGkxLS07XG5cblx0XHRcdFx0XHRcdHMubWluID0gZGF0YTBbaTBdO1xuXHRcdFx0XHRcdFx0cy5tYXggPSBkYXRhMFtpMV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKHMuc2hvdyAmJiBzLmF1dG8pXG5cdFx0XHRcdFx0XHRhY2NTY2FsZSh3c2MsIHBzYywgcywgZGF0YVtpXSwgcy5zb3J0ZWQpO1xuXG5cdFx0XHRcdFx0cy5pZHhzWzBdID0gaTA7XG5cdFx0XHRcdFx0cy5pZHhzWzFdID0gaTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdFx0XHRpZiAocy5zaG93ICYmIHMuYXV0bykge1xuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBvbmx5IGhhbmRsZXMsIGFzc3VtZXMgYW5kIHJlcXVpcmVzIGZhY2V0c1swXSAvICd4JyBzY2FsZSwgYW5kIGZhY2V0c1sxXSAvICd5JyBzY2FsZVxuXHRcdFx0XHRcdFx0XHRsZXQgWyB4RmFjZXQsIHlGYWNldCBdID0gcy5mYWNldHM7XG5cdFx0XHRcdFx0XHRcdGxldCB4U2NhbGVLZXkgPSB4RmFjZXQuc2NhbGU7XG5cdFx0XHRcdFx0XHRcdGxldCB5U2NhbGVLZXkgPSB5RmFjZXQuc2NhbGU7XG5cdFx0XHRcdFx0XHRcdGxldCBbIHhEYXRhLCB5RGF0YSBdID0gZGF0YVtpXTtcblxuXHRcdFx0XHRcdFx0XHRhY2NTY2FsZSh3aXBTY2FsZXNbeFNjYWxlS2V5XSwgcGVuZFNjYWxlc1t4U2NhbGVLZXldLCB4RmFjZXQsIHhEYXRhLCB4RmFjZXQuc29ydGVkKTtcblx0XHRcdFx0XHRcdFx0YWNjU2NhbGUod2lwU2NhbGVzW3lTY2FsZUtleV0sIHBlbmRTY2FsZXNbeVNjYWxlS2V5XSwgeUZhY2V0LCB5RGF0YSwgeUZhY2V0LnNvcnRlZCk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gdGVtcFxuXHRcdFx0XHRcdFx0XHRzLm1pbiA9IHlGYWNldC5taW47XG5cdFx0XHRcdFx0XHRcdHMubWF4ID0geUZhY2V0Lm1heDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyByYW5nZSBpbmRlcGVuZGVudCBzY2FsZXNcblx0XHRcdGZvciAobGV0IGsgaW4gd2lwU2NhbGVzKSB7XG5cdFx0XHRcdGxldCB3c2MgPSB3aXBTY2FsZXNba107XG5cdFx0XHRcdGxldCBwc2MgPSBwZW5kU2NhbGVzW2tdO1xuXG5cdFx0XHRcdGlmICh3c2MuZnJvbSA9PSBudWxsICYmIChwc2MgPT0gbnVsbCB8fCBwc2MubWluID09IG51bGwpKSB7XG5cdFx0XHRcdFx0bGV0IG1pbk1heCA9IHdzYy5yYW5nZShcblx0XHRcdFx0XHRcdHNlbGYsXG5cdFx0XHRcdFx0XHR3c2MubWluID09ICBpbmYgPyBudWxsIDogd3NjLm1pbixcblx0XHRcdFx0XHRcdHdzYy5tYXggPT0gLWluZiA/IG51bGwgOiB3c2MubWF4LFxuXHRcdFx0XHRcdFx0a1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0d3NjLm1pbiA9IG1pbk1heFswXTtcblx0XHRcdFx0XHR3c2MubWF4ID0gbWluTWF4WzFdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcmFuZ2UgZGVwZW5kZW50IHNjYWxlc1xuXHRcdGZvciAobGV0IGsgaW4gd2lwU2NhbGVzKSB7XG5cdFx0XHRsZXQgd3NjID0gd2lwU2NhbGVzW2tdO1xuXG5cdFx0XHRpZiAod3NjLmZyb20gIT0gbnVsbCkge1xuXHRcdFx0XHRsZXQgYmFzZSA9IHdpcFNjYWxlc1t3c2MuZnJvbV07XG5cblx0XHRcdFx0aWYgKGJhc2UubWluID09IG51bGwpXG5cdFx0XHRcdFx0d3NjLm1pbiA9IHdzYy5tYXggPSBudWxsO1xuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRsZXQgbWluTWF4ID0gd3NjLnJhbmdlKHNlbGYsIGJhc2UubWluLCBiYXNlLm1heCwgayk7XG5cdFx0XHRcdFx0d3NjLm1pbiA9IG1pbk1heFswXTtcblx0XHRcdFx0XHR3c2MubWF4ID0gbWluTWF4WzFdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IGNoYW5nZWQgPSB7fTtcblx0XHRsZXQgYW55Q2hhbmdlZCA9IGZhbHNlO1xuXG5cdFx0Zm9yIChsZXQgayBpbiB3aXBTY2FsZXMpIHtcblx0XHRcdGxldCB3c2MgPSB3aXBTY2FsZXNba107XG5cdFx0XHRsZXQgc2MgPSBzY2FsZXNba107XG5cblx0XHRcdGlmIChzYy5taW4gIT0gd3NjLm1pbiB8fCBzYy5tYXggIT0gd3NjLm1heCkge1xuXHRcdFx0XHRzYy5taW4gPSB3c2MubWluO1xuXHRcdFx0XHRzYy5tYXggPSB3c2MubWF4O1xuXG5cdFx0XHRcdGxldCBkaXN0ciA9IHNjLmRpc3RyO1xuXG5cdFx0XHRcdHNjLl9taW4gPSBkaXN0ciA9PSAzID8gbG9nMTAoc2MubWluKSA6IGRpc3RyID09IDQgPyBhc2luaChzYy5taW4sIHNjLmFzaW5oKSA6IHNjLm1pbjtcblx0XHRcdFx0c2MuX21heCA9IGRpc3RyID09IDMgPyBsb2cxMChzYy5tYXgpIDogZGlzdHIgPT0gNCA/IGFzaW5oKHNjLm1heCwgc2MuYXNpbmgpIDogc2MubWF4O1xuXG5cdFx0XHRcdGNoYW5nZWRba10gPSBhbnlDaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoYW55Q2hhbmdlZCkge1xuXHRcdFx0Ly8gaW52YWxpZGF0ZSBwYXRocyBvZiBhbGwgc2VyaWVzIG9uIGNoYW5nZWQgc2NhbGVzXG5cdFx0XHRzZXJpZXMuZm9yRWFjaCgocywgaSkgPT4ge1xuXHRcdFx0XHRpZiAobW9kZSA9PSAyKSB7XG5cdFx0XHRcdFx0aWYgKGkgPiAwICYmIGNoYW5nZWQueSlcblx0XHRcdFx0XHRcdHMuX3BhdGhzID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoY2hhbmdlZFtzLnNjYWxlXSlcblx0XHRcdFx0XHRcdHMuX3BhdGhzID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGZvciAobGV0IGsgaW4gY2hhbmdlZCkge1xuXHRcdFx0XHRzaG91bGRDb252ZXJnZVNpemUgPSB0cnVlO1xuXHRcdFx0XHRmaXJlKFwic2V0U2NhbGVcIiwgayk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjdXJzb3Iuc2hvdylcblx0XHRcdFx0c2hvdWxkU2V0Q3Vyc29yID0gc2hvdWxkU2V0TGVnZW5kID0gY3Vyc29yLmxlZnQgPj0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGxldCBrIGluIHBlbmRTY2FsZXMpXG5cdFx0XHRwZW5kU2NhbGVzW2tdID0gbnVsbDtcblx0fVxuXG5cdC8vIGdyYWJzIHRoZSBuZWFyZXN0IGluZGljZXMgd2l0aCB5IGRhdGEgb3V0c2lkZSBvZiB4LXNjYWxlIGxpbWl0c1xuXHRmdW5jdGlvbiBnZXRPdXRlcklkeHMoeWRhdGEpIHtcblx0XHRsZXQgX2kwID0gY2xhbXAoaTAgLSAxLCAwLCBkYXRhTGVuIC0gMSk7XG5cdFx0bGV0IF9pMSA9IGNsYW1wKGkxICsgMSwgMCwgZGF0YUxlbiAtIDEpO1xuXG5cdFx0d2hpbGUgKHlkYXRhW19pMF0gPT0gbnVsbCAmJiBfaTAgPiAwKVxuXHRcdFx0X2kwLS07XG5cblx0XHR3aGlsZSAoeWRhdGFbX2kxXSA9PSBudWxsICYmIF9pMSA8IGRhdGFMZW4gLSAxKVxuXHRcdFx0X2kxKys7XG5cblx0XHRyZXR1cm4gW19pMCwgX2kxXTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRyYXdTZXJpZXMoKSB7XG5cdFx0aWYgKGRhdGFMZW4gPiAwKSB7XG5cdFx0XHRzZXJpZXMuZm9yRWFjaCgocywgaSkgPT4ge1xuXHRcdFx0XHRpZiAoaSA+IDAgJiYgcy5zaG93ICYmIHMuX3BhdGhzID09IG51bGwpIHtcblx0XHRcdFx0XHRsZXQgX2lkeHMgPSBnZXRPdXRlcklkeHMoZGF0YVtpXSk7XG5cdFx0XHRcdFx0cy5fcGF0aHMgPSBzLnBhdGhzKHNlbGYsIGksIF9pZHhzWzBdLCBfaWR4c1sxXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRzZXJpZXMuZm9yRWFjaCgocywgaSkgPT4ge1xuXHRcdFx0XHRpZiAoaSA+IDAgJiYgcy5zaG93KSB7XG5cdFx0XHRcdFx0aWYgKGN0eEFscGhhICE9IHMuYWxwaGEpXG5cdFx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBjdHhBbHBoYSA9IHMuYWxwaGE7XG5cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjYWNoZVN0cm9rZUZpbGwoaSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0cy5fcGF0aHMgJiYgZHJhd1BhdGgoaSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNhY2hlU3Ryb2tlRmlsbChpLCB0cnVlKTtcblxuXHRcdFx0XHRcdFx0bGV0IHNob3cgPSBzLnBvaW50cy5zaG93KHNlbGYsIGksIGkwLCBpMSk7XG5cdFx0XHRcdFx0XHRsZXQgaWR4cyA9IHMucG9pbnRzLmZpbHRlcihzZWxmLCBpLCBzaG93LCBzLl9wYXRocyA/IHMuX3BhdGhzLmdhcHMgOiBudWxsKTtcblxuXHRcdFx0XHRcdFx0aWYgKHNob3cgfHwgaWR4cykge1xuXHRcdFx0XHRcdFx0XHRzLnBvaW50cy5fcGF0aHMgPSBzLnBvaW50cy5wYXRocyhzZWxmLCBpLCBpMCwgaTEsIGlkeHMpO1xuXHRcdFx0XHRcdFx0XHRkcmF3UGF0aChpLCB0cnVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoY3R4QWxwaGEgIT0gMSlcblx0XHRcdFx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IGN0eEFscGhhID0gMTtcblxuXHRcdFx0XHRcdGZpcmUoXCJkcmF3U2VyaWVzXCIsIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjYWNoZVN0cm9rZUZpbGwoc2ksIF9wb2ludHMpIHtcblx0XHRsZXQgcyA9IF9wb2ludHMgPyBzZXJpZXNbc2ldLnBvaW50cyA6IHNlcmllc1tzaV07XG5cblx0XHRzLl9zdHJva2UgPSBzLnN0cm9rZShzZWxmLCBzaSk7XG5cdFx0cy5fZmlsbCAgID0gcy5maWxsKHNlbGYsIHNpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRyYXdQYXRoKHNpLCBfcG9pbnRzKSB7XG5cdFx0bGV0IHMgPSBfcG9pbnRzID8gc2VyaWVzW3NpXS5wb2ludHMgOiBzZXJpZXNbc2ldO1xuXG5cdFx0bGV0IHN0cm9rZVN0eWxlID0gcy5fc3Ryb2tlO1xuXHRcdGxldCBmaWxsU3R5bGUgICA9IHMuX2ZpbGw7XG5cblx0XHRsZXQgeyBzdHJva2UsIGZpbGwsIGNsaXA6IGdhcHNDbGlwLCBmbGFncyB9ID0gcy5fcGF0aHM7XG5cdFx0bGV0IGJvdW5kc0NsaXAgPSBudWxsO1xuXHRcdGxldCB3aWR0aCA9IHJvdW5kRGVjKHMud2lkdGggKiBweFJhdGlvLCAzKTtcblx0XHRsZXQgb2Zmc2V0ID0gKHdpZHRoICUgMikgLyAyO1xuXG5cdFx0aWYgKF9wb2ludHMgJiYgZmlsbFN0eWxlID09IG51bGwpXG5cdFx0XHRmaWxsU3R5bGUgPSB3aWR0aCA+IDAgPyBcIiNmZmZcIiA6IHN0cm9rZVN0eWxlO1xuXG5cdFx0bGV0IF9weEFsaWduID0gcy5weEFsaWduID09IDE7XG5cblx0XHRfcHhBbGlnbiAmJiBjdHgudHJhbnNsYXRlKG9mZnNldCwgb2Zmc2V0KTtcblxuXHRcdGlmICghX3BvaW50cykge1xuXHRcdFx0bGV0IGxmdCA9IHBsb3RMZnQsXG5cdFx0XHRcdHRvcCA9IHBsb3RUb3AsXG5cdFx0XHRcdHdpZCA9IHBsb3RXaWQsXG5cdFx0XHRcdGhndCA9IHBsb3RIZ3Q7XG5cblx0XHRcdGxldCBoYWxmV2lkID0gd2lkdGggKiBweFJhdGlvIC8gMjtcblxuXHRcdFx0aWYgKHMubWluID09IDApXG5cdFx0XHRcdGhndCArPSBoYWxmV2lkO1xuXG5cdFx0XHRpZiAocy5tYXggPT0gMCkge1xuXHRcdFx0XHR0b3AgLT0gaGFsZldpZDtcblx0XHRcdFx0aGd0ICs9IGhhbGZXaWQ7XG5cdFx0XHR9XG5cblx0XHRcdGJvdW5kc0NsaXAgPSBuZXcgUGF0aDJEKCk7XG5cdFx0XHRib3VuZHNDbGlwLnJlY3QobGZ0LCB0b3AsIHdpZCwgaGd0KTtcblx0XHR9XG5cblx0XHQvLyB0aGUgcG9pbnRzIHBhdGhidWlsZGVyJ3MgZ2Fwc0NsaXAgaXMgaXRzIGJvdW5kc0NsaXAsIHNpbmNlIHBvaW50cyBkb250IG5lZWQgZ2FwcyBjbGlwcGluZywgYW5kIGJvdW5kcyBkZXBlbmQgb24gcG9pbnQgc2l6ZVxuXHRcdGlmIChfcG9pbnRzKVxuXHRcdFx0c3Ryb2tlRmlsbChzdHJva2VTdHlsZSwgd2lkdGgsIHMuZGFzaCwgcy5jYXAsIGZpbGxTdHlsZSwgc3Ryb2tlLCBmaWxsLCBmbGFncywgZ2Fwc0NsaXApO1xuXHRcdGVsc2Vcblx0XHRcdGZpbGxTdHJva2Uoc2ksIHN0cm9rZVN0eWxlLCB3aWR0aCwgcy5kYXNoLCBzLmNhcCwgZmlsbFN0eWxlLCBzdHJva2UsIGZpbGwsIGZsYWdzLCBib3VuZHNDbGlwLCBnYXBzQ2xpcCk7XG5cblx0XHRfcHhBbGlnbiAmJiBjdHgudHJhbnNsYXRlKC1vZmZzZXQsIC1vZmZzZXQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZmlsbFN0cm9rZShzaSwgc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCwgbGluZURhc2gsIGxpbmVDYXAsIGZpbGxTdHlsZSwgc3Ryb2tlUGF0aCwgZmlsbFBhdGgsIGZsYWdzLCBib3VuZHNDbGlwLCBnYXBzQ2xpcCkge1xuXHRcdGxldCBkaWRTdHJva2VGaWxsID0gZmFsc2U7XG5cblx0XHQvLyBmb3IgYWxsIGJhbmRzIHdoZXJlIHRoaXMgc2VyaWVzIGlzIHRoZSB0b3AgZWRnZSwgY3JlYXRlIHVwd2FyZHMgY2xpcHMgdXNpbmcgdGhlIGJvdHRvbSBlZGdlc1xuXHRcdC8vIGFuZCBhcHBseSBjbGlwcyArIGZpbGwgd2l0aCBiYW5kIGZpbGwgb3IgZGZsdEZpbGxcblx0XHRiYW5kcy5mb3JFYWNoKChiLCBiaSkgPT4ge1xuXHRcdFx0Ly8gaXNVcHBlckVkZ2U/XG5cdFx0XHRpZiAoYi5zZXJpZXNbMF0gPT0gc2kpIHtcblx0XHRcdFx0bGV0IGxvd2VyRWRnZSA9IHNlcmllc1tiLnNlcmllc1sxXV07XG5cdFx0XHRcdGxldCBsb3dlckRhdGEgPSBkYXRhW2Iuc2VyaWVzWzFdXTtcblxuXHRcdFx0XHRsZXQgYmFuZENsaXAgPSAobG93ZXJFZGdlLl9wYXRocyB8fCBFTVBUWV9PQkopLmJhbmQ7XG5cblx0XHRcdFx0aWYgKGlzQXJyKGJhbmRDbGlwKSlcblx0XHRcdFx0XHRiYW5kQ2xpcCA9IGIuZGlyID09IDEgPyBiYW5kQ2xpcFswXSA6IGJhbmRDbGlwWzFdO1xuXG5cdFx0XHRcdGxldCBnYXBzQ2xpcDI7XG5cblx0XHRcdFx0bGV0IF9maWxsU3R5bGUgPSBudWxsO1xuXG5cdFx0XHRcdC8vIGhhc0xvd2VyRWRnZT9cblx0XHRcdFx0aWYgKGxvd2VyRWRnZS5zaG93ICYmIGJhbmRDbGlwICYmIGhhc0RhdGEobG93ZXJEYXRhLCBpMCwgaTEpKSB7XG5cdFx0XHRcdFx0X2ZpbGxTdHlsZSA9IGIuZmlsbChzZWxmLCBiaSkgfHwgZmlsbFN0eWxlO1xuXHRcdFx0XHRcdGdhcHNDbGlwMiA9IGxvd2VyRWRnZS5fcGF0aHMuY2xpcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0YmFuZENsaXAgPSBudWxsO1xuXG5cdFx0XHRcdHN0cm9rZUZpbGwoc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCwgbGluZURhc2gsIGxpbmVDYXAsIF9maWxsU3R5bGUsIHN0cm9rZVBhdGgsIGZpbGxQYXRoLCBmbGFncywgYm91bmRzQ2xpcCwgZ2Fwc0NsaXAsIGdhcHNDbGlwMiwgYmFuZENsaXApO1xuXG5cdFx0XHRcdGRpZFN0cm9rZUZpbGwgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKCFkaWRTdHJva2VGaWxsKVxuXHRcdFx0c3Ryb2tlRmlsbChzdHJva2VTdHlsZSwgbGluZVdpZHRoLCBsaW5lRGFzaCwgbGluZUNhcCwgZmlsbFN0eWxlLCBzdHJva2VQYXRoLCBmaWxsUGF0aCwgZmxhZ3MsIGJvdW5kc0NsaXAsIGdhcHNDbGlwKTtcblx0fVxuXG5cdGNvbnN0IENMSVBfRklMTF9TVFJPS0UgPSBCQU5EX0NMSVBfRklMTCB8IEJBTkRfQ0xJUF9TVFJPS0U7XG5cblx0ZnVuY3Rpb24gc3Ryb2tlRmlsbChzdHJva2VTdHlsZSwgbGluZVdpZHRoLCBsaW5lRGFzaCwgbGluZUNhcCwgZmlsbFN0eWxlLCBzdHJva2VQYXRoLCBmaWxsUGF0aCwgZmxhZ3MsIGJvdW5kc0NsaXAsIGdhcHNDbGlwLCBnYXBzQ2xpcDIsIGJhbmRDbGlwKSB7XG5cdFx0c2V0Q3R4U3R5bGUoc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCwgbGluZURhc2gsIGxpbmVDYXAsIGZpbGxTdHlsZSk7XG5cblx0XHRpZiAoYm91bmRzQ2xpcCB8fCBnYXBzQ2xpcCB8fCBiYW5kQ2xpcCkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGJvdW5kc0NsaXAgJiYgY3R4LmNsaXAoYm91bmRzQ2xpcCk7XG5cdFx0XHRnYXBzQ2xpcCAmJiBjdHguY2xpcChnYXBzQ2xpcCk7XG5cdFx0fVxuXG5cdFx0aWYgKGJhbmRDbGlwKSB7XG5cdFx0XHRpZiAoKGZsYWdzICYgQ0xJUF9GSUxMX1NUUk9LRSkgPT0gQ0xJUF9GSUxMX1NUUk9LRSkge1xuXHRcdFx0XHRjdHguY2xpcChiYW5kQ2xpcCk7XG5cdFx0XHRcdGdhcHNDbGlwMiAmJiBjdHguY2xpcChnYXBzQ2xpcDIpO1xuXHRcdFx0XHRkb0ZpbGwoZmlsbFN0eWxlLCBmaWxsUGF0aCk7XG5cdFx0XHRcdGRvU3Ryb2tlKHN0cm9rZVN0eWxlLCBzdHJva2VQYXRoLCBsaW5lV2lkdGgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoZmxhZ3MgJiBCQU5EX0NMSVBfU1RST0tFKSB7XG5cdFx0XHRcdGRvRmlsbChmaWxsU3R5bGUsIGZpbGxQYXRoKTtcblx0XHRcdFx0Y3R4LmNsaXAoYmFuZENsaXApO1xuXHRcdFx0XHRkb1N0cm9rZShzdHJva2VTdHlsZSwgc3Ryb2tlUGF0aCwgbGluZVdpZHRoKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGZsYWdzICYgQkFORF9DTElQX0ZJTEwpIHtcblx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0Y3R4LmNsaXAoYmFuZENsaXApO1xuXHRcdFx0XHRnYXBzQ2xpcDIgJiYgY3R4LmNsaXAoZ2Fwc0NsaXAyKTtcblx0XHRcdFx0ZG9GaWxsKGZpbGxTdHlsZSwgZmlsbFBhdGgpO1xuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHRkb1N0cm9rZShzdHJva2VTdHlsZSwgc3Ryb2tlUGF0aCwgbGluZVdpZHRoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRkb0ZpbGwoZmlsbFN0eWxlLCBmaWxsUGF0aCk7XG5cdFx0XHRkb1N0cm9rZShzdHJva2VTdHlsZSwgc3Ryb2tlUGF0aCwgbGluZVdpZHRoKTtcblx0XHR9XG5cblx0XHRpZiAoYm91bmRzQ2xpcCB8fCBnYXBzQ2xpcCB8fCBiYW5kQ2xpcClcblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBkb1N0cm9rZShzdHJva2VTdHlsZSwgc3Ryb2tlUGF0aCwgbGluZVdpZHRoKSB7XG5cdFx0aWYgKGxpbmVXaWR0aCA+IDApIHtcblx0XHRcdGlmIChzdHJva2VQYXRoIGluc3RhbmNlb2YgTWFwKSB7XG5cdFx0XHRcdHN0cm9rZVBhdGguZm9yRWFjaCgoc3Ryb2tlUGF0aCwgc3Ryb2tlU3R5bGUpID0+IHtcblx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjdHhTdHJva2UgPSBzdHJva2VTdHlsZTtcblx0XHRcdFx0XHRjdHguc3Ryb2tlKHN0cm9rZVBhdGgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdFx0c3Ryb2tlUGF0aCAhPSBudWxsICYmIHN0cm9rZVN0eWxlICYmIGN0eC5zdHJva2Uoc3Ryb2tlUGF0aCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZG9GaWxsKGZpbGxTdHlsZSwgZmlsbFBhdGgpIHtcblx0XHRpZiAoZmlsbFBhdGggaW5zdGFuY2VvZiBNYXApIHtcblx0XHRcdGZpbGxQYXRoLmZvckVhY2goKGZpbGxQYXRoLCBmaWxsU3R5bGUpID0+IHtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGN0eEZpbGwgPSBmaWxsU3R5bGU7XG5cdFx0XHRcdGN0eC5maWxsKGZpbGxQYXRoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0XHRmaWxsUGF0aCAhPSBudWxsICYmIGZpbGxTdHlsZSAmJiBjdHguZmlsbChmaWxsUGF0aCk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRJbmNyU3BhY2UoYXhpc0lkeCwgbWluLCBtYXgsIGZ1bGxEaW0pIHtcblx0XHRsZXQgYXhpcyA9IGF4ZXNbYXhpc0lkeF07XG5cblx0XHRsZXQgaW5jclNwYWNlO1xuXG5cdFx0aWYgKGZ1bGxEaW0gPD0gMClcblx0XHRcdGluY3JTcGFjZSA9IFswLCAwXTtcblx0XHRlbHNlIHtcblx0XHRcdGxldCBtaW5TcGFjZSA9IGF4aXMuX3NwYWNlID0gYXhpcy5zcGFjZShzZWxmLCBheGlzSWR4LCBtaW4sIG1heCwgZnVsbERpbSk7XG5cdFx0XHRsZXQgaW5jcnMgICAgPSBheGlzLl9pbmNycyA9IGF4aXMuaW5jcnMoc2VsZiwgYXhpc0lkeCwgbWluLCBtYXgsIGZ1bGxEaW0sIG1pblNwYWNlKTtcblx0XHRcdGluY3JTcGFjZSAgICA9IGZpbmRJbmNyKG1pbiwgbWF4LCBpbmNycywgZnVsbERpbSwgbWluU3BhY2UpO1xuXHRcdH1cblxuXHRcdHJldHVybiAoYXhpcy5fZm91bmQgPSBpbmNyU3BhY2UpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZHJhd09ydGhvTGluZXMob2ZmcywgZmlsdHMsIG9yaSwgc2lkZSwgcG9zMCwgbGVuLCB3aWR0aCwgc3Ryb2tlLCBkYXNoLCBjYXApIHtcblx0XHRsZXQgb2Zmc2V0ID0gKHdpZHRoICUgMikgLyAyO1xuXG5cdFx0cHhBbGlnbiA9PSAxICYmIGN0eC50cmFuc2xhdGUob2Zmc2V0LCBvZmZzZXQpO1xuXG5cdFx0c2V0Q3R4U3R5bGUoc3Ryb2tlLCB3aWR0aCwgZGFzaCwgY2FwLCBzdHJva2UpO1xuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0bGV0IHgwLCB5MCwgeDEsIHkxLCBwb3MxID0gcG9zMCArIChzaWRlID09IDAgfHwgc2lkZSA9PSAzID8gLWxlbiA6IGxlbik7XG5cblx0XHRpZiAob3JpID09IDApIHtcblx0XHRcdHkwID0gcG9zMDtcblx0XHRcdHkxID0gcG9zMTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR4MCA9IHBvczA7XG5cdFx0XHR4MSA9IHBvczE7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBvZmZzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoZmlsdHNbaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAob3JpID09IDApXG5cdFx0XHRcdFx0eDAgPSB4MSA9IG9mZnNbaV07XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR5MCA9IHkxID0gb2Zmc1tpXTtcblxuXHRcdFx0XHRjdHgubW92ZVRvKHgwLCB5MCk7XG5cdFx0XHRcdGN0eC5saW5lVG8oeDEsIHkxKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjdHguc3Ryb2tlKCk7XG5cblx0XHRweEFsaWduID09IDEgJiYgY3R4LnRyYW5zbGF0ZSgtb2Zmc2V0LCAtb2Zmc2V0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGF4ZXNDYWxjKGN5Y2xlTnVtKSB7XG5cdC8vXHRsb2coXCJheGVzQ2FsYygpXCIsIGFyZ3VtZW50cyk7XG5cblx0XHRsZXQgY29udmVyZ2VkID0gdHJ1ZTtcblxuXHRcdGF4ZXMuZm9yRWFjaCgoYXhpcywgaSkgPT4ge1xuXHRcdFx0aWYgKCFheGlzLnNob3cpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0bGV0IHNjYWxlID0gc2NhbGVzW2F4aXMuc2NhbGVdO1xuXG5cdFx0XHRpZiAoc2NhbGUubWluID09IG51bGwpIHtcblx0XHRcdFx0aWYgKGF4aXMuX3Nob3cpIHtcblx0XHRcdFx0XHRjb252ZXJnZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRheGlzLl9zaG93ID0gZmFsc2U7XG5cdFx0XHRcdFx0cmVzZXRZU2VyaWVzKGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKCFheGlzLl9zaG93KSB7XG5cdFx0XHRcdFx0Y29udmVyZ2VkID0gZmFsc2U7XG5cdFx0XHRcdFx0YXhpcy5fc2hvdyA9IHRydWU7XG5cdFx0XHRcdFx0cmVzZXRZU2VyaWVzKGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgc2lkZSA9IGF4aXMuc2lkZTtcblx0XHRcdGxldCBvcmkgPSBzaWRlICUgMjtcblxuXHRcdFx0bGV0IHttaW4sIG1heH0gPSBzY2FsZTtcdFx0Ly8gXHRcdC8vIHNob3VsZCB0aGlzIHRvZ2dsZSB0aGVtIC5fc2hvdyA9IGZhbHNlXG5cblx0XHRcdGxldCBbX2luY3IsIF9zcGFjZV0gPSBnZXRJbmNyU3BhY2UoaSwgbWluLCBtYXgsIG9yaSA9PSAwID8gcGxvdFdpZENzcyA6IHBsb3RIZ3RDc3MpO1xuXG5cdFx0XHRpZiAoX3NwYWNlID09IDApXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0Ly8gaWYgd2UncmUgdXNpbmcgaW5kZXggcG9zaXRpb25zLCBmb3JjZSBmaXJzdCB0aWNrIHRvIG1hdGNoIHBhc3NlZCBpbmRleFxuXHRcdFx0bGV0IGZvcmNlTWluID0gc2NhbGUuZGlzdHIgPT0gMjtcblxuXHRcdFx0bGV0IF9zcGxpdHMgPSBheGlzLl9zcGxpdHMgPSBheGlzLnNwbGl0cyhzZWxmLCBpLCBtaW4sIG1heCwgX2luY3IsIF9zcGFjZSwgZm9yY2VNaW4pO1xuXG5cdFx0XHQvLyB0aWNrIGxhYmVsc1xuXHRcdFx0Ly8gQk9PIHRoaXMgYXNzdW1lcyBhIHNwZWNpZmljIGRhdGEvc2VyaWVzXG5cdFx0XHRsZXQgc3BsaXRzID0gc2NhbGUuZGlzdHIgPT0gMiA/IF9zcGxpdHMubWFwKGkgPT4gZGF0YTBbaV0pIDogX3NwbGl0cztcblx0XHRcdGxldCBpbmNyICAgPSBzY2FsZS5kaXN0ciA9PSAyID8gZGF0YTBbX3NwbGl0c1sxXV0gLSBkYXRhMFtfc3BsaXRzWzBdXSA6IF9pbmNyO1xuXG5cdFx0XHRsZXQgdmFsdWVzID0gYXhpcy5fdmFsdWVzID0gYXhpcy52YWx1ZXMoc2VsZiwgYXhpcy5maWx0ZXIoc2VsZiwgc3BsaXRzLCBpLCBfc3BhY2UsIGluY3IpLCBpLCBfc3BhY2UsIGluY3IpO1xuXG5cdFx0XHQvLyByb3RhdGluZyBvZiBsYWJlbHMgb25seSBzdXBwb3J0ZWQgb24gYm90dG9tIHggYXhpc1xuXHRcdFx0YXhpcy5fcm90YXRlID0gc2lkZSA9PSAyID8gYXhpcy5yb3RhdGUoc2VsZiwgdmFsdWVzLCBpLCBfc3BhY2UpIDogMDtcblxuXHRcdFx0bGV0IG9sZFNpemUgPSBheGlzLl9zaXplO1xuXG5cdFx0XHRheGlzLl9zaXplID0gY2VpbChheGlzLnNpemUoc2VsZiwgdmFsdWVzLCBpLCBjeWNsZU51bSkpO1xuXG5cdFx0XHRpZiAob2xkU2l6ZSAhPSBudWxsICYmIGF4aXMuX3NpemUgIT0gb2xkU2l6ZSlcdFx0XHQvLyByZWFkeSAmJiA/XG5cdFx0XHRcdGNvbnZlcmdlZCA9IGZhbHNlO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNvbnZlcmdlZDtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhZGRpbmdDYWxjKGN5Y2xlTnVtKSB7XG5cdFx0bGV0IGNvbnZlcmdlZCA9IHRydWU7XG5cblx0XHRwYWRkaW5nLmZvckVhY2goKHAsIGkpID0+IHtcblx0XHRcdGxldCBfcCA9IHAoc2VsZiwgaSwgc2lkZXNXaXRoQXhlcywgY3ljbGVOdW0pO1xuXG5cdFx0XHRpZiAoX3AgIT0gX3BhZGRpbmdbaV0pXG5cdFx0XHRcdGNvbnZlcmdlZCA9IGZhbHNlO1xuXG5cdFx0XHRfcGFkZGluZ1tpXSA9IF9wO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNvbnZlcmdlZDtcblx0fVxuXG5cdGZ1bmN0aW9uIGRyYXdBeGVzR3JpZCgpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBheGlzID0gYXhlc1tpXTtcblxuXHRcdFx0aWYgKCFheGlzLnNob3cgfHwgIWF4aXMuX3Nob3cpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRsZXQgc2lkZSA9IGF4aXMuc2lkZTtcblx0XHRcdGxldCBvcmkgPSBzaWRlICUgMjtcblxuXHRcdFx0bGV0IHgsIHk7XG5cblx0XHRcdGxldCBmaWxsU3R5bGUgPSBheGlzLnN0cm9rZShzZWxmLCBpKTtcblxuXHRcdFx0bGV0IHNoaWZ0RGlyID0gc2lkZSA9PSAwIHx8IHNpZGUgPT0gMyA/IC0xIDogMTtcblxuXHRcdFx0Ly8gYXhpcyBsYWJlbFxuXHRcdFx0aWYgKGF4aXMubGFiZWwpIHtcblx0XHRcdFx0bGV0IHNoaWZ0QW10ID0gYXhpcy5sYWJlbEdhcCAqIHNoaWZ0RGlyO1xuXHRcdFx0XHRsZXQgYmFzZUxwb3MgPSByb3VuZCgoYXhpcy5fbHBvcyArIHNoaWZ0QW10KSAqIHB4UmF0aW8pO1xuXG5cdFx0XHRcdHNldEZvbnRTdHlsZShheGlzLmxhYmVsRm9udFswXSwgZmlsbFN0eWxlLCBcImNlbnRlclwiLCBzaWRlID09IDIgPyBUT1AgOiBCT1RUT00pO1xuXG5cdFx0XHRcdGN0eC5zYXZlKCk7XG5cblx0XHRcdFx0aWYgKG9yaSA9PSAxKSB7XG5cdFx0XHRcdFx0eCA9IHkgPSAwO1xuXG5cdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdGJhc2VMcG9zLFxuXHRcdFx0XHRcdFx0cm91bmQocGxvdFRvcCArIHBsb3RIZ3QgLyAyKSxcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGN0eC5yb3RhdGUoKHNpZGUgPT0gMyA/IC1QSSA6IFBJKSAvIDIpO1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0eCA9IHJvdW5kKHBsb3RMZnQgKyBwbG90V2lkIC8gMik7XG5cdFx0XHRcdFx0eSA9IGJhc2VMcG9zO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3R4LmZpbGxUZXh0KGF4aXMubGFiZWwsIHgsIHkpO1xuXG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBbX2luY3IsIF9zcGFjZV0gPSBheGlzLl9mb3VuZDtcblxuXHRcdFx0aWYgKF9zcGFjZSA9PSAwKVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0bGV0IHNjYWxlID0gc2NhbGVzW2F4aXMuc2NhbGVdO1xuXG5cdFx0XHRsZXQgcGxvdERpbSA9IG9yaSA9PSAwID8gcGxvdFdpZCA6IHBsb3RIZ3Q7XG5cdFx0XHRsZXQgcGxvdE9mZiA9IG9yaSA9PSAwID8gcGxvdExmdCA6IHBsb3RUb3A7XG5cblx0XHRcdGxldCBheGlzR2FwID0gcm91bmQoYXhpcy5nYXAgKiBweFJhdGlvKTtcblxuXHRcdFx0bGV0IF9zcGxpdHMgPSBheGlzLl9zcGxpdHM7XG5cblx0XHRcdC8vIHRpY2sgbGFiZWxzXG5cdFx0XHQvLyBCT08gdGhpcyBhc3N1bWVzIGEgc3BlY2lmaWMgZGF0YS9zZXJpZXNcblx0XHRcdGxldCBzcGxpdHMgPSBzY2FsZS5kaXN0ciA9PSAyID8gX3NwbGl0cy5tYXAoaSA9PiBkYXRhMFtpXSkgOiBfc3BsaXRzO1xuXHRcdFx0bGV0IGluY3IgICA9IHNjYWxlLmRpc3RyID09IDIgPyBkYXRhMFtfc3BsaXRzWzFdXSAtIGRhdGEwW19zcGxpdHNbMF1dIDogX2luY3I7XG5cblx0XHRcdGxldCB0aWNrcyA9IGF4aXMudGlja3M7XG5cdFx0XHRsZXQgYm9yZGVyID0gYXhpcy5ib3JkZXI7XG5cdFx0XHRsZXQgdGlja1NpemUgPSB0aWNrcy5zaG93ID8gcm91bmQodGlja3Muc2l6ZSAqIHB4UmF0aW8pIDogMDtcblxuXHRcdFx0Ly8gcm90YXRpbmcgb2YgbGFiZWxzIG9ubHkgc3VwcG9ydGVkIG9uIGJvdHRvbSB4IGF4aXNcblx0XHRcdGxldCBhbmdsZSA9IGF4aXMuX3JvdGF0ZSAqIC1QSS8xODA7XG5cblx0XHRcdGxldCBiYXNlUG9zICA9IHB4Um91bmQoYXhpcy5fcG9zICogcHhSYXRpbyk7XG5cdFx0XHRsZXQgc2hpZnRBbXQgPSAodGlja1NpemUgKyBheGlzR2FwKSAqIHNoaWZ0RGlyO1xuXHRcdFx0bGV0IGZpbmFsUG9zID0gYmFzZVBvcyArIHNoaWZ0QW10O1xuXHRcdFx0ICAgIHkgICAgICAgID0gb3JpID09IDAgPyBmaW5hbFBvcyA6IDA7XG5cdFx0XHQgICAgeCAgICAgICAgPSBvcmkgPT0gMSA/IGZpbmFsUG9zIDogMDtcblxuXHRcdFx0bGV0IGZvbnQgICAgICAgICA9IGF4aXMuZm9udFswXTtcblx0XHRcdGxldCB0ZXh0QWxpZ24gICAgPSBheGlzLmFsaWduID09IDEgPyBMRUZUIDpcblx0XHRcdCAgICAgICAgICAgICAgICAgICBheGlzLmFsaWduID09IDIgPyBSSUdIVCA6XG5cdFx0XHQgICAgICAgICAgICAgICAgICAgYW5nbGUgPiAwID8gTEVGVCA6XG5cdFx0XHQgICAgICAgICAgICAgICAgICAgYW5nbGUgPCAwID8gUklHSFQgOlxuXHRcdFx0ICAgICAgICAgICAgICAgICAgIG9yaSA9PSAwID8gXCJjZW50ZXJcIiA6IHNpZGUgPT0gMyA/IFJJR0hUIDogTEVGVDtcblx0XHRcdGxldCB0ZXh0QmFzZWxpbmUgPSBhbmdsZSB8fFxuXHRcdFx0ICAgICAgICAgICAgICAgICAgIG9yaSA9PSAxID8gXCJtaWRkbGVcIiA6IHNpZGUgPT0gMiA/IFRPUCAgIDogQk9UVE9NO1xuXG5cdFx0XHRzZXRGb250U3R5bGUoZm9udCwgZmlsbFN0eWxlLCB0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSk7XG5cblx0XHRcdGxldCBsaW5lSGVpZ2h0ID0gYXhpcy5mb250WzFdICogbGluZU11bHQ7XG5cblx0XHRcdGxldCBjYW5PZmZzID0gX3NwbGl0cy5tYXAodmFsID0+IHB4Um91bmQoZ2V0UG9zKHZhbCwgc2NhbGUsIHBsb3REaW0sIHBsb3RPZmYpKSk7XG5cblx0XHRcdGxldCBfdmFsdWVzID0gYXhpcy5fdmFsdWVzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IF92YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bGV0IHZhbCA9IF92YWx1ZXNbaV07XG5cblx0XHRcdFx0aWYgKHZhbCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKG9yaSA9PSAwKVxuXHRcdFx0XHRcdFx0eCA9IGNhbk9mZnNbaV07XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0eSA9IGNhbk9mZnNbaV07XG5cblx0XHRcdFx0XHR2YWwgPSBcIlwiICsgdmFsO1xuXG5cdFx0XHRcdFx0bGV0IF9wYXJ0cyA9IHZhbC5pbmRleE9mKFwiXFxuXCIpID09IC0xID8gW3ZhbF0gOiB2YWwuc3BsaXQoL1xcbi9nbSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IF9wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0bGV0IHRleHQgPSBfcGFydHNbal07XG5cblx0XHRcdFx0XHRcdGlmIChhbmdsZSkge1xuXHRcdFx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKHgsIHkgKyBqICogbGluZUhlaWdodCk7IC8vIGNhbiB0aGlzIGJlIHJlcGxhY2VkIHdpdGggcG9zaXRpb24gbWF0aD9cblx0XHRcdFx0XHRcdFx0Y3R4LnJvdGF0ZShhbmdsZSk7IC8vIGNhbiB0aGlzIGJlIGRvbmUgb25jZT9cblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRleHQsIDAsIDApO1xuXHRcdFx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRjdHguZmlsbFRleHQodGV4dCwgeCwgeSArIGogKiBsaW5lSGVpZ2h0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gdGlja3Ncblx0XHRcdGlmICh0aWNrcy5zaG93KSB7XG5cdFx0XHRcdGRyYXdPcnRob0xpbmVzKFxuXHRcdFx0XHRcdGNhbk9mZnMsXG5cdFx0XHRcdFx0dGlja3MuZmlsdGVyKHNlbGYsIHNwbGl0cywgaSwgX3NwYWNlLCBpbmNyKSxcblx0XHRcdFx0XHRvcmksXG5cdFx0XHRcdFx0c2lkZSxcblx0XHRcdFx0XHRiYXNlUG9zLFxuXHRcdFx0XHRcdHRpY2tTaXplLFxuXHRcdFx0XHRcdHJvdW5kRGVjKHRpY2tzLndpZHRoICogcHhSYXRpbywgMyksXG5cdFx0XHRcdFx0dGlja3Muc3Ryb2tlKHNlbGYsIGkpLFxuXHRcdFx0XHRcdHRpY2tzLmRhc2gsXG5cdFx0XHRcdFx0dGlja3MuY2FwLFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBncmlkXG5cdFx0XHRsZXQgZ3JpZCA9IGF4aXMuZ3JpZDtcblxuXHRcdFx0aWYgKGdyaWQuc2hvdykge1xuXHRcdFx0XHRkcmF3T3J0aG9MaW5lcyhcblx0XHRcdFx0XHRjYW5PZmZzLFxuXHRcdFx0XHRcdGdyaWQuZmlsdGVyKHNlbGYsIHNwbGl0cywgaSwgX3NwYWNlLCBpbmNyKSxcblx0XHRcdFx0XHRvcmksXG5cdFx0XHRcdFx0b3JpID09IDAgPyAyIDogMSxcblx0XHRcdFx0XHRvcmkgPT0gMCA/IHBsb3RUb3AgOiBwbG90TGZ0LFxuXHRcdFx0XHRcdG9yaSA9PSAwID8gcGxvdEhndCA6IHBsb3RXaWQsXG5cdFx0XHRcdFx0cm91bmREZWMoZ3JpZC53aWR0aCAqIHB4UmF0aW8sIDMpLFxuXHRcdFx0XHRcdGdyaWQuc3Ryb2tlKHNlbGYsIGkpLFxuXHRcdFx0XHRcdGdyaWQuZGFzaCxcblx0XHRcdFx0XHRncmlkLmNhcCxcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJvcmRlci5zaG93KSB7XG5cdFx0XHRcdGRyYXdPcnRob0xpbmVzKFxuXHRcdFx0XHRcdFtiYXNlUG9zXSxcblx0XHRcdFx0XHRbMV0sXG5cdFx0XHRcdFx0b3JpID09IDAgPyAxIDogMCxcblx0XHRcdFx0XHRvcmkgPT0gMCA/IDEgOiAyLFxuXHRcdFx0XHRcdG9yaSA9PSAxID8gcGxvdFRvcCA6IHBsb3RMZnQsXG5cdFx0XHRcdFx0b3JpID09IDEgPyBwbG90SGd0IDogcGxvdFdpZCxcblx0XHRcdFx0XHRyb3VuZERlYyhib3JkZXIud2lkdGggKiBweFJhdGlvLCAzKSxcblx0XHRcdFx0XHRib3JkZXIuc3Ryb2tlKHNlbGYsIGkpLFxuXHRcdFx0XHRcdGJvcmRlci5kYXNoLFxuXHRcdFx0XHRcdGJvcmRlci5jYXAsXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZmlyZShcImRyYXdBeGVzXCIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVzZXRZU2VyaWVzKG1pbk1heCkge1xuXHQvL1x0bG9nKFwicmVzZXRZU2VyaWVzKClcIiwgYXJndW1lbnRzKTtcblxuXHRcdHNlcmllcy5mb3JFYWNoKChzLCBpKSA9PiB7XG5cdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0cy5fcGF0aHMgPSBudWxsO1xuXG5cdFx0XHRcdGlmIChtaW5NYXgpIHtcblx0XHRcdFx0XHRpZiAobW9kZSA9PSAxKSB7XG5cdFx0XHRcdFx0XHRzLm1pbiA9IG51bGw7XG5cdFx0XHRcdFx0XHRzLm1heCA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cy5mYWNldHMuZm9yRWFjaChmID0+IHtcblx0XHRcdFx0XHRcdFx0Zi5taW4gPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRmLm1heCA9IG51bGw7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGxldCBxdWV1ZWRDb21taXQgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBjb21taXQoKSB7XG5cdFx0aWYgKCFxdWV1ZWRDb21taXQpIHtcblx0XHRcdG1pY3JvVGFzayhfY29tbWl0KTtcblx0XHRcdHF1ZXVlZENvbW1pdCA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gX2NvbW1pdCgpIHtcblx0Ly9cdGxvZyhcIl9jb21taXQoKVwiLCBhcmd1bWVudHMpO1xuXG5cdFx0aWYgKHNob3VsZFNldFNjYWxlcykge1xuXHRcdFx0c2V0U2NhbGVzKCk7XG5cdFx0XHRzaG91bGRTZXRTY2FsZXMgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoc2hvdWxkQ29udmVyZ2VTaXplKSB7XG5cdFx0XHRjb252ZXJnZVNpemUoKTtcblx0XHRcdHNob3VsZENvbnZlcmdlU2l6ZSA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChzaG91bGRTZXRTaXplKSB7XG5cdFx0XHRzZXRTdHlsZVB4KHVuZGVyLCBMRUZULCAgIHBsb3RMZnRDc3MpO1xuXHRcdFx0c2V0U3R5bGVQeCh1bmRlciwgVE9QLCAgICBwbG90VG9wQ3NzKTtcblx0XHRcdHNldFN0eWxlUHgodW5kZXIsIFdJRFRILCAgcGxvdFdpZENzcyk7XG5cdFx0XHRzZXRTdHlsZVB4KHVuZGVyLCBIRUlHSFQsIHBsb3RIZ3RDc3MpO1xuXG5cdFx0XHRzZXRTdHlsZVB4KG92ZXIsIExFRlQsICAgIHBsb3RMZnRDc3MpO1xuXHRcdFx0c2V0U3R5bGVQeChvdmVyLCBUT1AsICAgICBwbG90VG9wQ3NzKTtcblx0XHRcdHNldFN0eWxlUHgob3ZlciwgV0lEVEgsICAgcGxvdFdpZENzcyk7XG5cdFx0XHRzZXRTdHlsZVB4KG92ZXIsIEhFSUdIVCwgIHBsb3RIZ3RDc3MpO1xuXG5cdFx0XHRzZXRTdHlsZVB4KHdyYXAsIFdJRFRILCAgIGZ1bGxXaWRDc3MpO1xuXHRcdFx0c2V0U3R5bGVQeCh3cmFwLCBIRUlHSFQsICBmdWxsSGd0Q3NzKTtcblxuXHRcdFx0Ly8gTk9URTogbXV0YXRpbmcgdGhpcyBkdXJpbmcgcHJpbnQgcHJldmlldyBpbiBDaHJvbWUgZm9yY2VzIHRyYW5zcGFyZW50XG5cdFx0XHQvLyBjYW52YXMgcGl4ZWxzIHRvIHdoaXRlLCBldmVuIHdoZW4gZm9sbG93ZWQgdXAgd2l0aCBjbGVhclJlY3QoKSBiZWxvd1xuXHRcdFx0Y2FuLndpZHRoICA9IHJvdW5kKGZ1bGxXaWRDc3MgKiBweFJhdGlvKTtcblx0XHRcdGNhbi5oZWlnaHQgPSByb3VuZChmdWxsSGd0Q3NzICogcHhSYXRpbyk7XG5cblx0XHRcdGF4ZXMuZm9yRWFjaCgoeyBfZWwsIF9zaG93LCBfc2l6ZSwgX3Bvcywgc2lkZSB9KSA9PiB7XG5cdFx0XHRcdGlmIChfZWwgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChfc2hvdykge1xuXHRcdFx0XHRcdFx0bGV0IHBvc09mZnNldCA9IChzaWRlID09PSAzIHx8IHNpZGUgPT09IDAgPyBfc2l6ZSA6IDApO1xuXHRcdFx0XHRcdFx0bGV0IGlzVnQgPSBzaWRlICUgMiA9PSAxO1xuXG5cdFx0XHRcdFx0XHRzZXRTdHlsZVB4KF9lbCwgaXNWdCA/IFwibGVmdFwiICAgOiBcInRvcFwiLCAgICBfcG9zIC0gcG9zT2Zmc2V0KTtcblx0XHRcdFx0XHRcdHNldFN0eWxlUHgoX2VsLCBpc1Z0ID8gXCJ3aWR0aFwiICA6IFwiaGVpZ2h0XCIsIF9zaXplKTtcblx0XHRcdFx0XHRcdHNldFN0eWxlUHgoX2VsLCBpc1Z0ID8gXCJ0b3BcIiAgICA6IFwibGVmdFwiLCAgIGlzVnQgPyBwbG90VG9wQ3NzIDogcGxvdExmdENzcyk7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZVB4KF9lbCwgaXNWdCA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCIsICBpc1Z0ID8gcGxvdEhndENzcyA6IHBsb3RXaWRDc3MpO1xuXG5cdFx0XHRcdFx0XHRyZW1DbGFzcyhfZWwsIE9GRik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdGFkZENsYXNzKF9lbCwgT0ZGKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIGludmFsaWRhdGUgY3R4IHN0eWxlIGNhY2hlXG5cdFx0XHRjdHhTdHJva2UgPSBjdHhGaWxsID0gY3R4V2lkdGggPSBjdHhKb2luID0gY3R4Q2FwID0gY3R4Rm9udCA9IGN0eEFsaWduID0gY3R4QmFzZWxpbmUgPSBjdHhEYXNoID0gbnVsbDtcblx0XHRcdGN0eEFscGhhID0gMTtcblxuXHRcdFx0c3luY1JlY3QodHJ1ZSk7XG5cblx0XHRcdGZpcmUoXCJzZXRTaXplXCIpO1xuXG5cdFx0XHRzaG91bGRTZXRTaXplID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKGZ1bGxXaWRDc3MgPiAwICYmIGZ1bGxIZ3RDc3MgPiAwKSB7XG5cdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIGNhbi53aWR0aCwgY2FuLmhlaWdodCk7XG5cdFx0XHRmaXJlKFwiZHJhd0NsZWFyXCIpO1xuXHRcdFx0ZHJhd09yZGVyLmZvckVhY2goZm4gPT4gZm4oKSk7XG5cdFx0XHRmaXJlKFwiZHJhd1wiKTtcblx0XHR9XG5cblx0Ly9cdGlmIChzaG91bGRTZXRTZWxlY3QpIHtcblx0XHQvLyBUT0RPOiB1cGRhdGUgLnUtc2VsZWN0IG1ldHJpY3MgKGlmIHZpc2libGUpXG5cdFx0Ly9cdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBUT1AsIHNlbGVjdC50b3AgPSAwKTtcblx0XHQvL1x0c2V0U3R5bGVQeChzZWxlY3REaXYsIExFRlQsIHNlbGVjdC5sZWZ0ID0gMCk7XG5cdFx0Ly9cdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBXSURUSCwgc2VsZWN0LndpZHRoID0gMCk7XG5cdFx0Ly9cdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBIRUlHSFQsIHNlbGVjdC5oZWlnaHQgPSAwKTtcblx0XHQvL1x0c2hvdWxkU2V0U2VsZWN0ID0gZmFsc2U7XG5cdC8vXHR9XG5cblx0XHRpZiAoY3Vyc29yLnNob3cgJiYgc2hvdWxkU2V0Q3Vyc29yKSB7XG5cdFx0XHR1cGRhdGVDdXJzb3IobnVsbCwgdHJ1ZSwgZmFsc2UpO1xuXHRcdFx0c2hvdWxkU2V0Q3Vyc29yID0gZmFsc2U7XG5cdFx0fVxuXG5cdC8vXHRpZiAoRkVBVF9MRUdFTkQgJiYgbGVnZW5kLnNob3cgJiYgbGVnZW5kLmxpdmUgJiYgc2hvdWxkU2V0TGVnZW5kKSB7fVxuXG5cdFx0aWYgKCFyZWFkeSkge1xuXHRcdFx0cmVhZHkgPSB0cnVlO1xuXHRcdFx0c2VsZi5zdGF0dXMgPSAxO1xuXG5cdFx0XHRmaXJlKFwicmVhZHlcIik7XG5cdFx0fVxuXG5cdFx0dmlhQXV0b1NjYWxlWCA9IGZhbHNlO1xuXG5cdFx0cXVldWVkQ29tbWl0ID0gZmFsc2U7XG5cdH1cblxuXHRzZWxmLnJlZHJhdyA9IChyZWJ1aWxkUGF0aHMsIHJlY2FsY0F4ZXMpID0+IHtcblx0XHRzaG91bGRDb252ZXJnZVNpemUgPSByZWNhbGNBeGVzIHx8IGZhbHNlO1xuXG5cdFx0aWYgKHJlYnVpbGRQYXRocyAhPT0gZmFsc2UpXG5cdFx0XHRfc2V0U2NhbGUoeFNjYWxlS2V5LCBzY2FsZVgubWluLCBzY2FsZVgubWF4KTtcblx0XHRlbHNlXG5cdFx0XHRjb21taXQoKTtcblx0fTtcblxuXHQvLyByZWRyYXcoKSA9PiBzZXRTY2FsZSgneCcsIHNjYWxlcy54Lm1pbiwgc2NhbGVzLngubWF4KTtcblxuXHQvLyBleHBsaWNpdCwgbmV2ZXIgcmUtcmFuZ2VkIChpcyB0aGlzIGFjdHVhbGx5IHRydWU/IGZvciB4IGFuZCB5KVxuXHRmdW5jdGlvbiBzZXRTY2FsZShrZXksIG9wdHMpIHtcblx0XHRsZXQgc2MgPSBzY2FsZXNba2V5XTtcblxuXHRcdGlmIChzYy5mcm9tID09IG51bGwpIHtcblx0XHRcdGlmIChkYXRhTGVuID09IDApIHtcblx0XHRcdFx0bGV0IG1pbk1heCA9IHNjLnJhbmdlKHNlbGYsIG9wdHMubWluLCBvcHRzLm1heCwga2V5KTtcblx0XHRcdFx0b3B0cy5taW4gPSBtaW5NYXhbMF07XG5cdFx0XHRcdG9wdHMubWF4ID0gbWluTWF4WzFdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0cy5taW4gPiBvcHRzLm1heCkge1xuXHRcdFx0XHRsZXQgX21pbiA9IG9wdHMubWluO1xuXHRcdFx0XHRvcHRzLm1pbiA9IG9wdHMubWF4O1xuXHRcdFx0XHRvcHRzLm1heCA9IF9taW47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhTGVuID4gMSAmJiBvcHRzLm1pbiAhPSBudWxsICYmIG9wdHMubWF4ICE9IG51bGwgJiYgb3B0cy5tYXggLSBvcHRzLm1pbiA8IDFlLTE2KVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGlmIChrZXkgPT0geFNjYWxlS2V5KSB7XG5cdFx0XHRcdGlmIChzYy5kaXN0ciA9PSAyICYmIGRhdGFMZW4gPiAwKSB7XG5cdFx0XHRcdFx0b3B0cy5taW4gPSBjbG9zZXN0SWR4KG9wdHMubWluLCBkYXRhWzBdKTtcblx0XHRcdFx0XHRvcHRzLm1heCA9IGNsb3Nlc3RJZHgob3B0cy5tYXgsIGRhdGFbMF0pO1xuXG5cdFx0XHRcdFx0aWYgKG9wdHMubWluID09IG9wdHMubWF4KVxuXHRcdFx0XHRcdFx0b3B0cy5tYXgrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly9cdGxvZyhcInNldFNjYWxlKClcIiwgYXJndW1lbnRzKTtcblxuXHRcdFx0cGVuZFNjYWxlc1trZXldID0gb3B0cztcblxuXHRcdFx0c2hvdWxkU2V0U2NhbGVzID0gdHJ1ZTtcblx0XHRcdGNvbW1pdCgpO1xuXHRcdH1cblx0fVxuXG5cdHNlbGYuc2V0U2NhbGUgPSBzZXRTY2FsZTtcblxuLy9cdElOVEVSQUNUSU9OXG5cblx0bGV0IHhDdXJzb3I7XG5cdGxldCB5Q3Vyc29yO1xuXHRsZXQgdkN1cnNvcjtcblx0bGV0IGhDdXJzb3I7XG5cblx0Ly8gc3RhcnRpbmcgcG9zaXRpb24gYmVmb3JlIGN1cnNvci5tb3ZlXG5cdGxldCByYXdNb3VzZUxlZnQwO1xuXHRsZXQgcmF3TW91c2VUb3AwO1xuXG5cdC8vIHN0YXJ0aW5nIHBvc2l0aW9uXG5cdGxldCBtb3VzZUxlZnQwO1xuXHRsZXQgbW91c2VUb3AwO1xuXG5cdC8vIGN1cnJlbnQgcG9zaXRpb24gYmVmb3JlIGN1cnNvci5tb3ZlXG5cdGxldCByYXdNb3VzZUxlZnQxO1xuXHRsZXQgcmF3TW91c2VUb3AxO1xuXG5cdC8vIGN1cnJlbnQgcG9zaXRpb25cblx0bGV0IG1vdXNlTGVmdDE7XG5cdGxldCBtb3VzZVRvcDE7XG5cblx0bGV0IGRyYWdnaW5nID0gZmFsc2U7XG5cblx0Y29uc3QgZHJhZyA9IGN1cnNvci5kcmFnO1xuXG5cdGxldCBkcmFnWCA9IGRyYWcueDtcblx0bGV0IGRyYWdZID0gZHJhZy55O1xuXG5cdGlmIChjdXJzb3Iuc2hvdykge1xuXHRcdGlmIChjdXJzb3IueClcblx0XHRcdHhDdXJzb3IgPSBwbGFjZURpdihDVVJTT1JfWCwgb3Zlcik7XG5cdFx0aWYgKGN1cnNvci55KVxuXHRcdFx0eUN1cnNvciA9IHBsYWNlRGl2KENVUlNPUl9ZLCBvdmVyKTtcblxuXHRcdGlmIChzY2FsZVgub3JpID09IDApIHtcblx0XHRcdHZDdXJzb3IgPSB4Q3Vyc29yO1xuXHRcdFx0aEN1cnNvciA9IHlDdXJzb3I7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dkN1cnNvciA9IHlDdXJzb3I7XG5cdFx0XHRoQ3Vyc29yID0geEN1cnNvcjtcblx0XHR9XG5cblx0XHRtb3VzZUxlZnQxID0gY3Vyc29yLmxlZnQ7XG5cdFx0bW91c2VUb3AxID0gY3Vyc29yLnRvcDtcblx0fVxuXG5cdGNvbnN0IHNlbGVjdCA9IHNlbGYuc2VsZWN0ID0gYXNzaWduKHtcblx0XHRzaG93OiAgIHRydWUsXG5cdFx0b3ZlcjogICB0cnVlLFxuXHRcdGxlZnQ6ICAgMCxcblx0XHR3aWR0aDogIDAsXG5cdFx0dG9wOiAgICAwLFxuXHRcdGhlaWdodDogMCxcblx0fSwgb3B0cy5zZWxlY3QpO1xuXG5cdGNvbnN0IHNlbGVjdERpdiA9IHNlbGVjdC5zaG93ID8gcGxhY2VEaXYoU0VMRUNULCBzZWxlY3Qub3ZlciA/IG92ZXIgOiB1bmRlcikgOiBudWxsO1xuXG5cdGZ1bmN0aW9uIHNldFNlbGVjdChvcHRzLCBfZmlyZSkge1xuXHRcdGlmIChzZWxlY3Quc2hvdykge1xuXHRcdFx0Zm9yIChsZXQgcHJvcCBpbiBvcHRzKVxuXHRcdFx0XHRzZXRTdHlsZVB4KHNlbGVjdERpdiwgcHJvcCwgc2VsZWN0W3Byb3BdID0gb3B0c1twcm9wXSk7XG5cblx0XHRcdF9maXJlICE9PSBmYWxzZSAmJiBmaXJlKFwic2V0U2VsZWN0XCIpO1xuXHRcdH1cblx0fVxuXG5cdHNlbGYuc2V0U2VsZWN0ID0gc2V0U2VsZWN0O1xuXG5cdGZ1bmN0aW9uIHRvZ2dsZURPTShpLCBvbk9mZikge1xuXHRcdGxldCBzID0gc2VyaWVzW2ldO1xuXHRcdGxldCBsYWJlbCA9IHNob3dMZWdlbmQgPyBsZWdlbmRSb3dzW2ldIDogbnVsbDtcblxuXHRcdGlmIChzLnNob3cpXG5cdFx0XHRsYWJlbCAmJiByZW1DbGFzcyhsYWJlbCwgT0ZGKTtcblx0XHRlbHNlIHtcblx0XHRcdGxhYmVsICYmIGFkZENsYXNzKGxhYmVsLCBPRkYpO1xuXHRcdFx0Y3Vyc29yUHRzLmxlbmd0aCA+IDEgJiYgZWxUcmFucyhjdXJzb3JQdHNbaV0sIC0xMCwgLTEwLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBfc2V0U2NhbGUoa2V5LCBtaW4sIG1heCkge1xuXHRcdHNldFNjYWxlKGtleSwge21pbiwgbWF4fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTZXJpZXMoaSwgb3B0cywgX2ZpcmUsIF9wdWIpIHtcblx0Ly9cdGxvZyhcInNldFNlcmllcygpXCIsIGFyZ3VtZW50cyk7XG5cblx0XHRpZiAob3B0cy5mb2N1cyAhPSBudWxsKVxuXHRcdFx0c2V0Rm9jdXMoaSk7XG5cblx0XHRpZiAob3B0cy5zaG93ICE9IG51bGwpIHtcblx0XHRcdHNlcmllcy5mb3JFYWNoKChzLCBzaSkgPT4ge1xuXHRcdFx0XHRpZiAoc2kgPiAwICYmIChpID09IHNpIHx8IGkgPT0gbnVsbCkpIHtcblx0XHRcdFx0XHRzLnNob3cgPSBvcHRzLnNob3c7XG5cdFx0XHRcdFx0dG9nZ2xlRE9NKHNpLCBvcHRzLnNob3cpO1xuXG5cdFx0XHRcdFx0X3NldFNjYWxlKG1vZGUgPT0gMiA/IHMuZmFjZXRzWzFdLnNjYWxlIDogcy5zY2FsZSwgbnVsbCwgbnVsbCk7XG5cdFx0XHRcdFx0Y29tbWl0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdF9maXJlICE9PSBmYWxzZSAmJiBmaXJlKFwic2V0U2VyaWVzXCIsIGksIG9wdHMpO1xuXG5cdFx0X3B1YiAmJiBwdWJTeW5jKFwic2V0U2VyaWVzXCIsIHNlbGYsIGksIG9wdHMpO1xuXHR9XG5cblx0c2VsZi5zZXRTZXJpZXMgPSBzZXRTZXJpZXM7XG5cblx0ZnVuY3Rpb24gc2V0QmFuZChiaSwgb3B0cykge1xuXHRcdGFzc2lnbihiYW5kc1tiaV0sIG9wdHMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQmFuZChvcHRzLCBiaSkge1xuXHRcdG9wdHMuZmlsbCA9IGZuT3JTZWxmKG9wdHMuZmlsbCB8fCBudWxsKTtcblx0XHRvcHRzLmRpciA9IGlmTnVsbChvcHRzLmRpciwgLTEpO1xuXHRcdGJpID0gYmkgPT0gbnVsbCA/IGJhbmRzLmxlbmd0aCA6IGJpO1xuXHRcdGJhbmRzLnNwbGljZShiaSwgMCwgb3B0cyk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWxCYW5kKGJpKSB7XG5cdFx0aWYgKGJpID09IG51bGwpXG5cdFx0XHRiYW5kcy5sZW5ndGggPSAwO1xuXHRcdGVsc2Vcblx0XHRcdGJhbmRzLnNwbGljZShiaSwgMSk7XG5cdH1cblxuXHRzZWxmLmFkZEJhbmQgPSBhZGRCYW5kO1xuXHRzZWxmLnNldEJhbmQgPSBzZXRCYW5kO1xuXHRzZWxmLmRlbEJhbmQgPSBkZWxCYW5kO1xuXG5cdGZ1bmN0aW9uIHNldEFscGhhKGksIHZhbHVlKSB7XG5cdFx0c2VyaWVzW2ldLmFscGhhID0gdmFsdWU7XG5cblx0XHRpZiAoY3Vyc29yLnNob3cgJiYgY3Vyc29yUHRzW2ldKVxuXHRcdFx0Y3Vyc29yUHRzW2ldLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcblxuXHRcdGlmIChzaG93TGVnZW5kICYmIGxlZ2VuZFJvd3NbaV0pXG5cdFx0XHRsZWdlbmRSb3dzW2ldLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcblx0fVxuXG5cdC8vIHktZGlzdGFuY2Vcblx0bGV0IGNsb3Nlc3REaXN0O1xuXHRsZXQgY2xvc2VzdFNlcmllcztcblx0bGV0IGZvY3VzZWRTZXJpZXM7XG5cdGNvbnN0IEZPQ1VTX1RSVUUgID0ge2ZvY3VzOiB0cnVlfTtcblxuXHRmdW5jdGlvbiBzZXRGb2N1cyhpKSB7XG5cdFx0aWYgKGkgIT0gZm9jdXNlZFNlcmllcykge1xuXHRcdC8vXHRsb2coXCJzZXRGb2N1cygpXCIsIGFyZ3VtZW50cyk7XG5cblx0XHRcdGxldCBhbGxGb2N1c2VkID0gaSA9PSBudWxsO1xuXG5cdFx0XHRsZXQgX3NldEFscGhhID0gZm9jdXMuYWxwaGEgIT0gMTtcblxuXHRcdFx0c2VyaWVzLmZvckVhY2goKHMsIGkyKSA9PiB7XG5cdFx0XHRcdGxldCBpc0ZvY3VzZWQgPSBhbGxGb2N1c2VkIHx8IGkyID09IDAgfHwgaTIgPT0gaTtcblx0XHRcdFx0cy5fZm9jdXMgPSBhbGxGb2N1c2VkID8gbnVsbCA6IGlzRm9jdXNlZDtcblx0XHRcdFx0X3NldEFscGhhICYmIHNldEFscGhhKGkyLCBpc0ZvY3VzZWQgPyAxIDogZm9jdXMuYWxwaGEpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGZvY3VzZWRTZXJpZXMgPSBpO1xuXHRcdFx0X3NldEFscGhhICYmIGNvbW1pdCgpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChzaG93TGVnZW5kICYmIGN1cnNvckZvY3VzKSB7XG5cdFx0b24obW91c2VsZWF2ZSwgbGVnZW5kRWwsIGUgPT4ge1xuXHRcdFx0aWYgKGN1cnNvci5fbG9jaylcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRpZiAoZm9jdXNlZFNlcmllcyAhPSBudWxsKVxuXHRcdFx0XHRzZXRTZXJpZXMobnVsbCwgRk9DVVNfVFJVRSwgdHJ1ZSwgc3luY09wdHMuc2V0U2VyaWVzKTtcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBvc1RvVmFsKHBvcywgc2NhbGUsIGNhbikge1xuXHRcdGxldCBzYyA9IHNjYWxlc1tzY2FsZV07XG5cblx0XHRpZiAoY2FuKVxuXHRcdFx0cG9zID0gcG9zIC8gcHhSYXRpbyAtIChzYy5vcmkgPT0gMSA/IHBsb3RUb3BDc3MgOiBwbG90TGZ0Q3NzKTtcblxuXHRcdGxldCBkaW0gPSBwbG90V2lkQ3NzO1xuXG5cdFx0aWYgKHNjLm9yaSA9PSAxKSB7XG5cdFx0XHRkaW0gPSBwbG90SGd0Q3NzO1xuXHRcdFx0cG9zID0gZGltIC0gcG9zO1xuXHRcdH1cblxuXHRcdGlmIChzYy5kaXIgPT0gLTEpXG5cdFx0XHRwb3MgPSBkaW0gLSBwb3M7XG5cblx0XHRsZXQgX21pbiA9IHNjLl9taW4sXG5cdFx0XHRfbWF4ID0gc2MuX21heCxcblx0XHRcdHBjdCA9IHBvcyAvIGRpbTtcblxuXHRcdGxldCBzdiA9IF9taW4gKyAoX21heCAtIF9taW4pICogcGN0O1xuXG5cdFx0bGV0IGRpc3RyID0gc2MuZGlzdHI7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0ZGlzdHIgPT0gMyA/IHBvdygxMCwgc3YpIDpcblx0XHRcdGRpc3RyID09IDQgPyBzaW5oKHN2LCBzYy5hc2luaCkgOlxuXHRcdFx0c3Zcblx0XHQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2xvc2VzdElkeEZyb21YcG9zKHBvcywgY2FuKSB7XG5cdFx0bGV0IHYgPSBwb3NUb1ZhbChwb3MsIHhTY2FsZUtleSwgY2FuKTtcblx0XHRyZXR1cm4gY2xvc2VzdElkeCh2LCBkYXRhWzBdLCBpMCwgaTEpO1xuXHR9XG5cblx0c2VsZi52YWxUb0lkeCA9IHZhbCA9PiBjbG9zZXN0SWR4KHZhbCwgZGF0YVswXSk7XG5cdHNlbGYucG9zVG9JZHggPSBjbG9zZXN0SWR4RnJvbVhwb3M7XG5cdHNlbGYucG9zVG9WYWwgPSBwb3NUb1ZhbDtcblx0c2VsZi52YWxUb1BvcyA9ICh2YWwsIHNjYWxlLCBjYW4pID0+IChcblx0XHRzY2FsZXNbc2NhbGVdLm9yaSA9PSAwID9cblx0XHRnZXRIUG9zKHZhbCwgc2NhbGVzW3NjYWxlXSxcblx0XHRcdGNhbiA/IHBsb3RXaWQgOiBwbG90V2lkQ3NzLFxuXHRcdFx0Y2FuID8gcGxvdExmdCA6IDAsXG5cdFx0KSA6XG5cdFx0Z2V0VlBvcyh2YWwsIHNjYWxlc1tzY2FsZV0sXG5cdFx0XHRjYW4gPyBwbG90SGd0IDogcGxvdEhndENzcyxcblx0XHRcdGNhbiA/IHBsb3RUb3AgOiAwLFxuXHRcdClcblx0KTtcblxuXHQvLyBkZWZlcnMgY2FsbGluZyBleHBlbnNpdmUgZnVuY3Rpb25zXG5cdGZ1bmN0aW9uIGJhdGNoKGZuKSB7XG5cdFx0Zm4oc2VsZik7XG5cdFx0Y29tbWl0KCk7XG5cdH1cblxuXHRzZWxmLmJhdGNoID0gYmF0Y2g7XG5cblx0KHNlbGYuc2V0Q3Vyc29yID0gKG9wdHMsIF9maXJlLCBfcHViKSA9PiB7XG5cdFx0bW91c2VMZWZ0MSA9IG9wdHMubGVmdDtcblx0XHRtb3VzZVRvcDEgPSBvcHRzLnRvcDtcblx0Ly9cdGFzc2lnbihjdXJzb3IsIG9wdHMpO1xuXHRcdHVwZGF0ZUN1cnNvcihudWxsLCBfZmlyZSwgX3B1Yik7XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIHNldFNlbEgob2ZmLCBkaW0pIHtcblx0XHRzZXRTdHlsZVB4KHNlbGVjdERpdiwgTEVGVCwgIHNlbGVjdC5sZWZ0ID0gb2ZmKTtcblx0XHRzZXRTdHlsZVB4KHNlbGVjdERpdiwgV0lEVEgsIHNlbGVjdC53aWR0aCA9IGRpbSk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTZWxWKG9mZiwgZGltKSB7XG5cdFx0c2V0U3R5bGVQeChzZWxlY3REaXYsIFRPUCwgICAgc2VsZWN0LnRvcCA9IG9mZik7XG5cdFx0c2V0U3R5bGVQeChzZWxlY3REaXYsIEhFSUdIVCwgc2VsZWN0LmhlaWdodCA9IGRpbSk7XG5cdH1cblxuXHRsZXQgc2V0U2VsWCA9IHNjYWxlWC5vcmkgPT0gMCA/IHNldFNlbEggOiBzZXRTZWxWO1xuXHRsZXQgc2V0U2VsWSA9IHNjYWxlWC5vcmkgPT0gMSA/IHNldFNlbEggOiBzZXRTZWxWO1xuXG5cdGZ1bmN0aW9uIHN5bmNMZWdlbmQoKSB7XG5cdFx0aWYgKHNob3dMZWdlbmQgJiYgbGVnZW5kLmxpdmUpIHtcblx0XHRcdGZvciAobGV0IGkgPSBtb2RlID09IDIgPyAxIDogMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoaSA9PSAwICYmIG11bHRpVmFsTGVnZW5kKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdGxldCB2YWxzID0gbGVnZW5kLnZhbHVlc1tpXTtcblxuXHRcdFx0XHRsZXQgaiA9IDA7XG5cblx0XHRcdFx0Zm9yIChsZXQgayBpbiB2YWxzKVxuXHRcdFx0XHRcdGxlZ2VuZENlbGxzW2ldW2orK10uZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB2YWxzW2tdO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHNldExlZ2VuZChvcHRzLCBfZmlyZSkge1xuXHRcdGlmIChvcHRzICE9IG51bGwpIHtcblx0XHRcdGxldCBpZHggPSBvcHRzLmlkeDtcblxuXHRcdFx0bGVnZW5kLmlkeCA9IGlkeDtcblx0XHRcdHNlcmllcy5mb3JFYWNoKChzLCBzaWR4KSA9PiB7XG5cdFx0XHRcdChzaWR4ID4gMCB8fCAhbXVsdGlWYWxMZWdlbmQpICYmIHNldExlZ2VuZFZhbHVlcyhzaWR4LCBpZHgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKHNob3dMZWdlbmQgJiYgbGVnZW5kLmxpdmUpXG5cdFx0XHRzeW5jTGVnZW5kKCk7XG5cblx0XHRzaG91bGRTZXRMZWdlbmQgPSBmYWxzZTtcblxuXHRcdF9maXJlICE9PSBmYWxzZSAmJiBmaXJlKFwic2V0TGVnZW5kXCIpO1xuXHR9XG5cblx0c2VsZi5zZXRMZWdlbmQgPSBzZXRMZWdlbmQ7XG5cblx0ZnVuY3Rpb24gc2V0TGVnZW5kVmFsdWVzKHNpZHgsIGlkeCkge1xuXHRcdGxldCB2YWw7XG5cblx0XHRpZiAoaWR4ID09IG51bGwpXG5cdFx0XHR2YWwgPSBOVUxMX0xFR0VORF9WQUxVRVM7XG5cdFx0ZWxzZSB7XG5cdFx0XHRsZXQgcyA9IHNlcmllc1tzaWR4XTtcblx0XHRcdGxldCBzcmMgPSBzaWR4ID09IDAgJiYgeFNjYWxlRGlzdHIgPT0gMiA/IGRhdGEwIDogZGF0YVtzaWR4XTtcblx0XHRcdHZhbCA9IG11bHRpVmFsTGVnZW5kID8gcy52YWx1ZXMoc2VsZiwgc2lkeCwgaWR4KSA6IHtfOiBzLnZhbHVlKHNlbGYsIHNyY1tpZHhdLCBzaWR4LCBpZHgpfTtcblx0XHR9XG5cblx0XHRsZWdlbmQudmFsdWVzW3NpZHhdID0gdmFsO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlQ3Vyc29yKHNyYywgX2ZpcmUsIF9wdWIpIHtcblx0Ly9cdHRzID09IG51bGwgJiYgbG9nKFwidXBkYXRlQ3Vyc29yKClcIiwgYXJndW1lbnRzKTtcblxuXHRcdHJhd01vdXNlTGVmdDEgPSBtb3VzZUxlZnQxO1xuXHRcdHJhd01vdXNlVG9wMSA9IG1vdXNlVG9wMTtcblxuXHRcdFttb3VzZUxlZnQxLCBtb3VzZVRvcDFdID0gY3Vyc29yLm1vdmUoc2VsZiwgbW91c2VMZWZ0MSwgbW91c2VUb3AxKTtcblxuXHRcdGlmIChjdXJzb3Iuc2hvdykge1xuXHRcdFx0dkN1cnNvciAmJiBlbFRyYW5zKHZDdXJzb3IsIHJvdW5kKG1vdXNlTGVmdDEpLCAwLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzKTtcblx0XHRcdGhDdXJzb3IgJiYgZWxUcmFucyhoQ3Vyc29yLCAwLCByb3VuZChtb3VzZVRvcDEpLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzKTtcblx0XHR9XG5cblx0XHRsZXQgaWR4O1xuXG5cdFx0Ly8gd2hlbiB6b29taW5nIHRvIGFuIHggc2NhbGUgcmFuZ2UgYmV0d2VlbiBkYXRhcG9pbnRzIHRoZSBiaW5hcnkgc2VhcmNoXG5cdFx0Ly8gZm9yIG5lYXJlc3QgbWluL21heCBpbmRpY2VzIHJlc3VsdHMgaW4gdGhpcyBjb25kaXRpb24uIGNoZWFwIGhhY2sgOkRcblx0XHRsZXQgbm9EYXRhSW5SYW5nZSA9IGkwID4gaTE7IC8vIHdvcmtzIGZvciBtb2RlIDEgb25seVxuXG5cdFx0Y2xvc2VzdERpc3QgPSBpbmY7XG5cblx0XHQvLyBUT0RPOiBleHRyYWN0XG5cdFx0bGV0IHhEaW0gPSBzY2FsZVgub3JpID09IDAgPyBwbG90V2lkQ3NzIDogcGxvdEhndENzcztcblx0XHRsZXQgeURpbSA9IHNjYWxlWC5vcmkgPT0gMSA/IHBsb3RXaWRDc3MgOiBwbG90SGd0Q3NzO1xuXG5cdFx0Ly8gaWYgY3Vyc29yIGhpZGRlbiwgaGlkZSBwb2ludHMgJiBjbGVhciBsZWdlbmQgdmFsc1xuXHRcdGlmIChtb3VzZUxlZnQxIDwgMCB8fCBkYXRhTGVuID09IDAgfHwgbm9EYXRhSW5SYW5nZSkge1xuXHRcdFx0aWR4ID0gbnVsbDtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdFx0Y3Vyc29yUHRzLmxlbmd0aCA+IDEgJiYgZWxUcmFucyhjdXJzb3JQdHNbaV0sIC0xMCwgLTEwLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY3Vyc29yRm9jdXMpXG5cdFx0XHRcdHNldFNlcmllcyhudWxsLCBGT0NVU19UUlVFLCB0cnVlLCBzcmMgPT0gbnVsbCAmJiBzeW5jT3B0cy5zZXRTZXJpZXMpO1xuXG5cdFx0XHRpZiAobGVnZW5kLmxpdmUpIHtcblx0XHRcdFx0YWN0aXZlSWR4cy5maWxsKG51bGwpO1xuXHRcdFx0XHRzaG91bGRTZXRMZWdlbmQgPSB0cnVlO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdGxlZ2VuZC52YWx1ZXNbaV0gPSBOVUxMX0xFR0VORF9WQUxVRVM7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdC8vXHRsZXQgcGN0WSA9IDEgLSAoeSAvIHJlY3QuaGVpZ2h0KTtcblxuXHRcdFx0bGV0IG1vdXNlWFBvcywgdmFsQXRQb3NYLCB4UG9zO1xuXG5cdFx0XHRpZiAobW9kZSA9PSAxKSB7XG5cdFx0XHRcdG1vdXNlWFBvcyA9IHNjYWxlWC5vcmkgPT0gMCA/IG1vdXNlTGVmdDEgOiBtb3VzZVRvcDE7XG5cdFx0XHRcdHZhbEF0UG9zWCA9IHBvc1RvVmFsKG1vdXNlWFBvcywgeFNjYWxlS2V5KTtcblx0XHRcdFx0aWR4ID0gY2xvc2VzdElkeCh2YWxBdFBvc1gsIGRhdGFbMF0sIGkwLCBpMSk7XG5cdFx0XHRcdHhQb3MgPSBpbmNyUm91bmRVcCh2YWxUb1Bvc1goZGF0YVswXVtpZHhdLCBzY2FsZVgsIHhEaW0sIDApLCAwLjUpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBpID0gbW9kZSA9PSAyID8gMSA6IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bGV0IHMgPSBzZXJpZXNbaV07XG5cblx0XHRcdFx0bGV0IGlkeDEgID0gYWN0aXZlSWR4c1tpXTtcblx0XHRcdFx0bGV0IHlWYWwxID0gbW9kZSA9PSAxID8gZGF0YVtpXVtpZHgxXSA6IGRhdGFbaV1bMV1baWR4MV07XG5cblx0XHRcdFx0bGV0IGlkeDIgID0gY3Vyc29yLmRhdGFJZHgoc2VsZiwgaSwgaWR4LCB2YWxBdFBvc1gpO1xuXHRcdFx0XHRsZXQgeVZhbDIgPSBtb2RlID09IDEgPyBkYXRhW2ldW2lkeDJdIDogZGF0YVtpXVsxXVtpZHgyXTtcblxuXHRcdFx0XHRzaG91bGRTZXRMZWdlbmQgPSBzaG91bGRTZXRMZWdlbmQgfHwgeVZhbDIgIT0geVZhbDEgfHwgaWR4MiAhPSBpZHgxO1xuXG5cdFx0XHRcdGFjdGl2ZUlkeHNbaV0gPSBpZHgyO1xuXG5cdFx0XHRcdGxldCB4UG9zMiA9IGlkeDIgPT0gaWR4ID8geFBvcyA6IGluY3JSb3VuZFVwKHZhbFRvUG9zWChtb2RlID09IDEgPyBkYXRhWzBdW2lkeDJdIDogZGF0YVtpXVswXVtpZHgyXSwgc2NhbGVYLCB4RGltLCAwKSwgMC41KTtcblxuXHRcdFx0XHRpZiAoaSA+IDAgJiYgcy5zaG93KSB7XG5cdFx0XHRcdFx0bGV0IHlQb3MgPSB5VmFsMiA9PSBudWxsID8gLTEwIDogaW5jclJvdW5kVXAodmFsVG9Qb3NZKHlWYWwyLCBtb2RlID09IDEgPyBzY2FsZXNbcy5zY2FsZV0gOiBzY2FsZXNbcy5mYWNldHNbMV0uc2NhbGVdLCB5RGltLCAwKSwgMC41KTtcblxuXHRcdFx0XHRcdGlmICh5UG9zID4gMCAmJiBtb2RlID09IDEpIHtcblx0XHRcdFx0XHRcdGxldCBkaXN0ID0gYWJzKHlQb3MgLSBtb3VzZVRvcDEpO1xuXG5cdFx0XHRcdFx0XHRpZiAoZGlzdCA8PSBjbG9zZXN0RGlzdCkge1xuXHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdCA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRcdGNsb3Nlc3RTZXJpZXMgPSBpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCBoUG9zLCB2UG9zO1xuXG5cdFx0XHRcdFx0aWYgKHNjYWxlWC5vcmkgPT0gMCkge1xuXHRcdFx0XHRcdFx0aFBvcyA9IHhQb3MyO1xuXHRcdFx0XHRcdFx0dlBvcyA9IHlQb3M7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0aFBvcyA9IHlQb3M7XG5cdFx0XHRcdFx0XHR2UG9zID0geFBvczI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHNob3VsZFNldExlZ2VuZCAmJiBjdXJzb3JQdHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdFx0ZWxDb2xvcihjdXJzb3JQdHNbaV0sIGN1cnNvci5wb2ludHMuZmlsbChzZWxmLCBpKSwgY3Vyc29yLnBvaW50cy5zdHJva2Uoc2VsZiwgaSkpO1xuXG5cdFx0XHRcdFx0XHRsZXQgcHRXaWQsIHB0SGd0LCBwdExmdCwgcHRUb3AsXG5cdFx0XHRcdFx0XHRcdGNlbnRlcmVkID0gdHJ1ZSxcblx0XHRcdFx0XHRcdFx0Z2V0QkJveCA9IGN1cnNvci5wb2ludHMuYmJveDtcblxuXHRcdFx0XHRcdFx0aWYgKGdldEJCb3ggIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRjZW50ZXJlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRcdGxldCBiYm94ID0gZ2V0QkJveChzZWxmLCBpKTtcblxuXHRcdFx0XHRcdFx0XHRwdExmdCA9IGJib3gubGVmdDtcblx0XHRcdFx0XHRcdFx0cHRUb3AgPSBiYm94LnRvcDtcblx0XHRcdFx0XHRcdFx0cHRXaWQgPSBiYm94LndpZHRoO1xuXHRcdFx0XHRcdFx0XHRwdEhndCA9IGJib3guaGVpZ2h0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHB0TGZ0ID0gaFBvcztcblx0XHRcdFx0XHRcdFx0cHRUb3AgPSB2UG9zO1xuXHRcdFx0XHRcdFx0XHRwdFdpZCA9IHB0SGd0ID0gY3Vyc29yLnBvaW50cy5zaXplKHNlbGYsIGkpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRlbFNpemUoY3Vyc29yUHRzW2ldLCBwdFdpZCwgcHRIZ3QsIGNlbnRlcmVkKTtcblx0XHRcdFx0XHRcdGVsVHJhbnMoY3Vyc29yUHRzW2ldLCBwdExmdCwgcHRUb3AsIHBsb3RXaWRDc3MsIHBsb3RIZ3RDc3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChsZWdlbmQubGl2ZSkge1xuXHRcdFx0XHRcdGlmICghc2hvdWxkU2V0TGVnZW5kIHx8IGkgPT0gMCAmJiBtdWx0aVZhbExlZ2VuZClcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0c2V0TGVnZW5kVmFsdWVzKGksIGlkeDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y3Vyc29yLmlkeCA9IGlkeDtcblx0XHRjdXJzb3IubGVmdCA9IG1vdXNlTGVmdDE7XG5cdFx0Y3Vyc29yLnRvcCA9IG1vdXNlVG9wMTtcblxuXHRcdGlmIChzaG91bGRTZXRMZWdlbmQpIHtcblx0XHRcdGxlZ2VuZC5pZHggPSBpZHg7XG5cdFx0XHRzZXRMZWdlbmQoKTtcblx0XHR9XG5cblx0XHQvLyBuaXQ6IGN1cnNvci5kcmFnLnNldFNlbGVjdCBpcyBhc3N1bWVkIGFsd2F5cyB0cnVlXG5cdFx0aWYgKHNlbGVjdC5zaG93ICYmIGRyYWdnaW5nKSB7XG5cdFx0XHRpZiAoc3JjICE9IG51bGwpIHtcblx0XHRcdFx0bGV0IFt4S2V5LCB5S2V5XSA9IHN5bmNPcHRzLnNjYWxlcztcblx0XHRcdFx0bGV0IFttYXRjaFhLZXlzLCBtYXRjaFlLZXlzXSA9IHN5bmNPcHRzLm1hdGNoO1xuXHRcdFx0XHRsZXQgW3hLZXlTcmMsIHlLZXlTcmNdID0gc3JjLmN1cnNvci5zeW5jLnNjYWxlcztcblxuXHRcdFx0XHQvLyBtYXRjaCB0aGUgZHJhZ1gvZHJhZ1kgaW1wbGljaXRuZXNzL2V4cGxpY2l0bmVzcyBvZiBzcmNcblx0XHRcdFx0bGV0IHNkcmFnID0gc3JjLmN1cnNvci5kcmFnO1xuXHRcdFx0XHRkcmFnWCA9IHNkcmFnLl94O1xuXHRcdFx0XHRkcmFnWSA9IHNkcmFnLl95O1xuXG5cdFx0XHRcdGlmIChkcmFnWCB8fCBkcmFnWSkge1xuXHRcdFx0XHRcdGxldCB7IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB9ID0gc3JjLnNlbGVjdDtcblxuXHRcdFx0XHRcdGxldCBzb3JpID0gc3JjLnNjYWxlc1t4S2V5XS5vcmk7XG5cdFx0XHRcdFx0bGV0IHNQb3NUb1ZhbCA9IHNyYy5wb3NUb1ZhbDtcblxuXHRcdFx0XHRcdGxldCBzT2ZmLCBzRGltLCBzYywgYSwgYjtcblxuXHRcdFx0XHRcdGxldCBtYXRjaGluZ1ggPSB4S2V5ICE9IG51bGwgJiYgbWF0Y2hYS2V5cyh4S2V5LCB4S2V5U3JjKTtcblx0XHRcdFx0XHRsZXQgbWF0Y2hpbmdZID0geUtleSAhPSBudWxsICYmIG1hdGNoWUtleXMoeUtleSwgeUtleVNyYyk7XG5cblx0XHRcdFx0XHRpZiAobWF0Y2hpbmdYICYmIGRyYWdYKSB7XG5cdFx0XHRcdFx0XHRpZiAoc29yaSA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHNPZmYgPSBsZWZ0O1xuXHRcdFx0XHRcdFx0XHRzRGltID0gd2lkdGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0c09mZiA9IHRvcDtcblx0XHRcdFx0XHRcdFx0c0RpbSA9IGhlaWdodDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c2MgPSBzY2FsZXNbeEtleV07XG5cblx0XHRcdFx0XHRcdGEgPSB2YWxUb1Bvc1goc1Bvc1RvVmFsKHNPZmYsIHhLZXlTcmMpLCAgICAgICAgc2MsIHhEaW0sIDApO1xuXHRcdFx0XHRcdFx0YiA9IHZhbFRvUG9zWChzUG9zVG9WYWwoc09mZiArIHNEaW0sIHhLZXlTcmMpLCBzYywgeERpbSwgMCk7XG5cblx0XHRcdFx0XHRcdHNldFNlbFgobWluKGEsYiksIGFicyhiLWEpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0c2V0U2VsWCgwLCB4RGltKTtcblxuXHRcdFx0XHRcdGlmIChtYXRjaGluZ1kgJiYgZHJhZ1kpIHtcblx0XHRcdFx0XHRcdGlmIChzb3JpID09IDEpIHtcblx0XHRcdFx0XHRcdFx0c09mZiA9IGxlZnQ7XG5cdFx0XHRcdFx0XHRcdHNEaW0gPSB3aWR0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzT2ZmID0gdG9wO1xuXHRcdFx0XHRcdFx0XHRzRGltID0gaGVpZ2h0O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzYyA9IHNjYWxlc1t5S2V5XTtcblxuXHRcdFx0XHRcdFx0YSA9IHZhbFRvUG9zWShzUG9zVG9WYWwoc09mZiwgeUtleVNyYyksICAgICAgICBzYywgeURpbSwgMCk7XG5cdFx0XHRcdFx0XHRiID0gdmFsVG9Qb3NZKHNQb3NUb1ZhbChzT2ZmICsgc0RpbSwgeUtleVNyYyksIHNjLCB5RGltLCAwKTtcblxuXHRcdFx0XHRcdFx0c2V0U2VsWShtaW4oYSxiKSwgYWJzKGItYSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRzZXRTZWxZKDAsIHlEaW0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRoaWRlU2VsZWN0KCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bGV0IHJhd0RYID0gYWJzKHJhd01vdXNlTGVmdDEgLSByYXdNb3VzZUxlZnQwKTtcblx0XHRcdFx0bGV0IHJhd0RZID0gYWJzKHJhd01vdXNlVG9wMSAtIHJhd01vdXNlVG9wMCk7XG5cblx0XHRcdFx0aWYgKHNjYWxlWC5vcmkgPT0gMSkge1xuXHRcdFx0XHRcdGxldCBfcmF3RFggPSByYXdEWDtcblx0XHRcdFx0XHRyYXdEWCA9IHJhd0RZO1xuXHRcdFx0XHRcdHJhd0RZID0gX3Jhd0RYO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZHJhZ1ggPSBkcmFnLnggJiYgcmF3RFggPj0gZHJhZy5kaXN0O1xuXHRcdFx0XHRkcmFnWSA9IGRyYWcueSAmJiByYXdEWSA+PSBkcmFnLmRpc3Q7XG5cblx0XHRcdFx0bGV0IHVuaSA9IGRyYWcudW5pO1xuXG5cdFx0XHRcdGlmICh1bmkgIT0gbnVsbCkge1xuXHRcdFx0XHRcdC8vIG9ubHkgY2FsYyBkcmFnIHN0YXR1cyBpZiB0aGV5IHBhc3MgdGhlIGRpc3QgdGhyZXNoXG5cdFx0XHRcdFx0aWYgKGRyYWdYICYmIGRyYWdZKSB7XG5cdFx0XHRcdFx0XHRkcmFnWCA9IHJhd0RYID49IHVuaTtcblx0XHRcdFx0XHRcdGRyYWdZID0gcmF3RFkgPj0gdW5pO1xuXG5cdFx0XHRcdFx0XHQvLyBmb3JjZSB1bmlkaXJlY3Rpb25hbGl0eSB3aGVuIGJvdGggYXJlIHVuZGVyIHVuaSBsaW1pdFxuXHRcdFx0XHRcdFx0aWYgKCFkcmFnWCAmJiAhZHJhZ1kpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHJhd0RZID4gcmF3RFgpXG5cdFx0XHRcdFx0XHRcdFx0ZHJhZ1kgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0ZHJhZ1ggPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChkcmFnLnggJiYgZHJhZy55ICYmIChkcmFnWCB8fCBkcmFnWSkpXG5cdFx0XHRcdFx0Ly8gaWYgb21uaSB3aXRoIG5vIHVuaSB0aGVuIGJvdGggZHJhZ1ggLyBkcmFnWSBzaG91bGQgYmUgdHJ1ZSBpZiBlaXRoZXIgaXMgdHJ1ZVxuXHRcdFx0XHRcdGRyYWdYID0gZHJhZ1kgPSB0cnVlO1xuXG5cdFx0XHRcdGxldCBwMCwgcDE7XG5cblx0XHRcdFx0aWYgKGRyYWdYKSB7XG5cdFx0XHRcdFx0aWYgKHNjYWxlWC5vcmkgPT0gMCkge1xuXHRcdFx0XHRcdFx0cDAgPSBtb3VzZUxlZnQwO1xuXHRcdFx0XHRcdFx0cDEgPSBtb3VzZUxlZnQxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHAwID0gbW91c2VUb3AwO1xuXHRcdFx0XHRcdFx0cDEgPSBtb3VzZVRvcDE7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2V0U2VsWChtaW4ocDAsIHAxKSwgYWJzKHAxIC0gcDApKTtcblxuXHRcdFx0XHRcdGlmICghZHJhZ1kpXG5cdFx0XHRcdFx0XHRzZXRTZWxZKDAsIHlEaW0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGRyYWdZKSB7XG5cdFx0XHRcdFx0aWYgKHNjYWxlWC5vcmkgPT0gMSkge1xuXHRcdFx0XHRcdFx0cDAgPSBtb3VzZUxlZnQwO1xuXHRcdFx0XHRcdFx0cDEgPSBtb3VzZUxlZnQxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHAwID0gbW91c2VUb3AwO1xuXHRcdFx0XHRcdFx0cDEgPSBtb3VzZVRvcDE7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2V0U2VsWShtaW4ocDAsIHAxKSwgYWJzKHAxIC0gcDApKTtcblxuXHRcdFx0XHRcdGlmICghZHJhZ1gpXG5cdFx0XHRcdFx0XHRzZXRTZWxYKDAsIHhEaW0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdGhlIGRyYWcgZGlkbid0IHBhc3MgdGhlIGRpc3QgcmVxdWlyZW1lbnRcblx0XHRcdFx0aWYgKCFkcmFnWCAmJiAhZHJhZ1kpIHtcblx0XHRcdFx0XHRzZXRTZWxYKDAsIDApO1xuXHRcdFx0XHRcdHNldFNlbFkoMCwgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRkcmFnLl94ID0gZHJhZ1g7XG5cdFx0ZHJhZy5feSA9IGRyYWdZO1xuXG5cdFx0aWYgKHNyYyA9PSBudWxsKSB7XG5cdFx0XHRpZiAoX3B1Yikge1xuXHRcdFx0XHRpZiAoc3luY0tleSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0bGV0IFt4U3luY0tleSwgeVN5bmNLZXldID0gc3luY09wdHMuc2NhbGVzO1xuXG5cdFx0XHRcdFx0c3luY09wdHMudmFsdWVzWzBdID0geFN5bmNLZXkgIT0gbnVsbCA/IHBvc1RvVmFsKHNjYWxlWC5vcmkgPT0gMCA/IG1vdXNlTGVmdDEgOiBtb3VzZVRvcDEsIHhTeW5jS2V5KSA6IG51bGw7XG5cdFx0XHRcdFx0c3luY09wdHMudmFsdWVzWzFdID0geVN5bmNLZXkgIT0gbnVsbCA/IHBvc1RvVmFsKHNjYWxlWC5vcmkgPT0gMSA/IG1vdXNlTGVmdDEgOiBtb3VzZVRvcDEsIHlTeW5jS2V5KSA6IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwdWJTeW5jKG1vdXNlbW92ZSwgc2VsZiwgbW91c2VMZWZ0MSwgbW91c2VUb3AxLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzLCBpZHgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY3Vyc29yRm9jdXMpIHtcblx0XHRcdFx0bGV0IHNob3VsZFB1YiA9IF9wdWIgJiYgc3luY09wdHMuc2V0U2VyaWVzO1xuXHRcdFx0XHRsZXQgcCA9IGZvY3VzLnByb3g7XG5cblx0XHRcdFx0aWYgKGZvY3VzZWRTZXJpZXMgPT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChjbG9zZXN0RGlzdCA8PSBwKVxuXHRcdFx0XHRcdFx0c2V0U2VyaWVzKGNsb3Nlc3RTZXJpZXMsIEZPQ1VTX1RSVUUsIHRydWUsIHNob3VsZFB1Yik7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGNsb3Nlc3REaXN0ID4gcClcblx0XHRcdFx0XHRcdHNldFNlcmllcyhudWxsLCBGT0NVU19UUlVFLCB0cnVlLCBzaG91bGRQdWIpO1xuXHRcdFx0XHRcdGVsc2UgaWYgKGNsb3Nlc3RTZXJpZXMgIT0gZm9jdXNlZFNlcmllcylcblx0XHRcdFx0XHRcdHNldFNlcmllcyhjbG9zZXN0U2VyaWVzLCBGT0NVU19UUlVFLCB0cnVlLCBzaG91bGRQdWIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmVhZHkgJiYgX2ZpcmUgIT09IGZhbHNlICYmIGZpcmUoXCJzZXRDdXJzb3JcIik7XG5cdH1cblxuXHRsZXQgcmVjdCA9IG51bGw7XG5cblx0ZnVuY3Rpb24gc3luY1JlY3QoZGVmZXIpIHtcblx0XHRpZiAoZGVmZXIgPT09IHRydWUpXG5cdFx0XHRyZWN0ID0gbnVsbDtcblx0XHRlbHNlIHtcblx0XHRcdHJlY3QgPSBvdmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0ZmlyZShcInN5bmNSZWN0XCIsIHJlY3QpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1vdXNlTW92ZShlLCBzcmMsIF9sLCBfdCwgX3csIF9oLCBfaSkge1xuXHRcdGlmIChjdXJzb3IuX2xvY2spXG5cdFx0XHRyZXR1cm47XG5cblx0XHRjYWNoZU1vdXNlKGUsIHNyYywgX2wsIF90LCBfdywgX2gsIF9pLCBmYWxzZSwgZSAhPSBudWxsKTtcblxuXHRcdGlmIChlICE9IG51bGwpXG5cdFx0XHR1cGRhdGVDdXJzb3IobnVsbCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0ZWxzZVxuXHRcdFx0dXBkYXRlQ3Vyc29yKHNyYywgdHJ1ZSwgZmFsc2UpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FjaGVNb3VzZShlLCBzcmMsIF9sLCBfdCwgX3csIF9oLCBfaSwgaW5pdGlhbCwgc25hcCkge1xuXHRcdGlmIChyZWN0ID09IG51bGwpXG5cdFx0XHRzeW5jUmVjdChmYWxzZSk7XG5cblx0XHRpZiAoZSAhPSBudWxsKSB7XG5cdFx0XHRfbCA9IGUuY2xpZW50WCAtIHJlY3QubGVmdDtcblx0XHRcdF90ID0gZS5jbGllbnRZIC0gcmVjdC50b3A7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKF9sIDwgMCB8fCBfdCA8IDApIHtcblx0XHRcdFx0bW91c2VMZWZ0MSA9IC0xMDtcblx0XHRcdFx0bW91c2VUb3AxID0gLTEwO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGxldCBbeEtleSwgeUtleV0gPSBzeW5jT3B0cy5zY2FsZXM7XG5cblx0XHRcdGxldCBzeW5jT3B0c1NyYyA9IHNyYy5jdXJzb3Iuc3luYztcblx0XHRcdGxldCBbeFZhbFNyYywgeVZhbFNyY10gPSBzeW5jT3B0c1NyYy52YWx1ZXM7XG5cdFx0XHRsZXQgW3hLZXlTcmMsIHlLZXlTcmNdID0gc3luY09wdHNTcmMuc2NhbGVzO1xuXHRcdFx0bGV0IFttYXRjaFhLZXlzLCBtYXRjaFlLZXlzXSA9IHN5bmNPcHRzLm1hdGNoO1xuXG5cdFx0XHRsZXQgcm90U3JjID0gc3JjLmF4ZXNbMF0uc2lkZSAlIDIgPT0gMTtcblxuXHRcdFx0bGV0IHhEaW0gPSBzY2FsZVgub3JpID09IDAgPyBwbG90V2lkQ3NzIDogcGxvdEhndENzcyxcblx0XHRcdFx0eURpbSA9IHNjYWxlWC5vcmkgPT0gMSA/IHBsb3RXaWRDc3MgOiBwbG90SGd0Q3NzLFxuXHRcdFx0XHRfeERpbSA9IHJvdFNyYyA/IF9oIDogX3csXG5cdFx0XHRcdF95RGltID0gcm90U3JjID8gX3cgOiBfaCxcblx0XHRcdFx0X3hQb3MgPSByb3RTcmMgPyBfdCA6IF9sLFxuXHRcdFx0XHRfeVBvcyA9IHJvdFNyYyA/IF9sIDogX3Q7XG5cblx0XHRcdGlmICh4S2V5U3JjICE9IG51bGwpXG5cdFx0XHRcdF9sID0gbWF0Y2hYS2V5cyh4S2V5LCB4S2V5U3JjKSA/IGdldFBvcyh4VmFsU3JjLCBzY2FsZXNbeEtleV0sIHhEaW0sIDApIDogLTEwO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRfbCA9IHhEaW0gKiAoX3hQb3MvX3hEaW0pO1xuXG5cdFx0XHRpZiAoeUtleVNyYyAhPSBudWxsKVxuXHRcdFx0XHRfdCA9IG1hdGNoWUtleXMoeUtleSwgeUtleVNyYykgPyBnZXRQb3MoeVZhbFNyYywgc2NhbGVzW3lLZXldLCB5RGltLCAwKSA6IC0xMDtcblx0XHRcdGVsc2Vcblx0XHRcdFx0X3QgPSB5RGltICogKF95UG9zL195RGltKTtcblxuXHRcdFx0aWYgKHNjYWxlWC5vcmkgPT0gMSkge1xuXHRcdFx0XHRsZXQgX19sID0gX2w7XG5cdFx0XHRcdF9sID0gX3Q7XG5cdFx0XHRcdF90ID0gX19sO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChzbmFwKSB7XG5cdFx0XHRpZiAoX2wgPD0gMSB8fCBfbCA+PSBwbG90V2lkQ3NzIC0gMSlcblx0XHRcdFx0X2wgPSBpbmNyUm91bmQoX2wsIHBsb3RXaWRDc3MpO1xuXG5cdFx0XHRpZiAoX3QgPD0gMSB8fCBfdCA+PSBwbG90SGd0Q3NzIC0gMSlcblx0XHRcdFx0X3QgPSBpbmNyUm91bmQoX3QsIHBsb3RIZ3RDc3MpO1xuXHRcdH1cblxuXHRcdGlmIChpbml0aWFsKSB7XG5cdFx0XHRyYXdNb3VzZUxlZnQwID0gX2w7XG5cdFx0XHRyYXdNb3VzZVRvcDAgPSBfdDtcblxuXHRcdFx0W21vdXNlTGVmdDAsIG1vdXNlVG9wMF0gPSBjdXJzb3IubW92ZShzZWxmLCBfbCwgX3QpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG1vdXNlTGVmdDEgPSBfbDtcblx0XHRcdG1vdXNlVG9wMSA9IF90O1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IF9oaWRlUHJvcHMgPSB7XG5cdFx0d2lkdGg6IDAsXG5cdFx0aGVpZ2h0OiAwLFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGhpZGVTZWxlY3QoKSB7XG5cdFx0c2V0U2VsZWN0KF9oaWRlUHJvcHMsIGZhbHNlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1vdXNlRG93bihlLCBzcmMsIF9sLCBfdCwgX3csIF9oLCBfaSkge1xuXHRcdGRyYWdnaW5nID0gdHJ1ZTtcblx0XHRkcmFnWCA9IGRyYWdZID0gZHJhZy5feCA9IGRyYWcuX3kgPSBmYWxzZTtcblxuXHRcdGNhY2hlTW91c2UoZSwgc3JjLCBfbCwgX3QsIF93LCBfaCwgX2ksIHRydWUsIGZhbHNlKTtcblxuXHRcdGlmIChlICE9IG51bGwpIHtcblx0XHRcdG9uTW91c2UobW91c2V1cCwgZG9jLCBtb3VzZVVwKTtcblx0XHRcdHB1YlN5bmMobW91c2Vkb3duLCBzZWxmLCBtb3VzZUxlZnQwLCBtb3VzZVRvcDAsIHBsb3RXaWRDc3MsIHBsb3RIZ3RDc3MsIG51bGwpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1vdXNlVXAoZSwgc3JjLCBfbCwgX3QsIF93LCBfaCwgX2kpIHtcblx0XHRkcmFnZ2luZyA9IGRyYWcuX3ggPSBkcmFnLl95ID0gZmFsc2U7XG5cblx0XHRjYWNoZU1vdXNlKGUsIHNyYywgX2wsIF90LCBfdywgX2gsIF9pLCBmYWxzZSwgdHJ1ZSk7XG5cblx0XHRsZXQgeyBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgfSA9IHNlbGVjdDtcblxuXHRcdGxldCBoYXNTZWxlY3QgPSB3aWR0aCA+IDAgfHwgaGVpZ2h0ID4gMDtcblxuXHRcdGhhc1NlbGVjdCAmJiBzZXRTZWxlY3Qoc2VsZWN0KTtcblxuXHRcdGlmIChkcmFnLnNldFNjYWxlICYmIGhhc1NlbGVjdCkge1xuXHRcdC8vXHRpZiAoc3luY0tleSAhPSBudWxsKSB7XG5cdFx0Ly9cdFx0ZHJhZ1ggPSBkcmFnLng7XG5cdFx0Ly9cdFx0ZHJhZ1kgPSBkcmFnLnk7XG5cdFx0Ly9cdH1cblxuXHRcdFx0bGV0IHhPZmYgPSBsZWZ0LFxuXHRcdFx0XHR4RGltID0gd2lkdGgsXG5cdFx0XHRcdHlPZmYgPSB0b3AsXG5cdFx0XHRcdHlEaW0gPSBoZWlnaHQ7XG5cblx0XHRcdGlmIChzY2FsZVgub3JpID09IDEpIHtcblx0XHRcdFx0eE9mZiA9IHRvcCxcblx0XHRcdFx0eERpbSA9IGhlaWdodCxcblx0XHRcdFx0eU9mZiA9IGxlZnQsXG5cdFx0XHRcdHlEaW0gPSB3aWR0aDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRyYWdYKSB7XG5cdFx0XHRcdF9zZXRTY2FsZSh4U2NhbGVLZXksXG5cdFx0XHRcdFx0cG9zVG9WYWwoeE9mZiwgeFNjYWxlS2V5KSxcblx0XHRcdFx0XHRwb3NUb1ZhbCh4T2ZmICsgeERpbSwgeFNjYWxlS2V5KVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZHJhZ1kpIHtcblx0XHRcdFx0Zm9yIChsZXQgayBpbiBzY2FsZXMpIHtcblx0XHRcdFx0XHRsZXQgc2MgPSBzY2FsZXNba107XG5cblx0XHRcdFx0XHRpZiAoayAhPSB4U2NhbGVLZXkgJiYgc2MuZnJvbSA9PSBudWxsICYmIHNjLm1pbiAhPSBpbmYpIHtcblx0XHRcdFx0XHRcdF9zZXRTY2FsZShrLFxuXHRcdFx0XHRcdFx0XHRwb3NUb1ZhbCh5T2ZmICsgeURpbSwgayksXG5cdFx0XHRcdFx0XHRcdHBvc1RvVmFsKHlPZmYsIGspXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRoaWRlU2VsZWN0KCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGN1cnNvci5sb2NrKSB7XG5cdFx0XHRjdXJzb3IuX2xvY2sgPSAhY3Vyc29yLl9sb2NrO1xuXG5cdFx0XHRpZiAoIWN1cnNvci5fbG9jaylcblx0XHRcdFx0dXBkYXRlQ3Vyc29yKG51bGwsIHRydWUsIGZhbHNlKTtcblx0XHR9XG5cblx0XHRpZiAoZSAhPSBudWxsKSB7XG5cdFx0XHRvZmZNb3VzZShtb3VzZXVwLCBkb2MpO1xuXHRcdFx0cHViU3luYyhtb3VzZXVwLCBzZWxmLCBtb3VzZUxlZnQxLCBtb3VzZVRvcDEsIHBsb3RXaWRDc3MsIHBsb3RIZ3RDc3MsIG51bGwpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1vdXNlTGVhdmUoZSwgc3JjLCBfbCwgX3QsIF93LCBfaCwgX2kpIHtcblx0XHRpZiAoIWN1cnNvci5fbG9jaykge1xuXHRcdFx0bGV0IF9kcmFnZ2luZyA9IGRyYWdnaW5nO1xuXG5cdFx0XHRpZiAoZHJhZ2dpbmcpIHtcblx0XHRcdFx0Ly8gaGFuZGxlIGNhc2Ugd2hlbiBtb3VzZW1vdmUgYXJlbid0IGZpcmVkIGFsbCB0aGUgd2F5IHRvIGVkZ2VzIGJ5IGJyb3dzZXJcblx0XHRcdFx0bGV0IHNuYXBIID0gdHJ1ZTtcblx0XHRcdFx0bGV0IHNuYXBWID0gdHJ1ZTtcblx0XHRcdFx0bGV0IHNuYXBQcm94ID0gMTA7XG5cblx0XHRcdFx0bGV0IGRyYWdILCBkcmFnVjtcblxuXHRcdFx0XHRpZiAoc2NhbGVYLm9yaSA9PSAwKSB7XG5cdFx0XHRcdFx0ZHJhZ0ggPSBkcmFnWDtcblx0XHRcdFx0XHRkcmFnViA9IGRyYWdZO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGRyYWdIID0gZHJhZ1k7XG5cdFx0XHRcdFx0ZHJhZ1YgPSBkcmFnWDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkcmFnSCAmJiBkcmFnVikge1xuXHRcdFx0XHRcdC8vIG1heWJlIG9tbmkgY29ybmVyIHNuYXBcblx0XHRcdFx0XHRzbmFwSCA9IG1vdXNlTGVmdDEgPD0gc25hcFByb3ggfHwgbW91c2VMZWZ0MSA+PSBwbG90V2lkQ3NzIC0gc25hcFByb3g7XG5cdFx0XHRcdFx0c25hcFYgPSBtb3VzZVRvcDEgIDw9IHNuYXBQcm94IHx8IG1vdXNlVG9wMSAgPj0gcGxvdEhndENzcyAtIHNuYXBQcm94O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGRyYWdIICYmIHNuYXBIKVxuXHRcdFx0XHRcdG1vdXNlTGVmdDEgPSBtb3VzZUxlZnQxIDwgbW91c2VMZWZ0MCA/IDAgOiBwbG90V2lkQ3NzO1xuXG5cdFx0XHRcdGlmIChkcmFnViAmJiBzbmFwVilcblx0XHRcdFx0XHRtb3VzZVRvcDEgPSBtb3VzZVRvcDEgPCBtb3VzZVRvcDAgPyAwIDogcGxvdEhndENzcztcblxuXHRcdFx0XHR1cGRhdGVDdXJzb3IobnVsbCwgdHJ1ZSwgdHJ1ZSk7XG5cblx0XHRcdFx0ZHJhZ2dpbmcgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0bW91c2VMZWZ0MSA9IC0xMDtcblx0XHRcdG1vdXNlVG9wMSA9IC0xMDtcblxuXHRcdFx0Ly8gcGFzc2luZyBhIG5vbi1udWxsIHRpbWVzdGFtcCB0byBmb3JjZSBzeW5jL21vdXNlbW92ZSBldmVudFxuXHRcdFx0dXBkYXRlQ3Vyc29yKG51bGwsIHRydWUsIHRydWUpO1xuXG5cdFx0XHRpZiAoX2RyYWdnaW5nKVxuXHRcdFx0XHRkcmFnZ2luZyA9IF9kcmFnZ2luZztcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBkYmxDbGljayhlLCBzcmMsIF9sLCBfdCwgX3csIF9oLCBfaSkge1xuXHRcdGF1dG9TY2FsZVgoKTtcblxuXHRcdGhpZGVTZWxlY3QoKTtcblxuXHRcdGlmIChlICE9IG51bGwpXG5cdFx0XHRwdWJTeW5jKGRibGNsaWNrLCBzZWxmLCBtb3VzZUxlZnQxLCBtb3VzZVRvcDEsIHBsb3RXaWRDc3MsIHBsb3RIZ3RDc3MsIG51bGwpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc3luY1B4UmF0aW8oKSB7XG5cdFx0YXhlcy5mb3JFYWNoKHN5bmNGb250U2l6ZSk7XG5cdFx0X3NldFNpemUoc2VsZi53aWR0aCwgc2VsZi5oZWlnaHQsIHRydWUpO1xuXHR9XG5cblx0b24oZHBweGNoYW5nZSwgd2luLCBzeW5jUHhSYXRpbyk7XG5cblx0Ly8gaW50ZXJuYWwgcHViL3N1YlxuXHRjb25zdCBldmVudHMgPSB7fTtcblxuXHRldmVudHMubW91c2Vkb3duID0gbW91c2VEb3duO1xuXHRldmVudHMubW91c2Vtb3ZlID0gbW91c2VNb3ZlO1xuXHRldmVudHMubW91c2V1cCA9IG1vdXNlVXA7XG5cdGV2ZW50cy5kYmxjbGljayA9IGRibENsaWNrO1xuXHRldmVudHNbXCJzZXRTZXJpZXNcIl0gPSAoZSwgc3JjLCBpZHgsIG9wdHMpID0+IHtcblx0XHRzZXRTZXJpZXMoaWR4LCBvcHRzLCB0cnVlLCBmYWxzZSk7XG5cdH07XG5cblx0aWYgKGN1cnNvci5zaG93KSB7XG5cdFx0b25Nb3VzZShtb3VzZWRvd24sICBvdmVyLCBtb3VzZURvd24pO1xuXHRcdG9uTW91c2UobW91c2Vtb3ZlLCAgb3ZlciwgbW91c2VNb3ZlKTtcblx0XHRvbk1vdXNlKG1vdXNlZW50ZXIsIG92ZXIsIHN5bmNSZWN0KTtcblx0XHRvbk1vdXNlKG1vdXNlbGVhdmUsIG92ZXIsIG1vdXNlTGVhdmUpO1xuXG5cdFx0b25Nb3VzZShkYmxjbGljaywgb3ZlciwgZGJsQ2xpY2spO1xuXG5cdFx0Y3Vyc29yUGxvdHMuYWRkKHNlbGYpO1xuXG5cdFx0c2VsZi5zeW5jUmVjdCA9IHN5bmNSZWN0O1xuXHR9XG5cblx0Ly8gZXh0ZXJuYWwgb24vb2ZmXG5cdGNvbnN0IGhvb2tzID0gc2VsZi5ob29rcyA9IG9wdHMuaG9va3MgfHwge307XG5cblx0ZnVuY3Rpb24gZmlyZShldk5hbWUsIGExLCBhMikge1xuXHRcdGlmIChldk5hbWUgaW4gaG9va3MpIHtcblx0XHRcdGhvb2tzW2V2TmFtZV0uZm9yRWFjaChmbiA9PiB7XG5cdFx0XHRcdGZuLmNhbGwobnVsbCwgc2VsZiwgYTEsIGEyKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdChvcHRzLnBsdWdpbnMgfHwgW10pLmZvckVhY2gocCA9PiB7XG5cdFx0Zm9yIChsZXQgZXZOYW1lIGluIHAuaG9va3MpXG5cdFx0XHRob29rc1tldk5hbWVdID0gKGhvb2tzW2V2TmFtZV0gfHwgW10pLmNvbmNhdChwLmhvb2tzW2V2TmFtZV0pO1xuXHR9KTtcblxuXHRjb25zdCBzeW5jT3B0cyA9IGFzc2lnbih7XG5cdFx0a2V5OiBudWxsLFxuXHRcdHNldFNlcmllczogZmFsc2UsXG5cdFx0ZmlsdGVyczoge1xuXHRcdFx0cHViOiByZXRUcnVlLFxuXHRcdFx0c3ViOiByZXRUcnVlLFxuXHRcdH0sXG5cdFx0c2NhbGVzOiBbeFNjYWxlS2V5LCBzZXJpZXNbMV0gPyBzZXJpZXNbMV0uc2NhbGUgOiBudWxsXSxcblx0XHRtYXRjaDogW3JldEVxLCByZXRFcV0sXG5cdFx0dmFsdWVzOiBbbnVsbCwgbnVsbF0sXG5cdH0sIGN1cnNvci5zeW5jKTtcblxuXHQoY3Vyc29yLnN5bmMgPSBzeW5jT3B0cyk7XG5cblx0Y29uc3Qgc3luY0tleSA9IHN5bmNPcHRzLmtleTtcblxuXHRjb25zdCBzeW5jID0gX3N5bmMoc3luY0tleSk7XG5cblx0ZnVuY3Rpb24gcHViU3luYyh0eXBlLCBzcmMsIHgsIHksIHcsIGgsIGkpIHtcblx0XHRpZiAoc3luY09wdHMuZmlsdGVycy5wdWIodHlwZSwgc3JjLCB4LCB5LCB3LCBoLCBpKSlcblx0XHRcdHN5bmMucHViKHR5cGUsIHNyYywgeCwgeSwgdywgaCwgaSk7XG5cdH1cblxuXHRzeW5jLnN1YihzZWxmKTtcblxuXHRmdW5jdGlvbiBwdWIodHlwZSwgc3JjLCB4LCB5LCB3LCBoLCBpKSB7XG5cdFx0aWYgKHN5bmNPcHRzLmZpbHRlcnMuc3ViKHR5cGUsIHNyYywgeCwgeSwgdywgaCwgaSkpXG5cdFx0XHRldmVudHNbdHlwZV0obnVsbCwgc3JjLCB4LCB5LCB3LCBoLCBpKTtcblx0fVxuXG5cdChzZWxmLnB1YiA9IHB1Yik7XG5cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRzeW5jLnVuc3ViKHNlbGYpO1xuXHRcdGN1cnNvclBsb3RzLmRlbGV0ZShzZWxmKTtcblx0XHRtb3VzZUxpc3RlbmVycy5jbGVhcigpO1xuXHRcdG9mZihkcHB4Y2hhbmdlLCB3aW4sIHN5bmNQeFJhdGlvKTtcblx0XHRyb290LnJlbW92ZSgpO1xuXHRcdGZpcmUoXCJkZXN0cm95XCIpO1xuXHR9XG5cblx0c2VsZi5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRmdW5jdGlvbiBfaW5pdCgpIHtcblx0XHRmaXJlKFwiaW5pdFwiLCBvcHRzLCBkYXRhKTtcblxuXHRcdHNldERhdGEoZGF0YSB8fCBvcHRzLmRhdGEsIGZhbHNlKTtcblxuXHRcdGlmIChwZW5kU2NhbGVzW3hTY2FsZUtleV0pXG5cdFx0XHRzZXRTY2FsZSh4U2NhbGVLZXksIHBlbmRTY2FsZXNbeFNjYWxlS2V5XSk7XG5cdFx0ZWxzZVxuXHRcdFx0YXV0b1NjYWxlWCgpO1xuXG5cdFx0X3NldFNpemUob3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xuXG5cdFx0dXBkYXRlQ3Vyc29yKG51bGwsIHRydWUsIGZhbHNlKTtcblxuXHRcdHNldFNlbGVjdChzZWxlY3QsIGZhbHNlKTtcblx0fVxuXG5cdHNlcmllcy5mb3JFYWNoKGluaXRTZXJpZXMpO1xuXG5cdGF4ZXMuZm9yRWFjaChpbml0QXhpcyk7XG5cblx0aWYgKHRoZW4pIHtcblx0XHRpZiAodGhlbiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG5cdFx0XHR0aGVuLmFwcGVuZENoaWxkKHJvb3QpO1xuXHRcdFx0X2luaXQoKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdFx0dGhlbihzZWxmLCBfaW5pdCk7XG5cdH1cblx0ZWxzZVxuXHRcdF9pbml0KCk7XG5cblx0cmV0dXJuIHNlbGY7XG59XG5cbnVQbG90LmFzc2lnbiA9IGFzc2lnbjtcbnVQbG90LmZtdE51bSA9IGZtdE51bTtcbnVQbG90LnJhbmdlTnVtID0gcmFuZ2VOdW07XG51UGxvdC5yYW5nZUxvZyA9IHJhbmdlTG9nO1xudVBsb3QucmFuZ2VBc2luaCA9IHJhbmdlQXNpbmg7XG51UGxvdC5vcmllbnQgICA9IG9yaWVudDtcbnVQbG90LnB4UmF0aW8gPSBweFJhdGlvO1xuXG57XG5cdHVQbG90LmpvaW4gPSBqb2luO1xufVxuXG57XG5cdHVQbG90LmZtdERhdGUgPSBmbXREYXRlO1xuXHR1UGxvdC50ekRhdGUgID0gdHpEYXRlO1xufVxuXG57XG5cdHVQbG90LnN5bmMgPSBfc3luYztcbn1cblxue1xuXHR1UGxvdC5hZGRHYXAgPSBhZGRHYXA7XG5cdHVQbG90LmNsaXBHYXBzID0gY2xpcEdhcHM7XG5cblx0bGV0IHBhdGhzID0gdVBsb3QucGF0aHMgPSB7XG5cdFx0cG9pbnRzLFxuXHR9O1xuXG5cdChwYXRocy5saW5lYXIgID0gbGluZWFyKTtcblx0KHBhdGhzLnN0ZXBwZWQgPSBzdGVwcGVkKTtcblx0KHBhdGhzLmJhcnMgICAgPSBiYXJzKTtcblx0KHBhdGhzLnNwbGluZSAgPSBtb25vdG9uZUN1YmljKTtcbn1cblxuZXhwb3J0IHsgdVBsb3QgYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCBfY3NzIGZyb20gJ3VwbG90L2Rpc3QvdVBsb3QubWluLmNzcydcbmltcG9ydCB1UGxvdCBmcm9tIFwidXBsb3RcIlxuXG5sZXQgQ2hhcnRIb29rID0ge1xuICBtb3VudGVkKCkge1xuICAgIGxldCBwcm9kdWN0X2lkID0gdGhpcy5lbC5wcm9kdWN0X2lkLFxuICAgICAgZXZlbnQgPSBgbmV3LXRyYWRlOiR7cHJvZHVjdF9pZH1gLFxuICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLnRyYWRlcyA9IFtdO1xuICAgIHRoaXMucGxvdCA9IG5ldyB1UGxvdChwbG90T3B0aW9ucygpLCBbW10sIFtdXSwgdGhpcy5lbCk7XG4gICAgdGhpcy5oYW5kbGVFdmVudChldmVudCwgKHBheWxvYWQpID0+IHNlbGYuaGFuZGxlTmV3VHJhZGUocGF5bG9hZCkpXG4gIH0sXG4gIGhhbmRsZU5ld1RyYWRlKHRyYWRlKSB7XG4gICAgbGV0IHByaWNlID0gcGFyc2VGbG9hdCh0cmFkZS5wcmljZSksXG4gICAgICB0aW1lc3RhbXAgPSB0cmFkZS50cmFkZWRBdDtcblxuICAgIHRoaXMudHJhZGVzLnB1c2goe1xuICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAsIHByaWNlOiBwcmljZVxuICAgIH0pO1xuXG4gICAgaWYodGhpcy50cmFkZXMubGVuZ3RoID4gMjApIHtcbiAgICAgIHRoaXMudHJhZGVzLnNwbGljZSgwLCAxKVxuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUNoYXJ0KClcbiAgfSxcblxuICB1cGRhdGVDaGFydCgpIHtcbiAgICBsZXQgeCA9IHRoaXMudHJhZGVzLm1hcCh0ID0+IHQudGltZXN0YW1wKTtcbiAgICBsZXQgeSA9IHRoaXMudHJhZGVzLm1hcCh0ID0+IHQucHJpY2UpO1xuICAgIHRoaXMucGxvdC5zZXREYXRhKFt4LCB5XSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGxvdE9wdGlvbnMoKSB7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IDIwMCwgaGVpZ2h0OiA4MCwgXG4gICAgY2xhc3M6IFwiY2hhcnQtY29udGFpbmVyXCIsXG4gICAgY3Vyc29yOiB7c2hvdzogZmFsc2V9LCBcbiAgICBzZWxlY3Q6IHtzaG93OiBmYWxzZX0sIFxuICAgIGxlZ2VuZDoge3Nob3c6IGZhbHNlfSxcbiAgICBzY2FsZXM6IHt9LFxuICAgIGF4ZXM6IFtcbiAgICAgIHtzaG93OiBmYWxzZX0sXG4gICAgICB7c2hvdzogZmFsc2V9XG4gICAgXSxcbiAgICBzZXJpZXM6IFtcbiAgICAgIHt9LFxuICAgICAge1xuICAgICAgICBzaXplOiAwLFxuICAgICAgICB3aWR0aDogMixcbiAgICAgICAgc3Ryb2tlOiBcIndoaXRlXCIsXG4gICAgICAgIGZpbGw6IFwicmdiKDQ1LDg1LDE1MClcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgfTtcbn1cblxuZXhwb3J0IHsgQ2hhcnRIb29rIH0iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFNQSxNQUFDLFVBQVUsU0FBUSxXQUFVO0FBQzNCO0FBR0EsUUFBQyxZQUFZO0FBQ1gsY0FBSSxXQUFXO0FBQ2YsY0FBSSxVQUFVLENBQUMsTUFBTSxPQUFPLFVBQVUsR0FBRztBQUN6QyxtQkFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLFVBQVUsQ0FBQyxRQUFPLHVCQUF1QixFQUFFLEdBQUc7QUFDeEUsb0JBQU8sd0JBQ0wsUUFBTyxRQUFRLEtBQUs7QUFDdEIsb0JBQU8sdUJBQ0wsUUFBTyxRQUFRLEtBQUssMkJBQ3BCLFFBQU8sUUFBUSxLQUFLO0FBQUEsVUFDeEI7QUFDQSxjQUFJLENBQUMsUUFBTztBQUNWLG9CQUFPLHdCQUF3QixTQUFVLFVBQVUsU0FBUztBQUMxRCxrQkFBSSxXQUFXLElBQUksS0FBSyxFQUFFLFFBQVE7QUFDbEMsa0JBQUksYUFBYSxLQUFLLElBQUksR0FBRyxLQUFNLFlBQVcsU0FBUztBQUN2RCxrQkFBSSxLQUFLLFFBQU8sV0FBVyxXQUFZO0FBQ3JDLHlCQUFTLFdBQVcsVUFBVTtBQUFBLGNBQ2hDLEdBQUcsVUFBVTtBQUNiLHlCQUFXLFdBQVc7QUFD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
