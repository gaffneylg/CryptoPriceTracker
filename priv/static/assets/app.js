(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));

  // vendor/topbar.js
  var require_topbar = __commonJS({
    "vendor/topbar.js"(exports, module) {
      (function(window2, document2) {
        "use strict";
        (function() {
          var lastTime = 0;
          var vendors = ["ms", "moz", "webkit", "o"];
          for (var x = 0; x < vendors.length && !window2.requestAnimationFrame; ++x) {
            window2.requestAnimationFrame = window2[vendors[x] + "RequestAnimationFrame"];
            window2.cancelAnimationFrame = window2[vendors[x] + "CancelAnimationFrame"] || window2[vendors[x] + "CancelRequestAnimationFrame"];
          }
          if (!window2.requestAnimationFrame)
            window2.requestAnimationFrame = function(callback, element) {
              var currTime = new Date().getTime();
              var timeToCall = Math.max(0, 16 - (currTime - lastTime));
              var id = window2.setTimeout(function() {
                callback(currTime + timeToCall);
              }, timeToCall);
              lastTime = currTime + timeToCall;
              return id;
            };
          if (!window2.cancelAnimationFrame)
            window2.cancelAnimationFrame = function(id) {
              clearTimeout(id);
            };
        })();
        var canvas, progressTimerId, fadeTimerId, currentProgress, showing, addEvent = function(elem, type, handler) {
          if (elem.addEventListener)
            elem.addEventListener(type, handler, false);
          else if (elem.attachEvent)
            elem.attachEvent("on" + type, handler);
          else
            elem["on" + type] = handler;
        }, options = {
          autoRun: true,
          barThickness: 3,
          barColors: {
            0: "rgba(26,  188, 156, .9)",
            ".25": "rgba(52,  152, 219, .9)",
            ".50": "rgba(241, 196, 15,  .9)",
            ".75": "rgba(230, 126, 34,  .9)",
            "1.0": "rgba(211, 84,  0,   .9)"
          },
          shadowBlur: 10,
          shadowColor: "rgba(0,   0,   0,   .6)",
          className: null
        }, repaint = function() {
          canvas.width = window2.innerWidth;
          canvas.height = options.barThickness * 5;
          var ctx = canvas.getContext("2d");
          ctx.shadowBlur = options.shadowBlur;
          ctx.shadowColor = options.shadowColor;
          var lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          for (var stop in options.barColors)
            lineGradient.addColorStop(stop, options.barColors[stop]);
          ctx.lineWidth = options.barThickness;
          ctx.beginPath();
          ctx.moveTo(0, options.barThickness / 2);
          ctx.lineTo(Math.ceil(currentProgress * canvas.width), options.barThickness / 2);
          ctx.strokeStyle = lineGradient;
          ctx.stroke();
        }, createCanvas = function() {
          canvas = document2.createElement("canvas");
          var style = canvas.style;
          style.position = "fixed";
          style.top = style.left = style.right = style.margin = style.padding = 0;
          style.zIndex = 100001;
          style.display = "none";
          if (options.className)
            canvas.classList.add(options.className);
          document2.body.appendChild(canvas);
          addEvent(window2, "resize", repaint);
        }, topbar2 = {
          config: function(opts) {
            for (var key in opts)
              if (options.hasOwnProperty(key))
                options[key] = opts[key];
          },
          show: function() {
            if (showing)
              return;
            showing = true;
            if (fadeTimerId !== null)
              window2.cancelAnimationFrame(fadeTimerId);
            if (!canvas)
              createCanvas();
            canvas.style.opacity = 1;
            canvas.style.display = "block";
            topbar2.progress(0);
            if (options.autoRun) {
              (function loop() {
                progressTimerId = window2.requestAnimationFrame(loop);
                topbar2.progress("+" + 0.05 * Math.pow(1 - Math.sqrt(currentProgress), 2));
              })();
            }
          },
          progress: function(to) {
            if (typeof to === "undefined")
              return currentProgress;
            if (typeof to === "string") {
              to = (to.indexOf("+") >= 0 || to.indexOf("-") >= 0 ? currentProgress : 0) + parseFloat(to);
            }
            currentProgress = to > 1 ? 1 : to;
            repaint();
            return currentProgress;
          },
          hide: function() {
            if (!showing)
              return;
            showing = false;
            if (progressTimerId != null) {
              window2.cancelAnimationFrame(progressTimerId);
              progressTimerId = null;
            }
            (function loop() {
              if (topbar2.progress("+.1") >= 1) {
                canvas.style.opacity -= 0.05;
                if (canvas.style.opacity <= 0.05) {
                  canvas.style.display = "none";
                  fadeTimerId = null;
                  return;
                }
              }
              fadeTimerId = window2.requestAnimationFrame(loop);
            })();
          }
        };
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = topbar2;
        } else if (typeof define === "function" && define.amd) {
          define(function() {
            return topbar2;
          });
        } else {
          this.topbar = topbar2;
        }
      }).call(exports, window, document);
    }
  });

  // ../deps/phoenix_html/priv/static/phoenix_html.js
  (function() {
    var PolyfillEvent = eventConstructor();
    function eventConstructor() {
      if (typeof window.CustomEvent === "function")
        return window.CustomEvent;
      function CustomEvent2(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: void 0 };
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      }
      CustomEvent2.prototype = window.Event.prototype;
      return CustomEvent2;
    }
    function buildHiddenInput(name, value) {
      var input = document.createElement("input");
      input.type = "hidden";
      input.name = name;
      input.value = value;
      return input;
    }
    function handleClick(element, targetModifierKey) {
      var to = element.getAttribute("data-to"), method = buildHiddenInput("_method", element.getAttribute("data-method")), csrf = buildHiddenInput("_csrf_token", element.getAttribute("data-csrf")), form = document.createElement("form"), target = element.getAttribute("target");
      form.method = element.getAttribute("data-method") === "get" ? "get" : "post";
      form.action = to;
      form.style.display = "hidden";
      if (target)
        form.target = target;
      else if (targetModifierKey)
        form.target = "_blank";
      form.appendChild(csrf);
      form.appendChild(method);
      document.body.appendChild(form);
      form.submit();
    }
    window.addEventListener("click", function(e) {
      var element = e.target;
      if (e.defaultPrevented)
        return;
      while (element && element.getAttribute) {
        var phoenixLinkEvent = new PolyfillEvent("phoenix.link.click", {
          "bubbles": true,
          "cancelable": true
        });
        if (!element.dispatchEvent(phoenixLinkEvent)) {
          e.preventDefault();
          e.stopImmediatePropagation();
          return false;
        }
        if (element.getAttribute("data-method")) {
          handleClick(element, e.metaKey || e.shiftKey);
          e.preventDefault();
          return false;
        } else {
          element = element.parentNode;
        }
      }
    }, false);
    window.addEventListener("phoenix.link.click", function(e) {
      var message = e.target.getAttribute("data-confirm");
      if (message && !window.confirm(message)) {
        e.preventDefault();
      }
    }, false);
  })();

  // ../deps/phoenix/priv/static/phoenix.mjs
  var closure = (value) => {
    if (typeof value === "function") {
      return value;
    } else {
      let closure22 = function() {
        return value;
      };
      return closure22;
    }
  };
  var globalSelf = typeof self !== "undefined" ? self : null;
  var phxWindow = typeof window !== "undefined" ? window : null;
  var global = globalSelf || phxWindow || global;
  var DEFAULT_VSN = "2.0.0";
  var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
  var DEFAULT_TIMEOUT = 1e4;
  var WS_CLOSE_NORMAL = 1e3;
  var CHANNEL_STATES = {
    closed: "closed",
    errored: "errored",
    joined: "joined",
    joining: "joining",
    leaving: "leaving"
  };
  var CHANNEL_EVENTS = {
    close: "phx_close",
    error: "phx_error",
    join: "phx_join",
    reply: "phx_reply",
    leave: "phx_leave"
  };
  var TRANSPORTS = {
    longpoll: "longpoll",
    websocket: "websocket"
  };
  var XHR_STATES = {
    complete: 4
  };
  var Push = class {
    constructor(channel, event, payload, timeout) {
      this.channel = channel;
      this.event = event;
      this.payload = payload || function() {
        return {};
      };
      this.receivedResp = null;
      this.timeout = timeout;
      this.timeoutTimer = null;
      this.recHooks = [];
      this.sent = false;
    }
    resend(timeout) {
      this.timeout = timeout;
      this.reset();
      this.send();
    }
    send() {
      if (this.hasReceived("timeout")) {
        return;
      }
      this.startTimeout();
      this.sent = true;
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload(),
        ref: this.ref,
        join_ref: this.channel.joinRef()
      });
    }
    receive(status, callback) {
      if (this.hasReceived(status)) {
        callback(this.receivedResp.response);
      }
      this.recHooks.push({ status, callback });
      return this;
    }
    reset() {
      this.cancelRefEvent();
      this.ref = null;
      this.refEvent = null;
      this.receivedResp = null;
      this.sent = false;
    }
    matchReceive({ status, response, _ref }) {
      this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
    }
    cancelRefEvent() {
      if (!this.refEvent) {
        return;
      }
      this.channel.off(this.refEvent);
    }
    cancelTimeout() {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
    startTimeout() {
      if (this.timeoutTimer) {
        this.cancelTimeout();
      }
      this.ref = this.channel.socket.makeRef();
      this.refEvent = this.channel.replyEventName(this.ref);
      this.channel.on(this.refEvent, (payload) => {
        this.cancelRefEvent();
        this.cancelTimeout();
        this.receivedResp = payload;
        this.matchReceive(payload);
      });
      this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout);
    }
    hasReceived(status) {
      return this.receivedResp && this.receivedResp.status === status;
    }
    trigger(status, response) {
      this.channel.trigger(this.refEvent, { status, response });
    }
  };
  var Timer = class {
    constructor(callback, timerCalc) {
      this.callback = callback;
      this.timerCalc = timerCalc;
      this.timer = null;
      this.tries = 0;
    }
    reset() {
      this.tries = 0;
      clearTimeout(this.timer);
    }
    scheduleTimeout() {
      clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.tries = this.tries + 1;
        this.callback();
      }, this.timerCalc(this.tries + 1));
    }
  };
  var Channel = class {
    constructor(topic, params, socket) {
      this.state = CHANNEL_STATES.closed;
      this.topic = topic;
      this.params = closure(params || {});
      this.socket = socket;
      this.bindings = [];
      this.bindingRef = 0;
      this.timeout = this.socket.timeout;
      this.joinedOnce = false;
      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
      this.pushBuffer = [];
      this.stateChangeRefs = [];
      this.rejoinTimer = new Timer(() => {
        if (this.socket.isConnected()) {
          this.rejoin();
        }
      }, this.socket.rejoinAfterMs);
      this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
      this.stateChangeRefs.push(this.socket.onOpen(() => {
        this.rejoinTimer.reset();
        if (this.isErrored()) {
          this.rejoin();
        }
      }));
      this.joinPush.receive("ok", () => {
        this.state = CHANNEL_STATES.joined;
        this.rejoinTimer.reset();
        this.pushBuffer.forEach((pushEvent) => pushEvent.send());
        this.pushBuffer = [];
      });
      this.joinPush.receive("error", () => {
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.onClose(() => {
        this.rejoinTimer.reset();
        if (this.socket.hasLogger())
          this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
        this.state = CHANNEL_STATES.closed;
        this.socket.remove(this);
      });
      this.onError((reason) => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `error ${this.topic}`, reason);
        if (this.isJoining()) {
          this.joinPush.reset();
        }
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.joinPush.receive("timeout", () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
        leavePush.send();
        this.state = CHANNEL_STATES.errored;
        this.joinPush.reset();
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
        this.trigger(this.replyEventName(ref), payload);
      });
    }
    join(timeout = this.timeout) {
      if (this.joinedOnce) {
        throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
      } else {
        this.timeout = timeout;
        this.joinedOnce = true;
        this.rejoin();
        return this.joinPush;
      }
    }
    onClose(callback) {
      this.on(CHANNEL_EVENTS.close, callback);
    }
    onError(callback) {
      return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));
    }
    on(event, callback) {
      let ref = this.bindingRef++;
      this.bindings.push({ event, ref, callback });
      return ref;
    }
    off(event, ref) {
      this.bindings = this.bindings.filter((bind) => {
        return !(bind.event === event && (typeof ref === "undefined" || ref === bind.ref));
      });
    }
    canPush() {
      return this.socket.isConnected() && this.isJoined();
    }
    push(event, payload, timeout = this.timeout) {
      payload = payload || {};
      if (!this.joinedOnce) {
        throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
      }
      let pushEvent = new Push(this, event, function() {
        return payload;
      }, timeout);
      if (this.canPush()) {
        pushEvent.send();
      } else {
        pushEvent.startTimeout();
        this.pushBuffer.push(pushEvent);
      }
      return pushEvent;
    }
    leave(timeout = this.timeout) {
      this.rejoinTimer.reset();
      this.joinPush.cancelTimeout();
      this.state = CHANNEL_STATES.leaving;
      let onClose = () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `leave ${this.topic}`);
        this.trigger(CHANNEL_EVENTS.close, "leave");
      };
      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
      leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
      leavePush.send();
      if (!this.canPush()) {
        leavePush.trigger("ok", {});
      }
      return leavePush;
    }
    onMessage(_event, payload, _ref) {
      return payload;
    }
    isMember(topic, event, payload, joinRef) {
      if (this.topic !== topic) {
        return false;
      }
      if (joinRef && joinRef !== this.joinRef()) {
        if (this.socket.hasLogger())
          this.socket.log("channel", "dropping outdated message", { topic, event, payload, joinRef });
        return false;
      } else {
        return true;
      }
    }
    joinRef() {
      return this.joinPush.ref;
    }
    rejoin(timeout = this.timeout) {
      if (this.isLeaving()) {
        return;
      }
      this.socket.leaveOpenTopic(this.topic);
      this.state = CHANNEL_STATES.joining;
      this.joinPush.resend(timeout);
    }
    trigger(event, payload, ref, joinRef) {
      let handledPayload = this.onMessage(event, payload, ref, joinRef);
      if (payload && !handledPayload) {
        throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
      }
      let eventBindings = this.bindings.filter((bind) => bind.event === event);
      for (let i = 0; i < eventBindings.length; i++) {
        let bind = eventBindings[i];
        bind.callback(handledPayload, ref, joinRef || this.joinRef());
      }
    }
    replyEventName(ref) {
      return `chan_reply_${ref}`;
    }
    isClosed() {
      return this.state === CHANNEL_STATES.closed;
    }
    isErrored() {
      return this.state === CHANNEL_STATES.errored;
    }
    isJoined() {
      return this.state === CHANNEL_STATES.joined;
    }
    isJoining() {
      return this.state === CHANNEL_STATES.joining;
    }
    isLeaving() {
      return this.state === CHANNEL_STATES.leaving;
    }
  };
  var Ajax = class {
    static request(method, endPoint, accept, body, timeout, ontimeout, callback) {
      if (global.XDomainRequest) {
        let req = new global.XDomainRequest();
        return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);
      } else {
        let req = new global.XMLHttpRequest();
        return this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);
      }
    }
    static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {
      req.timeout = timeout;
      req.open(method, endPoint);
      req.onload = () => {
        let response = this.parseJSON(req.responseText);
        callback && callback(response);
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.onprogress = () => {
      };
      req.send(body);
      return req;
    }
    static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {
      req.open(method, endPoint, true);
      req.timeout = timeout;
      req.setRequestHeader("Content-Type", accept);
      req.onerror = () => callback && callback(null);
      req.onreadystatechange = () => {
        if (req.readyState === XHR_STATES.complete && callback) {
          let response = this.parseJSON(req.responseText);
          callback(response);
        }
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.send(body);
      return req;
    }
    static parseJSON(resp) {
      if (!resp || resp === "") {
        return null;
      }
      try {
        return JSON.parse(resp);
      } catch (e) {
        console && console.log("failed to parse JSON response", resp);
        return null;
      }
    }
    static serialize(obj, parentKey) {
      let queryStr = [];
      for (var key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
          continue;
        }
        let paramKey = parentKey ? `${parentKey}[${key}]` : key;
        let paramVal = obj[key];
        if (typeof paramVal === "object") {
          queryStr.push(this.serialize(paramVal, paramKey));
        } else {
          queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
        }
      }
      return queryStr.join("&");
    }
    static appendParams(url, params) {
      if (Object.keys(params).length === 0) {
        return url;
      }
      let prefix = url.match(/\?/) ? "&" : "?";
      return `${url}${prefix}${this.serialize(params)}`;
    }
  };
  var LongPoll = class {
    constructor(endPoint) {
      this.endPoint = null;
      this.token = null;
      this.skipHeartbeat = true;
      this.reqs = /* @__PURE__ */ new Set();
      this.onopen = function() {
      };
      this.onerror = function() {
      };
      this.onmessage = function() {
      };
      this.onclose = function() {
      };
      this.pollEndpoint = this.normalizeEndpoint(endPoint);
      this.readyState = SOCKET_STATES.connecting;
      this.poll();
    }
    normalizeEndpoint(endPoint) {
      return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
    }
    endpointURL() {
      return Ajax.appendParams(this.pollEndpoint, { token: this.token });
    }
    closeAndRetry(code, reason, wasClean) {
      this.close(code, reason, wasClean);
      this.readyState = SOCKET_STATES.connecting;
    }
    ontimeout() {
      this.onerror("timeout");
      this.closeAndRetry(1005, "timeout", false);
    }
    isActive() {
      return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;
    }
    poll() {
      this.ajax("GET", null, () => this.ontimeout(), (resp) => {
        if (resp) {
          var { status, token, messages } = resp;
          this.token = token;
        } else {
          status = 0;
        }
        switch (status) {
          case 200:
            messages.forEach((msg) => {
              setTimeout(() => this.onmessage({ data: msg }), 0);
            });
            this.poll();
            break;
          case 204:
            this.poll();
            break;
          case 410:
            this.readyState = SOCKET_STATES.open;
            this.onopen({});
            this.poll();
            break;
          case 403:
            this.onerror(403);
            this.close(1008, "forbidden", false);
            break;
          case 0:
          case 500:
            this.onerror(500);
            this.closeAndRetry(1011, "internal server error", 500);
            break;
          default:
            throw new Error(`unhandled poll status ${status}`);
        }
      });
    }
    send(body) {
      this.ajax("POST", body, () => this.onerror("timeout"), (resp) => {
        if (!resp || resp.status !== 200) {
          this.onerror(resp && resp.status);
          this.closeAndRetry(1011, "internal server error", false);
        }
      });
    }
    close(code, reason, wasClean) {
      for (let req of this.reqs) {
        req.abort();
      }
      this.readyState = SOCKET_STATES.closed;
      let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });
      if (typeof CloseEvent !== "undefined") {
        this.onclose(new CloseEvent("close", opts));
      } else {
        this.onclose(opts);
      }
    }
    ajax(method, body, onCallerTimeout, callback) {
      let req;
      let ontimeout = () => {
        this.reqs.delete(req);
        onCallerTimeout();
      };
      req = Ajax.request(method, this.endpointURL(), "application/json", body, this.timeout, ontimeout, (resp) => {
        this.reqs.delete(req);
        if (this.isActive()) {
          callback(resp);
        }
      });
      this.reqs.add(req);
    }
  };
  var serializer_default = {
    HEADER_LENGTH: 1,
    META_LENGTH: 4,
    KINDS: { push: 0, reply: 1, broadcast: 2 },
    encode(msg, callback) {
      if (msg.payload.constructor === ArrayBuffer) {
        return callback(this.binaryEncode(msg));
      } else {
        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
        return callback(JSON.stringify(payload));
      }
    },
    decode(rawPayload, callback) {
      if (rawPayload.constructor === ArrayBuffer) {
        return callback(this.binaryDecode(rawPayload));
      } else {
        let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);
        return callback({ join_ref, ref, topic, event, payload });
      }
    },
    binaryEncode(message) {
      let { join_ref, ref, event, topic, payload } = message;
      let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;
      let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
      let view = new DataView(header);
      let offset = 0;
      view.setUint8(offset++, this.KINDS.push);
      view.setUint8(offset++, join_ref.length);
      view.setUint8(offset++, ref.length);
      view.setUint8(offset++, topic.length);
      view.setUint8(offset++, event.length);
      Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      var combined = new Uint8Array(header.byteLength + payload.byteLength);
      combined.set(new Uint8Array(header), 0);
      combined.set(new Uint8Array(payload), header.byteLength);
      return combined.buffer;
    },
    binaryDecode(buffer) {
      let view = new DataView(buffer);
      let kind = view.getUint8(0);
      let decoder = new TextDecoder();
      switch (kind) {
        case this.KINDS.push:
          return this.decodePush(buffer, view, decoder);
        case this.KINDS.reply:
          return this.decodeReply(buffer, view, decoder);
        case this.KINDS.broadcast:
          return this.decodeBroadcast(buffer, view, decoder);
      }
    },
    decodePush(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let topicSize = view.getUint8(2);
      let eventSize = view.getUint8(3);
      let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: joinRef, ref: null, topic, event, payload: data };
    },
    decodeReply(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let refSize = view.getUint8(2);
      let topicSize = view.getUint8(3);
      let eventSize = view.getUint8(4);
      let offset = this.HEADER_LENGTH + this.META_LENGTH;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let ref = decoder.decode(buffer.slice(offset, offset + refSize));
      offset = offset + refSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      let payload = { status: event, response: data };
      return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
    },
    decodeBroadcast(buffer, view, decoder) {
      let topicSize = view.getUint8(1);
      let eventSize = view.getUint8(2);
      let offset = this.HEADER_LENGTH + 2;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: null, ref: null, topic, event, payload: data };
    }
  };
  var Socket = class {
    constructor(endPoint, opts = {}) {
      this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
      this.channels = [];
      this.sendBuffer = [];
      this.ref = 0;
      this.timeout = opts.timeout || DEFAULT_TIMEOUT;
      this.transport = opts.transport || global.WebSocket || LongPoll;
      this.establishedConnections = 0;
      this.defaultEncoder = serializer_default.encode.bind(serializer_default);
      this.defaultDecoder = serializer_default.decode.bind(serializer_default);
      this.closeWasClean = false;
      this.binaryType = opts.binaryType || "arraybuffer";
      this.connectClock = 1;
      if (this.transport !== LongPoll) {
        this.encode = opts.encode || this.defaultEncoder;
        this.decode = opts.decode || this.defaultDecoder;
      } else {
        this.encode = this.defaultEncoder;
        this.decode = this.defaultDecoder;
      }
      let awaitingConnectionOnPageShow = null;
      if (phxWindow && phxWindow.addEventListener) {
        phxWindow.addEventListener("pagehide", (_e) => {
          if (this.conn) {
            this.disconnect();
            awaitingConnectionOnPageShow = this.connectClock;
          }
        });
        phxWindow.addEventListener("pageshow", (_e) => {
          if (awaitingConnectionOnPageShow === this.connectClock) {
            awaitingConnectionOnPageShow = null;
            this.connect();
          }
        });
      }
      this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
      this.rejoinAfterMs = (tries) => {
        if (opts.rejoinAfterMs) {
          return opts.rejoinAfterMs(tries);
        } else {
          return [1e3, 2e3, 5e3][tries - 1] || 1e4;
        }
      };
      this.reconnectAfterMs = (tries) => {
        if (opts.reconnectAfterMs) {
          return opts.reconnectAfterMs(tries);
        } else {
          return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
        }
      };
      this.logger = opts.logger || null;
      this.longpollerTimeout = opts.longpollerTimeout || 2e4;
      this.params = closure(opts.params || {});
      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
      this.vsn = opts.vsn || DEFAULT_VSN;
      this.heartbeatTimer = null;
      this.pendingHeartbeatRef = null;
      this.reconnectTimer = new Timer(() => {
        this.teardown(() => this.connect());
      }, this.reconnectAfterMs);
    }
    getLongPollTransport() {
      return LongPoll;
    }
    replaceTransport(newTransport) {
      this.connectClock++;
      this.closeWasClean = true;
      this.reconnectTimer.reset();
      this.sendBuffer = [];
      if (this.conn) {
        this.conn.close();
        this.conn = null;
      }
      this.transport = newTransport;
    }
    protocol() {
      return location.protocol.match(/^https/) ? "wss" : "ws";
    }
    endPointURL() {
      let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), { vsn: this.vsn });
      if (uri.charAt(0) !== "/") {
        return uri;
      }
      if (uri.charAt(1) === "/") {
        return `${this.protocol()}:${uri}`;
      }
      return `${this.protocol()}://${location.host}${uri}`;
    }
    disconnect(callback, code, reason) {
      this.connectClock++;
      this.closeWasClean = true;
      this.reconnectTimer.reset();
      this.teardown(callback, code, reason);
    }
    connect(params) {
      if (params) {
        console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
        this.params = closure(params);
      }
      if (this.conn) {
        return;
      }
      this.connectClock++;
      this.closeWasClean = false;
      this.conn = new this.transport(this.endPointURL());
      this.conn.binaryType = this.binaryType;
      this.conn.timeout = this.longpollerTimeout;
      this.conn.onopen = () => this.onConnOpen();
      this.conn.onerror = (error) => this.onConnError(error);
      this.conn.onmessage = (event) => this.onConnMessage(event);
      this.conn.onclose = (event) => this.onConnClose(event);
    }
    log(kind, msg, data) {
      this.logger(kind, msg, data);
    }
    hasLogger() {
      return this.logger !== null;
    }
    onOpen(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.open.push([ref, callback]);
      return ref;
    }
    onClose(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.close.push([ref, callback]);
      return ref;
    }
    onError(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.error.push([ref, callback]);
      return ref;
    }
    onMessage(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.message.push([ref, callback]);
      return ref;
    }
    ping(callback) {
      if (!this.isConnected()) {
        return false;
      }
      let ref = this.makeRef();
      let startTime = Date.now();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref });
      let onMsgRef = this.onMessage((msg) => {
        if (msg.ref === ref) {
          this.off([onMsgRef]);
          callback(Date.now() - startTime);
        }
      });
      return true;
    }
    onConnOpen() {
      if (this.hasLogger())
        this.log("transport", `connected to ${this.endPointURL()}`);
      this.closeWasClean = false;
      this.establishedConnections++;
      this.flushSendBuffer();
      this.reconnectTimer.reset();
      this.resetHeartbeat();
      this.stateChangeCallbacks.open.forEach(([, callback]) => callback());
    }
    heartbeatTimeout() {
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        if (this.hasLogger()) {
          this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
        }
        this.abnormalClose("heartbeat timeout");
      }
    }
    resetHeartbeat() {
      if (this.conn && this.conn.skipHeartbeat) {
        return;
      }
      this.pendingHeartbeatRef = null;
      clearTimeout(this.heartbeatTimer);
      setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    }
    teardown(callback, code, reason) {
      if (!this.conn) {
        return callback && callback();
      }
      this.waitForBufferDone(() => {
        if (this.conn) {
          if (code) {
            this.conn.close(code, reason || "");
          } else {
            this.conn.close();
          }
        }
        this.waitForSocketClosed(() => {
          if (this.conn) {
            this.conn.onclose = function() {
            };
            this.conn = null;
          }
          callback && callback();
        });
      });
    }
    waitForBufferDone(callback, tries = 1) {
      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
        callback();
        return;
      }
      setTimeout(() => {
        this.waitForBufferDone(callback, tries + 1);
      }, 150 * tries);
    }
    waitForSocketClosed(callback, tries = 1) {
      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
        callback();
        return;
      }
      setTimeout(() => {
        this.waitForSocketClosed(callback, tries + 1);
      }, 150 * tries);
    }
    onConnClose(event) {
      let closeCode = event && event.code;
      if (this.hasLogger())
        this.log("transport", "close", event);
      this.triggerChanError();
      clearTimeout(this.heartbeatTimer);
      if (!this.closeWasClean && closeCode !== 1e3) {
        this.reconnectTimer.scheduleTimeout();
      }
      this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));
    }
    onConnError(error) {
      if (this.hasLogger())
        this.log("transport", error);
      let transportBefore = this.transport;
      let establishedBefore = this.establishedConnections;
      this.stateChangeCallbacks.error.forEach(([, callback]) => {
        callback(error, transportBefore, establishedBefore);
      });
      if (transportBefore === this.transport || establishedBefore > 0) {
        this.triggerChanError();
      }
    }
    triggerChanError() {
      this.channels.forEach((channel) => {
        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
          channel.trigger(CHANNEL_EVENTS.error);
        }
      });
    }
    connectionState() {
      switch (this.conn && this.conn.readyState) {
        case SOCKET_STATES.connecting:
          return "connecting";
        case SOCKET_STATES.open:
          return "open";
        case SOCKET_STATES.closing:
          return "closing";
        default:
          return "closed";
      }
    }
    isConnected() {
      return this.connectionState() === "open";
    }
    remove(channel) {
      this.off(channel.stateChangeRefs);
      this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());
    }
    off(refs) {
      for (let key in this.stateChangeCallbacks) {
        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {
          return refs.indexOf(ref) === -1;
        });
      }
    }
    channel(topic, chanParams = {}) {
      let chan = new Channel(topic, chanParams, this);
      this.channels.push(chan);
      return chan;
    }
    push(data) {
      if (this.hasLogger()) {
        let { topic, event, payload, ref, join_ref } = data;
        this.log("push", `${topic} ${event} (${join_ref}, ${ref})`, payload);
      }
      if (this.isConnected()) {
        this.encode(data, (result) => this.conn.send(result));
      } else {
        this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));
      }
    }
    makeRef() {
      let newRef = this.ref + 1;
      if (newRef === this.ref) {
        this.ref = 0;
      } else {
        this.ref = newRef;
      }
      return this.ref.toString();
    }
    sendHeartbeat() {
      if (this.pendingHeartbeatRef && !this.isConnected()) {
        return;
      }
      this.pendingHeartbeatRef = this.makeRef();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
      this.heartbeatTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
    }
    abnormalClose(reason) {
      this.closeWasClean = false;
      if (this.isConnected()) {
        this.conn.close(WS_CLOSE_NORMAL, reason);
      }
    }
    flushSendBuffer() {
      if (this.isConnected() && this.sendBuffer.length > 0) {
        this.sendBuffer.forEach((callback) => callback());
        this.sendBuffer = [];
      }
    }
    onConnMessage(rawMessage) {
      this.decode(rawMessage.data, (msg) => {
        let { topic, event, payload, ref, join_ref } = msg;
        if (ref && ref === this.pendingHeartbeatRef) {
          clearTimeout(this.heartbeatTimer);
          this.pendingHeartbeatRef = null;
          setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
        }
        if (this.hasLogger())
          this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
        for (let i = 0; i < this.channels.length; i++) {
          const channel = this.channels[i];
          if (!channel.isMember(topic, event, payload, join_ref)) {
            continue;
          }
          channel.trigger(event, payload, ref, join_ref);
        }
        for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {
          let [, callback] = this.stateChangeCallbacks.message[i];
          callback(msg);
        }
      });
    }
    leaveOpenTopic(topic) {
      let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));
      if (dupChannel) {
        if (this.hasLogger())
          this.log("transport", `leaving duplicate topic "${topic}"`);
        dupChannel.leave();
      }
    }
  };

  // ../deps/phoenix_live_view/priv/static/phoenix_live_view.esm.js
  var CONSECUTIVE_RELOADS = "consecutive-reloads";
  var MAX_RELOADS = 10;
  var RELOAD_JITTER_MIN = 5e3;
  var RELOAD_JITTER_MAX = 1e4;
  var FAILSAFE_JITTER = 3e4;
  var PHX_EVENT_CLASSES = [
    "phx-click-loading",
    "phx-change-loading",
    "phx-submit-loading",
    "phx-keydown-loading",
    "phx-keyup-loading",
    "phx-blur-loading",
    "phx-focus-loading"
  ];
  var PHX_COMPONENT = "data-phx-component";
  var PHX_LIVE_LINK = "data-phx-link";
  var PHX_TRACK_STATIC = "track-static";
  var PHX_LINK_STATE = "data-phx-link-state";
  var PHX_REF = "data-phx-ref";
  var PHX_REF_SRC = "data-phx-ref-src";
  var PHX_TRACK_UPLOADS = "track-uploads";
  var PHX_UPLOAD_REF = "data-phx-upload-ref";
  var PHX_PREFLIGHTED_REFS = "data-phx-preflighted-refs";
  var PHX_DONE_REFS = "data-phx-done-refs";
  var PHX_DROP_TARGET = "drop-target";
  var PHX_ACTIVE_ENTRY_REFS = "data-phx-active-refs";
  var PHX_LIVE_FILE_UPDATED = "phx:live-file:updated";
  var PHX_SKIP = "data-phx-skip";
  var PHX_PRUNE = "data-phx-prune";
  var PHX_PAGE_LOADING = "page-loading";
  var PHX_CONNECTED_CLASS = "phx-connected";
  var PHX_DISCONNECTED_CLASS = "phx-loading";
  var PHX_NO_FEEDBACK_CLASS = "phx-no-feedback";
  var PHX_ERROR_CLASS = "phx-error";
  var PHX_PARENT_ID = "data-phx-parent-id";
  var PHX_MAIN = "data-phx-main";
  var PHX_ROOT_ID = "data-phx-root-id";
  var PHX_TRIGGER_ACTION = "trigger-action";
  var PHX_FEEDBACK_FOR = "feedback-for";
  var PHX_HAS_FOCUSED = "phx-has-focused";
  var FOCUSABLE_INPUTS = ["text", "textarea", "number", "email", "password", "search", "tel", "url", "date", "time", "datetime-local", "color", "range"];
  var CHECKABLE_INPUTS = ["checkbox", "radio"];
  var PHX_HAS_SUBMITTED = "phx-has-submitted";
  var PHX_SESSION = "data-phx-session";
  var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;
  var PHX_STICKY = "data-phx-sticky";
  var PHX_STATIC = "data-phx-static";
  var PHX_READONLY = "data-phx-readonly";
  var PHX_DISABLED = "data-phx-disabled";
  var PHX_DISABLE_WITH = "disable-with";
  var PHX_DISABLE_WITH_RESTORE = "data-phx-disable-with-restore";
  var PHX_HOOK = "hook";
  var PHX_DEBOUNCE = "debounce";
  var PHX_THROTTLE = "throttle";
  var PHX_UPDATE = "update";
  var PHX_KEY = "key";
  var PHX_PRIVATE = "phxPrivate";
  var PHX_AUTO_RECOVER = "auto-recover";
  var PHX_LV_DEBUG = "phx:live-socket:debug";
  var PHX_LV_PROFILE = "phx:live-socket:profiling";
  var PHX_LV_LATENCY_SIM = "phx:live-socket:latency-sim";
  var PHX_PROGRESS = "progress";
  var LOADER_TIMEOUT = 1;
  var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;
  var BINDING_PREFIX = "phx-";
  var PUSH_TIMEOUT = 3e4;
  var DEBOUNCE_TRIGGER = "debounce-trigger";
  var THROTTLED = "throttled";
  var DEBOUNCE_PREV_KEY = "debounce-prev-key";
  var DEFAULTS = {
    debounce: 300,
    throttle: 300
  };
  var DYNAMICS = "d";
  var STATIC = "s";
  var COMPONENTS = "c";
  var EVENTS = "e";
  var REPLY = "r";
  var TITLE = "t";
  var TEMPLATES = "p";
  var EntryUploader = class {
    constructor(entry, chunkSize, liveSocket2) {
      this.liveSocket = liveSocket2;
      this.entry = entry;
      this.offset = 0;
      this.chunkSize = chunkSize;
      this.chunkTimer = null;
      this.uploadChannel = liveSocket2.channel(`lvu:${entry.ref}`, { token: entry.metadata() });
    }
    error(reason) {
      clearTimeout(this.chunkTimer);
      this.uploadChannel.leave();
      this.entry.error(reason);
    }
    upload() {
      this.uploadChannel.onError((reason) => this.error(reason));
      this.uploadChannel.join().receive("ok", (_data) => this.readNextChunk()).receive("error", (reason) => this.error(reason));
    }
    isDone() {
      return this.offset >= this.entry.file.size;
    }
    readNextChunk() {
      let reader = new window.FileReader();
      let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);
      reader.onload = (e) => {
        if (e.target.error === null) {
          this.offset += e.target.result.byteLength;
          this.pushChunk(e.target.result);
        } else {
          return logError("Read error: " + e.target.error);
        }
      };
      reader.readAsArrayBuffer(blob);
    }
    pushChunk(chunk) {
      if (!this.uploadChannel.isJoined()) {
        return;
      }
      this.uploadChannel.push("chunk", chunk).receive("ok", () => {
        this.entry.progress(this.offset / this.entry.file.size * 100);
        if (!this.isDone()) {
          this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);
        }
      });
    }
  };
  var logError = (msg, obj) => console.error && console.error(msg, obj);
  var isCid = (cid) => {
    let type = typeof cid;
    return type === "number" || type === "string" && /^(0|[1-9]\d*)$/.test(cid);
  };
  function detectDuplicateIds() {
    let ids = /* @__PURE__ */ new Set();
    let elems = document.querySelectorAll("*[id]");
    for (let i = 0, len = elems.length; i < len; i++) {
      if (ids.has(elems[i].id)) {
        console.error(`Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`);
      } else {
        ids.add(elems[i].id);
      }
    }
  }
  var debug = (view, kind, msg, obj) => {
    if (view.liveSocket.isDebugEnabled()) {
      console.log(`${view.id} ${kind}: ${msg} - `, obj);
    }
  };
  var closure2 = (val) => typeof val === "function" ? val : function() {
    return val;
  };
  var clone = (obj) => {
    return JSON.parse(JSON.stringify(obj));
  };
  var closestPhxBinding = (el, binding, borderEl) => {
    do {
      if (el.matches(`[${binding}]`)) {
        return el;
      }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));
    return null;
  };
  var isObject = (obj) => {
    return obj !== null && typeof obj === "object" && !(obj instanceof Array);
  };
  var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);
  var isEmpty = (obj) => {
    for (let x in obj) {
      return false;
    }
    return true;
  };
  var maybe = (el, callback) => el && callback(el);
  var channelUploader = function(entries, onError, resp, liveSocket2) {
    entries.forEach((entry) => {
      let entryUploader = new EntryUploader(entry, resp.config.chunk_size, liveSocket2);
      entryUploader.upload();
    });
  };
  var Browser = {
    canPushState() {
      return typeof history.pushState !== "undefined";
    },
    dropLocal(localStorage, namespace, subkey) {
      return localStorage.removeItem(this.localKey(namespace, subkey));
    },
    updateLocal(localStorage, namespace, subkey, initial, func) {
      let current = this.getLocal(localStorage, namespace, subkey);
      let key = this.localKey(namespace, subkey);
      let newVal = current === null ? initial : func(current);
      localStorage.setItem(key, JSON.stringify(newVal));
      return newVal;
    },
    getLocal(localStorage, namespace, subkey) {
      return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));
    },
    updateCurrentState(callback) {
      if (!this.canPushState()) {
        return;
      }
      history.replaceState(callback(history.state || {}), "", window.location.href);
    },
    pushState(kind, meta, to) {
      if (this.canPushState()) {
        if (to !== window.location.href) {
          if (meta.type == "redirect" && meta.scroll) {
            let currentState = history.state || {};
            currentState.scroll = meta.scroll;
            history.replaceState(currentState, "", window.location.href);
          }
          delete meta.scroll;
          history[kind + "State"](meta, "", to || null);
          let hashEl = this.getHashTargetEl(window.location.hash);
          if (hashEl) {
            hashEl.scrollIntoView();
          } else if (meta.type === "redirect") {
            window.scroll(0, 0);
          }
        }
      } else {
        this.redirect(to);
      }
    },
    setCookie(name, value) {
      document.cookie = `${name}=${value}`;
    },
    getCookie(name) {
      return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), "$1");
    },
    redirect(toURL, flash) {
      if (flash) {
        Browser.setCookie("__phoenix_flash__", flash + "; max-age=60000; path=/");
      }
      window.location = toURL;
    },
    localKey(namespace, subkey) {
      return `${namespace}-${subkey}`;
    },
    getHashTargetEl(maybeHash) {
      let hash = maybeHash.toString().substring(1);
      if (hash === "") {
        return;
      }
      return document.getElementById(hash) || document.querySelector(`a[name="${hash}"]`);
    }
  };
  var browser_default = Browser;
  var DOM = {
    byId(id) {
      return document.getElementById(id) || logError(`no id found for ${id}`);
    },
    removeClass(el, className) {
      el.classList.remove(className);
      if (el.classList.length === 0) {
        el.removeAttribute("class");
      }
    },
    all(node, query2, callback) {
      if (!node) {
        return [];
      }
      let array = Array.from(node.querySelectorAll(query2));
      return callback ? array.forEach(callback) : array;
    },
    childNodeLength(html) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return template.content.childElementCount;
    },
    isUploadInput(el) {
      return el.type === "file" && el.getAttribute(PHX_UPLOAD_REF) !== null;
    },
    findUploadInputs(node) {
      return this.all(node, `input[type="file"][${PHX_UPLOAD_REF}]`);
    },
    findComponentNodeList(node, cid) {
      return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}="${cid}"]`), node);
    },
    isPhxDestroyed(node) {
      return node.id && DOM.private(node, "destroyed") ? true : false;
    },
    markPhxChildDestroyed(el) {
      if (this.isPhxChild(el)) {
        el.setAttribute(PHX_SESSION, "");
      }
      this.putPrivate(el, "destroyed", true);
    },
    findPhxChildrenInFragment(html, parentId) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return this.findPhxChildren(template.content, parentId);
    },
    isIgnored(el, phxUpdate) {
      return (el.getAttribute(phxUpdate) || el.getAttribute("data-phx-update")) === "ignore";
    },
    isPhxUpdate(el, phxUpdate, updateTypes) {
      return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;
    },
    findPhxSticky(el) {
      return this.all(el, `[${PHX_STICKY}]`);
    },
    findPhxChildren(el, parentId) {
      return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}="${parentId}"]`);
    },
    findParentCIDs(node, cids) {
      let initial = new Set(cids);
      return cids.reduce((acc, cid) => {
        let selector = `[${PHX_COMPONENT}="${cid}"] [${PHX_COMPONENT}]`;
        this.filterWithinSameLiveView(this.all(node, selector), node).map((el) => parseInt(el.getAttribute(PHX_COMPONENT))).forEach((childCID) => acc.delete(childCID));
        return acc;
      }, initial);
    },
    filterWithinSameLiveView(nodes, parent) {
      if (parent.querySelector(PHX_VIEW_SELECTOR)) {
        return nodes.filter((el) => this.withinSameLiveView(el, parent));
      } else {
        return nodes;
      }
    },
    withinSameLiveView(node, parent) {
      while (node = node.parentNode) {
        if (node.isSameNode(parent)) {
          return true;
        }
        if (node.getAttribute(PHX_SESSION) !== null) {
          return false;
        }
      }
    },
    private(el, key) {
      return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];
    },
    deletePrivate(el, key) {
      el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];
    },
    putPrivate(el, key, value) {
      if (!el[PHX_PRIVATE]) {
        el[PHX_PRIVATE] = {};
      }
      el[PHX_PRIVATE][key] = value;
    },
    updatePrivate(el, key, defaultVal, updateFunc) {
      let existing = this.private(el, key);
      if (existing === void 0) {
        this.putPrivate(el, key, updateFunc(defaultVal));
      } else {
        this.putPrivate(el, key, updateFunc(existing));
      }
    },
    copyPrivates(target, source) {
      if (source[PHX_PRIVATE]) {
        target[PHX_PRIVATE] = source[PHX_PRIVATE];
      }
    },
    putTitle(str) {
      let titleEl = document.querySelector("title");
      let { prefix, suffix } = titleEl.dataset;
      document.title = `${prefix || ""}${str}${suffix || ""}`;
    },
    debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, callback) {
      let debounce = el.getAttribute(phxDebounce);
      let throttle = el.getAttribute(phxThrottle);
      if (debounce === "") {
        debounce = defaultDebounce;
      }
      if (throttle === "") {
        throttle = defaultThrottle;
      }
      let value = debounce || throttle;
      switch (value) {
        case null:
          return callback();
        case "blur":
          if (this.once(el, "debounce-blur")) {
            el.addEventListener("blur", () => callback());
          }
          return;
        default:
          let timeout = parseInt(value);
          let trigger = () => throttle ? this.deletePrivate(el, THROTTLED) : callback();
          let currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);
          if (isNaN(timeout)) {
            return logError(`invalid throttle/debounce value: ${value}`);
          }
          if (throttle) {
            let newKeyDown = false;
            if (event.type === "keydown") {
              let prevKey = this.private(el, DEBOUNCE_PREV_KEY);
              this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);
              newKeyDown = prevKey !== event.key;
            }
            if (!newKeyDown && this.private(el, THROTTLED)) {
              return false;
            } else {
              callback();
              this.putPrivate(el, THROTTLED, true);
              setTimeout(() => {
                if (asyncFilter()) {
                  this.triggerCycle(el, DEBOUNCE_TRIGGER);
                }
              }, timeout);
            }
          } else {
            setTimeout(() => {
              if (asyncFilter()) {
                this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle);
              }
            }, timeout);
          }
          let form = el.form;
          if (form && this.once(form, "bind-debounce")) {
            form.addEventListener("submit", () => {
              Array.from(new FormData(form).entries(), ([name]) => {
                let input = form.querySelector(`[name="${name}"]`);
                this.incCycle(input, DEBOUNCE_TRIGGER);
                this.deletePrivate(input, THROTTLED);
              });
            });
          }
          if (this.once(el, "bind-debounce")) {
            el.addEventListener("blur", () => this.triggerCycle(el, DEBOUNCE_TRIGGER));
          }
      }
    },
    triggerCycle(el, key, currentCycle) {
      let [cycle, trigger] = this.private(el, key);
      if (!currentCycle) {
        currentCycle = cycle;
      }
      if (currentCycle === cycle) {
        this.incCycle(el, key);
        trigger();
      }
    },
    once(el, key) {
      if (this.private(el, key) === true) {
        return false;
      }
      this.putPrivate(el, key, true);
      return true;
    },
    incCycle(el, key, trigger = function() {
    }) {
      let [currentCycle] = this.private(el, key) || [0, trigger];
      currentCycle++;
      this.putPrivate(el, key, [currentCycle, trigger]);
      return currentCycle;
    },
    discardError(container, el, phxFeedbackFor) {
      let field = el.getAttribute && el.getAttribute(phxFeedbackFor);
      let input = field && container.querySelector(`[id="${field}"], [name="${field}"]`);
      if (!input) {
        return;
      }
      if (!(this.private(input, PHX_HAS_FOCUSED) || this.private(input.form, PHX_HAS_SUBMITTED))) {
        el.classList.add(PHX_NO_FEEDBACK_CLASS);
      }
    },
    showError(inputEl, phxFeedbackFor) {
      if (inputEl.id || inputEl.name) {
        this.all(inputEl.form, `[${phxFeedbackFor}="${inputEl.id}"], [${phxFeedbackFor}="${inputEl.name}"]`, (el) => {
          this.removeClass(el, PHX_NO_FEEDBACK_CLASS);
        });
      }
    },
    isPhxChild(node) {
      return node.getAttribute && node.getAttribute(PHX_PARENT_ID);
    },
    isPhxSticky(node) {
      return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;
    },
    firstPhxChild(el) {
      return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];
    },
    dispatchEvent(target, name, opts = {}) {
      let bubbles = opts.bubbles === void 0 ? true : !!opts.bubbles;
      let eventOpts = { bubbles, cancelable: true, detail: opts.detail || {} };
      let event = name === "click" ? new MouseEvent("click", eventOpts) : new CustomEvent(name, eventOpts);
      target.dispatchEvent(event);
    },
    cloneNode(node, html) {
      if (typeof html === "undefined") {
        return node.cloneNode(true);
      } else {
        let cloned = node.cloneNode(false);
        cloned.innerHTML = html;
        return cloned;
      }
    },
    mergeAttrs(target, source, opts = {}) {
      let exclude = opts.exclude || [];
      let isIgnored = opts.isIgnored;
      let sourceAttrs = source.attributes;
      for (let i = sourceAttrs.length - 1; i >= 0; i--) {
        let name = sourceAttrs[i].name;
        if (exclude.indexOf(name) < 0) {
          target.setAttribute(name, source.getAttribute(name));
        }
      }
      let targetAttrs = target.attributes;
      for (let i = targetAttrs.length - 1; i >= 0; i--) {
        let name = targetAttrs[i].name;
        if (isIgnored) {
          if (name.startsWith("data-") && !source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        } else {
          if (!source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        }
      }
    },
    mergeFocusedInput(target, source) {
      if (!(target instanceof HTMLSelectElement)) {
        DOM.mergeAttrs(target, source, { exclude: ["value"] });
      }
      if (source.readOnly) {
        target.setAttribute("readonly", true);
      } else {
        target.removeAttribute("readonly");
      }
    },
    hasSelectionRange(el) {
      return el.setSelectionRange && (el.type === "text" || el.type === "textarea");
    },
    restoreFocus(focused, selectionStart, selectionEnd) {
      if (!DOM.isTextualInput(focused)) {
        return;
      }
      let wasFocused = focused.matches(":focus");
      if (focused.readOnly) {
        focused.blur();
      }
      if (!wasFocused) {
        focused.focus();
      }
      if (this.hasSelectionRange(focused)) {
        focused.setSelectionRange(selectionStart, selectionEnd);
      }
    },
    isFormInput(el) {
      return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== "button";
    },
    syncAttrsToProps(el) {
      if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {
        el.checked = el.getAttribute("checked") !== null;
      }
    },
    isTextualInput(el) {
      return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;
    },
    isNowTriggerFormExternal(el, phxTriggerExternal) {
      return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null;
    },
    syncPendingRef(fromEl, toEl, disableWith) {
      let ref = fromEl.getAttribute(PHX_REF);
      if (ref === null) {
        return true;
      }
      let refSrc = fromEl.getAttribute(PHX_REF_SRC);
      if (DOM.isFormInput(fromEl) || fromEl.getAttribute(disableWith) !== null) {
        if (DOM.isUploadInput(fromEl)) {
          DOM.mergeAttrs(fromEl, toEl, { isIgnored: true });
        }
        DOM.putPrivate(fromEl, PHX_REF, toEl);
        return false;
      } else {
        PHX_EVENT_CLASSES.forEach((className) => {
          fromEl.classList.contains(className) && toEl.classList.add(className);
        });
        toEl.setAttribute(PHX_REF, ref);
        toEl.setAttribute(PHX_REF_SRC, refSrc);
        return true;
      }
    },
    cleanChildNodes(container, phxUpdate) {
      if (DOM.isPhxUpdate(container, phxUpdate, ["append", "prepend"])) {
        let toRemove = [];
        container.childNodes.forEach((childNode) => {
          if (!childNode.id) {
            let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === "";
            if (!isEmptyTextNode) {
              logError(`only HTML element tags with an id are allowed inside containers with phx-update.

removing illegal node: "${(childNode.outerHTML || childNode.nodeValue).trim()}"

`);
            }
            toRemove.push(childNode);
          }
        });
        toRemove.forEach((childNode) => childNode.remove());
      }
    },
    replaceRootContainer(container, tagName, attrs) {
      let retainedAttrs = /* @__PURE__ */ new Set(["id", PHX_SESSION, PHX_STATIC, PHX_MAIN, PHX_ROOT_ID]);
      if (container.tagName.toLowerCase() === tagName.toLowerCase()) {
        Array.from(container.attributes).filter((attr) => !retainedAttrs.has(attr.name.toLowerCase())).forEach((attr) => container.removeAttribute(attr.name));
        Object.keys(attrs).filter((name) => !retainedAttrs.has(name.toLowerCase())).forEach((attr) => container.setAttribute(attr, attrs[attr]));
        return container;
      } else {
        let newContainer = document.createElement(tagName);
        Object.keys(attrs).forEach((attr) => newContainer.setAttribute(attr, attrs[attr]));
        retainedAttrs.forEach((attr) => newContainer.setAttribute(attr, container.getAttribute(attr)));
        newContainer.innerHTML = container.innerHTML;
        container.replaceWith(newContainer);
        return newContainer;
      }
    },
    getSticky(el, name, defaultVal) {
      let op = (DOM.private(el, "sticky") || []).find(([existingName]) => name === existingName);
      if (op) {
        let [_name, _op, stashedResult] = op;
        return stashedResult;
      } else {
        return typeof defaultVal === "function" ? defaultVal() : defaultVal;
      }
    },
    deleteSticky(el, name) {
      this.updatePrivate(el, "sticky", [], (ops) => {
        return ops.filter(([existingName, _2]) => existingName !== name);
      });
    },
    putSticky(el, name, op) {
      let stashedResult = op(el);
      this.updatePrivate(el, "sticky", [], (ops) => {
        let existingIndex = ops.findIndex(([existingName]) => name === existingName);
        if (existingIndex >= 0) {
          ops[existingIndex] = [name, op, stashedResult];
        } else {
          ops.push([name, op, stashedResult]);
        }
        return ops;
      });
    },
    applyStickyOperations(el) {
      let ops = DOM.private(el, "sticky");
      if (!ops) {
        return;
      }
      ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));
    }
  };
  var dom_default = DOM;
  var UploadEntry = class {
    static isActive(fileEl, file) {
      let isNew = file._phxRef === void 0;
      let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return file.size > 0 && (isNew || isActive);
    }
    static isPreflighted(fileEl, file) {
      let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(",");
      let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return isPreflighted && this.isActive(fileEl, file);
    }
    constructor(fileEl, file, view) {
      this.ref = LiveUploader.genFileRef(file);
      this.fileEl = fileEl;
      this.file = file;
      this.view = view;
      this.meta = null;
      this._isCancelled = false;
      this._isDone = false;
      this._progress = 0;
      this._lastProgressSent = -1;
      this._onDone = function() {
      };
      this._onElUpdated = this.onElUpdated.bind(this);
      this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
    }
    metadata() {
      return this.meta;
    }
    progress(progress) {
      this._progress = Math.floor(progress);
      if (this._progress > this._lastProgressSent) {
        if (this._progress >= 100) {
          this._progress = 100;
          this._lastProgressSent = 100;
          this._isDone = true;
          this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {
            LiveUploader.untrackFile(this.fileEl, this.file);
            this._onDone();
          });
        } else {
          this._lastProgressSent = this._progress;
          this.view.pushFileProgress(this.fileEl, this.ref, this._progress);
        }
      }
    }
    cancel() {
      this._isCancelled = true;
      this._isDone = true;
      this._onDone();
    }
    isDone() {
      return this._isDone;
    }
    error(reason = "failed") {
      this.view.pushFileProgress(this.fileEl, this.ref, { error: reason });
      LiveUploader.clearFiles(this.fileEl);
    }
    onDone(callback) {
      this._onDone = () => {
        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
        callback();
      };
    }
    onElUpdated() {
      let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      if (activeRefs.indexOf(this.ref) === -1) {
        this.cancel();
      }
    }
    toPreflightPayload() {
      return {
        last_modified: this.file.lastModified,
        name: this.file.name,
        size: this.file.size,
        type: this.file.type,
        ref: this.ref
      };
    }
    uploader(uploaders) {
      if (this.meta.uploader) {
        let callback = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);
        return { name: this.meta.uploader, callback };
      } else {
        return { name: "channel", callback: channelUploader };
      }
    }
    zipPostFlight(resp) {
      this.meta = resp.entries[this.ref];
      if (!this.meta) {
        logError(`no preflight upload response returned with ref ${this.ref}`, { input: this.fileEl, response: resp });
      }
    }
  };
  var liveUploaderFileRef = 0;
  var LiveUploader = class {
    static genFileRef(file) {
      let ref = file._phxRef;
      if (ref !== void 0) {
        return ref;
      } else {
        file._phxRef = (liveUploaderFileRef++).toString();
        return file._phxRef;
      }
    }
    static getEntryDataURL(inputEl, ref, callback) {
      let file = this.activeFiles(inputEl).find((file2) => this.genFileRef(file2) === ref);
      callback(URL.createObjectURL(file));
    }
    static hasUploadsInProgress(formEl) {
      let active = 0;
      dom_default.findUploadInputs(formEl).forEach((input) => {
        if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {
          active++;
        }
      });
      return active > 0;
    }
    static serializeUploads(inputEl) {
      let files = this.activeFiles(inputEl);
      let fileData = {};
      files.forEach((file) => {
        let entry = { path: inputEl.name };
        let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);
        fileData[uploadRef] = fileData[uploadRef] || [];
        entry.ref = this.genFileRef(file);
        entry.name = file.name || entry.ref;
        entry.type = file.type;
        entry.size = file.size;
        fileData[uploadRef].push(entry);
      });
      return fileData;
    }
    static clearFiles(inputEl) {
      inputEl.value = null;
      inputEl.removeAttribute(PHX_UPLOAD_REF);
      dom_default.putPrivate(inputEl, "files", []);
    }
    static untrackFile(inputEl, file) {
      dom_default.putPrivate(inputEl, "files", dom_default.private(inputEl, "files").filter((f) => !Object.is(f, file)));
    }
    static trackFiles(inputEl, files) {
      if (inputEl.getAttribute("multiple") !== null) {
        let newFiles = files.filter((file) => !this.activeFiles(inputEl).find((f) => Object.is(f, file)));
        dom_default.putPrivate(inputEl, "files", this.activeFiles(inputEl).concat(newFiles));
        inputEl.value = null;
      } else {
        dom_default.putPrivate(inputEl, "files", files);
      }
    }
    static activeFileInputs(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((el) => el.files && this.activeFiles(el).length > 0);
    }
    static activeFiles(input) {
      return (dom_default.private(input, "files") || []).filter((f) => UploadEntry.isActive(input, f));
    }
    static inputsAwaitingPreflight(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((input) => this.filesAwaitingPreflight(input).length > 0);
    }
    static filesAwaitingPreflight(input) {
      return this.activeFiles(input).filter((f) => !UploadEntry.isPreflighted(input, f));
    }
    constructor(inputEl, view, onComplete) {
      this.view = view;
      this.onComplete = onComplete;
      this._entries = Array.from(LiveUploader.filesAwaitingPreflight(inputEl) || []).map((file) => new UploadEntry(inputEl, file, view));
      this.numEntriesInProgress = this._entries.length;
    }
    entries() {
      return this._entries;
    }
    initAdapterUpload(resp, onError, liveSocket2) {
      this._entries = this._entries.map((entry) => {
        entry.zipPostFlight(resp);
        entry.onDone(() => {
          this.numEntriesInProgress--;
          if (this.numEntriesInProgress === 0) {
            this.onComplete();
          }
        });
        return entry;
      });
      let groupedEntries = this._entries.reduce((acc, entry) => {
        let { name, callback } = entry.uploader(liveSocket2.uploaders);
        acc[name] = acc[name] || { callback, entries: [] };
        acc[name].entries.push(entry);
        return acc;
      }, {});
      for (let name in groupedEntries) {
        let { callback, entries } = groupedEntries[name];
        callback(entries, onError, resp, liveSocket2);
      }
    }
  };
  var Hooks = {
    LiveFileUpload: {
      activeRefs() {
        return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);
      },
      preflightedRefs() {
        return this.el.getAttribute(PHX_PREFLIGHTED_REFS);
      },
      mounted() {
        this.preflightedWas = this.preflightedRefs();
      },
      updated() {
        let newPreflights = this.preflightedRefs();
        if (this.preflightedWas !== newPreflights) {
          this.preflightedWas = newPreflights;
          if (newPreflights === "") {
            this.__view.cancelSubmit(this.el.form);
          }
        }
        if (this.activeRefs() === "") {
          this.el.value = null;
        }
        this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));
      }
    },
    LiveImgPreview: {
      mounted() {
        this.ref = this.el.getAttribute("data-phx-entry-ref");
        this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));
        LiveUploader.getEntryDataURL(this.inputEl, this.ref, (url) => {
          this.url = url;
          this.el.src = url;
        });
      },
      destroyed() {
        URL.revokeObjectURL(this.url);
      }
    }
  };
  var hooks_default = Hooks;
  var DOMPostMorphRestorer = class {
    constructor(containerBefore, containerAfter, updateType) {
      let idsBefore = /* @__PURE__ */ new Set();
      let idsAfter = new Set([...containerAfter.children].map((child) => child.id));
      let elementsToModify = [];
      Array.from(containerBefore.children).forEach((child) => {
        if (child.id) {
          idsBefore.add(child.id);
          if (idsAfter.has(child.id)) {
            let previousElementId = child.previousElementSibling && child.previousElementSibling.id;
            elementsToModify.push({ elementId: child.id, previousElementId });
          }
        }
      });
      this.containerId = containerAfter.id;
      this.updateType = updateType;
      this.elementsToModify = elementsToModify;
      this.elementIdsToAdd = [...idsAfter].filter((id) => !idsBefore.has(id));
    }
    perform() {
      let container = dom_default.byId(this.containerId);
      this.elementsToModify.forEach((elementToModify) => {
        if (elementToModify.previousElementId) {
          maybe(document.getElementById(elementToModify.previousElementId), (previousElem) => {
            maybe(document.getElementById(elementToModify.elementId), (elem) => {
              let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;
              if (!isInRightPlace) {
                previousElem.insertAdjacentElement("afterend", elem);
              }
            });
          });
        } else {
          maybe(document.getElementById(elementToModify.elementId), (elem) => {
            let isInRightPlace = elem.previousElementSibling == null;
            if (!isInRightPlace) {
              container.insertAdjacentElement("afterbegin", elem);
            }
          });
        }
      });
      if (this.updateType == "prepend") {
        this.elementIdsToAdd.reverse().forEach((elemId) => {
          maybe(document.getElementById(elemId), (elem) => container.insertAdjacentElement("afterbegin", elem));
        });
      }
    }
  };
  var DOCUMENT_FRAGMENT_NODE = 11;
  function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
      attr = toNodeAttrs[i];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      attrValue = attr.value;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attr.prefix === "xmlns") {
            attrName = attr.name;
          }
          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = fromNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          fromNode.setAttribute(attrName, attrValue);
        }
      }
    }
    var fromNodeAttrs = fromNode.attributes;
    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
      attr = fromNodeAttrs[d];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          fromNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!toNode.hasAttribute(attrName)) {
          fromNode.removeAttribute(attrName);
        }
      }
    }
  }
  var range;
  var NS_XHTML = "http://www.w3.org/1999/xhtml";
  var doc = typeof document === "undefined" ? void 0 : document;
  var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
  function createFragmentFromTemplate(str) {
    var template = doc.createElement("template");
    template.innerHTML = str;
    return template.content.childNodes[0];
  }
  function createFragmentFromRange(str) {
    if (!range) {
      range = doc.createRange();
      range.selectNode(doc.body);
    }
    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
  }
  function createFragmentFromWrap(str) {
    var fragment = doc.createElement("body");
    fragment.innerHTML = str;
    return fragment.childNodes[0];
  }
  function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }
    return createFragmentFromWrap(str);
  }
  function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;
    if (fromNodeName === toNodeName) {
      return true;
    }
    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);
    if (fromCodeStart <= 90 && toCodeStart >= 97) {
      return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {
      return toNodeName === fromNodeName.toUpperCase();
    } else {
      return false;
    }
  }
  function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);
  }
  function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
      var nextChild = curChild.nextSibling;
      toEl.appendChild(curChild);
      curChild = nextChild;
    }
    return toEl;
  }
  function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
      fromEl[name] = toEl[name];
      if (fromEl[name]) {
        fromEl.setAttribute(name, "");
      } else {
        fromEl.removeAttribute(name);
      }
    }
  }
  var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
      var parentNode = fromEl.parentNode;
      if (parentNode) {
        var parentName = parentNode.nodeName.toUpperCase();
        if (parentName === "OPTGROUP") {
          parentNode = parentNode.parentNode;
          parentName = parentNode && parentNode.nodeName.toUpperCase();
        }
        if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
          if (fromEl.hasAttribute("selected") && !toEl.selected) {
            fromEl.setAttribute("selected", "selected");
            fromEl.removeAttribute("selected");
          }
          parentNode.selectedIndex = -1;
        }
      }
      syncBooleanAttrProp(fromEl, toEl, "selected");
    },
    INPUT: function(fromEl, toEl) {
      syncBooleanAttrProp(fromEl, toEl, "checked");
      syncBooleanAttrProp(fromEl, toEl, "disabled");
      if (fromEl.value !== toEl.value) {
        fromEl.value = toEl.value;
      }
      if (!toEl.hasAttribute("value")) {
        fromEl.removeAttribute("value");
      }
    },
    TEXTAREA: function(fromEl, toEl) {
      var newValue = toEl.value;
      if (fromEl.value !== newValue) {
        fromEl.value = newValue;
      }
      var firstChild = fromEl.firstChild;
      if (firstChild) {
        var oldValue = firstChild.nodeValue;
        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
          return;
        }
        firstChild.nodeValue = newValue;
      }
    },
    SELECT: function(fromEl, toEl) {
      if (!toEl.hasAttribute("multiple")) {
        var selectedIndex = -1;
        var i = 0;
        var curChild = fromEl.firstChild;
        var optgroup;
        var nodeName;
        while (curChild) {
          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
          if (nodeName === "OPTGROUP") {
            optgroup = curChild;
            curChild = optgroup.firstChild;
          } else {
            if (nodeName === "OPTION") {
              if (curChild.hasAttribute("selected")) {
                selectedIndex = i;
                break;
              }
              i++;
            }
            curChild = curChild.nextSibling;
            if (!curChild && optgroup) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          }
        }
        fromEl.selectedIndex = selectedIndex;
      }
    }
  };
  var ELEMENT_NODE = 1;
  var DOCUMENT_FRAGMENT_NODE$1 = 11;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  function noop() {
  }
  function defaultGetNodeKey(node) {
    if (node) {
      return node.getAttribute && node.getAttribute("id") || node.id;
    }
  }
  function morphdomFactory(morphAttrs2) {
    return function morphdom2(fromNode, toNode, options) {
      if (!options) {
        options = {};
      }
      if (typeof toNode === "string") {
        if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML" || fromNode.nodeName === "BODY") {
          var toNodeHtml = toNode;
          toNode = doc.createElement("html");
          toNode.innerHTML = toNodeHtml;
        } else {
          toNode = toElement(toNode);
        }
      }
      var getNodeKey = options.getNodeKey || defaultGetNodeKey;
      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
      var onNodeAdded = options.onNodeAdded || noop;
      var onBeforeElUpdated = options.onBeforeElUpdated || noop;
      var onElUpdated = options.onElUpdated || noop;
      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
      var onNodeDiscarded = options.onNodeDiscarded || noop;
      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
      var childrenOnly = options.childrenOnly === true;
      var fromNodesLookup = /* @__PURE__ */ Object.create(null);
      var keyedRemovalList = [];
      function addKeyedRemoval(key) {
        keyedRemovalList.push(key);
      }
      function walkDiscardedChildNodes(node, skipKeyedNodes) {
        if (node.nodeType === ELEMENT_NODE) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = void 0;
            if (skipKeyedNodes && (key = getNodeKey(curChild))) {
              addKeyedRemoval(key);
            } else {
              onNodeDiscarded(curChild);
              if (curChild.firstChild) {
                walkDiscardedChildNodes(curChild, skipKeyedNodes);
              }
            }
            curChild = curChild.nextSibling;
          }
        }
      }
      function removeNode(node, parentNode, skipKeyedNodes) {
        if (onBeforeNodeDiscarded(node) === false) {
          return;
        }
        if (parentNode) {
          parentNode.removeChild(node);
        }
        onNodeDiscarded(node);
        walkDiscardedChildNodes(node, skipKeyedNodes);
      }
      function indexTree(node) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = getNodeKey(curChild);
            if (key) {
              fromNodesLookup[key] = curChild;
            }
            indexTree(curChild);
            curChild = curChild.nextSibling;
          }
        }
      }
      indexTree(fromNode);
      function handleNodeAdded(el) {
        onNodeAdded(el);
        var curChild = el.firstChild;
        while (curChild) {
          var nextSibling = curChild.nextSibling;
          var key = getNodeKey(curChild);
          if (key) {
            var unmatchedFromEl = fromNodesLookup[key];
            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
              morphEl(unmatchedFromEl, curChild);
            } else {
              handleNodeAdded(curChild);
            }
          } else {
            handleNodeAdded(curChild);
          }
          curChild = nextSibling;
        }
      }
      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
        while (curFromNodeChild) {
          var fromNextSibling = curFromNodeChild.nextSibling;
          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
            addKeyedRemoval(curFromNodeKey);
          } else {
            removeNode(curFromNodeChild, fromEl, true);
          }
          curFromNodeChild = fromNextSibling;
        }
      }
      function morphEl(fromEl, toEl, childrenOnly2) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
          delete fromNodesLookup[toElKey];
        }
        if (!childrenOnly2) {
          if (onBeforeElUpdated(fromEl, toEl) === false) {
            return;
          }
          morphAttrs2(fromEl, toEl);
          onElUpdated(fromEl);
          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
            return;
          }
        }
        if (fromEl.nodeName !== "TEXTAREA") {
          morphChildren(fromEl, toEl);
        } else {
          specialElHandlers.TEXTAREA(fromEl, toEl);
        }
      }
      function morphChildren(fromEl, toEl) {
        var curToNodeChild = toEl.firstChild;
        var curFromNodeChild = fromEl.firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        outer:
          while (curToNodeChild) {
            toNextSibling = curToNodeChild.nextSibling;
            curToNodeKey = getNodeKey(curToNodeChild);
            while (curFromNodeChild) {
              fromNextSibling = curFromNodeChild.nextSibling;
              if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              curFromNodeKey = getNodeKey(curFromNodeChild);
              var curFromNodeType = curFromNodeChild.nodeType;
              var isCompatible = void 0;
              if (curFromNodeType === curToNodeChild.nodeType) {
                if (curFromNodeType === ELEMENT_NODE) {
                  if (curToNodeKey) {
                    if (curToNodeKey !== curFromNodeKey) {
                      if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                        if (fromNextSibling === matchingFromEl) {
                          isCompatible = false;
                        } else {
                          fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                          if (curFromNodeKey) {
                            addKeyedRemoval(curFromNodeKey);
                          } else {
                            removeNode(curFromNodeChild, fromEl, true);
                          }
                          curFromNodeChild = matchingFromEl;
                        }
                      } else {
                        isCompatible = false;
                      }
                    }
                  } else if (curFromNodeKey) {
                    isCompatible = false;
                  }
                  isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                  if (isCompatible) {
                    morphEl(curFromNodeChild, curToNodeChild);
                  }
                } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                  isCompatible = true;
                  if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                  }
                }
              }
              if (isCompatible) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              if (curFromNodeKey) {
                addKeyedRemoval(curFromNodeKey);
              } else {
                removeNode(curFromNodeChild, fromEl, true);
              }
              curFromNodeChild = fromNextSibling;
            }
            if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
              fromEl.appendChild(matchingFromEl);
              morphEl(matchingFromEl, curToNodeChild);
            } else {
              var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
              if (onBeforeNodeAddedResult !== false) {
                if (onBeforeNodeAddedResult) {
                  curToNodeChild = onBeforeNodeAddedResult;
                }
                if (curToNodeChild.actualize) {
                  curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                }
                fromEl.appendChild(curToNodeChild);
                handleNodeAdded(curToNodeChild);
              }
            }
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
          }
        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
        var specialElHandler = specialElHandlers[fromEl.nodeName];
        if (specialElHandler) {
          specialElHandler(fromEl, toEl);
        }
      }
      var morphedNode = fromNode;
      var morphedNodeType = morphedNode.nodeType;
      var toNodeType = toNode.nodeType;
      if (!childrenOnly) {
        if (morphedNodeType === ELEMENT_NODE) {
          if (toNodeType === ELEMENT_NODE) {
            if (!compareNodeNames(fromNode, toNode)) {
              onNodeDiscarded(fromNode);
              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
            }
          } else {
            morphedNode = toNode;
          }
        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
          if (toNodeType === morphedNodeType) {
            if (morphedNode.nodeValue !== toNode.nodeValue) {
              morphedNode.nodeValue = toNode.nodeValue;
            }
            return morphedNode;
          } else {
            morphedNode = toNode;
          }
        }
      }
      if (morphedNode === toNode) {
        onNodeDiscarded(fromNode);
      } else {
        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
          return;
        }
        morphEl(morphedNode, toNode, childrenOnly);
        if (keyedRemovalList) {
          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {
            var elToRemove = fromNodesLookup[keyedRemovalList[i]];
            if (elToRemove) {
              removeNode(elToRemove, elToRemove.parentNode, false);
            }
          }
        }
      }
      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        if (morphedNode.actualize) {
          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
        }
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
      }
      return morphedNode;
    };
  }
  var morphdom = morphdomFactory(morphAttrs);
  var morphdom_esm_default = morphdom;
  var DOMPatch = class {
    static patchEl(fromEl, toEl, activeElement) {
      morphdom_esm_default(fromEl, toEl, {
        childrenOnly: false,
        onBeforeElUpdated: (fromEl2, toEl2) => {
          if (activeElement && activeElement.isSameNode(fromEl2) && dom_default.isFormInput(fromEl2)) {
            dom_default.mergeFocusedInput(fromEl2, toEl2);
            return false;
          }
        }
      });
    }
    constructor(view, container, id, html, targetCID) {
      this.view = view;
      this.liveSocket = view.liveSocket;
      this.container = container;
      this.id = id;
      this.rootID = view.root.id;
      this.html = html;
      this.targetCID = targetCID;
      this.cidPatch = isCid(this.targetCID);
      this.callbacks = {
        beforeadded: [],
        beforeupdated: [],
        beforephxChildAdded: [],
        afteradded: [],
        afterupdated: [],
        afterdiscarded: [],
        afterphxChildAdded: [],
        aftertransitionsDiscarded: []
      };
    }
    before(kind, callback) {
      this.callbacks[`before${kind}`].push(callback);
    }
    after(kind, callback) {
      this.callbacks[`after${kind}`].push(callback);
    }
    trackBefore(kind, ...args) {
      this.callbacks[`before${kind}`].forEach((callback) => callback(...args));
    }
    trackAfter(kind, ...args) {
      this.callbacks[`after${kind}`].forEach((callback) => callback(...args));
    }
    markPrunableContentForRemoval() {
      dom_default.all(this.container, "[phx-update=append] > *, [phx-update=prepend] > *", (el) => {
        el.setAttribute(PHX_PRUNE, "");
      });
    }
    perform() {
      let { view, liveSocket: liveSocket2, container, html } = this;
      let targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;
      if (this.isCIDPatch() && !targetContainer) {
        return;
      }
      let focused = liveSocket2.getActiveElement();
      let { selectionStart, selectionEnd } = focused && dom_default.hasSelectionRange(focused) ? focused : {};
      let phxUpdate = liveSocket2.binding(PHX_UPDATE);
      let phxFeedbackFor = liveSocket2.binding(PHX_FEEDBACK_FOR);
      let disableWith = liveSocket2.binding(PHX_DISABLE_WITH);
      let phxTriggerExternal = liveSocket2.binding(PHX_TRIGGER_ACTION);
      let phxRemove = liveSocket2.binding("remove");
      let added = [];
      let updates = [];
      let appendPrependUpdates = [];
      let pendingRemoves = [];
      let externalFormTriggered = null;
      let diffHTML = liveSocket2.time("premorph container prep", () => {
        return this.buildDiffHTML(container, html, phxUpdate, targetContainer);
      });
      this.trackBefore("added", container);
      this.trackBefore("updated", container, container);
      liveSocket2.time("morphdom", () => {
        morphdom_esm_default(targetContainer, diffHTML, {
          childrenOnly: targetContainer.getAttribute(PHX_COMPONENT) === null,
          getNodeKey: (node) => {
            return dom_default.isPhxDestroyed(node) ? null : node.id;
          },
          onBeforeNodeAdded: (el) => {
            this.trackBefore("added", el);
            return el;
          },
          onNodeAdded: (el) => {
            if (el instanceof HTMLImageElement && el.srcset) {
              el.srcset = el.srcset;
            } else if (el instanceof HTMLVideoElement && el.autoplay) {
              el.play();
            }
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            dom_default.discardError(targetContainer, el, phxFeedbackFor);
            if (dom_default.isPhxChild(el) && view.ownsElement(el) || dom_default.isPhxSticky(el) && view.ownsElement(el.parentNode)) {
              this.trackAfter("phxChildAdded", el);
            }
            added.push(el);
          },
          onNodeDiscarded: (el) => {
            if (dom_default.isPhxChild(el) || dom_default.isPhxSticky(el)) {
              liveSocket2.destroyViewByEl(el);
            }
            this.trackAfter("discarded", el);
          },
          onBeforeNodeDiscarded: (el) => {
            if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {
              return true;
            }
            if (el.parentNode !== null && dom_default.isPhxUpdate(el.parentNode, phxUpdate, ["append", "prepend"]) && el.id) {
              return false;
            }
            if (el.getAttribute && el.getAttribute(phxRemove)) {
              pendingRemoves.push(el);
              return false;
            }
            if (this.skipCIDSibling(el)) {
              return false;
            }
            return true;
          },
          onElUpdated: (el) => {
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            updates.push(el);
          },
          onBeforeElUpdated: (fromEl, toEl) => {
            dom_default.cleanChildNodes(toEl, phxUpdate);
            if (this.skipCIDSibling(toEl)) {
              return false;
            }
            if (dom_default.isPhxSticky(fromEl)) {
              return false;
            }
            if (dom_default.isIgnored(fromEl, phxUpdate)) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeAttrs(fromEl, toEl, { isIgnored: true });
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (fromEl.type === "number" && (fromEl.validity && fromEl.validity.badInput)) {
              return false;
            }
            if (!dom_default.syncPendingRef(fromEl, toEl, disableWith)) {
              if (dom_default.isUploadInput(fromEl)) {
                this.trackBefore("updated", fromEl, toEl);
                updates.push(fromEl);
              }
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (dom_default.isPhxChild(toEl)) {
              let prevSession = fromEl.getAttribute(PHX_SESSION);
              dom_default.mergeAttrs(fromEl, toEl, { exclude: [PHX_STATIC] });
              if (prevSession !== "") {
                fromEl.setAttribute(PHX_SESSION, prevSession);
              }
              fromEl.setAttribute(PHX_ROOT_ID, this.rootID);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            dom_default.copyPrivates(toEl, fromEl);
            dom_default.discardError(targetContainer, toEl, phxFeedbackFor);
            let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);
            if (isFocusedFormEl) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeFocusedInput(fromEl, toEl);
              dom_default.syncAttrsToProps(fromEl);
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            } else {
              if (dom_default.isPhxUpdate(toEl, phxUpdate, ["append", "prepend"])) {
                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));
              }
              dom_default.syncAttrsToProps(toEl);
              dom_default.applyStickyOperations(toEl);
              this.trackBefore("updated", fromEl, toEl);
              return true;
            }
          }
        });
      });
      if (liveSocket2.isDebugEnabled()) {
        detectDuplicateIds();
      }
      if (appendPrependUpdates.length > 0) {
        liveSocket2.time("post-morph append/prepend restoration", () => {
          appendPrependUpdates.forEach((update) => update.perform());
        });
      }
      liveSocket2.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));
      dom_default.dispatchEvent(document, "phx:update");
      added.forEach((el) => this.trackAfter("added", el));
      updates.forEach((el) => this.trackAfter("updated", el));
      if (pendingRemoves.length > 0) {
        liveSocket2.transitionRemoves(pendingRemoves);
        liveSocket2.requestDOMUpdate(() => {
          pendingRemoves.forEach((el) => {
            let child = dom_default.firstPhxChild(el);
            if (child) {
              liveSocket2.destroyViewByEl(child);
            }
            el.remove();
          });
          this.trackAfter("transitionsDiscarded", pendingRemoves);
        });
      }
      if (externalFormTriggered) {
        liveSocket2.disconnect();
        externalFormTriggered.submit();
      }
      return true;
    }
    isCIDPatch() {
      return this.cidPatch;
    }
    skipCIDSibling(el) {
      return el.nodeType === Node.ELEMENT_NODE && el.getAttribute(PHX_SKIP) !== null;
    }
    targetCIDContainer(html) {
      if (!this.isCIDPatch()) {
        return;
      }
      let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);
      if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {
        return first;
      } else {
        return first && first.parentNode;
      }
    }
    buildDiffHTML(container, html, phxUpdate, targetContainer) {
      let isCIDPatch = this.isCIDPatch();
      let isCIDWithSingleRoot = isCIDPatch && targetContainer.getAttribute(PHX_COMPONENT) === this.targetCID.toString();
      if (!isCIDPatch || isCIDWithSingleRoot) {
        return html;
      } else {
        let diffContainer = null;
        let template = document.createElement("template");
        diffContainer = dom_default.cloneNode(targetContainer);
        let [firstComponent, ...rest] = dom_default.findComponentNodeList(diffContainer, this.targetCID);
        template.innerHTML = html;
        rest.forEach((el) => el.remove());
        Array.from(diffContainer.childNodes).forEach((child) => {
          if (child.id && child.nodeType === Node.ELEMENT_NODE && child.getAttribute(PHX_COMPONENT) !== this.targetCID.toString()) {
            child.setAttribute(PHX_SKIP, "");
            child.innerHTML = "";
          }
        });
        Array.from(template.content.childNodes).forEach((el) => diffContainer.insertBefore(el, firstComponent));
        firstComponent.remove();
        return diffContainer.outerHTML;
      }
    }
  };
  var Rendered = class {
    static extract(diff) {
      let { [REPLY]: reply, [EVENTS]: events, [TITLE]: title } = diff;
      delete diff[REPLY];
      delete diff[EVENTS];
      delete diff[TITLE];
      return { diff, title, reply: reply || null, events: events || [] };
    }
    constructor(viewId, rendered) {
      this.viewId = viewId;
      this.rendered = {};
      this.mergeDiff(rendered);
    }
    parentViewId() {
      return this.viewId;
    }
    toString(onlyCids) {
      return this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids);
    }
    recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids) {
      onlyCids = onlyCids ? new Set(onlyCids) : null;
      let output = { buffer: "", components, onlyCids };
      this.toOutputBuffer(rendered, null, output);
      return output.buffer;
    }
    componentCIDs(diff) {
      return Object.keys(diff[COMPONENTS] || {}).map((i) => parseInt(i));
    }
    isComponentOnlyDiff(diff) {
      if (!diff[COMPONENTS]) {
        return false;
      }
      return Object.keys(diff).length === 1;
    }
    getComponent(diff, cid) {
      return diff[COMPONENTS][cid];
    }
    mergeDiff(diff) {
      let newc = diff[COMPONENTS];
      let cache = {};
      delete diff[COMPONENTS];
      this.rendered = this.mutableMerge(this.rendered, diff);
      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};
      if (newc) {
        let oldc = this.rendered[COMPONENTS];
        for (let cid in newc) {
          newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);
        }
        for (let cid in newc) {
          oldc[cid] = newc[cid];
        }
        diff[COMPONENTS] = newc;
      }
    }
    cachedFindComponent(cid, cdiff, oldc, newc, cache) {
      if (cache[cid]) {
        return cache[cid];
      } else {
        let ndiff, stat, scid = cdiff[STATIC];
        if (isCid(scid)) {
          let tdiff;
          if (scid > 0) {
            tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);
          } else {
            tdiff = oldc[-scid];
          }
          stat = tdiff[STATIC];
          ndiff = this.cloneMerge(tdiff, cdiff);
          ndiff[STATIC] = stat;
        } else {
          ndiff = cdiff[STATIC] !== void 0 ? cdiff : this.cloneMerge(oldc[cid] || {}, cdiff);
        }
        cache[cid] = ndiff;
        return ndiff;
      }
    }
    mutableMerge(target, source) {
      if (source[STATIC] !== void 0) {
        return source;
      } else {
        this.doMutableMerge(target, source);
        return target;
      }
    }
    doMutableMerge(target, source) {
      for (let key in source) {
        let val = source[key];
        let targetVal = target[key];
        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {
          this.doMutableMerge(targetVal, val);
        } else {
          target[key] = val;
        }
      }
    }
    cloneMerge(target, source) {
      let merged = __spreadValues(__spreadValues({}, target), source);
      for (let key in merged) {
        let val = source[key];
        let targetVal = target[key];
        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {
          merged[key] = this.cloneMerge(targetVal, val);
        }
      }
      return merged;
    }
    componentToString(cid) {
      return this.recursiveCIDToString(this.rendered[COMPONENTS], cid);
    }
    pruneCIDs(cids) {
      cids.forEach((cid) => delete this.rendered[COMPONENTS][cid]);
    }
    get() {
      return this.rendered;
    }
    isNewFingerprint(diff = {}) {
      return !!diff[STATIC];
    }
    templateStatic(part, templates) {
      if (typeof part === "number") {
        return templates[part];
      } else {
        return part;
      }
    }
    toOutputBuffer(rendered, templates, output) {
      if (rendered[DYNAMICS]) {
        return this.comprehensionToBuffer(rendered, templates, output);
      }
      let { [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      output.buffer += statics[0];
      for (let i = 1; i < statics.length; i++) {
        this.dynamicToBuffer(rendered[i - 1], templates, output);
        output.buffer += statics[i];
      }
    }
    comprehensionToBuffer(rendered, templates, output) {
      let { [DYNAMICS]: dynamics, [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      let compTemplates = templates || rendered[TEMPLATES];
      for (let d = 0; d < dynamics.length; d++) {
        let dynamic = dynamics[d];
        output.buffer += statics[0];
        for (let i = 1; i < statics.length; i++) {
          this.dynamicToBuffer(dynamic[i - 1], compTemplates, output);
          output.buffer += statics[i];
        }
      }
    }
    dynamicToBuffer(rendered, templates, output) {
      if (typeof rendered === "number") {
        output.buffer += this.recursiveCIDToString(output.components, rendered, output.onlyCids);
      } else if (isObject(rendered)) {
        this.toOutputBuffer(rendered, templates, output);
      } else {
        output.buffer += rendered;
      }
    }
    recursiveCIDToString(components, cid, onlyCids) {
      let component = components[cid] || logError(`no component for CID ${cid}`, components);
      let template = document.createElement("template");
      template.innerHTML = this.recursiveToString(component, components, onlyCids);
      let container = template.content;
      let skip = onlyCids && !onlyCids.has(cid);
      let [hasChildNodes, hasChildComponents] = Array.from(container.childNodes).reduce(([hasNodes, hasComponents], child, i) => {
        if (child.nodeType === Node.ELEMENT_NODE) {
          if (child.getAttribute(PHX_COMPONENT)) {
            return [hasNodes, true];
          }
          child.setAttribute(PHX_COMPONENT, cid);
          if (!child.id) {
            child.id = `${this.parentViewId()}-${cid}-${i}`;
          }
          if (skip) {
            child.setAttribute(PHX_SKIP, "");
            child.innerHTML = "";
          }
          return [true, hasComponents];
        } else {
          if (child.nodeValue.trim() !== "") {
            logError(`only HTML element tags are allowed at the root of components.

got: "${child.nodeValue.trim()}"

within:
`, template.innerHTML.trim());
            child.replaceWith(this.createSpan(child.nodeValue, cid));
            return [true, hasComponents];
          } else {
            child.remove();
            return [hasNodes, hasComponents];
          }
        }
      }, [false, false]);
      if (!hasChildNodes && !hasChildComponents) {
        logError("expected at least one HTML element tag inside a component, but the component is empty:\n", template.innerHTML.trim());
        return this.createSpan("", cid).outerHTML;
      } else if (!hasChildNodes && hasChildComponents) {
        logError("expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.", template.innerHTML.trim());
        return template.innerHTML;
      } else {
        return template.innerHTML;
      }
    }
    createSpan(text, cid) {
      let span = document.createElement("span");
      span.innerText = text;
      span.setAttribute(PHX_COMPONENT, cid);
      return span;
    }
  };
  var viewHookID = 1;
  var ViewHook = class {
    static makeID() {
      return viewHookID++;
    }
    static elementID(el) {
      return el.phxHookId;
    }
    constructor(view, el, callbacks) {
      this.__view = view;
      this.liveSocket = view.liveSocket;
      this.__callbacks = callbacks;
      this.__listeners = /* @__PURE__ */ new Set();
      this.__isDisconnected = false;
      this.el = el;
      this.el.phxHookId = this.constructor.makeID();
      for (let key in this.__callbacks) {
        this[key] = this.__callbacks[key];
      }
    }
    __mounted() {
      this.mounted && this.mounted();
    }
    __updated() {
      this.updated && this.updated();
    }
    __beforeUpdate() {
      this.beforeUpdate && this.beforeUpdate();
    }
    __destroyed() {
      this.destroyed && this.destroyed();
    }
    __reconnected() {
      if (this.__isDisconnected) {
        this.__isDisconnected = false;
        this.reconnected && this.reconnected();
      }
    }
    __disconnected() {
      this.__isDisconnected = true;
      this.disconnected && this.disconnected();
    }
    pushEvent(event, payload = {}, onReply = function() {
    }) {
      return this.__view.pushHookEvent(null, event, payload, onReply);
    }
    pushEventTo(phxTarget, event, payload = {}, onReply = function() {
    }) {
      return this.__view.withinTargets(phxTarget, (view, targetCtx) => {
        return view.pushHookEvent(targetCtx, event, payload, onReply);
      });
    }
    handleEvent(event, callback) {
      let callbackRef = (customEvent, bypass) => bypass ? event : callback(customEvent.detail);
      window.addEventListener(`phx:${event}`, callbackRef);
      this.__listeners.add(callbackRef);
      return callbackRef;
    }
    removeHandleEvent(callbackRef) {
      let event = callbackRef(null, true);
      window.removeEventListener(`phx:${event}`, callbackRef);
      this.__listeners.delete(callbackRef);
    }
    upload(name, files) {
      return this.__view.dispatchUploads(name, files);
    }
    uploadTo(phxTarget, name, files) {
      return this.__view.withinTargets(phxTarget, (view) => view.dispatchUploads(name, files));
    }
    __cleanup__() {
      this.__listeners.forEach((callbackRef) => this.removeHandleEvent(callbackRef));
    }
  };
  var JS = {
    exec(eventType, phxEvent, view, sourceEl, defaults) {
      let [defaultKind, defaultArgs] = defaults || [null, {}];
      let commands = phxEvent.charAt(0) === "[" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];
      commands.forEach(([kind, args]) => {
        if (kind === defaultKind && defaultArgs.data) {
          args.data = Object.assign(args.data || {}, defaultArgs.data);
        }
        this.filterToEls(sourceEl, args).forEach((el) => {
          this[`exec_${kind}`](eventType, phxEvent, view, sourceEl, el, args);
        });
      });
    },
    isVisible(el) {
      return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length > 0);
    },
    exec_dispatch(eventType, phxEvent, view, sourceEl, el, { to, event, detail, bubbles }) {
      detail = detail || {};
      detail.dispatcher = sourceEl;
      dom_default.dispatchEvent(el, event, { detail, bubbles });
    },
    exec_push(eventType, phxEvent, view, sourceEl, el, args) {
      if (!view.isConnected()) {
        return;
      }
      let { event, data, target, page_loading, loading, value, dispatcher } = args;
      let pushOpts = { loading, value, target, page_loading: !!page_loading };
      let targetSrc = eventType === "change" && dispatcher ? dispatcher : sourceEl;
      let phxTarget = target || targetSrc.getAttribute(view.binding("target")) || targetSrc;
      view.withinTargets(phxTarget, (targetView, targetCtx) => {
        if (eventType === "change") {
          let { newCid, _target, callback } = args;
          _target = _target || (sourceEl instanceof HTMLInputElement ? sourceEl.name : void 0);
          if (_target) {
            pushOpts._target = _target;
          }
          targetView.pushInput(sourceEl, targetCtx, newCid, event || phxEvent, pushOpts, callback);
        } else if (eventType === "submit") {
          targetView.submitForm(sourceEl, targetCtx, event || phxEvent, pushOpts);
        } else {
          targetView.pushEvent(eventType, sourceEl, targetCtx, event || phxEvent, data, pushOpts);
        }
      });
    },
    exec_add_class(eventType, phxEvent, view, sourceEl, el, { names, transition, time }) {
      this.addOrRemoveClasses(el, names, [], transition, time, view);
    },
    exec_remove_class(eventType, phxEvent, view, sourceEl, el, { names, transition, time }) {
      this.addOrRemoveClasses(el, [], names, transition, time, view);
    },
    exec_transition(eventType, phxEvent, view, sourceEl, el, { time, transition }) {
      let [transition_start, running, transition_end] = transition;
      let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(running), []);
      let onDone = () => this.addOrRemoveClasses(el, transition_end, transition_start.concat(running));
      view.transition(time, onStart, onDone);
    },
    exec_toggle(eventType, phxEvent, view, sourceEl, el, { display, ins, outs, time }) {
      this.toggle(eventType, view, el, display, ins, outs, time);
    },
    exec_show(eventType, phxEvent, view, sourceEl, el, { display, transition, time }) {
      this.show(eventType, view, el, display, transition, time);
    },
    exec_hide(eventType, phxEvent, view, sourceEl, el, { display, transition, time }) {
      this.hide(eventType, view, el, display, transition, time);
    },
    exec_set_attr(eventType, phxEvent, view, sourceEl, el, { attr: [attr, val] }) {
      this.setOrRemoveAttrs(el, [[attr, val]], []);
    },
    exec_remove_attr(eventType, phxEvent, view, sourceEl, el, { attr }) {
      this.setOrRemoveAttrs(el, [], [attr]);
    },
    show(eventType, view, el, display, transition, time) {
      if (!this.isVisible(el)) {
        this.toggle(eventType, view, el, display, transition, null, time);
      }
    },
    hide(eventType, view, el, display, transition, time) {
      if (this.isVisible(el)) {
        this.toggle(eventType, view, el, display, null, transition, time);
      }
    },
    toggle(eventType, view, el, display, ins, outs, time) {
      let [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];
      let [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];
      if (inClasses.length > 0 || outClasses.length > 0) {
        if (this.isVisible(el)) {
          let onStart = () => {
            this.addOrRemoveClasses(el, outStartClasses, inClasses.concat(inStartClasses).concat(inEndClasses));
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, outClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, outEndClasses, outStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:hide-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          if (eventType === "remove") {
            return;
          }
          let onStart = () => {
            this.addOrRemoveClasses(el, inStartClasses, outClasses.concat(outStartClasses).concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = display || "block");
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, inClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, inEndClasses, inStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:show-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      } else {
        if (this.isVisible(el)) {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:hide-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:show-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = display || "block");
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      }
    },
    addOrRemoveClasses(el, adds, removes, transition, time, view) {
      let [transition_run, transition_start, transition_end] = transition || [[], [], []];
      if (transition_run.length > 0) {
        let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(transition_run), []);
        let onDone = () => this.addOrRemoveClasses(el, adds.concat(transition_end), removes.concat(transition_run).concat(transition_start));
        return view.transition(time, onStart, onDone);
      }
      window.requestAnimationFrame(() => {
        let [prevAdds, prevRemoves] = dom_default.getSticky(el, "classes", [[], []]);
        let keepAdds = adds.filter((name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));
        let keepRemoves = removes.filter((name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));
        let newAdds = prevAdds.filter((name) => removes.indexOf(name) < 0).concat(keepAdds);
        let newRemoves = prevRemoves.filter((name) => adds.indexOf(name) < 0).concat(keepRemoves);
        dom_default.putSticky(el, "classes", (currentEl) => {
          currentEl.classList.remove(...newRemoves);
          currentEl.classList.add(...newAdds);
          return [newAdds, newRemoves];
        });
      });
    },
    setOrRemoveAttrs(el, sets, removes) {
      let [prevSets, prevRemoves] = dom_default.getSticky(el, "attrs", [[], []]);
      let alteredAttrs = sets.map(([attr, _val]) => attr).concat(removes);
      let newSets = prevSets.filter(([attr, _val]) => !alteredAttrs.includes(attr)).concat(sets);
      let newRemoves = prevRemoves.filter((attr) => !alteredAttrs.includes(attr)).concat(removes);
      dom_default.putSticky(el, "attrs", (currentEl) => {
        newRemoves.forEach((attr) => currentEl.removeAttribute(attr));
        newSets.forEach(([attr, val]) => currentEl.setAttribute(attr, val));
        return [newSets, newRemoves];
      });
    },
    hasAllClasses(el, classes) {
      return classes.every((name) => el.classList.contains(name));
    },
    isToggledOut(el, outClasses) {
      return !this.isVisible(el) || this.hasAllClasses(el, outClasses);
    },
    filterToEls(sourceEl, { to }) {
      return to ? dom_default.all(document, to) : [sourceEl];
    }
  };
  var js_default = JS;
  var serializeForm = (form, meta, onlyNames = []) => {
    let formData = new FormData(form);
    let toRemove = [];
    formData.forEach((val, key, _index) => {
      if (val instanceof File) {
        toRemove.push(key);
      }
    });
    toRemove.forEach((key) => formData.delete(key));
    let params = new URLSearchParams();
    for (let [key, val] of formData.entries()) {
      if (onlyNames.length === 0 || onlyNames.indexOf(key) >= 0) {
        params.append(key, val);
      }
    }
    for (let metaKey in meta) {
      params.append(metaKey, meta[metaKey]);
    }
    return params.toString();
  };
  var View = class {
    constructor(el, liveSocket2, parentView, flash) {
      this.liveSocket = liveSocket2;
      this.flash = flash;
      this.parent = parentView;
      this.root = parentView ? parentView.root : this;
      this.el = el;
      this.id = this.el.id;
      this.ref = 0;
      this.childJoins = 0;
      this.loaderTimer = null;
      this.pendingDiffs = [];
      this.pruningCIDs = [];
      this.redirect = false;
      this.href = null;
      this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;
      this.joinPending = true;
      this.destroyed = false;
      this.joinCallback = function(onDone) {
        onDone && onDone();
      };
      this.stopCallback = function() {
      };
      this.pendingJoinOps = this.parent ? null : [];
      this.viewHooks = {};
      this.uploaders = {};
      this.formSubmits = [];
      this.children = this.parent ? null : {};
      this.root.children[this.id] = {};
      this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {
        return {
          redirect: this.redirect ? this.href : void 0,
          url: this.redirect ? void 0 : this.href || void 0,
          params: this.connectParams(),
          session: this.getSession(),
          static: this.getStatic(),
          flash: this.flash
        };
      });
      this.showLoader(this.liveSocket.loaderTimeout);
      this.bindChannel();
    }
    setHref(href) {
      this.href = href;
    }
    setRedirect(href) {
      this.redirect = true;
      this.href = href;
    }
    isMain() {
      return this.el.getAttribute(PHX_MAIN) !== null;
    }
    connectParams() {
      let params = this.liveSocket.params(this.el);
      let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map((node) => node.src || node.href).filter((url) => typeof url === "string");
      if (manifest.length > 0) {
        params["_track_static"] = manifest;
      }
      params["_mounts"] = this.joinCount;
      return params;
    }
    isConnected() {
      return this.channel.canPush();
    }
    getSession() {
      return this.el.getAttribute(PHX_SESSION);
    }
    getStatic() {
      let val = this.el.getAttribute(PHX_STATIC);
      return val === "" ? null : val;
    }
    destroy(callback = function() {
    }) {
      this.destroyAllChildren();
      this.destroyed = true;
      delete this.root.children[this.id];
      if (this.parent) {
        delete this.root.children[this.parent.id][this.id];
      }
      clearTimeout(this.loaderTimer);
      let onFinished = () => {
        callback();
        for (let id in this.viewHooks) {
          this.destroyHook(this.viewHooks[id]);
        }
      };
      dom_default.markPhxChildDestroyed(this.el);
      this.log("destroyed", () => ["the child has been removed from the parent"]);
      this.channel.leave().receive("ok", onFinished).receive("error", onFinished).receive("timeout", onFinished);
    }
    setContainerClasses(...classes) {
      this.el.classList.remove(PHX_CONNECTED_CLASS, PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);
      this.el.classList.add(...classes);
    }
    showLoader(timeout) {
      clearTimeout(this.loaderTimer);
      if (timeout) {
        this.loaderTimer = setTimeout(() => this.showLoader(), timeout);
      } else {
        for (let id in this.viewHooks) {
          this.viewHooks[id].__disconnected();
        }
        this.setContainerClasses(PHX_DISCONNECTED_CLASS);
      }
    }
    hideLoader() {
      clearTimeout(this.loaderTimer);
      this.setContainerClasses(PHX_CONNECTED_CLASS);
    }
    triggerReconnected() {
      for (let id in this.viewHooks) {
        this.viewHooks[id].__reconnected();
      }
    }
    log(kind, msgCallback) {
      this.liveSocket.log(this, kind, msgCallback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.liveSocket.transition(time, onStart, onDone);
    }
    withinTargets(phxTarget, callback) {
      if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {
        return this.liveSocket.owner(phxTarget, (view) => callback(view, phxTarget));
      }
      if (isCid(phxTarget)) {
        let targets = dom_default.findComponentNodeList(this.el, phxTarget);
        if (targets.length === 0) {
          logError(`no component found matching phx-target of ${phxTarget}`);
        } else {
          callback(this, parseInt(phxTarget));
        }
      } else {
        let targets = Array.from(document.querySelectorAll(phxTarget));
        if (targets.length === 0) {
          logError(`nothing found matching the phx-target selector "${phxTarget}"`);
        }
        targets.forEach((target) => this.liveSocket.owner(target, (view) => callback(view, target)));
      }
    }
    applyDiff(type, rawDiff, callback) {
      this.log(type, () => ["", clone(rawDiff)]);
      let { diff, reply, events, title } = Rendered.extract(rawDiff);
      if (title) {
        dom_default.putTitle(title);
      }
      callback({ diff, reply, events });
      return reply;
    }
    onJoin(resp) {
      let { rendered, container } = resp;
      if (container) {
        let [tag, attrs] = container;
        this.el = dom_default.replaceRootContainer(this.el, tag, attrs);
      }
      this.childJoins = 0;
      this.joinPending = true;
      this.flash = null;
      browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);
      this.applyDiff("mount", rendered, ({ diff, events }) => {
        this.rendered = new Rendered(this.id, diff);
        let html = this.renderContainer(null, "join");
        this.dropPendingRefs();
        let forms = this.formsForRecovery(html);
        this.joinCount++;
        if (forms.length > 0) {
          forms.forEach(([form, newForm, newCid], i) => {
            this.pushFormRecovery(form, newCid, (resp2) => {
              if (i === forms.length - 1) {
                this.onJoinComplete(resp2, html, events);
              }
            });
          });
        } else {
          this.onJoinComplete(resp, html, events);
        }
      });
    }
    dropPendingRefs() {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}]`, (el) => {
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
      });
    }
    onJoinComplete({ live_patch }, html, events) {
      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {
        return this.applyJoinPatch(live_patch, html, events);
      }
      let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter((toEl) => {
        let fromEl = toEl.id && this.el.querySelector(`[id="${toEl.id}"]`);
        let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);
        if (phxStatic) {
          toEl.setAttribute(PHX_STATIC, phxStatic);
        }
        return this.joinChild(toEl);
      });
      if (newChildren.length === 0) {
        if (this.parent) {
          this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
          this.applyJoinPatch(live_patch, html, events);
        }
      } else {
        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);
      }
    }
    attachTrueDocEl() {
      this.el = dom_default.byId(this.id);
      this.el.setAttribute(PHX_ROOT_ID, this.root.id);
    }
    applyJoinPatch(live_patch, html, events) {
      this.attachTrueDocEl();
      let patch = new DOMPatch(this, this.el, this.id, html, null);
      patch.markPrunableContentForRemoval();
      this.performPatch(patch, false);
      this.joinNewChildren();
      dom_default.all(this.el, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, (hookEl) => {
        let hook = this.addHook(hookEl);
        if (hook) {
          hook.__mounted();
        }
      });
      this.joinPending = false;
      this.liveSocket.dispatchEvents(events);
      this.applyPendingUpdates();
      if (live_patch) {
        let { kind, to } = live_patch;
        this.liveSocket.historyPatch(to, kind);
      }
      this.hideLoader();
      if (this.joinCount > 1) {
        this.triggerReconnected();
      }
      this.stopCallback();
    }
    triggerBeforeUpdateHook(fromEl, toEl) {
      this.liveSocket.triggerDOM("onBeforeElUpdated", [fromEl, toEl]);
      let hook = this.getHook(fromEl);
      let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));
      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {
        hook.__beforeUpdate();
        return hook;
      }
    }
    performPatch(patch, pruneCids) {
      let removedEls = [];
      let phxChildrenAdded = false;
      let updatedHookIds = /* @__PURE__ */ new Set();
      patch.after("added", (el) => {
        this.liveSocket.triggerDOM("onNodeAdded", [el]);
        let newHook = this.addHook(el);
        if (newHook) {
          newHook.__mounted();
        }
      });
      patch.after("phxChildAdded", (el) => {
        if (dom_default.isPhxSticky(el)) {
          this.liveSocket.joinRootViews();
        } else {
          phxChildrenAdded = true;
        }
      });
      patch.before("updated", (fromEl, toEl) => {
        let hook = this.triggerBeforeUpdateHook(fromEl, toEl);
        if (hook) {
          updatedHookIds.add(fromEl.id);
        }
      });
      patch.after("updated", (el) => {
        if (updatedHookIds.has(el.id)) {
          this.getHook(el).__updated();
        }
      });
      patch.after("discarded", (el) => {
        if (el.nodeType === Node.ELEMENT_NODE) {
          removedEls.push(el);
        }
      });
      patch.after("transitionsDiscarded", (els) => this.afterElementsRemoved(els, pruneCids));
      patch.perform();
      this.afterElementsRemoved(removedEls, pruneCids);
      return phxChildrenAdded;
    }
    afterElementsRemoved(elements, pruneCids) {
      let destroyedCIDs = [];
      elements.forEach((parent) => {
        let components = dom_default.all(parent, `[${PHX_COMPONENT}]`);
        let hooks = dom_default.all(parent, `[${this.binding(PHX_HOOK)}]`);
        components.concat(parent).forEach((el) => {
          let cid = this.componentID(el);
          if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {
            destroyedCIDs.push(cid);
          }
        });
        hooks.concat(parent).forEach((hookEl) => {
          let hook = this.getHook(hookEl);
          hook && this.destroyHook(hook);
        });
      });
      if (pruneCids) {
        this.maybePushComponentsDestroyed(destroyedCIDs);
      }
    }
    joinNewChildren() {
      dom_default.findPhxChildren(this.el, this.id).forEach((el) => this.joinChild(el));
    }
    getChildById(id) {
      return this.root.children[this.id][id];
    }
    getDescendentByEl(el) {
      if (el.id === this.id) {
        return this;
      } else {
        return this.children[el.getAttribute(PHX_PARENT_ID)][el.id];
      }
    }
    destroyDescendent(id) {
      for (let parentId in this.root.children) {
        for (let childId in this.root.children[parentId]) {
          if (childId === id) {
            return this.root.children[parentId][childId].destroy();
          }
        }
      }
    }
    joinChild(el) {
      let child = this.getChildById(el.id);
      if (!child) {
        let view = new View(el, this.liveSocket, this);
        this.root.children[this.id][view.id] = view;
        view.join();
        this.childJoins++;
        return true;
      }
    }
    isJoinPending() {
      return this.joinPending;
    }
    ackJoin(_child) {
      this.childJoins--;
      if (this.childJoins === 0) {
        if (this.parent) {
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
        }
      }
    }
    onAllChildJoinsComplete() {
      this.joinCallback(() => {
        this.pendingJoinOps.forEach(([view, op]) => {
          if (!view.isDestroyed()) {
            op();
          }
        });
        this.pendingJoinOps = [];
      });
    }
    update(diff, events) {
      if (this.isJoinPending() || this.liveSocket.hasPendingLink() && !dom_default.isPhxSticky(this.el)) {
        return this.pendingDiffs.push({ diff, events });
      }
      this.rendered.mergeDiff(diff);
      let phxChildrenAdded = false;
      if (this.rendered.isComponentOnlyDiff(diff)) {
        this.liveSocket.time("component patch complete", () => {
          let parentCids = dom_default.findParentCIDs(this.el, this.rendered.componentCIDs(diff));
          parentCids.forEach((parentCID) => {
            if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {
              phxChildrenAdded = true;
            }
          });
        });
      } else if (!isEmpty(diff)) {
        this.liveSocket.time("full patch complete", () => {
          let html = this.renderContainer(diff, "update");
          let patch = new DOMPatch(this, this.el, this.id, html, null);
          phxChildrenAdded = this.performPatch(patch, true);
        });
      }
      this.liveSocket.dispatchEvents(events);
      if (phxChildrenAdded) {
        this.joinNewChildren();
      }
    }
    renderContainer(diff, kind) {
      return this.liveSocket.time(`toString diff (${kind})`, () => {
        let tag = this.el.tagName;
        let cids = diff ? this.rendered.componentCIDs(diff).concat(this.pruningCIDs) : null;
        let html = this.rendered.toString(cids);
        return `<${tag}>${html}</${tag}>`;
      });
    }
    componentPatch(diff, cid) {
      if (isEmpty(diff))
        return false;
      let html = this.rendered.componentToString(cid);
      let patch = new DOMPatch(this, this.el, this.id, html, cid);
      let childrenAdded = this.performPatch(patch, true);
      return childrenAdded;
    }
    getHook(el) {
      return this.viewHooks[ViewHook.elementID(el)];
    }
    addHook(el) {
      if (ViewHook.elementID(el) || !el.getAttribute) {
        return;
      }
      let hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));
      if (hookName && !this.ownsElement(el)) {
        return;
      }
      let callbacks = this.liveSocket.getHookCallbacks(hookName);
      if (callbacks) {
        if (!el.id) {
          logError(`no DOM ID for hook "${hookName}". Hooks require a unique ID on each element.`, el);
        }
        let hook = new ViewHook(this, el, callbacks);
        this.viewHooks[ViewHook.elementID(hook.el)] = hook;
        return hook;
      } else if (hookName !== null) {
        logError(`unknown hook found for "${hookName}"`, el);
      }
    }
    destroyHook(hook) {
      hook.__destroyed();
      hook.__cleanup__();
      delete this.viewHooks[ViewHook.elementID(hook.el)];
    }
    applyPendingUpdates() {
      this.pendingDiffs.forEach(({ diff, events }) => this.update(diff, events));
      this.pendingDiffs = [];
    }
    onChannel(event, cb) {
      this.liveSocket.onChannel(this.channel, event, (resp) => {
        if (this.isJoinPending()) {
          this.root.pendingJoinOps.push([this, () => cb(resp)]);
        } else {
          this.liveSocket.requestDOMUpdate(() => cb(resp));
        }
      });
    }
    bindChannel() {
      this.liveSocket.onChannel(this.channel, "diff", (rawDiff) => {
        this.liveSocket.requestDOMUpdate(() => {
          this.applyDiff("update", rawDiff, ({ diff, events }) => this.update(diff, events));
        });
      });
      this.onChannel("redirect", ({ to, flash }) => this.onRedirect({ to, flash }));
      this.onChannel("live_patch", (redir) => this.onLivePatch(redir));
      this.onChannel("live_redirect", (redir) => this.onLiveRedirect(redir));
      this.channel.onError((reason) => this.onError(reason));
      this.channel.onClose((reason) => this.onClose(reason));
    }
    destroyAllChildren() {
      for (let id in this.root.children[this.id]) {
        this.getChildById(id).destroy();
      }
    }
    onLiveRedirect(redir) {
      let { to, kind, flash } = redir;
      let url = this.expandURL(to);
      this.liveSocket.historyRedirect(url, kind, flash);
    }
    onLivePatch(redir) {
      let { to, kind } = redir;
      this.href = this.expandURL(to);
      this.liveSocket.historyPatch(to, kind);
    }
    expandURL(to) {
      return to.startsWith("/") ? `${window.location.protocol}//${window.location.host}${to}` : to;
    }
    onRedirect({ to, flash }) {
      this.liveSocket.redirect(to, flash);
    }
    isDestroyed() {
      return this.destroyed;
    }
    join(callback) {
      if (this.isMain()) {
        this.stopCallback = this.liveSocket.withPageLoading({ to: this.href, kind: "initial" });
      }
      this.joinCallback = (onDone) => {
        onDone = onDone || function() {
        };
        callback ? callback(this.joinCount, onDone) : onDone();
      };
      this.liveSocket.wrapPush(this, { timeout: false }, () => {
        return this.channel.join().receive("ok", (data) => {
          if (!this.isDestroyed()) {
            this.liveSocket.requestDOMUpdate(() => this.onJoin(data));
          }
        }).receive("error", (resp) => !this.isDestroyed() && this.onJoinError(resp)).receive("timeout", () => !this.isDestroyed() && this.onJoinError({ reason: "timeout" }));
      });
    }
    onJoinError(resp) {
      if (resp.reason === "unauthorized" || resp.reason === "stale") {
        this.log("error", () => ["unauthorized live_redirect. Falling back to page request", resp]);
        return this.onRedirect({ to: this.href });
      }
      if (resp.redirect || resp.live_redirect) {
        this.joinPending = false;
        this.channel.leave();
      }
      if (resp.redirect) {
        return this.onRedirect(resp.redirect);
      }
      if (resp.live_redirect) {
        return this.onLiveRedirect(resp.live_redirect);
      }
      this.log("error", () => ["unable to join", resp]);
      if (this.liveSocket.isConnected()) {
        this.liveSocket.reloadWithJitter(this);
      }
    }
    onClose(reason) {
      if (this.isDestroyed()) {
        return;
      }
      if (this.liveSocket.hasPendingLink() && reason !== "leave") {
        return this.liveSocket.reloadWithJitter(this);
      }
      this.destroyAllChildren();
      this.liveSocket.dropActiveElement(this);
      if (document.activeElement) {
        document.activeElement.blur();
      }
      if (this.liveSocket.isUnloaded()) {
        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);
      }
    }
    onError(reason) {
      this.onClose(reason);
      if (this.liveSocket.isConnected()) {
        this.log("error", () => ["view crashed", reason]);
      }
      if (!this.liveSocket.isUnloaded()) {
        this.displayError();
      }
    }
    displayError() {
      if (this.isMain()) {
        dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: { to: this.href, kind: "error" } });
      }
      this.showLoader();
      this.setContainerClasses(PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);
    }
    pushWithReply(refGenerator, event, payload, onReply = function() {
    }) {
      if (!this.isConnected()) {
        return;
      }
      let [ref, [el], opts] = refGenerator ? refGenerator() : [null, [], {}];
      let onLoadingDone = function() {
      };
      if (opts.page_loading || el && el.getAttribute(this.binding(PHX_PAGE_LOADING)) !== null) {
        onLoadingDone = this.liveSocket.withPageLoading({ kind: "element", target: el });
      }
      if (typeof payload.cid !== "number") {
        delete payload.cid;
      }
      return this.liveSocket.wrapPush(this, { timeout: true }, () => {
        return this.channel.push(event, payload, PUSH_TIMEOUT).receive("ok", (resp) => {
          if (ref !== null) {
            this.undoRefs(ref);
          }
          let finish = (hookReply) => {
            if (resp.redirect) {
              this.onRedirect(resp.redirect);
            }
            if (resp.live_patch) {
              this.onLivePatch(resp.live_patch);
            }
            if (resp.live_redirect) {
              this.onLiveRedirect(resp.live_redirect);
            }
            onLoadingDone();
            onReply(resp, hookReply);
          };
          if (resp.diff) {
            this.liveSocket.requestDOMUpdate(() => {
              let hookReply = this.applyDiff("update", resp.diff, ({ diff, events }) => {
                this.update(diff, events);
              });
              finish(hookReply);
            });
          } else {
            finish(null);
          }
        });
      });
    }
    undoRefs(ref) {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}="${ref}"]`, (el) => {
        let disabledVal = el.getAttribute(PHX_DISABLED);
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
        if (el.getAttribute(PHX_READONLY) !== null) {
          el.readOnly = false;
          el.removeAttribute(PHX_READONLY);
        }
        if (disabledVal !== null) {
          el.disabled = disabledVal === "true" ? true : false;
          el.removeAttribute(PHX_DISABLED);
        }
        PHX_EVENT_CLASSES.forEach((className) => dom_default.removeClass(el, className));
        let disableRestore = el.getAttribute(PHX_DISABLE_WITH_RESTORE);
        if (disableRestore !== null) {
          el.innerText = disableRestore;
          el.removeAttribute(PHX_DISABLE_WITH_RESTORE);
        }
        let toEl = dom_default.private(el, PHX_REF);
        if (toEl) {
          let hook = this.triggerBeforeUpdateHook(el, toEl);
          DOMPatch.patchEl(el, toEl, this.liveSocket.getActiveElement());
          if (hook) {
            hook.__updated();
          }
          dom_default.deletePrivate(el, PHX_REF);
        }
      });
    }
    putRef(elements, event, opts = {}) {
      let newRef = this.ref++;
      let disableWith = this.binding(PHX_DISABLE_WITH);
      if (opts.loading) {
        elements = elements.concat(dom_default.all(document, opts.loading));
      }
      elements.forEach((el) => {
        el.classList.add(`phx-${event}-loading`);
        el.setAttribute(PHX_REF, newRef);
        el.setAttribute(PHX_REF_SRC, this.el.id);
        let disableText = el.getAttribute(disableWith);
        if (disableText !== null) {
          if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {
            el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);
          }
          if (disableText !== "") {
            el.innerText = disableText;
          }
          el.setAttribute("disabled", "");
        }
      });
      return [newRef, elements, opts];
    }
    componentID(el) {
      let cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);
      return cid ? parseInt(cid) : null;
    }
    targetComponentID(target, targetCtx, opts = {}) {
      if (isCid(targetCtx)) {
        return targetCtx;
      }
      let cidOrSelector = target.getAttribute(this.binding("target"));
      if (isCid(cidOrSelector)) {
        return parseInt(cidOrSelector);
      } else if (targetCtx && (cidOrSelector !== null || opts.target)) {
        return this.closestComponentID(targetCtx);
      } else {
        return null;
      }
    }
    closestComponentID(targetCtx) {
      if (isCid(targetCtx)) {
        return targetCtx;
      } else if (targetCtx) {
        return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), (el) => this.ownsElement(el) && this.componentID(el));
      } else {
        return null;
      }
    }
    pushHookEvent(targetCtx, event, payload, onReply) {
      if (!this.isConnected()) {
        this.log("hook", () => ["unable to push hook event. LiveView not connected", event, payload]);
        return false;
      }
      let [ref, els, opts] = this.putRef([], "hook");
      this.pushWithReply(() => [ref, els, opts], "event", {
        type: "hook",
        event,
        value: payload,
        cid: this.closestComponentID(targetCtx)
      }, (resp, reply) => onReply(reply, ref));
      return ref;
    }
    extractMeta(el, meta, value) {
      let prefix = this.binding("value-");
      for (let i = 0; i < el.attributes.length; i++) {
        if (!meta) {
          meta = {};
        }
        let name = el.attributes[i].name;
        if (name.startsWith(prefix)) {
          meta[name.replace(prefix, "")] = el.getAttribute(name);
        }
      }
      if (el.value !== void 0) {
        if (!meta) {
          meta = {};
        }
        meta.value = el.value;
        if (el.tagName === "INPUT" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {
          delete meta.value;
        }
      }
      if (value) {
        if (!meta) {
          meta = {};
        }
        for (let key in value) {
          meta[key] = value[key];
        }
      }
      return meta;
    }
    pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}) {
      this.pushWithReply(() => this.putRef([el], type, opts), "event", {
        type,
        event: phxEvent,
        value: this.extractMeta(el, meta, opts.value),
        cid: this.targetComponentID(el, targetCtx, opts)
      });
    }
    pushFileProgress(fileEl, entryRef, progress, onReply = function() {
    }) {
      this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {
        view.pushWithReply(null, "progress", {
          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),
          ref: fileEl.getAttribute(PHX_UPLOAD_REF),
          entry_ref: entryRef,
          progress,
          cid: view.targetComponentID(fileEl.form, targetCtx)
        }, onReply);
      });
    }
    pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback) {
      let uploads;
      let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx);
      let refGenerator = () => this.putRef([inputEl, inputEl.form], "change", opts);
      let formData;
      if (inputEl.getAttribute(this.binding("change"))) {
        formData = serializeForm(inputEl.form, { _target: opts._target }, [inputEl.name]);
      } else {
        formData = serializeForm(inputEl.form, { _target: opts._target });
      }
      if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {
        LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));
      }
      uploads = LiveUploader.serializeUploads(inputEl);
      let event = {
        type: "form",
        event: phxEvent,
        value: formData,
        uploads,
        cid
      };
      this.pushWithReply(refGenerator, "event", event, (resp) => {
        dom_default.showError(inputEl, this.liveSocket.binding(PHX_FEEDBACK_FOR));
        if (dom_default.isUploadInput(inputEl) && inputEl.getAttribute("data-phx-auto-upload") !== null) {
          if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {
            let [ref, _els] = refGenerator();
            this.uploadFiles(inputEl.form, targetCtx, ref, cid, (_uploads) => {
              callback && callback(resp);
              this.triggerAwaitingSubmit(inputEl.form);
            });
          }
        } else {
          callback && callback(resp);
        }
      });
    }
    triggerAwaitingSubmit(formEl) {
      let awaitingSubmit = this.getScheduledSubmit(formEl);
      if (awaitingSubmit) {
        let [_el, _ref, _opts, callback] = awaitingSubmit;
        this.cancelSubmit(formEl);
        callback();
      }
    }
    getScheduledSubmit(formEl) {
      return this.formSubmits.find(([el, _ref, _opts, _callback]) => el.isSameNode(formEl));
    }
    scheduleSubmit(formEl, ref, opts, callback) {
      if (this.getScheduledSubmit(formEl)) {
        return true;
      }
      this.formSubmits.push([formEl, ref, opts, callback]);
    }
    cancelSubmit(formEl) {
      this.formSubmits = this.formSubmits.filter(([el, ref, _callback]) => {
        if (el.isSameNode(formEl)) {
          this.undoRefs(ref);
          return false;
        } else {
          return true;
        }
      });
    }
    pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply) {
      let filterIgnored = (el) => {
        let userIgnored = closestPhxBinding(el, `${this.binding(PHX_UPDATE)}=ignore`, el.form);
        return !(userIgnored || closestPhxBinding(el, "data-phx-update=ignore", el.form));
      };
      let filterDisables = (el) => {
        return el.hasAttribute(this.binding(PHX_DISABLE_WITH));
      };
      let filterButton = (el) => el.tagName == "BUTTON";
      let filterInput = (el) => ["INPUT", "TEXTAREA", "SELECT"].includes(el.tagName);
      let refGenerator = () => {
        let formElements = Array.from(formEl.elements);
        let disables = formElements.filter(filterDisables);
        let buttons = formElements.filter(filterButton).filter(filterIgnored);
        let inputs = formElements.filter(filterInput).filter(filterIgnored);
        buttons.forEach((button) => {
          button.setAttribute(PHX_DISABLED, button.disabled);
          button.disabled = true;
        });
        inputs.forEach((input) => {
          input.setAttribute(PHX_READONLY, input.readOnly);
          input.readOnly = true;
          if (input.files) {
            input.setAttribute(PHX_DISABLED, input.disabled);
            input.disabled = true;
          }
        });
        formEl.setAttribute(this.binding(PHX_PAGE_LOADING), "");
        return this.putRef([formEl].concat(disables).concat(buttons).concat(inputs), "submit", opts);
      };
      let cid = this.targetComponentID(formEl, targetCtx);
      if (LiveUploader.hasUploadsInProgress(formEl)) {
        let [ref, _els] = refGenerator();
        let push = () => this.pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply);
        return this.scheduleSubmit(formEl, ref, opts, push);
      } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
        let [ref, els] = refGenerator();
        let proxyRefGen = () => [ref, els, opts];
        this.uploadFiles(formEl, targetCtx, ref, cid, (_uploads) => {
          let formData = serializeForm(formEl, {});
          this.pushWithReply(proxyRefGen, "event", {
            type: "form",
            event: phxEvent,
            value: formData,
            cid
          }, onReply);
        });
      } else {
        let formData = serializeForm(formEl, {});
        this.pushWithReply(refGenerator, "event", {
          type: "form",
          event: phxEvent,
          value: formData,
          cid
        }, onReply);
      }
    }
    uploadFiles(formEl, targetCtx, ref, cid, onComplete) {
      let joinCountAtUpload = this.joinCount;
      let inputEls = LiveUploader.activeFileInputs(formEl);
      let numFileInputsInProgress = inputEls.length;
      inputEls.forEach((inputEl) => {
        let uploader = new LiveUploader(inputEl, this, () => {
          numFileInputsInProgress--;
          if (numFileInputsInProgress === 0) {
            onComplete();
          }
        });
        this.uploaders[inputEl] = uploader;
        let entries = uploader.entries().map((entry) => entry.toPreflightPayload());
        let payload = {
          ref: inputEl.getAttribute(PHX_UPLOAD_REF),
          entries,
          cid: this.targetComponentID(inputEl.form, targetCtx)
        };
        this.log("upload", () => ["sending preflight request", payload]);
        this.pushWithReply(null, "allow_upload", payload, (resp) => {
          this.log("upload", () => ["got preflight response", resp]);
          if (resp.error) {
            this.undoRefs(ref);
            let [entry_ref, reason] = resp.error;
            this.log("upload", () => [`error for entry ${entry_ref}`, reason]);
          } else {
            let onError = (callback) => {
              this.channel.onError(() => {
                if (this.joinCount === joinCountAtUpload) {
                  callback();
                }
              });
            };
            uploader.initAdapterUpload(resp, onError, this.liveSocket);
          }
        });
      });
    }
    dispatchUploads(name, filesOrBlobs) {
      let inputs = dom_default.findUploadInputs(this.el).filter((el) => el.name === name);
      if (inputs.length === 0) {
        logError(`no live file inputs found matching the name "${name}"`);
      } else if (inputs.length > 1) {
        logError(`duplicate live file inputs found matching the name "${name}"`);
      } else {
        dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, { detail: { files: filesOrBlobs } });
      }
    }
    pushFormRecovery(form, newCid, callback) {
      this.liveSocket.withinOwners(form, (view, targetCtx) => {
        let input = form.elements[0];
        let phxEvent = form.getAttribute(this.binding(PHX_AUTO_RECOVER)) || form.getAttribute(this.binding("change"));
        js_default.exec("change", phxEvent, view, input, ["push", { _target: input.name, newCid, callback }]);
      });
    }
    pushLinkPatch(href, targetEl, callback) {
      let linkRef = this.liveSocket.setPendingLink(href);
      let refGen = targetEl ? () => this.putRef([targetEl], "click") : null;
      let fallback = () => this.liveSocket.redirect(window.location.href);
      let push = this.pushWithReply(refGen, "live_patch", { url: href }, (resp) => {
        this.liveSocket.requestDOMUpdate(() => {
          if (resp.link_redirect) {
            this.liveSocket.replaceMain(href, null, callback, linkRef);
          } else {
            if (this.liveSocket.commitPendingLink(linkRef)) {
              this.href = href;
            }
            this.applyPendingUpdates();
            callback && callback(linkRef);
          }
        });
      });
      if (push) {
        push.receive("timeout", fallback);
      } else {
        fallback();
      }
    }
    formsForRecovery(html) {
      if (this.joinCount === 0) {
        return [];
      }
      let phxChange = this.binding("change");
      let template = document.createElement("template");
      template.innerHTML = html;
      return dom_default.all(this.el, `form[${phxChange}]`).filter((form) => form.id && this.ownsElement(form)).filter((form) => form.elements.length > 0).filter((form) => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== "ignore").map((form) => {
        let newForm = template.content.querySelector(`form[id="${form.id}"][${phxChange}="${form.getAttribute(phxChange)}"]`);
        if (newForm) {
          return [form, newForm, this.targetComponentID(newForm)];
        } else {
          return [form, null, null];
        }
      }).filter(([form, newForm, newCid]) => newForm);
    }
    maybePushComponentsDestroyed(destroyedCIDs) {
      let willDestroyCIDs = destroyedCIDs.filter((cid) => {
        return dom_default.findComponentNodeList(this.el, cid).length === 0;
      });
      if (willDestroyCIDs.length > 0) {
        this.pruningCIDs.push(...willDestroyCIDs);
        this.pushWithReply(null, "cids_will_destroy", { cids: willDestroyCIDs }, () => {
          this.pruningCIDs = this.pruningCIDs.filter((cid) => willDestroyCIDs.indexOf(cid) !== -1);
          let completelyDestroyCIDs = willDestroyCIDs.filter((cid) => {
            return dom_default.findComponentNodeList(this.el, cid).length === 0;
          });
          if (completelyDestroyCIDs.length > 0) {
            this.pushWithReply(null, "cids_destroyed", { cids: completelyDestroyCIDs }, (resp) => {
              this.rendered.pruneCIDs(resp.cids);
            });
          }
        });
      }
    }
    ownsElement(el) {
      return el.getAttribute(PHX_PARENT_ID) === this.id || maybe(el.closest(PHX_VIEW_SELECTOR), (node) => node.id) === this.id;
    }
    submitForm(form, targetCtx, phxEvent, opts = {}) {
      dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);
      let phxFeedback = this.liveSocket.binding(PHX_FEEDBACK_FOR);
      let inputs = Array.from(form.elements);
      this.liveSocket.blurActiveElement(this);
      this.pushFormSubmit(form, targetCtx, phxEvent, opts, () => {
        inputs.forEach((input) => dom_default.showError(input, phxFeedback));
        this.liveSocket.restorePreviouslyActiveFocus();
      });
    }
    binding(kind) {
      return this.liveSocket.binding(kind);
    }
  };
  var LiveSocket = class {
    constructor(url, phxSocket, opts = {}) {
      this.unloaded = false;
      if (!phxSocket || phxSocket.constructor.name === "Object") {
        throw new Error(`
      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:

          import {Socket} from "phoenix"
          import {LiveSocket} from "phoenix_live_view"
          let liveSocket = new LiveSocket("/live", Socket, {...})
      `);
      }
      this.socket = new phxSocket(url, opts);
      this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;
      this.opts = opts;
      this.params = closure2(opts.params || {});
      this.viewLogger = opts.viewLogger;
      this.metadataCallbacks = opts.metadata || {};
      this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});
      this.activeElement = null;
      this.prevActive = null;
      this.silenced = false;
      this.main = null;
      this.outgoingMainEl = null;
      this.clickStartedAtTarget = null;
      this.linkRef = 1;
      this.roots = {};
      this.href = window.location.href;
      this.pendingLink = null;
      this.currentLocation = clone(window.location);
      this.hooks = opts.hooks || {};
      this.uploaders = opts.uploaders || {};
      this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;
      this.reloadWithJitterTimer = null;
      this.maxReloads = opts.maxReloads || MAX_RELOADS;
      this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;
      this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;
      this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;
      this.localStorage = opts.localStorage || window.localStorage;
      this.sessionStorage = opts.sessionStorage || window.sessionStorage;
      this.boundTopLevelEvents = false;
      this.domCallbacks = Object.assign({ onNodeAdded: closure2(), onBeforeElUpdated: closure2() }, opts.dom || {});
      this.transitions = new TransitionSet();
      window.addEventListener("pagehide", (_e) => {
        this.unloaded = true;
      });
      this.socket.onOpen(() => {
        if (this.isUnloaded()) {
          window.location.reload();
        }
      });
    }
    isProfileEnabled() {
      return this.sessionStorage.getItem(PHX_LV_PROFILE) === "true";
    }
    isDebugEnabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "true";
    }
    isDebugDisabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "false";
    }
    enableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "true");
    }
    enableProfiling() {
      this.sessionStorage.setItem(PHX_LV_PROFILE, "true");
    }
    disableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "false");
    }
    disableProfiling() {
      this.sessionStorage.removeItem(PHX_LV_PROFILE);
    }
    enableLatencySim(upperBoundMs) {
      this.enableDebug();
      console.log("latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable");
      this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);
    }
    disableLatencySim() {
      this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);
    }
    getLatencySim() {
      let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);
      return str ? parseInt(str) : null;
    }
    getSocket() {
      return this.socket;
    }
    connect() {
      if (window.location.hostname === "localhost" && !this.isDebugDisabled()) {
        this.enableDebug();
      }
      let doConnect = () => {
        if (this.joinRootViews()) {
          this.bindTopLevelEvents();
          this.socket.connect();
        } else if (this.main) {
          this.socket.connect();
        }
      };
      if (["complete", "loaded", "interactive"].indexOf(document.readyState) >= 0) {
        doConnect();
      } else {
        document.addEventListener("DOMContentLoaded", () => doConnect());
      }
    }
    disconnect(callback) {
      clearTimeout(this.reloadWithJitterTimer);
      this.socket.disconnect(callback);
    }
    replaceTransport(transport) {
      clearTimeout(this.reloadWithJitterTimer);
      this.socket.replaceTransport(transport);
      this.connect();
    }
    execJS(el, encodedJS, eventType = null) {
      this.owner(el, (view) => js_default.exec(eventType, encodedJS, view, el));
    }
    triggerDOM(kind, args) {
      this.domCallbacks[kind](...args);
    }
    time(name, func) {
      if (!this.isProfileEnabled() || !console.time) {
        return func();
      }
      console.time(name);
      let result = func();
      console.timeEnd(name);
      return result;
    }
    log(view, kind, msgCallback) {
      if (this.viewLogger) {
        let [msg, obj] = msgCallback();
        this.viewLogger(view, kind, msg, obj);
      } else if (this.isDebugEnabled()) {
        let [msg, obj] = msgCallback();
        debug(view, kind, msg, obj);
      }
    }
    requestDOMUpdate(callback) {
      this.transitions.after(callback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.transitions.addTransition(time, onStart, onDone);
    }
    onChannel(channel, event, cb) {
      channel.on(event, (data) => {
        let latency = this.getLatencySim();
        if (!latency) {
          cb(data);
        } else {
          console.log(`simulating ${latency}ms of latency from server to client`);
          setTimeout(() => cb(data), latency);
        }
      });
    }
    wrapPush(view, opts, push) {
      let latency = this.getLatencySim();
      let oldJoinCount = view.joinCount;
      if (!latency) {
        if (this.isConnected() && opts.timeout) {
          return push().receive("timeout", () => {
            if (view.joinCount === oldJoinCount && !view.isDestroyed()) {
              this.reloadWithJitter(view, () => {
                this.log(view, "timeout", () => ["received timeout while communicating with server. Falling back to hard refresh for recovery"]);
              });
            }
          });
        } else {
          return push();
        }
      }
      console.log(`simulating ${latency}ms of latency from client to server`);
      let fakePush = {
        receives: [],
        receive(kind, cb) {
          this.receives.push([kind, cb]);
        }
      };
      setTimeout(() => {
        if (view.isDestroyed()) {
          return;
        }
        fakePush.receives.reduce((acc, [kind, cb]) => acc.receive(kind, cb), push());
      }, latency);
      return fakePush;
    }
    reloadWithJitter(view, log) {
      clearTimeout(this.reloadWithJitterTimer);
      this.disconnect();
      let minMs = this.reloadJitterMin;
      let maxMs = this.reloadJitterMax;
      let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
      let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, (count) => count + 1);
      if (tries > this.maxReloads) {
        afterMs = this.failsafeJitter;
      }
      this.reloadWithJitterTimer = setTimeout(() => {
        if (view.isDestroyed() || view.isConnected()) {
          return;
        }
        view.destroy();
        log ? log() : this.log(view, "join", () => [`encountered ${tries} consecutive reloads`]);
        if (tries > this.maxReloads) {
          this.log(view, "join", () => [`exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`]);
        }
        if (this.hasPendingLink()) {
          window.location = this.pendingLink;
        } else {
          window.location.reload();
        }
      }, afterMs);
    }
    getHookCallbacks(name) {
      return name && name.startsWith("Phoenix.") ? hooks_default[name.split(".")[1]] : this.hooks[name];
    }
    isUnloaded() {
      return this.unloaded;
    }
    isConnected() {
      return this.socket.isConnected();
    }
    getBindingPrefix() {
      return this.bindingPrefix;
    }
    binding(kind) {
      return `${this.getBindingPrefix()}${kind}`;
    }
    channel(topic, params) {
      return this.socket.channel(topic, params);
    }
    joinRootViews() {
      let rootsFound = false;
      dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, (rootEl) => {
        if (!this.getRootById(rootEl.id)) {
          let view = this.newRootView(rootEl);
          view.setHref(this.getHref());
          view.join();
          if (rootEl.getAttribute(PHX_MAIN)) {
            this.main = view;
          }
        }
        rootsFound = true;
      });
      return rootsFound;
    }
    redirect(to, flash) {
      this.disconnect();
      browser_default.redirect(to, flash);
    }
    replaceMain(href, flash, callback = null, linkRef = this.setPendingLink(href)) {
      this.outgoingMainEl = this.outgoingMainEl || this.main.el;
      let newMainEl = dom_default.cloneNode(this.outgoingMainEl, "");
      this.main.showLoader(this.loaderTimeout);
      this.main.destroy();
      this.main = this.newRootView(newMainEl, flash);
      this.main.setRedirect(href);
      this.transitionRemoves();
      this.main.join((joinCount, onDone) => {
        if (joinCount === 1 && this.commitPendingLink(linkRef)) {
          this.requestDOMUpdate(() => {
            dom_default.findPhxSticky(document).forEach((el) => newMainEl.appendChild(el));
            this.outgoingMainEl.replaceWith(newMainEl);
            this.outgoingMainEl = null;
            callback && requestAnimationFrame(callback);
            onDone();
          });
        }
      });
    }
    transitionRemoves(elements) {
      let removeAttr = this.binding("remove");
      elements = elements || dom_default.all(document, `[${removeAttr}]`);
      elements.forEach((el) => {
        if (document.body.contains(el)) {
          this.execJS(el, el.getAttribute(removeAttr), "remove");
        }
      });
    }
    isPhxView(el) {
      return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;
    }
    newRootView(el, flash) {
      let view = new View(el, this, null, flash);
      this.roots[view.id] = view;
      return view;
    }
    owner(childEl, callback) {
      let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), (el) => this.getViewByEl(el)) || this.main;
      if (view) {
        callback(view);
      }
    }
    withinOwners(childEl, callback) {
      this.owner(childEl, (view) => callback(view, childEl));
    }
    getViewByEl(el) {
      let rootId = el.getAttribute(PHX_ROOT_ID);
      return maybe(this.getRootById(rootId), (root) => root.getDescendentByEl(el));
    }
    getRootById(id) {
      return this.roots[id];
    }
    destroyAllViews() {
      for (let id in this.roots) {
        this.roots[id].destroy();
        delete this.roots[id];
      }
      this.main = null;
    }
    destroyViewByEl(el) {
      let root = this.getRootById(el.getAttribute(PHX_ROOT_ID));
      if (root && root.id === el.id) {
        root.destroy();
        delete this.roots[root.id];
      } else if (root) {
        root.destroyDescendent(el.id);
      }
    }
    setActiveElement(target) {
      if (this.activeElement === target) {
        return;
      }
      this.activeElement = target;
      let cancel = () => {
        if (target === this.activeElement) {
          this.activeElement = null;
        }
        target.removeEventListener("mouseup", this);
        target.removeEventListener("touchend", this);
      };
      target.addEventListener("mouseup", cancel);
      target.addEventListener("touchend", cancel);
    }
    getActiveElement() {
      if (document.activeElement === document.body) {
        return this.activeElement || document.activeElement;
      } else {
        return document.activeElement || document.body;
      }
    }
    dropActiveElement(view) {
      if (this.prevActive && view.ownsElement(this.prevActive)) {
        this.prevActive = null;
      }
    }
    restorePreviouslyActiveFocus() {
      if (this.prevActive && this.prevActive !== document.body) {
        this.prevActive.focus();
      }
    }
    blurActiveElement() {
      this.prevActive = this.getActiveElement();
      if (this.prevActive !== document.body) {
        this.prevActive.blur();
      }
    }
    bindTopLevelEvents() {
      if (this.boundTopLevelEvents) {
        return;
      }
      this.boundTopLevelEvents = true;
      this.socket.onClose((event) => {
        if (event && event.code === 1e3 && this.main) {
          this.reloadWithJitter(this.main);
        }
      });
      document.body.addEventListener("click", function() {
      });
      window.addEventListener("pageshow", (e) => {
        if (e.persisted) {
          this.getSocket().disconnect();
          this.withPageLoading({ to: window.location.href, kind: "redirect" });
          window.location.reload();
        }
      }, true);
      this.bindNav();
      this.bindClicks();
      this.bindForms();
      this.bind({ keyup: "keyup", keydown: "keydown" }, (e, type, view, targetEl, phxEvent, eventTarget) => {
        let matchKey = targetEl.getAttribute(this.binding(PHX_KEY));
        let pressedKey = e.key && e.key.toLowerCase();
        if (matchKey && matchKey.toLowerCase() !== pressedKey) {
          return;
        }
        let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
        js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
      });
      this.bind({ blur: "focusout", focus: "focusin" }, (e, type, view, targetEl, phxEvent, eventTarget) => {
        if (!eventTarget) {
          let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      this.bind({ blur: "blur", focus: "focus" }, (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) => {
        if (phxTarget === "window") {
          let data = this.eventMeta(type, e, targetEl);
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      window.addEventListener("dragover", (e) => e.preventDefault());
      window.addEventListener("drop", (e) => {
        e.preventDefault();
        let dropTargetId = maybe(closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)), (trueTarget) => {
          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));
        });
        let dropTarget = dropTargetId && document.getElementById(dropTargetId);
        let files = Array.from(e.dataTransfer.files || []);
        if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {
          return;
        }
        LiveUploader.trackFiles(dropTarget, files);
        dropTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
      this.on(PHX_TRACK_UPLOADS, (e) => {
        let uploadTarget = e.target;
        if (!dom_default.isUploadInput(uploadTarget)) {
          return;
        }
        let files = Array.from(e.detail.files || []).filter((f) => f instanceof File || f instanceof Blob);
        LiveUploader.trackFiles(uploadTarget, files);
        uploadTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
    }
    eventMeta(eventName, e, targetEl) {
      let callback = this.metadataCallbacks[eventName];
      return callback ? callback(e, targetEl) : {};
    }
    setPendingLink(href) {
      this.linkRef++;
      this.pendingLink = href;
      return this.linkRef;
    }
    commitPendingLink(linkRef) {
      if (this.linkRef !== linkRef) {
        return false;
      } else {
        this.href = this.pendingLink;
        this.pendingLink = null;
        return true;
      }
    }
    getHref() {
      return this.href;
    }
    hasPendingLink() {
      return !!this.pendingLink;
    }
    bind(events, callback) {
      for (let event in events) {
        let browserEventName = events[event];
        this.on(browserEventName, (e) => {
          let binding = this.binding(event);
          let windowBinding = this.binding(`window-${event}`);
          let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);
          if (targetPhxEvent) {
            this.debounce(e.target, e, browserEventName, () => {
              this.withinOwners(e.target, (view) => {
                callback(e, event, view, e.target, targetPhxEvent, null);
              });
            });
          } else {
            dom_default.all(document, `[${windowBinding}]`, (el) => {
              let phxEvent = el.getAttribute(windowBinding);
              this.debounce(el, e, browserEventName, () => {
                this.withinOwners(el, (view) => {
                  callback(e, event, view, el, phxEvent, "window");
                });
              });
            });
          }
        });
      }
    }
    bindClicks() {
      window.addEventListener("mousedown", (e) => this.clickStartedAtTarget = e.target);
      this.bindClick("click", "click", false);
      this.bindClick("mousedown", "capture-click", true);
    }
    bindClick(eventName, bindingName, capture) {
      let click = this.binding(bindingName);
      window.addEventListener(eventName, (e) => {
        let target = null;
        if (capture) {
          target = e.target.matches(`[${click}]`) ? e.target : e.target.querySelector(`[${click}]`);
        } else {
          let clickStartedAtTarget = this.clickStartedAtTarget || e.target;
          target = closestPhxBinding(clickStartedAtTarget, click);
          this.dispatchClickAway(e, clickStartedAtTarget);
          this.clickStartedAtTarget = null;
        }
        let phxEvent = target && target.getAttribute(click);
        if (!phxEvent) {
          return;
        }
        if (target.getAttribute("href") === "#") {
          e.preventDefault();
        }
        this.debounce(target, e, "click", () => {
          this.withinOwners(target, (view) => {
            js_default.exec("click", phxEvent, view, target, ["push", { data: this.eventMeta("click", e, target) }]);
          });
        });
      }, capture);
    }
    dispatchClickAway(e, clickStartedAt) {
      let phxClickAway = this.binding("click-away");
      dom_default.all(document, `[${phxClickAway}]`, (el) => {
        if (!(el.isSameNode(clickStartedAt) || el.contains(clickStartedAt))) {
          this.withinOwners(e.target, (view) => {
            let phxEvent = el.getAttribute(phxClickAway);
            if (js_default.isVisible(el)) {
              js_default.exec("click", phxEvent, view, el, ["push", { data: this.eventMeta("click", e, e.target) }]);
            }
          });
        }
      });
    }
    bindNav() {
      if (!browser_default.canPushState()) {
        return;
      }
      if (history.scrollRestoration) {
        history.scrollRestoration = "manual";
      }
      let scrollTimer = null;
      window.addEventListener("scroll", (_e) => {
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => {
          browser_default.updateCurrentState((state) => Object.assign(state, { scroll: window.scrollY }));
        }, 100);
      });
      window.addEventListener("popstate", (event) => {
        if (!this.registerNewLocation(window.location)) {
          return;
        }
        let { type, id, root, scroll: scroll2 } = event.state || {};
        let href = window.location.href;
        this.requestDOMUpdate(() => {
          if (this.main.isConnected() && (type === "patch" && id === this.main.id)) {
            this.main.pushLinkPatch(href, null);
          } else {
            this.replaceMain(href, null, () => {
              if (root) {
                this.replaceRootHistory();
              }
              if (typeof scroll2 === "number") {
                setTimeout(() => {
                  window.scrollTo(0, scroll2);
                }, 0);
              }
            });
          }
        });
      }, false);
      window.addEventListener("click", (e) => {
        let target = closestPhxBinding(e.target, PHX_LIVE_LINK);
        let type = target && target.getAttribute(PHX_LIVE_LINK);
        let wantsNewTab = e.metaKey || e.ctrlKey || e.button === 1;
        if (!type || !this.isConnected() || !this.main || wantsNewTab) {
          return;
        }
        let href = target.href;
        let linkState = target.getAttribute(PHX_LINK_STATE);
        e.preventDefault();
        e.stopImmediatePropagation();
        if (this.pendingLink === href) {
          return;
        }
        this.requestDOMUpdate(() => {
          if (type === "patch") {
            this.pushHistoryPatch(href, linkState, target);
          } else if (type === "redirect") {
            this.historyRedirect(href, linkState);
          } else {
            throw new Error(`expected ${PHX_LIVE_LINK} to be "patch" or "redirect", got: ${type}`);
          }
        });
      }, false);
    }
    dispatchEvent(event, payload = {}) {
      dom_default.dispatchEvent(window, `phx:${event}`, { detail: payload });
    }
    dispatchEvents(events) {
      events.forEach(([event, payload]) => this.dispatchEvent(event, payload));
    }
    withPageLoading(info, callback) {
      dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: info });
      let done = () => dom_default.dispatchEvent(window, "phx:page-loading-stop", { detail: info });
      return callback ? callback(done) : done;
    }
    pushHistoryPatch(href, linkState, targetEl) {
      this.withPageLoading({ to: href, kind: "patch" }, (done) => {
        this.main.pushLinkPatch(href, targetEl, (linkRef) => {
          this.historyPatch(href, linkState, linkRef);
          done();
        });
      });
    }
    historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {
      if (!this.commitPendingLink(linkRef)) {
        return;
      }
      browser_default.pushState(linkState, { type: "patch", id: this.main.id }, href);
      this.registerNewLocation(window.location);
    }
    historyRedirect(href, linkState, flash) {
      let scroll2 = window.scrollY;
      this.withPageLoading({ to: href, kind: "redirect" }, (done) => {
        this.replaceMain(href, flash, () => {
          browser_default.pushState(linkState, { type: "redirect", id: this.main.id, scroll: scroll2 }, href);
          this.registerNewLocation(window.location);
          done();
        });
      });
    }
    replaceRootHistory() {
      browser_default.pushState("replace", { root: true, type: "patch", id: this.main.id });
    }
    registerNewLocation(newLocation) {
      let { pathname, search } = this.currentLocation;
      if (pathname + search === newLocation.pathname + newLocation.search) {
        return false;
      } else {
        this.currentLocation = clone(newLocation);
        return true;
      }
    }
    bindForms() {
      let iterations = 0;
      this.on("submit", (e) => {
        let phxEvent = e.target.getAttribute(this.binding("submit"));
        if (!phxEvent) {
          return;
        }
        e.preventDefault();
        e.target.disabled = true;
        this.withinOwners(e.target, (view) => {
          js_default.exec("submit", phxEvent, view, e.target, ["push", {}]);
        });
      }, false);
      for (let type of ["change", "input"]) {
        this.on(type, (e) => {
          let phxChange = this.binding("change");
          let input = e.target;
          let inputEvent = input.getAttribute(phxChange);
          let formEvent = input.form && input.form.getAttribute(phxChange);
          let phxEvent = inputEvent || formEvent;
          if (!phxEvent) {
            return;
          }
          if (input.type === "number" && input.validity && input.validity.badInput) {
            return;
          }
          let dispatcher = inputEvent ? input : input.form;
          let currentIterations = iterations;
          iterations++;
          let { at, type: lastType } = dom_default.private(input, "prev-iteration") || {};
          if (at === currentIterations - 1 && type !== lastType) {
            return;
          }
          dom_default.putPrivate(input, "prev-iteration", { at: currentIterations, type });
          this.debounce(input, e, type, () => {
            this.withinOwners(dispatcher, (view) => {
              dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);
              if (!dom_default.isTextualInput(input)) {
                this.setActiveElement(input);
              }
              js_default.exec("change", phxEvent, view, input, ["push", { _target: e.target.name, dispatcher }]);
            });
          });
        }, false);
      }
    }
    debounce(el, event, eventType, callback) {
      if (eventType === "blur" || eventType === "focusout") {
        return callback();
      }
      let phxDebounce = this.binding(PHX_DEBOUNCE);
      let phxThrottle = this.binding(PHX_THROTTLE);
      let defaultDebounce = this.defaults.debounce.toString();
      let defaultThrottle = this.defaults.throttle.toString();
      this.withinOwners(el, (view) => {
        let asyncFilter = () => !view.isDestroyed() && document.body.contains(el);
        dom_default.debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, () => {
          callback();
        });
      });
    }
    silenceEvents(callback) {
      this.silenced = true;
      callback();
      this.silenced = false;
    }
    on(event, callback) {
      window.addEventListener(event, (e) => {
        if (!this.silenced) {
          callback(e);
        }
      });
    }
  };
  var TransitionSet = class {
    constructor() {
      this.transitions = /* @__PURE__ */ new Set();
      this.pendingOps = [];
      this.reset();
    }
    reset() {
      this.transitions.forEach((timer) => {
        cancelTimeout(timer);
        this.transitions.delete(timer);
      });
      this.flushPendingOps();
    }
    after(callback) {
      if (this.size() === 0) {
        callback();
      } else {
        this.pushPendingOp(callback);
      }
    }
    addTransition(time, onStart, onDone) {
      onStart();
      let timer = setTimeout(() => {
        this.transitions.delete(timer);
        onDone();
        if (this.size() === 0) {
          this.flushPendingOps();
        }
      }, time);
      this.transitions.add(timer);
    }
    pushPendingOp(op) {
      this.pendingOps.push(op);
    }
    size() {
      return this.transitions.size;
    }
    flushPendingOps() {
      this.pendingOps.forEach((op) => op());
      this.pendingOps = [];
    }
  };

  // js/app.js
  var import_topbar = __toESM(require_topbar());

  // node_modules/uplot/dist/uPlot.esm.js
  var FEAT_TIME = true;
  var pre = "u-";
  var UPLOT = "uplot";
  var ORI_HZ = pre + "hz";
  var ORI_VT = pre + "vt";
  var TITLE2 = pre + "title";
  var WRAP = pre + "wrap";
  var UNDER = pre + "under";
  var OVER = pre + "over";
  var AXIS = pre + "axis";
  var OFF = pre + "off";
  var SELECT = pre + "select";
  var CURSOR_X = pre + "cursor-x";
  var CURSOR_Y = pre + "cursor-y";
  var CURSOR_PT = pre + "cursor-pt";
  var LEGEND = pre + "legend";
  var LEGEND_LIVE = pre + "live";
  var LEGEND_INLINE = pre + "inline";
  var LEGEND_THEAD = pre + "thead";
  var LEGEND_SERIES = pre + "series";
  var LEGEND_MARKER = pre + "marker";
  var LEGEND_LABEL = pre + "label";
  var LEGEND_VALUE = pre + "value";
  var WIDTH = "width";
  var HEIGHT = "height";
  var TOP = "top";
  var BOTTOM = "bottom";
  var LEFT = "left";
  var RIGHT = "right";
  var hexBlack = "#000";
  var transparent = hexBlack + "0";
  var mousemove = "mousemove";
  var mousedown = "mousedown";
  var mouseup = "mouseup";
  var mouseenter = "mouseenter";
  var mouseleave = "mouseleave";
  var dblclick = "dblclick";
  var resize = "resize";
  var scroll = "scroll";
  var change = "change";
  var dppxchange = "dppxchange";
  var domEnv = typeof window != "undefined";
  var doc2 = domEnv ? document : null;
  var win = domEnv ? window : null;
  var nav = domEnv ? navigator : null;
  var pxRatio;
  var query;
  function setPxRatio() {
    let _pxRatio = devicePixelRatio;
    if (pxRatio != _pxRatio) {
      pxRatio = _pxRatio;
      query && off(change, query, setPxRatio);
      query = matchMedia(`(min-resolution: ${pxRatio - 1e-3}dppx) and (max-resolution: ${pxRatio + 1e-3}dppx)`);
      on(change, query, setPxRatio);
      win.dispatchEvent(new CustomEvent(dppxchange));
    }
  }
  function addClass(el, c) {
    if (c != null) {
      let cl = el.classList;
      !cl.contains(c) && cl.add(c);
    }
  }
  function remClass(el, c) {
    let cl = el.classList;
    cl.contains(c) && cl.remove(c);
  }
  function setStylePx(el, name, value) {
    el.style[name] = value + "px";
  }
  function placeTag(tag, cls, targ, refEl) {
    let el = doc2.createElement(tag);
    if (cls != null)
      addClass(el, cls);
    if (targ != null)
      targ.insertBefore(el, refEl);
    return el;
  }
  function placeDiv(cls, targ) {
    return placeTag("div", cls, targ);
  }
  var xformCache = /* @__PURE__ */ new WeakMap();
  function elTrans(el, xPos, yPos, xMax, yMax) {
    let xform = "translate(" + xPos + "px," + yPos + "px)";
    let xformOld = xformCache.get(el);
    if (xform != xformOld) {
      el.style.transform = xform;
      xformCache.set(el, xform);
      if (xPos < 0 || yPos < 0 || xPos > xMax || yPos > yMax)
        addClass(el, OFF);
      else
        remClass(el, OFF);
    }
  }
  var colorCache = /* @__PURE__ */ new WeakMap();
  function elColor(el, background, borderColor) {
    let newColor = background + borderColor;
    let oldColor = colorCache.get(el);
    if (newColor != oldColor) {
      colorCache.set(el, newColor);
      el.style.background = background;
      el.style.borderColor = borderColor;
    }
  }
  var sizeCache = /* @__PURE__ */ new WeakMap();
  function elSize(el, newWid, newHgt, centered) {
    let newSize = newWid + "" + newHgt;
    let oldSize = sizeCache.get(el);
    if (newSize != oldSize) {
      sizeCache.set(el, newSize);
      el.style.height = newHgt + "px";
      el.style.width = newWid + "px";
      el.style.marginLeft = centered ? -newWid / 2 + "px" : 0;
      el.style.marginTop = centered ? -newHgt / 2 + "px" : 0;
    }
  }
  var evOpts = { passive: true };
  var evOpts2 = __spreadProps(__spreadValues({}, evOpts), { capture: true });
  function on(ev, el, cb, capt) {
    el.addEventListener(ev, cb, capt ? evOpts2 : evOpts);
  }
  function off(ev, el, cb, capt) {
    el.removeEventListener(ev, cb, capt ? evOpts2 : evOpts);
  }
  domEnv && setPxRatio();
  function closestIdx(num, arr, lo, hi) {
    let mid;
    lo = lo || 0;
    hi = hi || arr.length - 1;
    let bitwise = hi <= 2147483647;
    while (hi - lo > 1) {
      mid = bitwise ? lo + hi >> 1 : floor((lo + hi) / 2);
      if (arr[mid] < num)
        lo = mid;
      else
        hi = mid;
    }
    if (num - arr[lo] <= arr[hi] - num)
      return lo;
    return hi;
  }
  function nonNullIdx(data, _i0, _i1, dir) {
    for (let i = dir == 1 ? _i0 : _i1; i >= _i0 && i <= _i1; i += dir) {
      if (data[i] != null)
        return i;
    }
    return -1;
  }
  function getMinMax(data, _i0, _i1, sorted) {
    let _min = inf;
    let _max = -inf;
    if (sorted == 1) {
      _min = data[_i0];
      _max = data[_i1];
    } else if (sorted == -1) {
      _min = data[_i1];
      _max = data[_i0];
    } else {
      for (let i = _i0; i <= _i1; i++) {
        if (data[i] != null) {
          _min = min(_min, data[i]);
          _max = max(_max, data[i]);
        }
      }
    }
    return [_min, _max];
  }
  function getMinMaxLog(data, _i0, _i1) {
    let _min = inf;
    let _max = -inf;
    for (let i = _i0; i <= _i1; i++) {
      if (data[i] > 0) {
        _min = min(_min, data[i]);
        _max = max(_max, data[i]);
      }
    }
    return [
      _min == inf ? 1 : _min,
      _max == -inf ? 10 : _max
    ];
  }
  var _fixedTuple = [0, 0];
  function fixIncr(minIncr, maxIncr, minExp, maxExp) {
    _fixedTuple[0] = minExp < 0 ? roundDec(minIncr, -minExp) : minIncr;
    _fixedTuple[1] = maxExp < 0 ? roundDec(maxIncr, -maxExp) : maxIncr;
    return _fixedTuple;
  }
  function rangeLog(min2, max2, base, fullMags) {
    let minSign = sign(min2);
    let logFn = base == 10 ? log10 : log2;
    if (min2 == max2) {
      if (minSign == -1) {
        min2 *= base;
        max2 /= base;
      } else {
        min2 /= base;
        max2 *= base;
      }
    }
    let minExp, maxExp, minMaxIncrs;
    if (fullMags) {
      minExp = floor(logFn(min2));
      maxExp = ceil(logFn(max2));
      minMaxIncrs = fixIncr(pow(base, minExp), pow(base, maxExp), minExp, maxExp);
      min2 = minMaxIncrs[0];
      max2 = minMaxIncrs[1];
    } else {
      minExp = floor(logFn(abs(min2)));
      maxExp = floor(logFn(abs(max2)));
      minMaxIncrs = fixIncr(pow(base, minExp), pow(base, maxExp), minExp, maxExp);
      min2 = incrRoundDn(min2, minMaxIncrs[0]);
      max2 = incrRoundUp(max2, minMaxIncrs[1]);
    }
    return [min2, max2];
  }
  function rangeAsinh(min2, max2, base, fullMags) {
    let minMax = rangeLog(min2, max2, base, fullMags);
    if (min2 == 0)
      minMax[0] = 0;
    if (max2 == 0)
      minMax[1] = 0;
    return minMax;
  }
  var rangePad = 0.1;
  var autoRangePart = {
    mode: 3,
    pad: rangePad
  };
  var _eqRangePart = {
    pad: 0,
    soft: null,
    mode: 0
  };
  var _eqRange = {
    min: _eqRangePart,
    max: _eqRangePart
  };
  function rangeNum(_min, _max, mult, extra) {
    if (isObj(mult))
      return _rangeNum(_min, _max, mult);
    _eqRangePart.pad = mult;
    _eqRangePart.soft = extra ? 0 : null;
    _eqRangePart.mode = extra ? 3 : 0;
    return _rangeNum(_min, _max, _eqRange);
  }
  function ifNull(lh, rh) {
    return lh == null ? rh : lh;
  }
  function hasData(data, idx0, idx1) {
    idx0 = ifNull(idx0, 0);
    idx1 = ifNull(idx1, data.length - 1);
    while (idx0 <= idx1) {
      if (data[idx0] != null)
        return true;
      idx0++;
    }
    return false;
  }
  function _rangeNum(_min, _max, cfg) {
    let cmin = cfg.min;
    let cmax = cfg.max;
    let padMin = ifNull(cmin.pad, 0);
    let padMax = ifNull(cmax.pad, 0);
    let hardMin = ifNull(cmin.hard, -inf);
    let hardMax = ifNull(cmax.hard, inf);
    let softMin = ifNull(cmin.soft, inf);
    let softMax = ifNull(cmax.soft, -inf);
    let softMinMode = ifNull(cmin.mode, 0);
    let softMaxMode = ifNull(cmax.mode, 0);
    let delta = _max - _min;
    if (delta < 1e-9) {
      delta = 0;
      if (_min == 0 || _max == 0) {
        delta = 1e-9;
        if (softMinMode == 2 && softMin != inf)
          padMin = 0;
        if (softMaxMode == 2 && softMax != -inf)
          padMax = 0;
      }
    }
    let nonZeroDelta = delta || abs(_max) || 1e3;
    let mag = log10(nonZeroDelta);
    let base = pow(10, floor(mag));
    let _padMin = nonZeroDelta * (delta == 0 ? _min == 0 ? 0.1 : 1 : padMin);
    let _newMin = roundDec(incrRoundDn(_min - _padMin, base / 10), 9);
    let _softMin = _min >= softMin && (softMinMode == 1 || softMinMode == 3 && _newMin <= softMin || softMinMode == 2 && _newMin >= softMin) ? softMin : inf;
    let minLim = max(hardMin, _newMin < _softMin && _min >= _softMin ? _softMin : min(_softMin, _newMin));
    let _padMax = nonZeroDelta * (delta == 0 ? _max == 0 ? 0.1 : 1 : padMax);
    let _newMax = roundDec(incrRoundUp(_max + _padMax, base / 10), 9);
    let _softMax = _max <= softMax && (softMaxMode == 1 || softMaxMode == 3 && _newMax >= softMax || softMaxMode == 2 && _newMax <= softMax) ? softMax : -inf;
    let maxLim = min(hardMax, _newMax > _softMax && _max <= _softMax ? _softMax : max(_softMax, _newMax));
    if (minLim == maxLim && minLim == 0)
      maxLim = 100;
    return [minLim, maxLim];
  }
  var numFormatter = new Intl.NumberFormat(domEnv ? nav.language : "en-US");
  var fmtNum = (val) => numFormatter.format(val);
  var M = Math;
  var PI = M.PI;
  var abs = M.abs;
  var floor = M.floor;
  var round = M.round;
  var ceil = M.ceil;
  var min = M.min;
  var max = M.max;
  var pow = M.pow;
  var sign = M.sign;
  var log10 = M.log10;
  var log2 = M.log2;
  var sinh = (v, linthresh = 1) => M.sinh(v) * linthresh;
  var asinh = (v, linthresh = 1) => M.asinh(v / linthresh);
  var inf = Infinity;
  function numIntDigits(x) {
    return (log10((x ^ x >> 31) - (x >> 31)) | 0) + 1;
  }
  function incrRound(num, incr) {
    return round(num / incr) * incr;
  }
  function clamp(num, _min, _max) {
    return min(max(num, _min), _max);
  }
  function fnOrSelf(v) {
    return typeof v == "function" ? v : () => v;
  }
  var retArg0 = (_0) => _0;
  var retArg1 = (_0, _1) => _1;
  var retNull = (_2) => null;
  var retTrue = (_2) => true;
  var retEq = (a, b) => a == b;
  function incrRoundUp(num, incr) {
    return ceil(num / incr) * incr;
  }
  function incrRoundDn(num, incr) {
    return floor(num / incr) * incr;
  }
  function roundDec(val, dec) {
    return round(val * (dec = 10 ** dec)) / dec;
  }
  var fixedDec = /* @__PURE__ */ new Map();
  function guessDec(num) {
    return (("" + num).split(".")[1] || "").length;
  }
  function genIncrs(base, minExp, maxExp, mults) {
    let incrs = [];
    let multDec = mults.map(guessDec);
    for (let exp = minExp; exp < maxExp; exp++) {
      let expa = abs(exp);
      let mag = roundDec(pow(base, exp), expa);
      for (let i = 0; i < mults.length; i++) {
        let _incr = mults[i] * mag;
        let dec = (_incr >= 0 && exp >= 0 ? 0 : expa) + (exp >= multDec[i] ? 0 : multDec[i]);
        let incr = roundDec(_incr, dec);
        incrs.push(incr);
        fixedDec.set(incr, dec);
      }
    }
    return incrs;
  }
  var EMPTY_OBJ = {};
  var EMPTY_ARR = [];
  var nullNullTuple = [null, null];
  var isArr = Array.isArray;
  function isStr(v) {
    return typeof v == "string";
  }
  function isObj(v) {
    let is = false;
    if (v != null) {
      let c = v.constructor;
      is = c == null || c == Object;
    }
    return is;
  }
  function fastIsObj(v) {
    return v != null && typeof v == "object";
  }
  var TypedArray = Object.getPrototypeOf(Uint8Array);
  function copy(o, _isObj = isObj) {
    let out;
    if (isArr(o)) {
      let val = o.find((v) => v != null);
      if (isArr(val) || _isObj(val)) {
        out = Array(o.length);
        for (let i = 0; i < o.length; i++)
          out[i] = copy(o[i], _isObj);
      } else
        out = o.slice();
    } else if (o instanceof TypedArray)
      out = o.slice();
    else if (_isObj(o)) {
      out = {};
      for (let k in o)
        out[k] = copy(o[k], _isObj);
    } else
      out = o;
    return out;
  }
  function assign(targ) {
    let args = arguments;
    for (let i = 1; i < args.length; i++) {
      let src = args[i];
      for (let key in src) {
        if (isObj(targ[key]))
          assign(targ[key], copy(src[key]));
        else
          targ[key] = copy(src[key]);
      }
    }
    return targ;
  }
  var NULL_REMOVE = 0;
  var NULL_RETAIN = 1;
  var NULL_EXPAND = 2;
  function nullExpand(yVals, nullIdxs, alignedLen) {
    for (let i = 0, xi, lastNullIdx = -1; i < nullIdxs.length; i++) {
      let nullIdx = nullIdxs[i];
      if (nullIdx > lastNullIdx) {
        xi = nullIdx - 1;
        while (xi >= 0 && yVals[xi] == null)
          yVals[xi--] = null;
        xi = nullIdx + 1;
        while (xi < alignedLen && yVals[xi] == null)
          yVals[lastNullIdx = xi++] = null;
      }
    }
  }
  function join(tables, nullModes) {
    let xVals = /* @__PURE__ */ new Set();
    for (let ti = 0; ti < tables.length; ti++) {
      let t = tables[ti];
      let xs = t[0];
      let len = xs.length;
      for (let i = 0; i < len; i++)
        xVals.add(xs[i]);
    }
    let data = [Array.from(xVals).sort((a, b) => a - b)];
    let alignedLen = data[0].length;
    let xIdxs = /* @__PURE__ */ new Map();
    for (let i = 0; i < alignedLen; i++)
      xIdxs.set(data[0][i], i);
    for (let ti = 0; ti < tables.length; ti++) {
      let t = tables[ti];
      let xs = t[0];
      for (let si = 1; si < t.length; si++) {
        let ys = t[si];
        let yVals = Array(alignedLen).fill(void 0);
        let nullMode = nullModes ? nullModes[ti][si] : NULL_RETAIN;
        let nullIdxs = [];
        for (let i = 0; i < ys.length; i++) {
          let yVal = ys[i];
          let alignedIdx = xIdxs.get(xs[i]);
          if (yVal === null) {
            if (nullMode != NULL_REMOVE) {
              yVals[alignedIdx] = yVal;
              if (nullMode == NULL_EXPAND)
                nullIdxs.push(alignedIdx);
            }
          } else
            yVals[alignedIdx] = yVal;
        }
        nullExpand(yVals, nullIdxs, alignedLen);
        data.push(yVals);
      }
    }
    return data;
  }
  var microTask = typeof queueMicrotask == "undefined" ? (fn) => Promise.resolve().then(fn) : queueMicrotask;
  var months = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];
  var days = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ];
  function slice3(str) {
    return str.slice(0, 3);
  }
  var days3 = days.map(slice3);
  var months3 = months.map(slice3);
  var engNames = {
    MMMM: months,
    MMM: months3,
    WWWW: days,
    WWW: days3
  };
  function zeroPad2(int) {
    return (int < 10 ? "0" : "") + int;
  }
  function zeroPad3(int) {
    return (int < 10 ? "00" : int < 100 ? "0" : "") + int;
  }
  var subs = {
    YYYY: (d) => d.getFullYear(),
    YY: (d) => (d.getFullYear() + "").slice(2),
    MMMM: (d, names) => names.MMMM[d.getMonth()],
    MMM: (d, names) => names.MMM[d.getMonth()],
    MM: (d) => zeroPad2(d.getMonth() + 1),
    M: (d) => d.getMonth() + 1,
    DD: (d) => zeroPad2(d.getDate()),
    D: (d) => d.getDate(),
    WWWW: (d, names) => names.WWWW[d.getDay()],
    WWW: (d, names) => names.WWW[d.getDay()],
    HH: (d) => zeroPad2(d.getHours()),
    H: (d) => d.getHours(),
    h: (d) => {
      let h = d.getHours();
      return h == 0 ? 12 : h > 12 ? h - 12 : h;
    },
    AA: (d) => d.getHours() >= 12 ? "PM" : "AM",
    aa: (d) => d.getHours() >= 12 ? "pm" : "am",
    a: (d) => d.getHours() >= 12 ? "p" : "a",
    mm: (d) => zeroPad2(d.getMinutes()),
    m: (d) => d.getMinutes(),
    ss: (d) => zeroPad2(d.getSeconds()),
    s: (d) => d.getSeconds(),
    fff: (d) => zeroPad3(d.getMilliseconds())
  };
  function fmtDate(tpl, names) {
    names = names || engNames;
    let parts = [];
    let R = /\{([a-z]+)\}|[^{]+/gi, m;
    while (m = R.exec(tpl))
      parts.push(m[0][0] == "{" ? subs[m[1]] : m[0]);
    return (d) => {
      let out = "";
      for (let i = 0; i < parts.length; i++)
        out += typeof parts[i] == "string" ? parts[i] : parts[i](d, names);
      return out;
    };
  }
  var localTz = new Intl.DateTimeFormat().resolvedOptions().timeZone;
  function tzDate(date, tz) {
    let date2;
    if (tz == "UTC" || tz == "Etc/UTC")
      date2 = new Date(+date + date.getTimezoneOffset() * 6e4);
    else if (tz == localTz)
      date2 = date;
    else {
      date2 = new Date(date.toLocaleString("en-US", { timeZone: tz }));
      date2.setMilliseconds(date.getMilliseconds());
    }
    return date2;
  }
  var onlyWhole = (v) => v % 1 == 0;
  var allMults = [1, 2, 2.5, 5];
  var decIncrs = genIncrs(10, -16, 0, allMults);
  var oneIncrs = genIncrs(10, 0, 16, allMults);
  var wholeIncrs = oneIncrs.filter(onlyWhole);
  var numIncrs = decIncrs.concat(oneIncrs);
  var NL = "\n";
  var yyyy = "{YYYY}";
  var NLyyyy = NL + yyyy;
  var md = "{M}/{D}";
  var NLmd = NL + md;
  var NLmdyy = NLmd + "/{YY}";
  var aa = "{aa}";
  var hmm = "{h}:{mm}";
  var hmmaa = hmm + aa;
  var NLhmmaa = NL + hmmaa;
  var ss = ":{ss}";
  var _ = null;
  function genTimeStuffs(ms) {
    let s = ms * 1e3, m = s * 60, h = m * 60, d = h * 24, mo = d * 30, y = d * 365;
    let subSecIncrs = ms == 1 ? genIncrs(10, 0, 3, allMults).filter(onlyWhole) : genIncrs(10, -3, 0, allMults);
    let timeIncrs = subSecIncrs.concat([
      s,
      s * 5,
      s * 10,
      s * 15,
      s * 30,
      m,
      m * 5,
      m * 10,
      m * 15,
      m * 30,
      h,
      h * 2,
      h * 3,
      h * 4,
      h * 6,
      h * 8,
      h * 12,
      d,
      d * 2,
      d * 3,
      d * 4,
      d * 5,
      d * 6,
      d * 7,
      d * 8,
      d * 9,
      d * 10,
      d * 15,
      mo,
      mo * 2,
      mo * 3,
      mo * 4,
      mo * 6,
      y,
      y * 2,
      y * 5,
      y * 10,
      y * 25,
      y * 50,
      y * 100
    ]);
    const _timeAxisStamps = [
      [y, yyyy, _, _, _, _, _, _, 1],
      [d * 28, "{MMM}", NLyyyy, _, _, _, _, _, 1],
      [d, md, NLyyyy, _, _, _, _, _, 1],
      [h, "{h}" + aa, NLmdyy, _, NLmd, _, _, _, 1],
      [m, hmmaa, NLmdyy, _, NLmd, _, _, _, 1],
      [s, ss, NLmdyy + " " + hmmaa, _, NLmd + " " + hmmaa, _, NLhmmaa, _, 1],
      [ms, ss + ".{fff}", NLmdyy + " " + hmmaa, _, NLmd + " " + hmmaa, _, NLhmmaa, _, 1]
    ];
    function timeAxisSplits(tzDate2) {
      return (self2, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace) => {
        let splits = [];
        let isYr = foundIncr >= y;
        let isMo = foundIncr >= mo && foundIncr < y;
        let minDate = tzDate2(scaleMin);
        let minDateTs = roundDec(minDate * ms, 3);
        let minMin = mkDate(minDate.getFullYear(), isYr ? 0 : minDate.getMonth(), isMo || isYr ? 1 : minDate.getDate());
        let minMinTs = roundDec(minMin * ms, 3);
        if (isMo || isYr) {
          let moIncr = isMo ? foundIncr / mo : 0;
          let yrIncr = isYr ? foundIncr / y : 0;
          let split = minDateTs == minMinTs ? minDateTs : roundDec(mkDate(minMin.getFullYear() + yrIncr, minMin.getMonth() + moIncr, 1) * ms, 3);
          let splitDate = new Date(round(split / ms));
          let baseYear = splitDate.getFullYear();
          let baseMonth = splitDate.getMonth();
          for (let i = 0; split <= scaleMax; i++) {
            let next = mkDate(baseYear + yrIncr * i, baseMonth + moIncr * i, 1);
            let offs = next - tzDate2(roundDec(next * ms, 3));
            split = roundDec((+next + offs) * ms, 3);
            if (split <= scaleMax)
              splits.push(split);
          }
        } else {
          let incr0 = foundIncr >= d ? d : foundIncr;
          let tzOffset = floor(scaleMin) - floor(minDateTs);
          let split = minMinTs + tzOffset + incrRoundUp(minDateTs - minMinTs, incr0);
          splits.push(split);
          let date0 = tzDate2(split);
          let prevHour = date0.getHours() + date0.getMinutes() / m + date0.getSeconds() / h;
          let incrHours = foundIncr / h;
          let minSpace = self2.axes[axisIdx]._space;
          let pctSpace = foundSpace / minSpace;
          while (1) {
            split = roundDec(split + foundIncr, ms == 1 ? 0 : 3);
            if (split > scaleMax)
              break;
            if (incrHours > 1) {
              let expectedHour = floor(roundDec(prevHour + incrHours, 6)) % 24;
              let splitDate = tzDate2(split);
              let actualHour = splitDate.getHours();
              let dstShift = actualHour - expectedHour;
              if (dstShift > 1)
                dstShift = -1;
              split -= dstShift * h;
              prevHour = (prevHour + incrHours) % 24;
              let prevSplit = splits[splits.length - 1];
              let pctIncr = roundDec((split - prevSplit) / foundIncr, 3);
              if (pctIncr * pctSpace >= 0.7)
                splits.push(split);
            } else
              splits.push(split);
          }
        }
        return splits;
      };
    }
    return [
      timeIncrs,
      _timeAxisStamps,
      timeAxisSplits
    ];
  }
  var [timeIncrsMs, _timeAxisStampsMs, timeAxisSplitsMs] = genTimeStuffs(1);
  var [timeIncrsS, _timeAxisStampsS, timeAxisSplitsS] = genTimeStuffs(1e-3);
  genIncrs(2, -53, 53, [1]);
  function timeAxisStamps(stampCfg, fmtDate2) {
    return stampCfg.map((s) => s.map((v, i) => i == 0 || i == 8 || v == null ? v : fmtDate2(i == 1 || s[8] == 0 ? v : s[1] + v)));
  }
  function timeAxisVals(tzDate2, stamps) {
    return (self2, splits, axisIdx, foundSpace, foundIncr) => {
      let s = stamps.find((s2) => foundIncr >= s2[0]) || stamps[stamps.length - 1];
      let prevYear;
      let prevMnth;
      let prevDate;
      let prevHour;
      let prevMins;
      let prevSecs;
      return splits.map((split) => {
        let date = tzDate2(split);
        let newYear = date.getFullYear();
        let newMnth = date.getMonth();
        let newDate = date.getDate();
        let newHour = date.getHours();
        let newMins = date.getMinutes();
        let newSecs = date.getSeconds();
        let stamp = newYear != prevYear && s[2] || newMnth != prevMnth && s[3] || newDate != prevDate && s[4] || newHour != prevHour && s[5] || newMins != prevMins && s[6] || newSecs != prevSecs && s[7] || s[1];
        prevYear = newYear;
        prevMnth = newMnth;
        prevDate = newDate;
        prevHour = newHour;
        prevMins = newMins;
        prevSecs = newSecs;
        return stamp(date);
      });
    };
  }
  function timeAxisVal(tzDate2, dateTpl) {
    let stamp = fmtDate(dateTpl);
    return (self2, splits, axisIdx, foundSpace, foundIncr) => splits.map((split) => stamp(tzDate2(split)));
  }
  function mkDate(y, m, d) {
    return new Date(y, m, d);
  }
  function timeSeriesStamp(stampCfg, fmtDate2) {
    return fmtDate2(stampCfg);
  }
  var _timeSeriesStamp = "{YYYY}-{MM}-{DD} {h}:{mm}{aa}";
  function timeSeriesVal(tzDate2, stamp) {
    return (self2, val) => stamp(tzDate2(val));
  }
  function legendStroke(self2, seriesIdx) {
    let s = self2.series[seriesIdx];
    return s.width ? s.stroke(self2, seriesIdx) : s.points.width ? s.points.stroke(self2, seriesIdx) : null;
  }
  function legendFill(self2, seriesIdx) {
    return self2.series[seriesIdx].fill(self2, seriesIdx);
  }
  var legendOpts = {
    show: true,
    live: true,
    isolate: false,
    markers: {
      show: true,
      width: 2,
      stroke: legendStroke,
      fill: legendFill,
      dash: "solid"
    },
    idx: null,
    idxs: null,
    values: []
  };
  function cursorPointShow(self2, si) {
    let o = self2.cursor.points;
    let pt = placeDiv();
    let size = o.size(self2, si);
    setStylePx(pt, WIDTH, size);
    setStylePx(pt, HEIGHT, size);
    let mar = size / -2;
    setStylePx(pt, "marginLeft", mar);
    setStylePx(pt, "marginTop", mar);
    let width = o.width(self2, si, size);
    width && setStylePx(pt, "borderWidth", width);
    return pt;
  }
  function cursorPointFill(self2, si) {
    let sp = self2.series[si].points;
    return sp._fill || sp._stroke;
  }
  function cursorPointStroke(self2, si) {
    let sp = self2.series[si].points;
    return sp._stroke || sp._fill;
  }
  function cursorPointSize(self2, si) {
    let sp = self2.series[si].points;
    return ptDia(sp.width, 1);
  }
  function dataIdx(self2, seriesIdx, cursorIdx) {
    return cursorIdx;
  }
  var moveTuple = [0, 0];
  function cursorMove(self2, mouseLeft1, mouseTop1) {
    moveTuple[0] = mouseLeft1;
    moveTuple[1] = mouseTop1;
    return moveTuple;
  }
  function filtBtn0(self2, targ, handle) {
    return (e) => {
      e.button == 0 && handle(e);
    };
  }
  function passThru(self2, targ, handle) {
    return handle;
  }
  var cursorOpts = {
    show: true,
    x: true,
    y: true,
    lock: false,
    move: cursorMove,
    points: {
      show: cursorPointShow,
      size: cursorPointSize,
      width: 0,
      stroke: cursorPointStroke,
      fill: cursorPointFill
    },
    bind: {
      mousedown: filtBtn0,
      mouseup: filtBtn0,
      click: filtBtn0,
      dblclick: filtBtn0,
      mousemove: passThru,
      mouseleave: passThru,
      mouseenter: passThru
    },
    drag: {
      setScale: true,
      x: true,
      y: false,
      dist: 0,
      uni: null,
      _x: false,
      _y: false
    },
    focus: {
      prox: -1
    },
    left: -10,
    top: -10,
    idx: null,
    dataIdx,
    idxs: null
  };
  var axisLines = {
    show: true,
    stroke: "rgba(0,0,0,0.07)",
    width: 2
  };
  var grid = assign({}, axisLines, {
    filter: retArg1
  });
  var ticks = assign({}, grid, {
    size: 10
  });
  var border = assign({}, axisLines, {
    show: false
  });
  var font = '12px system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"';
  var labelFont = "bold " + font;
  var lineMult = 1.5;
  var xAxisOpts = {
    show: true,
    scale: "x",
    stroke: hexBlack,
    space: 50,
    gap: 5,
    size: 50,
    labelGap: 0,
    labelSize: 30,
    labelFont,
    side: 2,
    grid,
    ticks,
    border,
    font,
    rotate: 0
  };
  var numSeriesLabel = "Value";
  var timeSeriesLabel = "Time";
  var xSeriesOpts = {
    show: true,
    scale: "x",
    auto: false,
    sorted: 1,
    min: inf,
    max: -inf,
    idxs: []
  };
  function numAxisVals(self2, splits, axisIdx, foundSpace, foundIncr) {
    return splits.map((v) => v == null ? "" : fmtNum(v));
  }
  function numAxisSplits(self2, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {
    let splits = [];
    let numDec = fixedDec.get(foundIncr) || 0;
    scaleMin = forceMin ? scaleMin : roundDec(incrRoundUp(scaleMin, foundIncr), numDec);
    for (let val = scaleMin; val <= scaleMax; val = roundDec(val + foundIncr, numDec))
      splits.push(Object.is(val, -0) ? 0 : val);
    return splits;
  }
  function logAxisSplits(self2, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {
    const splits = [];
    const logBase = self2.scales[self2.axes[axisIdx].scale].log;
    const logFn = logBase == 10 ? log10 : log2;
    const exp = floor(logFn(scaleMin));
    foundIncr = pow(logBase, exp);
    if (exp < 0)
      foundIncr = roundDec(foundIncr, -exp);
    let split = scaleMin;
    do {
      splits.push(split);
      split = roundDec(split + foundIncr, fixedDec.get(foundIncr));
      if (split >= foundIncr * logBase)
        foundIncr = split;
    } while (split <= scaleMax);
    return splits;
  }
  function asinhAxisSplits(self2, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {
    let sc = self2.scales[self2.axes[axisIdx].scale];
    let linthresh = sc.asinh;
    let posSplits = scaleMax > linthresh ? logAxisSplits(self2, axisIdx, max(linthresh, scaleMin), scaleMax, foundIncr) : [linthresh];
    let zero = scaleMax >= 0 && scaleMin <= 0 ? [0] : [];
    let negSplits = scaleMin < -linthresh ? logAxisSplits(self2, axisIdx, max(linthresh, -scaleMax), -scaleMin, foundIncr) : [linthresh];
    return negSplits.reverse().map((v) => -v).concat(zero, posSplits);
  }
  var RE_ALL = /./;
  var RE_12357 = /[12357]/;
  var RE_125 = /[125]/;
  var RE_1 = /1/;
  function logAxisValsFilt(self2, splits, axisIdx, foundSpace, foundIncr) {
    let axis = self2.axes[axisIdx];
    let scaleKey = axis.scale;
    let sc = self2.scales[scaleKey];
    if (sc.distr == 3 && sc.log == 2)
      return splits;
    let valToPos = self2.valToPos;
    let minSpace = axis._space;
    let _10 = valToPos(10, scaleKey);
    let re = valToPos(9, scaleKey) - _10 >= minSpace ? RE_ALL : valToPos(7, scaleKey) - _10 >= minSpace ? RE_12357 : valToPos(5, scaleKey) - _10 >= minSpace ? RE_125 : RE_1;
    return splits.map((v) => sc.distr == 4 && v == 0 || re.test(v) ? v : null);
  }
  function numSeriesVal(self2, val) {
    return val == null ? "" : fmtNum(val);
  }
  var yAxisOpts = {
    show: true,
    scale: "y",
    stroke: hexBlack,
    space: 30,
    gap: 5,
    size: 50,
    labelGap: 0,
    labelSize: 30,
    labelFont,
    side: 3,
    grid,
    ticks,
    border,
    font,
    rotate: 0
  };
  function ptDia(width, mult) {
    let dia = 3 + (width || 1) * 2;
    return roundDec(dia * mult, 3);
  }
  function seriesPointsShow(self2, si) {
    let { scale, idxs } = self2.series[0];
    let xData = self2._data[0];
    let p0 = self2.valToPos(xData[idxs[0]], scale, true);
    let p1 = self2.valToPos(xData[idxs[1]], scale, true);
    let dim = abs(p1 - p0);
    let s = self2.series[si];
    let maxPts = dim / (s.points.space * pxRatio);
    return idxs[1] - idxs[0] <= maxPts;
  }
  var facet = {
    scale: null,
    auto: true,
    sorted: 0,
    min: inf,
    max: -inf
  };
  var xySeriesOpts = {
    show: true,
    auto: true,
    sorted: 0,
    alpha: 1,
    facets: [
      assign({}, facet, { scale: "x" }),
      assign({}, facet, { scale: "y" })
    ]
  };
  var ySeriesOpts = {
    scale: "y",
    auto: true,
    sorted: 0,
    show: true,
    spanGaps: false,
    gaps: (self2, seriesIdx, idx0, idx1, nullGaps) => nullGaps,
    alpha: 1,
    points: {
      show: seriesPointsShow,
      filter: null
    },
    values: null,
    min: inf,
    max: -inf,
    idxs: [],
    path: null,
    clip: null
  };
  function clampScale(self2, val, scaleMin, scaleMax, scaleKey) {
    return scaleMin / 10;
  }
  var xScaleOpts = {
    time: FEAT_TIME,
    auto: true,
    distr: 1,
    log: 10,
    asinh: 1,
    min: null,
    max: null,
    dir: 1,
    ori: 0
  };
  var yScaleOpts = assign({}, xScaleOpts, {
    time: false,
    ori: 1
  });
  var syncs = {};
  function _sync(key, opts) {
    let s = syncs[key];
    if (!s) {
      s = {
        key,
        plots: [],
        sub(plot) {
          s.plots.push(plot);
        },
        unsub(plot) {
          s.plots = s.plots.filter((c) => c != plot);
        },
        pub(type, self2, x, y, w, h, i) {
          for (let j = 0; j < s.plots.length; j++)
            s.plots[j] != self2 && s.plots[j].pub(type, self2, x, y, w, h, i);
        }
      };
      if (key != null)
        syncs[key] = s;
    }
    return s;
  }
  var BAND_CLIP_FILL = 1 << 0;
  var BAND_CLIP_STROKE = 1 << 1;
  function orient(u, seriesIdx, cb) {
    const series = u.series[seriesIdx];
    const scales = u.scales;
    const bbox = u.bbox;
    const scaleX = u.mode == 2 ? scales[series.facets[0].scale] : scales[u.series[0].scale];
    let dx = u._data[0], dy = u._data[seriesIdx], sx = scaleX, sy = u.mode == 2 ? scales[series.facets[1].scale] : scales[series.scale], l = bbox.left, t = bbox.top, w = bbox.width, h = bbox.height, H = u.valToPosH, V = u.valToPosV;
    return sx.ori == 0 ? cb(series, dx, dy, sx, sy, H, V, l, t, w, h, moveToH, lineToH, rectH, arcH, bezierCurveToH) : cb(series, dx, dy, sx, sy, V, H, t, l, h, w, moveToV, lineToV, rectV, arcV, bezierCurveToV);
  }
  function bandFillClipDirs(self2, seriesIdx) {
    let fillDir = 0;
    let clipDirs = 0;
    let bands = ifNull(self2.bands, EMPTY_ARR);
    for (let i = 0; i < bands.length; i++) {
      let b = bands[i];
      if (b.series[0] == seriesIdx)
        fillDir = b.dir;
      else if (b.series[1] == seriesIdx) {
        if (b.dir == 1)
          clipDirs |= 1;
        else
          clipDirs |= 2;
      }
    }
    return [
      fillDir,
      clipDirs == 1 ? -1 : clipDirs == 2 ? 1 : clipDirs == 3 ? 2 : 0
    ];
  }
  function seriesFillTo(self2, seriesIdx, dataMin, dataMax, bandFillDir) {
    let scale = self2.scales[self2.series[seriesIdx].scale];
    return bandFillDir == -1 ? scale.min : bandFillDir == 1 ? scale.max : scale.distr == 3 ? scale.dir == 1 ? scale.min : scale.max : 0;
  }
  function clipBandLine(self2, seriesIdx, idx0, idx1, strokePath, clipDir) {
    return orient(self2, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
      let pxRound = series.pxRound;
      const dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);
      const lineTo = scaleX.ori == 0 ? lineToH : lineToV;
      let frIdx, toIdx;
      if (dir == 1) {
        frIdx = idx0;
        toIdx = idx1;
      } else {
        frIdx = idx1;
        toIdx = idx0;
      }
      let x0 = pxRound(valToPosX(dataX[frIdx], scaleX, xDim, xOff));
      let y0 = pxRound(valToPosY(dataY[frIdx], scaleY, yDim, yOff));
      let x1 = pxRound(valToPosX(dataX[toIdx], scaleX, xDim, xOff));
      let yLimit = pxRound(valToPosY(clipDir == 1 ? scaleY.max : scaleY.min, scaleY, yDim, yOff));
      let clip = new Path2D(strokePath);
      lineTo(clip, x1, yLimit);
      lineTo(clip, x0, yLimit);
      lineTo(clip, x0, y0);
      return clip;
    });
  }
  function clipGaps(gaps, ori, plotLft, plotTop, plotWid, plotHgt) {
    let clip = null;
    if (gaps.length > 0) {
      clip = new Path2D();
      const rect2 = ori == 0 ? rectH : rectV;
      let prevGapEnd = plotLft;
      for (let i = 0; i < gaps.length; i++) {
        let g = gaps[i];
        if (g[1] > g[0]) {
          let w2 = g[0] - prevGapEnd;
          w2 > 0 && rect2(clip, prevGapEnd, plotTop, w2, plotTop + plotHgt);
          prevGapEnd = g[1];
        }
      }
      let w = plotLft + plotWid - prevGapEnd;
      w > 0 && rect2(clip, prevGapEnd, plotTop, w, plotTop + plotHgt);
    }
    return clip;
  }
  function addGap(gaps, fromX, toX) {
    let prevGap = gaps[gaps.length - 1];
    if (prevGap && prevGap[0] == fromX)
      prevGap[1] = toX;
    else
      gaps.push([fromX, toX]);
  }
  function findGaps(xs, ys, idx0, idx1, dir, pixelForX, align) {
    let gaps = [];
    for (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {
      let yVal = ys[i];
      if (yVal === null) {
        let fr = i, to = i;
        if (dir == 1) {
          while (++i <= idx1 && ys[i] === null)
            to = i;
        } else {
          while (--i >= idx0 && ys[i] === null)
            to = i;
        }
        let frPx = pixelForX(xs[fr]);
        let toPx = to == fr ? frPx : pixelForX(xs[to]);
        let frPx2 = align <= 0 ? pixelForX(xs[fr - dir]) : frPx;
        frPx = frPx2;
        let toPx2 = align >= 0 ? pixelForX(xs[to + dir]) : toPx;
        toPx = toPx2;
        if (toPx >= frPx)
          gaps.push([frPx, toPx]);
      }
    }
    return gaps;
  }
  function pxRoundGen(pxAlign) {
    return pxAlign == 0 ? retArg0 : pxAlign == 1 ? round : (v) => incrRound(v, pxAlign);
  }
  function rect(ori) {
    let moveTo = ori == 0 ? moveToH : moveToV;
    let arcTo = ori == 0 ? (p, x1, y1, x2, y2, r) => {
      p.arcTo(x1, y1, x2, y2, r);
    } : (p, y1, x1, y2, x2, r) => {
      p.arcTo(x1, y1, x2, y2, r);
    };
    let rect2 = ori == 0 ? (p, x, y, w, h) => {
      p.rect(x, y, w, h);
    } : (p, y, x, h, w) => {
      p.rect(x, y, w, h);
    };
    return (p, x, y, w, h, r = 0) => {
      if (r == 0)
        rect2(p, x, y, w, h);
      else {
        r = min(r, w / 2, h / 2);
        moveTo(p, x + r, y);
        arcTo(p, x + w, y, x + w, y + h, r);
        arcTo(p, x + w, y + h, x, y + h, r);
        arcTo(p, x, y + h, x, y, r);
        arcTo(p, x, y, x + w, y, r);
        p.closePath();
      }
    };
  }
  var moveToH = (p, x, y) => {
    p.moveTo(x, y);
  };
  var moveToV = (p, y, x) => {
    p.moveTo(x, y);
  };
  var lineToH = (p, x, y) => {
    p.lineTo(x, y);
  };
  var lineToV = (p, y, x) => {
    p.lineTo(x, y);
  };
  var rectH = rect(0);
  var rectV = rect(1);
  var arcH = (p, x, y, r, startAngle, endAngle) => {
    p.arc(x, y, r, startAngle, endAngle);
  };
  var arcV = (p, y, x, r, startAngle, endAngle) => {
    p.arc(x, y, r, startAngle, endAngle);
  };
  var bezierCurveToH = (p, bp1x, bp1y, bp2x, bp2y, p2x, p2y) => {
    p.bezierCurveTo(bp1x, bp1y, bp2x, bp2y, p2x, p2y);
  };
  var bezierCurveToV = (p, bp1y, bp1x, bp2y, bp2x, p2y, p2x) => {
    p.bezierCurveTo(bp1x, bp1y, bp2x, bp2y, p2x, p2y);
  };
  function points(opts) {
    return (u, seriesIdx, idx0, idx1, filtIdxs) => {
      return orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
        let { pxRound, points: points2 } = series;
        let moveTo, arc;
        if (scaleX.ori == 0) {
          moveTo = moveToH;
          arc = arcH;
        } else {
          moveTo = moveToV;
          arc = arcV;
        }
        const width = roundDec(points2.width * pxRatio, 3);
        let rad = (points2.size - points2.width) / 2 * pxRatio;
        let dia = roundDec(rad * 2, 3);
        let fill = new Path2D();
        let clip = new Path2D();
        let { left: lft, top, width: wid, height: hgt } = u.bbox;
        rectH(clip, lft - dia, top - dia, wid + dia * 2, hgt + dia * 2);
        const drawPoint = (pi) => {
          if (dataY[pi] != null) {
            let x = pxRound(valToPosX(dataX[pi], scaleX, xDim, xOff));
            let y = pxRound(valToPosY(dataY[pi], scaleY, yDim, yOff));
            moveTo(fill, x + rad, y);
            arc(fill, x, y, rad, 0, PI * 2);
          }
        };
        if (filtIdxs)
          filtIdxs.forEach(drawPoint);
        else {
          for (let pi = idx0; pi <= idx1; pi++)
            drawPoint(pi);
        }
        return {
          stroke: width > 0 ? fill : null,
          fill,
          clip,
          flags: BAND_CLIP_FILL | BAND_CLIP_STROKE
        };
      });
    };
  }
  function _drawAcc(lineTo) {
    return (stroke, accX, minY, maxY, inY, outY) => {
      if (minY != maxY) {
        if (inY != minY && outY != minY)
          lineTo(stroke, accX, minY);
        if (inY != maxY && outY != maxY)
          lineTo(stroke, accX, maxY);
        lineTo(stroke, accX, outY);
      }
    };
  }
  var drawAccH = _drawAcc(lineToH);
  var drawAccV = _drawAcc(lineToV);
  function linear(opts) {
    const alignGaps = ifNull(opts == null ? void 0 : opts.alignGaps, 0);
    return (u, seriesIdx, idx0, idx1) => {
      return orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
        let pxRound = series.pxRound;
        let pixelForX = (val) => pxRound(valToPosX(val, scaleX, xDim, xOff));
        let pixelForY = (val) => pxRound(valToPosY(val, scaleY, yDim, yOff));
        let lineTo, drawAcc;
        if (scaleX.ori == 0) {
          lineTo = lineToH;
          drawAcc = drawAccH;
        } else {
          lineTo = lineToV;
          drawAcc = drawAccV;
        }
        const dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);
        const _paths = { stroke: new Path2D(), fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL };
        const stroke = _paths.stroke;
        let minY = inf, maxY = -inf, inY, outY, drawnAtX;
        let accX = pixelForX(dataX[dir == 1 ? idx0 : idx1]);
        let lftIdx = nonNullIdx(dataY, idx0, idx1, 1 * dir);
        let rgtIdx = nonNullIdx(dataY, idx0, idx1, -1 * dir);
        let lftX = pixelForX(dataX[lftIdx]);
        let rgtX = pixelForX(dataX[rgtIdx]);
        for (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {
          let x = pixelForX(dataX[i]);
          if (x == accX) {
            if (dataY[i] != null) {
              outY = pixelForY(dataY[i]);
              if (minY == inf) {
                lineTo(stroke, x, outY);
                inY = outY;
              }
              minY = min(outY, minY);
              maxY = max(outY, maxY);
            }
          } else {
            if (minY != inf) {
              drawAcc(stroke, accX, minY, maxY, inY, outY);
              drawnAtX = accX;
            }
            if (dataY[i] != null) {
              outY = pixelForY(dataY[i]);
              lineTo(stroke, x, outY);
              minY = maxY = inY = outY;
            } else {
              minY = inf;
              maxY = -inf;
            }
            accX = x;
          }
        }
        if (minY != inf && minY != maxY && drawnAtX != accX)
          drawAcc(stroke, accX, minY, maxY, inY, outY);
        let [bandFillDir, bandClipDir] = bandFillClipDirs(u, seriesIdx);
        if (series.fill != null || bandFillDir != 0) {
          let fill = _paths.fill = new Path2D(stroke);
          let fillToVal = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);
          let fillToY = pixelForY(fillToVal);
          lineTo(fill, rgtX, fillToY);
          lineTo(fill, lftX, fillToY);
        }
        if (!series.spanGaps) {
          let gaps = [];
          gaps.push(...findGaps(dataX, dataY, idx0, idx1, dir, pixelForX, alignGaps));
          _paths.gaps = gaps = series.gaps(u, seriesIdx, idx0, idx1, gaps);
          _paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);
        }
        if (bandClipDir != 0) {
          _paths.band = bandClipDir == 2 ? [
            clipBandLine(u, seriesIdx, idx0, idx1, stroke, -1),
            clipBandLine(u, seriesIdx, idx0, idx1, stroke, 1)
          ] : clipBandLine(u, seriesIdx, idx0, idx1, stroke, bandClipDir);
        }
        return _paths;
      });
    };
  }
  function stepped(opts) {
    const align = ifNull(opts.align, 1);
    const ascDesc = ifNull(opts.ascDesc, false);
    const alignGaps = ifNull(opts.alignGaps, 0);
    return (u, seriesIdx, idx0, idx1) => {
      return orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
        let pxRound = series.pxRound;
        let pixelForX = (val) => pxRound(valToPosX(val, scaleX, xDim, xOff));
        let pixelForY = (val) => pxRound(valToPosY(val, scaleY, yDim, yOff));
        let lineTo = scaleX.ori == 0 ? lineToH : lineToV;
        const _paths = { stroke: new Path2D(), fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL };
        const stroke = _paths.stroke;
        const dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);
        idx0 = nonNullIdx(dataY, idx0, idx1, 1);
        idx1 = nonNullIdx(dataY, idx0, idx1, -1);
        let prevYPos = pixelForY(dataY[dir == 1 ? idx0 : idx1]);
        let firstXPos = pixelForX(dataX[dir == 1 ? idx0 : idx1]);
        let prevXPos = firstXPos;
        lineTo(stroke, firstXPos, prevYPos);
        for (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {
          let yVal1 = dataY[i];
          if (yVal1 == null)
            continue;
          let x1 = pixelForX(dataX[i]);
          let y1 = pixelForY(yVal1);
          if (align == 1)
            lineTo(stroke, x1, prevYPos);
          else
            lineTo(stroke, prevXPos, y1);
          lineTo(stroke, x1, y1);
          prevYPos = y1;
          prevXPos = x1;
        }
        let [bandFillDir, bandClipDir] = bandFillClipDirs(u, seriesIdx);
        if (series.fill != null || bandFillDir != 0) {
          let fill = _paths.fill = new Path2D(stroke);
          let fillTo = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);
          let fillToY = pixelForY(fillTo);
          lineTo(fill, prevXPos, fillToY);
          lineTo(fill, firstXPos, fillToY);
        }
        if (!series.spanGaps) {
          let gaps = [];
          gaps.push(...findGaps(dataX, dataY, idx0, idx1, dir, pixelForX, alignGaps));
          let halfStroke = series.width * pxRatio / 2;
          let startsOffset = ascDesc || align == 1 ? halfStroke : -halfStroke;
          let endsOffset = ascDesc || align == -1 ? -halfStroke : halfStroke;
          gaps.forEach((g) => {
            g[0] += startsOffset;
            g[1] += endsOffset;
          });
          _paths.gaps = gaps = series.gaps(u, seriesIdx, idx0, idx1, gaps);
          _paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);
        }
        if (bandClipDir != 0) {
          _paths.band = bandClipDir == 2 ? [
            clipBandLine(u, seriesIdx, idx0, idx1, stroke, -1),
            clipBandLine(u, seriesIdx, idx0, idx1, stroke, 1)
          ] : clipBandLine(u, seriesIdx, idx0, idx1, stroke, bandClipDir);
        }
        return _paths;
      });
    };
  }
  function bars(opts) {
    opts = opts || EMPTY_OBJ;
    const size = ifNull(opts.size, [0.6, inf, 1]);
    const align = opts.align || 0;
    const extraGap = (opts.gap || 0) * pxRatio;
    const radius = ifNull(opts.radius, 0);
    const gapFactor = 1 - size[0];
    const maxWidth = ifNull(size[1], inf) * pxRatio;
    const minWidth = ifNull(size[2], 1) * pxRatio;
    const disp = ifNull(opts.disp, EMPTY_OBJ);
    const _each = ifNull(opts.each, (_2) => {
    });
    const { fill: dispFills, stroke: dispStrokes } = disp;
    return (u, seriesIdx, idx0, idx1) => {
      return orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
        let pxRound = series.pxRound;
        const _dirX = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);
        const _dirY = scaleY.dir * (scaleY.ori == 1 ? 1 : -1);
        let rect2 = scaleX.ori == 0 ? rectH : rectV;
        let each = scaleX.ori == 0 ? _each : (u2, seriesIdx2, i, top, lft, hgt, wid) => {
          _each(u2, seriesIdx2, i, lft, top, wid, hgt);
        };
        let [bandFillDir, bandClipDir] = bandFillClipDirs(u, seriesIdx);
        let fillToY = scaleY.distr == 3 ? bandFillDir == 1 ? scaleY.max : scaleY.min : 0;
        let y0Pos = valToPosY(fillToY, scaleY, yDim, yOff);
        let xShift, barWid;
        let strokeWidth = pxRound(series.width * pxRatio);
        let multiPath = false;
        let fillColors = null;
        let fillPaths = null;
        let strokeColors = null;
        let strokePaths = null;
        if (dispFills != null && (strokeWidth == 0 || dispStrokes != null)) {
          multiPath = true;
          fillColors = dispFills.values(u, seriesIdx, idx0, idx1);
          fillPaths = /* @__PURE__ */ new Map();
          new Set(fillColors).forEach((color) => {
            if (color != null)
              fillPaths.set(color, new Path2D());
          });
          if (strokeWidth > 0) {
            strokeColors = dispStrokes.values(u, seriesIdx, idx0, idx1);
            strokePaths = /* @__PURE__ */ new Map();
            new Set(strokeColors).forEach((color) => {
              if (color != null)
                strokePaths.set(color, new Path2D());
            });
          }
        }
        let { x0, size: size2 } = disp;
        if (x0 != null && size2 != null) {
          dataX = x0.values(u, seriesIdx, idx0, idx1);
          if (x0.unit == 2)
            dataX = dataX.map((pct) => u.posToVal(xOff + pct * xDim, scaleX.key, true));
          let sizes = size2.values(u, seriesIdx, idx0, idx1);
          if (size2.unit == 2)
            barWid = sizes[0] * xDim;
          else
            barWid = valToPosX(sizes[0], scaleX, xDim, xOff) - valToPosX(0, scaleX, xDim, xOff);
          barWid = pxRound(barWid - strokeWidth);
          xShift = _dirX == 1 ? -strokeWidth / 2 : barWid + strokeWidth / 2;
        } else {
          let colWid = xDim;
          if (dataX.length > 1) {
            let prevIdx = null;
            for (let i = 0, minDelta = Infinity; i < dataX.length; i++) {
              if (dataY[i] !== void 0) {
                if (prevIdx != null) {
                  let delta = abs(dataX[i] - dataX[prevIdx]);
                  if (delta < minDelta) {
                    minDelta = delta;
                    colWid = abs(valToPosX(dataX[i], scaleX, xDim, xOff) - valToPosX(dataX[prevIdx], scaleX, xDim, xOff));
                  }
                }
                prevIdx = i;
              }
            }
          }
          let gapWid = colWid * gapFactor;
          barWid = pxRound(min(maxWidth, max(minWidth, colWid - gapWid)) - strokeWidth - extraGap);
          xShift = (align == 0 ? barWid / 2 : align == _dirX ? 0 : barWid) - align * _dirX * extraGap / 2;
        }
        const _paths = { stroke: null, fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL | BAND_CLIP_STROKE };
        let yLimit;
        if (bandClipDir != 0) {
          _paths.band = new Path2D();
          yLimit = pxRound(valToPosY(bandClipDir == 1 ? scaleY.max : scaleY.min, scaleY, yDim, yOff));
        }
        const stroke = multiPath ? null : new Path2D();
        const band = _paths.band;
        let { y0, y1 } = disp;
        let dataY0 = null;
        if (y0 != null && y1 != null) {
          dataY = y1.values(u, seriesIdx, idx0, idx1);
          dataY0 = y0.values(u, seriesIdx, idx0, idx1);
        }
        for (let i = _dirX == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += _dirX) {
          let yVal = dataY[i];
          if (yVal === void 0)
            continue;
          let xVal = scaleX.distr != 2 || disp != null ? dataX[i] : i;
          let xPos = valToPosX(xVal, scaleX, xDim, xOff);
          let yPos = valToPosY(ifNull(yVal, fillToY), scaleY, yDim, yOff);
          if (dataY0 != null && yVal != null)
            y0Pos = valToPosY(dataY0[i], scaleY, yDim, yOff);
          let lft = pxRound(xPos - xShift);
          let btm = pxRound(max(yPos, y0Pos));
          let top = pxRound(min(yPos, y0Pos));
          let barHgt = btm - top;
          let r = radius * barWid;
          if (yVal != null) {
            if (multiPath) {
              if (strokeWidth > 0 && strokeColors[i] != null)
                rect2(strokePaths.get(strokeColors[i]), lft, top + floor(strokeWidth / 2), barWid, max(0, barHgt - strokeWidth), r);
              if (fillColors[i] != null)
                rect2(fillPaths.get(fillColors[i]), lft, top + floor(strokeWidth / 2), barWid, max(0, barHgt - strokeWidth), r);
            } else
              rect2(stroke, lft, top + floor(strokeWidth / 2), barWid, max(0, barHgt - strokeWidth), r);
            each(u, seriesIdx, i, lft - strokeWidth / 2, top, barWid + strokeWidth, barHgt);
          }
          if (bandClipDir != 0) {
            if (_dirY * bandClipDir == 1) {
              btm = top;
              top = yLimit;
            } else {
              top = btm;
              btm = yLimit;
            }
            barHgt = btm - top;
            rect2(band, lft - strokeWidth / 2, top, barWid + strokeWidth, max(0, barHgt), 0);
          }
        }
        if (strokeWidth > 0)
          _paths.stroke = multiPath ? strokePaths : stroke;
        _paths.fill = multiPath ? fillPaths : stroke;
        return _paths;
      });
    };
  }
  function splineInterp(interp, opts) {
    const alignGaps = ifNull(opts == null ? void 0 : opts.alignGaps, 0);
    return (u, seriesIdx, idx0, idx1) => {
      return orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
        let pxRound = series.pxRound;
        let pixelForX = (val) => pxRound(valToPosX(val, scaleX, xDim, xOff));
        let pixelForY = (val) => pxRound(valToPosY(val, scaleY, yDim, yOff));
        let moveTo, bezierCurveTo, lineTo;
        if (scaleX.ori == 0) {
          moveTo = moveToH;
          lineTo = lineToH;
          bezierCurveTo = bezierCurveToH;
        } else {
          moveTo = moveToV;
          lineTo = lineToV;
          bezierCurveTo = bezierCurveToV;
        }
        const dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);
        idx0 = nonNullIdx(dataY, idx0, idx1, 1);
        idx1 = nonNullIdx(dataY, idx0, idx1, -1);
        let firstXPos = pixelForX(dataX[dir == 1 ? idx0 : idx1]);
        let prevXPos = firstXPos;
        let xCoords = [];
        let yCoords = [];
        for (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {
          let yVal = dataY[i];
          if (yVal != null) {
            let xVal = dataX[i];
            let xPos = pixelForX(xVal);
            xCoords.push(prevXPos = xPos);
            yCoords.push(pixelForY(dataY[i]));
          }
        }
        const _paths = { stroke: interp(xCoords, yCoords, moveTo, lineTo, bezierCurveTo, pxRound), fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL };
        const stroke = _paths.stroke;
        let [bandFillDir, bandClipDir] = bandFillClipDirs(u, seriesIdx);
        if (series.fill != null || bandFillDir != 0) {
          let fill = _paths.fill = new Path2D(stroke);
          let fillTo = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);
          let fillToY = pixelForY(fillTo);
          lineTo(fill, prevXPos, fillToY);
          lineTo(fill, firstXPos, fillToY);
        }
        if (!series.spanGaps) {
          let gaps = [];
          gaps.push(...findGaps(dataX, dataY, idx0, idx1, dir, pixelForX, alignGaps));
          _paths.gaps = gaps = series.gaps(u, seriesIdx, idx0, idx1, gaps);
          _paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);
        }
        if (bandClipDir != 0) {
          _paths.band = bandClipDir == 2 ? [
            clipBandLine(u, seriesIdx, idx0, idx1, stroke, -1),
            clipBandLine(u, seriesIdx, idx0, idx1, stroke, 1)
          ] : clipBandLine(u, seriesIdx, idx0, idx1, stroke, bandClipDir);
        }
        return _paths;
      });
    };
  }
  function monotoneCubic(opts) {
    return splineInterp(_monotoneCubic, opts);
  }
  function _monotoneCubic(xs, ys, moveTo, lineTo, bezierCurveTo, pxRound) {
    const n = xs.length;
    if (n < 2)
      return null;
    const path = new Path2D();
    moveTo(path, xs[0], ys[0]);
    if (n == 2)
      lineTo(path, xs[1], ys[1]);
    else {
      let ms = Array(n), ds = Array(n - 1), dys = Array(n - 1), dxs = Array(n - 1);
      for (let i = 0; i < n - 1; i++) {
        dys[i] = ys[i + 1] - ys[i];
        dxs[i] = xs[i + 1] - xs[i];
        ds[i] = dys[i] / dxs[i];
      }
      ms[0] = ds[0];
      for (let i = 1; i < n - 1; i++) {
        if (ds[i] === 0 || ds[i - 1] === 0 || ds[i - 1] > 0 !== ds[i] > 0)
          ms[i] = 0;
        else {
          ms[i] = 3 * (dxs[i - 1] + dxs[i]) / ((2 * dxs[i] + dxs[i - 1]) / ds[i - 1] + (dxs[i] + 2 * dxs[i - 1]) / ds[i]);
          if (!isFinite(ms[i]))
            ms[i] = 0;
        }
      }
      ms[n - 1] = ds[n - 2];
      for (let i = 0; i < n - 1; i++) {
        bezierCurveTo(path, xs[i] + dxs[i] / 3, ys[i] + ms[i] * dxs[i] / 3, xs[i + 1] - dxs[i] / 3, ys[i + 1] - ms[i + 1] * dxs[i] / 3, xs[i + 1], ys[i + 1]);
      }
    }
    return path;
  }
  var cursorPlots = /* @__PURE__ */ new Set();
  function invalidateRects() {
    cursorPlots.forEach((u) => {
      u.syncRect(true);
    });
  }
  if (domEnv) {
    on(resize, win, invalidateRects);
    on(scroll, win, invalidateRects, true);
    on(dppxchange, win, () => {
      uPlot.pxRatio = pxRatio;
    });
  }
  var linearPath = linear();
  var pointsPath = points();
  function setDefaults(d, xo, yo, initY) {
    let d2 = initY ? [d[0], d[1]].concat(d.slice(2)) : [d[0]].concat(d.slice(1));
    return d2.map((o, i) => setDefault(o, i, xo, yo));
  }
  function setDefaults2(d, xyo) {
    return d.map((o, i) => i == 0 ? null : assign({}, xyo, o));
  }
  function setDefault(o, i, xo, yo) {
    return assign({}, i == 0 ? xo : yo, o);
  }
  function snapNumX(self2, dataMin, dataMax) {
    return dataMin == null ? nullNullTuple : [dataMin, dataMax];
  }
  var snapTimeX = snapNumX;
  function snapNumY(self2, dataMin, dataMax) {
    return dataMin == null ? nullNullTuple : rangeNum(dataMin, dataMax, rangePad, true);
  }
  function snapLogY(self2, dataMin, dataMax, scale) {
    return dataMin == null ? nullNullTuple : rangeLog(dataMin, dataMax, self2.scales[scale].log, false);
  }
  var snapLogX = snapLogY;
  function snapAsinhY(self2, dataMin, dataMax, scale) {
    return dataMin == null ? nullNullTuple : rangeAsinh(dataMin, dataMax, self2.scales[scale].log, false);
  }
  var snapAsinhX = snapAsinhY;
  function findIncr(minVal, maxVal, incrs, dim, minSpace) {
    let intDigits = max(numIntDigits(minVal), numIntDigits(maxVal));
    let delta = maxVal - minVal;
    let incrIdx = closestIdx(minSpace / dim * delta, incrs);
    do {
      let foundIncr = incrs[incrIdx];
      let foundSpace = dim * foundIncr / delta;
      if (foundSpace >= minSpace && intDigits + (foundIncr < 5 ? fixedDec.get(foundIncr) : 0) <= 17)
        return [foundIncr, foundSpace];
    } while (++incrIdx < incrs.length);
    return [0, 0];
  }
  function pxRatioFont(font2) {
    let fontSize, fontSizeCss;
    font2 = font2.replace(/(\d+)px/, (m, p1) => (fontSize = round((fontSizeCss = +p1) * pxRatio)) + "px");
    return [font2, fontSize, fontSizeCss];
  }
  function syncFontSize(axis) {
    if (axis.show) {
      [axis.font, axis.labelFont].forEach((f) => {
        let size = roundDec(f[2] * pxRatio, 1);
        f[0] = f[0].replace(/[0-9.]+px/, size + "px");
        f[1] = size;
      });
    }
  }
  function uPlot(opts, data, then) {
    const self2 = {
      mode: ifNull(opts.mode, 1)
    };
    const mode = self2.mode;
    function getValPct(val, scale) {
      let _val = scale.distr == 3 ? log10(val > 0 ? val : scale.clamp(self2, val, scale.min, scale.max, scale.key)) : scale.distr == 4 ? asinh(val, scale.asinh) : val;
      return (_val - scale._min) / (scale._max - scale._min);
    }
    function getHPos(val, scale, dim, off2) {
      let pct = getValPct(val, scale);
      return off2 + dim * (scale.dir == -1 ? 1 - pct : pct);
    }
    function getVPos(val, scale, dim, off2) {
      let pct = getValPct(val, scale);
      return off2 + dim * (scale.dir == -1 ? pct : 1 - pct);
    }
    function getPos(val, scale, dim, off2) {
      return scale.ori == 0 ? getHPos(val, scale, dim, off2) : getVPos(val, scale, dim, off2);
    }
    self2.valToPosH = getHPos;
    self2.valToPosV = getVPos;
    let ready = false;
    self2.status = 0;
    const root = self2.root = placeDiv(UPLOT);
    if (opts.id != null)
      root.id = opts.id;
    addClass(root, opts.class);
    if (opts.title) {
      let title = placeDiv(TITLE2, root);
      title.textContent = opts.title;
    }
    const can = placeTag("canvas");
    const ctx = self2.ctx = can.getContext("2d");
    const wrap = placeDiv(WRAP, root);
    const under = self2.under = placeDiv(UNDER, wrap);
    wrap.appendChild(can);
    const over = self2.over = placeDiv(OVER, wrap);
    opts = copy(opts);
    const pxAlign = +ifNull(opts.pxAlign, 1);
    const pxRound = pxRoundGen(pxAlign);
    (opts.plugins || []).forEach((p) => {
      if (p.opts)
        opts = p.opts(self2, opts) || opts;
    });
    const ms = opts.ms || 1e-3;
    const series = self2.series = mode == 1 ? setDefaults(opts.series || [], xSeriesOpts, ySeriesOpts, false) : setDefaults2(opts.series || [null], xySeriesOpts);
    const axes = self2.axes = setDefaults(opts.axes || [], xAxisOpts, yAxisOpts, true);
    const scales = self2.scales = {};
    const bands = self2.bands = opts.bands || [];
    bands.forEach((b) => {
      b.fill = fnOrSelf(b.fill || null);
      b.dir = ifNull(b.dir, -1);
    });
    const xScaleKey = mode == 2 ? series[1].facets[0].scale : series[0].scale;
    const drawOrderMap = {
      axes: drawAxesGrid,
      series: drawSeries
    };
    const drawOrder = (opts.drawOrder || ["axes", "series"]).map((key2) => drawOrderMap[key2]);
    function initScale(scaleKey) {
      let sc = scales[scaleKey];
      if (sc == null) {
        let scaleOpts = (opts.scales || EMPTY_OBJ)[scaleKey] || EMPTY_OBJ;
        if (scaleOpts.from != null) {
          initScale(scaleOpts.from);
          scales[scaleKey] = assign({}, scales[scaleOpts.from], scaleOpts, { key: scaleKey });
        } else {
          sc = scales[scaleKey] = assign({}, scaleKey == xScaleKey ? xScaleOpts : yScaleOpts, scaleOpts);
          sc.key = scaleKey;
          let isTime = sc.time;
          let rn = sc.range;
          let rangeIsArr = isArr(rn);
          if (scaleKey != xScaleKey || mode == 2 && !isTime) {
            if (rangeIsArr && (rn[0] == null || rn[1] == null)) {
              rn = {
                min: rn[0] == null ? autoRangePart : {
                  mode: 1,
                  hard: rn[0],
                  soft: rn[0]
                },
                max: rn[1] == null ? autoRangePart : {
                  mode: 1,
                  hard: rn[1],
                  soft: rn[1]
                }
              };
              rangeIsArr = false;
            }
            if (!rangeIsArr && isObj(rn)) {
              let cfg = rn;
              rn = (self3, dataMin, dataMax) => dataMin == null ? nullNullTuple : rangeNum(dataMin, dataMax, cfg);
            }
          }
          sc.range = fnOrSelf(rn || (isTime ? snapTimeX : scaleKey == xScaleKey ? sc.distr == 3 ? snapLogX : sc.distr == 4 ? snapAsinhX : snapNumX : sc.distr == 3 ? snapLogY : sc.distr == 4 ? snapAsinhY : snapNumY));
          sc.auto = fnOrSelf(rangeIsArr ? false : sc.auto);
          sc.clamp = fnOrSelf(sc.clamp || clampScale);
          sc._min = sc._max = null;
        }
      }
    }
    initScale("x");
    initScale("y");
    if (mode == 1) {
      series.forEach((s) => {
        initScale(s.scale);
      });
    }
    axes.forEach((a) => {
      initScale(a.scale);
    });
    for (let k in opts.scales)
      initScale(k);
    const scaleX = scales[xScaleKey];
    const xScaleDistr = scaleX.distr;
    let valToPosX, valToPosY;
    if (scaleX.ori == 0) {
      addClass(root, ORI_HZ);
      valToPosX = getHPos;
      valToPosY = getVPos;
    } else {
      addClass(root, ORI_VT);
      valToPosX = getVPos;
      valToPosY = getHPos;
    }
    const pendScales = {};
    for (let k in scales) {
      let sc = scales[k];
      if (sc.min != null || sc.max != null) {
        pendScales[k] = { min: sc.min, max: sc.max };
        sc.min = sc.max = null;
      }
    }
    const _tzDate = opts.tzDate || ((ts) => new Date(round(ts / ms)));
    const _fmtDate = opts.fmtDate || fmtDate;
    const _timeAxisSplits = ms == 1 ? timeAxisSplitsMs(_tzDate) : timeAxisSplitsS(_tzDate);
    const _timeAxisVals = timeAxisVals(_tzDate, timeAxisStamps(ms == 1 ? _timeAxisStampsMs : _timeAxisStampsS, _fmtDate));
    const _timeSeriesVal = timeSeriesVal(_tzDate, timeSeriesStamp(_timeSeriesStamp, _fmtDate));
    const activeIdxs = [];
    const legend = self2.legend = assign({}, legendOpts, opts.legend);
    const showLegend = legend.show;
    const markers = legend.markers;
    {
      legend.idxs = activeIdxs;
      markers.width = fnOrSelf(markers.width);
      markers.dash = fnOrSelf(markers.dash);
      markers.stroke = fnOrSelf(markers.stroke);
      markers.fill = fnOrSelf(markers.fill);
    }
    let legendEl;
    let legendRows = [];
    let legendCells = [];
    let legendCols;
    let multiValLegend = false;
    let NULL_LEGEND_VALUES = {};
    if (legend.live) {
      const getMultiVals = series[1] ? series[1].values : null;
      multiValLegend = getMultiVals != null;
      legendCols = multiValLegend ? getMultiVals(self2, 1, 0) : { _: 0 };
      for (let k in legendCols)
        NULL_LEGEND_VALUES[k] = "--";
    }
    if (showLegend) {
      legendEl = placeTag("table", LEGEND, root);
      if (multiValLegend) {
        let head = placeTag("tr", LEGEND_THEAD, legendEl);
        placeTag("th", null, head);
        for (var key in legendCols)
          placeTag("th", LEGEND_LABEL, head).textContent = key;
      } else {
        addClass(legendEl, LEGEND_INLINE);
        legend.live && addClass(legendEl, LEGEND_LIVE);
      }
    }
    const son = { show: true };
    const soff = { show: false };
    function initLegendRow(s, i) {
      if (i == 0 && (multiValLegend || !legend.live || mode == 2))
        return nullNullTuple;
      let cells = [];
      let row = placeTag("tr", LEGEND_SERIES, legendEl, legendEl.childNodes[i]);
      addClass(row, s.class);
      if (!s.show)
        addClass(row, OFF);
      let label = placeTag("th", null, row);
      if (markers.show) {
        let indic = placeDiv(LEGEND_MARKER, label);
        if (i > 0) {
          let width = markers.width(self2, i);
          if (width)
            indic.style.border = width + "px " + markers.dash(self2, i) + " " + markers.stroke(self2, i);
          indic.style.background = markers.fill(self2, i);
        }
      }
      let text = placeDiv(LEGEND_LABEL, label);
      text.textContent = s.label;
      if (i > 0) {
        if (!markers.show)
          text.style.color = s.width > 0 ? markers.stroke(self2, i) : markers.fill(self2, i);
        onMouse("click", label, (e) => {
          if (cursor._lock)
            return;
          let seriesIdx = series.indexOf(s);
          if ((e.ctrlKey || e.metaKey) != legend.isolate) {
            let isolate = series.some((s2, i2) => i2 > 0 && i2 != seriesIdx && s2.show);
            series.forEach((s2, i2) => {
              i2 > 0 && setSeries(i2, isolate ? i2 == seriesIdx ? son : soff : son, true, syncOpts.setSeries);
            });
          } else
            setSeries(seriesIdx, { show: !s.show }, true, syncOpts.setSeries);
        });
        if (cursorFocus) {
          onMouse(mouseenter, label, (e) => {
            if (cursor._lock)
              return;
            setSeries(series.indexOf(s), FOCUS_TRUE, true, syncOpts.setSeries);
          });
        }
      }
      for (var key2 in legendCols) {
        let v = placeTag("td", LEGEND_VALUE, row);
        v.textContent = "--";
        cells.push(v);
      }
      return [row, cells];
    }
    const mouseListeners = /* @__PURE__ */ new Map();
    function onMouse(ev, targ, fn) {
      const targListeners = mouseListeners.get(targ) || {};
      const listener = cursor.bind[ev](self2, targ, fn);
      if (listener) {
        on(ev, targ, targListeners[ev] = listener);
        mouseListeners.set(targ, targListeners);
      }
    }
    function offMouse(ev, targ, fn) {
      const targListeners = mouseListeners.get(targ) || {};
      for (let k in targListeners) {
        if (ev == null || k == ev) {
          off(k, targ, targListeners[k]);
          delete targListeners[k];
        }
      }
      if (ev == null)
        mouseListeners.delete(targ);
    }
    let fullWidCss = 0;
    let fullHgtCss = 0;
    let plotWidCss = 0;
    let plotHgtCss = 0;
    let plotLftCss = 0;
    let plotTopCss = 0;
    let plotLft = 0;
    let plotTop = 0;
    let plotWid = 0;
    let plotHgt = 0;
    self2.bbox = {};
    let shouldSetScales = false;
    let shouldSetSize = false;
    let shouldConvergeSize = false;
    let shouldSetCursor = false;
    let shouldSetLegend = false;
    function _setSize(width, height, force) {
      if (force || (width != self2.width || height != self2.height))
        calcSize(width, height);
      resetYSeries(false);
      shouldConvergeSize = true;
      shouldSetSize = true;
      shouldSetCursor = shouldSetLegend = cursor.left >= 0;
      commit();
    }
    function calcSize(width, height) {
      self2.width = fullWidCss = plotWidCss = width;
      self2.height = fullHgtCss = plotHgtCss = height;
      plotLftCss = plotTopCss = 0;
      calcPlotRect();
      calcAxesRects();
      let bb = self2.bbox;
      plotLft = bb.left = incrRound(plotLftCss * pxRatio, 0.5);
      plotTop = bb.top = incrRound(plotTopCss * pxRatio, 0.5);
      plotWid = bb.width = incrRound(plotWidCss * pxRatio, 0.5);
      plotHgt = bb.height = incrRound(plotHgtCss * pxRatio, 0.5);
    }
    const CYCLE_LIMIT = 3;
    function convergeSize() {
      let converged = false;
      let cycleNum = 0;
      while (!converged) {
        cycleNum++;
        let axesConverged = axesCalc(cycleNum);
        let paddingConverged = paddingCalc(cycleNum);
        converged = cycleNum == CYCLE_LIMIT || axesConverged && paddingConverged;
        if (!converged) {
          calcSize(self2.width, self2.height);
          shouldSetSize = true;
        }
      }
    }
    function setSize({ width, height }) {
      _setSize(width, height);
    }
    self2.setSize = setSize;
    function calcPlotRect() {
      let hasTopAxis = false;
      let hasBtmAxis = false;
      let hasRgtAxis = false;
      let hasLftAxis = false;
      axes.forEach((axis, i) => {
        if (axis.show && axis._show) {
          let { side, _size } = axis;
          let isVt = side % 2;
          let labelSize = axis.label != null ? axis.labelSize : 0;
          let fullSize = _size + labelSize;
          if (fullSize > 0) {
            if (isVt) {
              plotWidCss -= fullSize;
              if (side == 3) {
                plotLftCss += fullSize;
                hasLftAxis = true;
              } else
                hasRgtAxis = true;
            } else {
              plotHgtCss -= fullSize;
              if (side == 0) {
                plotTopCss += fullSize;
                hasTopAxis = true;
              } else
                hasBtmAxis = true;
            }
          }
        }
      });
      sidesWithAxes[0] = hasTopAxis;
      sidesWithAxes[1] = hasRgtAxis;
      sidesWithAxes[2] = hasBtmAxis;
      sidesWithAxes[3] = hasLftAxis;
      plotWidCss -= _padding[1] + _padding[3];
      plotLftCss += _padding[3];
      plotHgtCss -= _padding[2] + _padding[0];
      plotTopCss += _padding[0];
    }
    function calcAxesRects() {
      let off1 = plotLftCss + plotWidCss;
      let off2 = plotTopCss + plotHgtCss;
      let off3 = plotLftCss;
      let off0 = plotTopCss;
      function incrOffset(side, size) {
        switch (side) {
          case 1:
            off1 += size;
            return off1 - size;
          case 2:
            off2 += size;
            return off2 - size;
          case 3:
            off3 -= size;
            return off3 + size;
          case 0:
            off0 -= size;
            return off0 + size;
        }
      }
      axes.forEach((axis, i) => {
        if (axis.show && axis._show) {
          let side = axis.side;
          axis._pos = incrOffset(side, axis._size);
          if (axis.label != null)
            axis._lpos = incrOffset(side, axis.labelSize);
        }
      });
    }
    const cursor = self2.cursor = assign({}, cursorOpts, { drag: { y: mode == 2 } }, opts.cursor);
    {
      cursor.idxs = activeIdxs;
      cursor._lock = false;
      let points2 = cursor.points;
      points2.show = fnOrSelf(points2.show);
      points2.size = fnOrSelf(points2.size);
      points2.stroke = fnOrSelf(points2.stroke);
      points2.width = fnOrSelf(points2.width);
      points2.fill = fnOrSelf(points2.fill);
    }
    const focus = self2.focus = assign({}, opts.focus || { alpha: 0.3 }, cursor.focus);
    const cursorFocus = focus.prox >= 0;
    let cursorPts = [null];
    function initCursorPt(s, si) {
      if (si > 0) {
        let pt = cursor.points.show(self2, si);
        if (pt) {
          addClass(pt, CURSOR_PT);
          addClass(pt, s.class);
          elTrans(pt, -10, -10, plotWidCss, plotHgtCss);
          over.insertBefore(pt, cursorPts[si]);
          return pt;
        }
      }
    }
    function initSeries(s, i) {
      if (mode == 1 || i > 0) {
        let isTime = mode == 1 && scales[s.scale].time;
        let sv = s.value;
        s.value = isTime ? isStr(sv) ? timeSeriesVal(_tzDate, timeSeriesStamp(sv, _fmtDate)) : sv || _timeSeriesVal : sv || numSeriesVal;
        s.label = s.label || (isTime ? timeSeriesLabel : numSeriesLabel);
      }
      if (i > 0) {
        s.width = s.width == null ? 1 : s.width;
        s.paths = s.paths || linearPath || retNull;
        s.fillTo = fnOrSelf(s.fillTo || seriesFillTo);
        s.pxAlign = +ifNull(s.pxAlign, pxAlign);
        s.pxRound = pxRoundGen(s.pxAlign);
        s.stroke = fnOrSelf(s.stroke || null);
        s.fill = fnOrSelf(s.fill || null);
        s._stroke = s._fill = s._paths = s._focus = null;
        let _ptDia = ptDia(s.width, 1);
        let points2 = s.points = assign({}, {
          size: _ptDia,
          width: max(1, _ptDia * 0.2),
          stroke: s.stroke,
          space: _ptDia * 2,
          paths: pointsPath,
          _stroke: null,
          _fill: null
        }, s.points);
        points2.show = fnOrSelf(points2.show);
        points2.filter = fnOrSelf(points2.filter);
        points2.fill = fnOrSelf(points2.fill);
        points2.stroke = fnOrSelf(points2.stroke);
        points2.paths = fnOrSelf(points2.paths);
        points2.pxAlign = s.pxAlign;
      }
      if (showLegend) {
        let rowCells = initLegendRow(s, i);
        legendRows.splice(i, 0, rowCells[0]);
        legendCells.splice(i, 0, rowCells[1]);
        legend.values.push(null);
      }
      if (cursor.show) {
        activeIdxs.splice(i, 0, null);
        let pt = initCursorPt(s, i);
        pt && cursorPts.splice(i, 0, pt);
      }
      fire("addSeries", i);
    }
    function addSeries(opts2, si) {
      si = si == null ? series.length : si;
      opts2 = setDefault(opts2, si, xSeriesOpts, ySeriesOpts);
      series.splice(si, 0, opts2);
      initSeries(series[si], si);
    }
    self2.addSeries = addSeries;
    function delSeries(i) {
      series.splice(i, 1);
      if (showLegend) {
        legend.values.splice(i, 1);
        legendCells.splice(i, 1);
        let tr = legendRows.splice(i, 1)[0];
        offMouse(null, tr.firstChild);
        tr.remove();
      }
      if (cursor.show) {
        activeIdxs.splice(i, 1);
        cursorPts.length > 1 && cursorPts.splice(i, 1)[0].remove();
      }
      fire("delSeries", i);
    }
    self2.delSeries = delSeries;
    const sidesWithAxes = [false, false, false, false];
    function initAxis(axis, i) {
      axis._show = axis.show;
      if (axis.show) {
        let isVt = axis.side % 2;
        let sc = scales[axis.scale];
        if (sc == null) {
          axis.scale = isVt ? series[1].scale : xScaleKey;
          sc = scales[axis.scale];
        }
        let isTime = sc.time;
        axis.size = fnOrSelf(axis.size);
        axis.space = fnOrSelf(axis.space);
        axis.rotate = fnOrSelf(axis.rotate);
        axis.incrs = fnOrSelf(axis.incrs || (sc.distr == 2 ? wholeIncrs : isTime ? ms == 1 ? timeIncrsMs : timeIncrsS : numIncrs));
        axis.splits = fnOrSelf(axis.splits || (isTime && sc.distr == 1 ? _timeAxisSplits : sc.distr == 3 ? logAxisSplits : sc.distr == 4 ? asinhAxisSplits : numAxisSplits));
        axis.stroke = fnOrSelf(axis.stroke);
        axis.grid.stroke = fnOrSelf(axis.grid.stroke);
        axis.ticks.stroke = fnOrSelf(axis.ticks.stroke);
        axis.border.stroke = fnOrSelf(axis.border.stroke);
        let av = axis.values;
        axis.values = isArr(av) && !isArr(av[0]) ? fnOrSelf(av) : isTime ? isArr(av) ? timeAxisVals(_tzDate, timeAxisStamps(av, _fmtDate)) : isStr(av) ? timeAxisVal(_tzDate, av) : av || _timeAxisVals : av || numAxisVals;
        axis.filter = fnOrSelf(axis.filter || (sc.distr >= 3 ? logAxisValsFilt : retArg1));
        axis.font = pxRatioFont(axis.font);
        axis.labelFont = pxRatioFont(axis.labelFont);
        axis._size = axis.size(self2, null, i, 0);
        axis._space = axis._rotate = axis._incrs = axis._found = axis._splits = axis._values = null;
        if (axis._size > 0) {
          sidesWithAxes[i] = true;
          axis._el = placeDiv(AXIS, wrap);
        }
      }
    }
    function autoPadSide(self3, side, sidesWithAxes2, cycleNum) {
      let [hasTopAxis, hasRgtAxis, hasBtmAxis, hasLftAxis] = sidesWithAxes2;
      let ori = side % 2;
      let size = 0;
      if (ori == 0 && (hasLftAxis || hasRgtAxis))
        size = side == 0 && !hasTopAxis || side == 2 && !hasBtmAxis ? round(xAxisOpts.size / 3) : 0;
      if (ori == 1 && (hasTopAxis || hasBtmAxis))
        size = side == 1 && !hasRgtAxis || side == 3 && !hasLftAxis ? round(yAxisOpts.size / 2) : 0;
      return size;
    }
    const padding = self2.padding = (opts.padding || [autoPadSide, autoPadSide, autoPadSide, autoPadSide]).map((p) => fnOrSelf(ifNull(p, autoPadSide)));
    const _padding = self2._padding = padding.map((p, i) => p(self2, i, sidesWithAxes, 0));
    let dataLen;
    let i0 = null;
    let i1 = null;
    const idxs = mode == 1 ? series[0].idxs : null;
    let data0 = null;
    let viaAutoScaleX = false;
    function setData(_data, _resetScales) {
      data = _data == null ? [] : copy(_data, fastIsObj);
      if (mode == 2) {
        dataLen = 0;
        for (let i = 1; i < series.length; i++)
          dataLen += data[i][0].length;
        self2.data = data = _data;
      } else {
        if (data[0] == null)
          data[0] = [];
        self2.data = data.slice();
        data0 = data[0];
        dataLen = data0.length;
        if (xScaleDistr == 2) {
          data[0] = Array(dataLen);
          for (let i = 0; i < dataLen; i++)
            data[0][i] = i;
        }
      }
      self2._data = data;
      resetYSeries(true);
      fire("setData");
      if (xScaleDistr == 2) {
        shouldConvergeSize = true;
      }
      if (_resetScales !== false) {
        let xsc = scaleX;
        if (xsc.auto(self2, viaAutoScaleX))
          autoScaleX();
        else
          _setScale(xScaleKey, xsc.min, xsc.max);
        shouldSetCursor = cursor.left >= 0;
        shouldSetLegend = true;
        commit();
      }
    }
    self2.setData = setData;
    function autoScaleX() {
      viaAutoScaleX = true;
      let _min, _max;
      if (mode == 1) {
        if (dataLen > 0) {
          i0 = idxs[0] = 0;
          i1 = idxs[1] = dataLen - 1;
          _min = data[0][i0];
          _max = data[0][i1];
          if (xScaleDistr == 2) {
            _min = i0;
            _max = i1;
          } else if (dataLen == 1) {
            if (xScaleDistr == 3)
              [_min, _max] = rangeLog(_min, _min, scaleX.log, false);
            else if (xScaleDistr == 4)
              [_min, _max] = rangeAsinh(_min, _min, scaleX.log, false);
            else if (scaleX.time)
              _max = _min + round(86400 / ms);
            else
              [_min, _max] = rangeNum(_min, _max, rangePad, true);
          }
        } else {
          i0 = idxs[0] = _min = null;
          i1 = idxs[1] = _max = null;
        }
      }
      _setScale(xScaleKey, _min, _max);
    }
    let ctxStroke, ctxFill, ctxWidth, ctxDash, ctxJoin, ctxCap, ctxFont, ctxAlign, ctxBaseline;
    let ctxAlpha;
    function setCtxStyle(stroke = transparent, width, dash = EMPTY_ARR, cap = "butt", fill = transparent, join2 = "round") {
      if (stroke != ctxStroke)
        ctx.strokeStyle = ctxStroke = stroke;
      if (fill != ctxFill)
        ctx.fillStyle = ctxFill = fill;
      if (width != ctxWidth)
        ctx.lineWidth = ctxWidth = width;
      if (join2 != ctxJoin)
        ctx.lineJoin = ctxJoin = join2;
      if (cap != ctxCap)
        ctx.lineCap = ctxCap = cap;
      if (dash != ctxDash)
        ctx.setLineDash(ctxDash = dash);
    }
    function setFontStyle(font2, fill, align, baseline) {
      if (fill != ctxFill)
        ctx.fillStyle = ctxFill = fill;
      if (font2 != ctxFont)
        ctx.font = ctxFont = font2;
      if (align != ctxAlign)
        ctx.textAlign = ctxAlign = align;
      if (baseline != ctxBaseline)
        ctx.textBaseline = ctxBaseline = baseline;
    }
    function accScale(wsc, psc, facet2, data2, sorted = 0) {
      if (data2.length > 0 && wsc.auto(self2, viaAutoScaleX) && (psc == null || psc.min == null)) {
        let _i0 = ifNull(i0, 0);
        let _i1 = ifNull(i1, data2.length - 1);
        let minMax = facet2.min == null ? wsc.distr == 3 ? getMinMaxLog(data2, _i0, _i1) : getMinMax(data2, _i0, _i1, sorted) : [facet2.min, facet2.max];
        wsc.min = min(wsc.min, facet2.min = minMax[0]);
        wsc.max = max(wsc.max, facet2.max = minMax[1]);
      }
    }
    function setScales() {
      let wipScales = copy(scales, fastIsObj);
      for (let k in wipScales) {
        let wsc = wipScales[k];
        let psc = pendScales[k];
        if (psc != null && psc.min != null) {
          assign(wsc, psc);
          if (k == xScaleKey)
            resetYSeries(true);
        } else if (k != xScaleKey || mode == 2) {
          if (dataLen == 0 && wsc.from == null) {
            let minMax = wsc.range(self2, null, null, k);
            wsc.min = minMax[0];
            wsc.max = minMax[1];
          } else {
            wsc.min = inf;
            wsc.max = -inf;
          }
        }
      }
      if (dataLen > 0) {
        series.forEach((s, i) => {
          if (mode == 1) {
            let k = s.scale;
            let wsc = wipScales[k];
            let psc = pendScales[k];
            if (i == 0) {
              let minMax = wsc.range(self2, wsc.min, wsc.max, k);
              wsc.min = minMax[0];
              wsc.max = minMax[1];
              i0 = closestIdx(wsc.min, data[0]);
              i1 = closestIdx(wsc.max, data[0]);
              if (data[0][i0] < wsc.min)
                i0++;
              if (data[0][i1] > wsc.max)
                i1--;
              s.min = data0[i0];
              s.max = data0[i1];
            } else if (s.show && s.auto)
              accScale(wsc, psc, s, data[i], s.sorted);
            s.idxs[0] = i0;
            s.idxs[1] = i1;
          } else {
            if (i > 0) {
              if (s.show && s.auto) {
                let [xFacet, yFacet] = s.facets;
                let xScaleKey2 = xFacet.scale;
                let yScaleKey = yFacet.scale;
                let [xData, yData] = data[i];
                accScale(wipScales[xScaleKey2], pendScales[xScaleKey2], xFacet, xData, xFacet.sorted);
                accScale(wipScales[yScaleKey], pendScales[yScaleKey], yFacet, yData, yFacet.sorted);
                s.min = yFacet.min;
                s.max = yFacet.max;
              }
            }
          }
        });
        for (let k in wipScales) {
          let wsc = wipScales[k];
          let psc = pendScales[k];
          if (wsc.from == null && (psc == null || psc.min == null)) {
            let minMax = wsc.range(self2, wsc.min == inf ? null : wsc.min, wsc.max == -inf ? null : wsc.max, k);
            wsc.min = minMax[0];
            wsc.max = minMax[1];
          }
        }
      }
      for (let k in wipScales) {
        let wsc = wipScales[k];
        if (wsc.from != null) {
          let base = wipScales[wsc.from];
          if (base.min == null)
            wsc.min = wsc.max = null;
          else {
            let minMax = wsc.range(self2, base.min, base.max, k);
            wsc.min = minMax[0];
            wsc.max = minMax[1];
          }
        }
      }
      let changed = {};
      let anyChanged = false;
      for (let k in wipScales) {
        let wsc = wipScales[k];
        let sc = scales[k];
        if (sc.min != wsc.min || sc.max != wsc.max) {
          sc.min = wsc.min;
          sc.max = wsc.max;
          let distr = sc.distr;
          sc._min = distr == 3 ? log10(sc.min) : distr == 4 ? asinh(sc.min, sc.asinh) : sc.min;
          sc._max = distr == 3 ? log10(sc.max) : distr == 4 ? asinh(sc.max, sc.asinh) : sc.max;
          changed[k] = anyChanged = true;
        }
      }
      if (anyChanged) {
        series.forEach((s, i) => {
          if (mode == 2) {
            if (i > 0 && changed.y)
              s._paths = null;
          } else {
            if (changed[s.scale])
              s._paths = null;
          }
        });
        for (let k in changed) {
          shouldConvergeSize = true;
          fire("setScale", k);
        }
        if (cursor.show)
          shouldSetCursor = shouldSetLegend = cursor.left >= 0;
      }
      for (let k in pendScales)
        pendScales[k] = null;
    }
    function getOuterIdxs(ydata) {
      let _i0 = clamp(i0 - 1, 0, dataLen - 1);
      let _i1 = clamp(i1 + 1, 0, dataLen - 1);
      while (ydata[_i0] == null && _i0 > 0)
        _i0--;
      while (ydata[_i1] == null && _i1 < dataLen - 1)
        _i1++;
      return [_i0, _i1];
    }
    function drawSeries() {
      if (dataLen > 0) {
        series.forEach((s, i) => {
          if (i > 0 && s.show && s._paths == null) {
            let _idxs = getOuterIdxs(data[i]);
            s._paths = s.paths(self2, i, _idxs[0], _idxs[1]);
          }
        });
        series.forEach((s, i) => {
          if (i > 0 && s.show) {
            if (ctxAlpha != s.alpha)
              ctx.globalAlpha = ctxAlpha = s.alpha;
            {
              cacheStrokeFill(i, false);
              s._paths && drawPath(i, false);
            }
            {
              cacheStrokeFill(i, true);
              let show = s.points.show(self2, i, i0, i1);
              let idxs2 = s.points.filter(self2, i, show, s._paths ? s._paths.gaps : null);
              if (show || idxs2) {
                s.points._paths = s.points.paths(self2, i, i0, i1, idxs2);
                drawPath(i, true);
              }
            }
            if (ctxAlpha != 1)
              ctx.globalAlpha = ctxAlpha = 1;
            fire("drawSeries", i);
          }
        });
      }
    }
    function cacheStrokeFill(si, _points) {
      let s = _points ? series[si].points : series[si];
      s._stroke = s.stroke(self2, si);
      s._fill = s.fill(self2, si);
    }
    function drawPath(si, _points) {
      let s = _points ? series[si].points : series[si];
      let strokeStyle = s._stroke;
      let fillStyle = s._fill;
      let { stroke, fill, clip: gapsClip, flags } = s._paths;
      let boundsClip = null;
      let width = roundDec(s.width * pxRatio, 3);
      let offset = width % 2 / 2;
      if (_points && fillStyle == null)
        fillStyle = width > 0 ? "#fff" : strokeStyle;
      let _pxAlign = s.pxAlign == 1;
      _pxAlign && ctx.translate(offset, offset);
      if (!_points) {
        let lft = plotLft, top = plotTop, wid = plotWid, hgt = plotHgt;
        let halfWid = width * pxRatio / 2;
        if (s.min == 0)
          hgt += halfWid;
        if (s.max == 0) {
          top -= halfWid;
          hgt += halfWid;
        }
        boundsClip = new Path2D();
        boundsClip.rect(lft, top, wid, hgt);
      }
      if (_points)
        strokeFill(strokeStyle, width, s.dash, s.cap, fillStyle, stroke, fill, flags, gapsClip);
      else
        fillStroke(si, strokeStyle, width, s.dash, s.cap, fillStyle, stroke, fill, flags, boundsClip, gapsClip);
      _pxAlign && ctx.translate(-offset, -offset);
    }
    function fillStroke(si, strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip) {
      let didStrokeFill = false;
      bands.forEach((b, bi) => {
        if (b.series[0] == si) {
          let lowerEdge = series[b.series[1]];
          let lowerData = data[b.series[1]];
          let bandClip = (lowerEdge._paths || EMPTY_OBJ).band;
          if (isArr(bandClip))
            bandClip = b.dir == 1 ? bandClip[0] : bandClip[1];
          let gapsClip2;
          let _fillStyle = null;
          if (lowerEdge.show && bandClip && hasData(lowerData, i0, i1)) {
            _fillStyle = b.fill(self2, bi) || fillStyle;
            gapsClip2 = lowerEdge._paths.clip;
          } else
            bandClip = null;
          strokeFill(strokeStyle, lineWidth, lineDash, lineCap, _fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip, gapsClip2, bandClip);
          didStrokeFill = true;
        }
      });
      if (!didStrokeFill)
        strokeFill(strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip);
    }
    const CLIP_FILL_STROKE = BAND_CLIP_FILL | BAND_CLIP_STROKE;
    function strokeFill(strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip, gapsClip2, bandClip) {
      setCtxStyle(strokeStyle, lineWidth, lineDash, lineCap, fillStyle);
      if (boundsClip || gapsClip || bandClip) {
        ctx.save();
        boundsClip && ctx.clip(boundsClip);
        gapsClip && ctx.clip(gapsClip);
      }
      if (bandClip) {
        if ((flags & CLIP_FILL_STROKE) == CLIP_FILL_STROKE) {
          ctx.clip(bandClip);
          gapsClip2 && ctx.clip(gapsClip2);
          doFill(fillStyle, fillPath);
          doStroke(strokeStyle, strokePath, lineWidth);
        } else if (flags & BAND_CLIP_STROKE) {
          doFill(fillStyle, fillPath);
          ctx.clip(bandClip);
          doStroke(strokeStyle, strokePath, lineWidth);
        } else if (flags & BAND_CLIP_FILL) {
          ctx.save();
          ctx.clip(bandClip);
          gapsClip2 && ctx.clip(gapsClip2);
          doFill(fillStyle, fillPath);
          ctx.restore();
          doStroke(strokeStyle, strokePath, lineWidth);
        }
      } else {
        doFill(fillStyle, fillPath);
        doStroke(strokeStyle, strokePath, lineWidth);
      }
      if (boundsClip || gapsClip || bandClip)
        ctx.restore();
    }
    function doStroke(strokeStyle, strokePath, lineWidth) {
      if (lineWidth > 0) {
        if (strokePath instanceof Map) {
          strokePath.forEach((strokePath2, strokeStyle2) => {
            ctx.strokeStyle = ctxStroke = strokeStyle2;
            ctx.stroke(strokePath2);
          });
        } else
          strokePath != null && strokeStyle && ctx.stroke(strokePath);
      }
    }
    function doFill(fillStyle, fillPath) {
      if (fillPath instanceof Map) {
        fillPath.forEach((fillPath2, fillStyle2) => {
          ctx.fillStyle = ctxFill = fillStyle2;
          ctx.fill(fillPath2);
        });
      } else
        fillPath != null && fillStyle && ctx.fill(fillPath);
    }
    function getIncrSpace(axisIdx, min2, max2, fullDim) {
      let axis = axes[axisIdx];
      let incrSpace;
      if (fullDim <= 0)
        incrSpace = [0, 0];
      else {
        let minSpace = axis._space = axis.space(self2, axisIdx, min2, max2, fullDim);
        let incrs = axis._incrs = axis.incrs(self2, axisIdx, min2, max2, fullDim, minSpace);
        incrSpace = findIncr(min2, max2, incrs, fullDim, minSpace);
      }
      return axis._found = incrSpace;
    }
    function drawOrthoLines(offs, filts, ori, side, pos0, len, width, stroke, dash, cap) {
      let offset = width % 2 / 2;
      pxAlign == 1 && ctx.translate(offset, offset);
      setCtxStyle(stroke, width, dash, cap, stroke);
      ctx.beginPath();
      let x0, y0, x1, y1, pos1 = pos0 + (side == 0 || side == 3 ? -len : len);
      if (ori == 0) {
        y0 = pos0;
        y1 = pos1;
      } else {
        x0 = pos0;
        x1 = pos1;
      }
      for (let i = 0; i < offs.length; i++) {
        if (filts[i] != null) {
          if (ori == 0)
            x0 = x1 = offs[i];
          else
            y0 = y1 = offs[i];
          ctx.moveTo(x0, y0);
          ctx.lineTo(x1, y1);
        }
      }
      ctx.stroke();
      pxAlign == 1 && ctx.translate(-offset, -offset);
    }
    function axesCalc(cycleNum) {
      let converged = true;
      axes.forEach((axis, i) => {
        if (!axis.show)
          return;
        let scale = scales[axis.scale];
        if (scale.min == null) {
          if (axis._show) {
            converged = false;
            axis._show = false;
            resetYSeries(false);
          }
          return;
        } else {
          if (!axis._show) {
            converged = false;
            axis._show = true;
            resetYSeries(false);
          }
        }
        let side = axis.side;
        let ori = side % 2;
        let { min: min2, max: max2 } = scale;
        let [_incr, _space] = getIncrSpace(i, min2, max2, ori == 0 ? plotWidCss : plotHgtCss);
        if (_space == 0)
          return;
        let forceMin = scale.distr == 2;
        let _splits = axis._splits = axis.splits(self2, i, min2, max2, _incr, _space, forceMin);
        let splits = scale.distr == 2 ? _splits.map((i2) => data0[i2]) : _splits;
        let incr = scale.distr == 2 ? data0[_splits[1]] - data0[_splits[0]] : _incr;
        let values = axis._values = axis.values(self2, axis.filter(self2, splits, i, _space, incr), i, _space, incr);
        axis._rotate = side == 2 ? axis.rotate(self2, values, i, _space) : 0;
        let oldSize = axis._size;
        axis._size = ceil(axis.size(self2, values, i, cycleNum));
        if (oldSize != null && axis._size != oldSize)
          converged = false;
      });
      return converged;
    }
    function paddingCalc(cycleNum) {
      let converged = true;
      padding.forEach((p, i) => {
        let _p = p(self2, i, sidesWithAxes, cycleNum);
        if (_p != _padding[i])
          converged = false;
        _padding[i] = _p;
      });
      return converged;
    }
    function drawAxesGrid() {
      for (let i = 0; i < axes.length; i++) {
        let axis = axes[i];
        if (!axis.show || !axis._show)
          continue;
        let side = axis.side;
        let ori = side % 2;
        let x, y;
        let fillStyle = axis.stroke(self2, i);
        let shiftDir = side == 0 || side == 3 ? -1 : 1;
        if (axis.label) {
          let shiftAmt2 = axis.labelGap * shiftDir;
          let baseLpos = round((axis._lpos + shiftAmt2) * pxRatio);
          setFontStyle(axis.labelFont[0], fillStyle, "center", side == 2 ? TOP : BOTTOM);
          ctx.save();
          if (ori == 1) {
            x = y = 0;
            ctx.translate(baseLpos, round(plotTop + plotHgt / 2));
            ctx.rotate((side == 3 ? -PI : PI) / 2);
          } else {
            x = round(plotLft + plotWid / 2);
            y = baseLpos;
          }
          ctx.fillText(axis.label, x, y);
          ctx.restore();
        }
        let [_incr, _space] = axis._found;
        if (_space == 0)
          continue;
        let scale = scales[axis.scale];
        let plotDim = ori == 0 ? plotWid : plotHgt;
        let plotOff = ori == 0 ? plotLft : plotTop;
        let axisGap = round(axis.gap * pxRatio);
        let _splits = axis._splits;
        let splits = scale.distr == 2 ? _splits.map((i2) => data0[i2]) : _splits;
        let incr = scale.distr == 2 ? data0[_splits[1]] - data0[_splits[0]] : _incr;
        let ticks2 = axis.ticks;
        let border2 = axis.border;
        let tickSize = ticks2.show ? round(ticks2.size * pxRatio) : 0;
        let angle = axis._rotate * -PI / 180;
        let basePos = pxRound(axis._pos * pxRatio);
        let shiftAmt = (tickSize + axisGap) * shiftDir;
        let finalPos = basePos + shiftAmt;
        y = ori == 0 ? finalPos : 0;
        x = ori == 1 ? finalPos : 0;
        let font2 = axis.font[0];
        let textAlign = axis.align == 1 ? LEFT : axis.align == 2 ? RIGHT : angle > 0 ? LEFT : angle < 0 ? RIGHT : ori == 0 ? "center" : side == 3 ? RIGHT : LEFT;
        let textBaseline = angle || ori == 1 ? "middle" : side == 2 ? TOP : BOTTOM;
        setFontStyle(font2, fillStyle, textAlign, textBaseline);
        let lineHeight = axis.font[1] * lineMult;
        let canOffs = _splits.map((val) => pxRound(getPos(val, scale, plotDim, plotOff)));
        let _values = axis._values;
        for (let i2 = 0; i2 < _values.length; i2++) {
          let val = _values[i2];
          if (val != null) {
            if (ori == 0)
              x = canOffs[i2];
            else
              y = canOffs[i2];
            val = "" + val;
            let _parts = val.indexOf("\n") == -1 ? [val] : val.split(/\n/gm);
            for (let j = 0; j < _parts.length; j++) {
              let text = _parts[j];
              if (angle) {
                ctx.save();
                ctx.translate(x, y + j * lineHeight);
                ctx.rotate(angle);
                ctx.fillText(text, 0, 0);
                ctx.restore();
              } else
                ctx.fillText(text, x, y + j * lineHeight);
            }
          }
        }
        if (ticks2.show) {
          drawOrthoLines(canOffs, ticks2.filter(self2, splits, i, _space, incr), ori, side, basePos, tickSize, roundDec(ticks2.width * pxRatio, 3), ticks2.stroke(self2, i), ticks2.dash, ticks2.cap);
        }
        let grid2 = axis.grid;
        if (grid2.show) {
          drawOrthoLines(canOffs, grid2.filter(self2, splits, i, _space, incr), ori, ori == 0 ? 2 : 1, ori == 0 ? plotTop : plotLft, ori == 0 ? plotHgt : plotWid, roundDec(grid2.width * pxRatio, 3), grid2.stroke(self2, i), grid2.dash, grid2.cap);
        }
        if (border2.show) {
          drawOrthoLines([basePos], [1], ori == 0 ? 1 : 0, ori == 0 ? 1 : 2, ori == 1 ? plotTop : plotLft, ori == 1 ? plotHgt : plotWid, roundDec(border2.width * pxRatio, 3), border2.stroke(self2, i), border2.dash, border2.cap);
        }
      }
      fire("drawAxes");
    }
    function resetYSeries(minMax) {
      series.forEach((s, i) => {
        if (i > 0) {
          s._paths = null;
          if (minMax) {
            if (mode == 1) {
              s.min = null;
              s.max = null;
            } else {
              s.facets.forEach((f) => {
                f.min = null;
                f.max = null;
              });
            }
          }
        }
      });
    }
    let queuedCommit = false;
    function commit() {
      if (!queuedCommit) {
        microTask(_commit);
        queuedCommit = true;
      }
    }
    function _commit() {
      if (shouldSetScales) {
        setScales();
        shouldSetScales = false;
      }
      if (shouldConvergeSize) {
        convergeSize();
        shouldConvergeSize = false;
      }
      if (shouldSetSize) {
        setStylePx(under, LEFT, plotLftCss);
        setStylePx(under, TOP, plotTopCss);
        setStylePx(under, WIDTH, plotWidCss);
        setStylePx(under, HEIGHT, plotHgtCss);
        setStylePx(over, LEFT, plotLftCss);
        setStylePx(over, TOP, plotTopCss);
        setStylePx(over, WIDTH, plotWidCss);
        setStylePx(over, HEIGHT, plotHgtCss);
        setStylePx(wrap, WIDTH, fullWidCss);
        setStylePx(wrap, HEIGHT, fullHgtCss);
        can.width = round(fullWidCss * pxRatio);
        can.height = round(fullHgtCss * pxRatio);
        axes.forEach(({ _el, _show, _size, _pos, side }) => {
          if (_el != null) {
            if (_show) {
              let posOffset = side === 3 || side === 0 ? _size : 0;
              let isVt = side % 2 == 1;
              setStylePx(_el, isVt ? "left" : "top", _pos - posOffset);
              setStylePx(_el, isVt ? "width" : "height", _size);
              setStylePx(_el, isVt ? "top" : "left", isVt ? plotTopCss : plotLftCss);
              setStylePx(_el, isVt ? "height" : "width", isVt ? plotHgtCss : plotWidCss);
              remClass(_el, OFF);
            } else
              addClass(_el, OFF);
          }
        });
        ctxStroke = ctxFill = ctxWidth = ctxJoin = ctxCap = ctxFont = ctxAlign = ctxBaseline = ctxDash = null;
        ctxAlpha = 1;
        syncRect(true);
        fire("setSize");
        shouldSetSize = false;
      }
      if (fullWidCss > 0 && fullHgtCss > 0) {
        ctx.clearRect(0, 0, can.width, can.height);
        fire("drawClear");
        drawOrder.forEach((fn) => fn());
        fire("draw");
      }
      if (cursor.show && shouldSetCursor) {
        updateCursor(null, true, false);
        shouldSetCursor = false;
      }
      if (!ready) {
        ready = true;
        self2.status = 1;
        fire("ready");
      }
      viaAutoScaleX = false;
      queuedCommit = false;
    }
    self2.redraw = (rebuildPaths, recalcAxes) => {
      shouldConvergeSize = recalcAxes || false;
      if (rebuildPaths !== false)
        _setScale(xScaleKey, scaleX.min, scaleX.max);
      else
        commit();
    };
    function setScale(key2, opts2) {
      let sc = scales[key2];
      if (sc.from == null) {
        if (dataLen == 0) {
          let minMax = sc.range(self2, opts2.min, opts2.max, key2);
          opts2.min = minMax[0];
          opts2.max = minMax[1];
        }
        if (opts2.min > opts2.max) {
          let _min = opts2.min;
          opts2.min = opts2.max;
          opts2.max = _min;
        }
        if (dataLen > 1 && opts2.min != null && opts2.max != null && opts2.max - opts2.min < 1e-16)
          return;
        if (key2 == xScaleKey) {
          if (sc.distr == 2 && dataLen > 0) {
            opts2.min = closestIdx(opts2.min, data[0]);
            opts2.max = closestIdx(opts2.max, data[0]);
            if (opts2.min == opts2.max)
              opts2.max++;
          }
        }
        pendScales[key2] = opts2;
        shouldSetScales = true;
        commit();
      }
    }
    self2.setScale = setScale;
    let xCursor;
    let yCursor;
    let vCursor;
    let hCursor;
    let rawMouseLeft0;
    let rawMouseTop0;
    let mouseLeft0;
    let mouseTop0;
    let rawMouseLeft1;
    let rawMouseTop1;
    let mouseLeft1;
    let mouseTop1;
    let dragging = false;
    const drag = cursor.drag;
    let dragX = drag.x;
    let dragY = drag.y;
    if (cursor.show) {
      if (cursor.x)
        xCursor = placeDiv(CURSOR_X, over);
      if (cursor.y)
        yCursor = placeDiv(CURSOR_Y, over);
      if (scaleX.ori == 0) {
        vCursor = xCursor;
        hCursor = yCursor;
      } else {
        vCursor = yCursor;
        hCursor = xCursor;
      }
      mouseLeft1 = cursor.left;
      mouseTop1 = cursor.top;
    }
    const select = self2.select = assign({
      show: true,
      over: true,
      left: 0,
      width: 0,
      top: 0,
      height: 0
    }, opts.select);
    const selectDiv = select.show ? placeDiv(SELECT, select.over ? over : under) : null;
    function setSelect(opts2, _fire) {
      if (select.show) {
        for (let prop in opts2)
          setStylePx(selectDiv, prop, select[prop] = opts2[prop]);
        _fire !== false && fire("setSelect");
      }
    }
    self2.setSelect = setSelect;
    function toggleDOM(i, onOff) {
      let s = series[i];
      let label = showLegend ? legendRows[i] : null;
      if (s.show)
        label && remClass(label, OFF);
      else {
        label && addClass(label, OFF);
        cursorPts.length > 1 && elTrans(cursorPts[i], -10, -10, plotWidCss, plotHgtCss);
      }
    }
    function _setScale(key2, min2, max2) {
      setScale(key2, { min: min2, max: max2 });
    }
    function setSeries(i, opts2, _fire, _pub) {
      if (opts2.focus != null)
        setFocus(i);
      if (opts2.show != null) {
        series.forEach((s, si) => {
          if (si > 0 && (i == si || i == null)) {
            s.show = opts2.show;
            toggleDOM(si, opts2.show);
            _setScale(mode == 2 ? s.facets[1].scale : s.scale, null, null);
            commit();
          }
        });
      }
      _fire !== false && fire("setSeries", i, opts2);
      _pub && pubSync("setSeries", self2, i, opts2);
    }
    self2.setSeries = setSeries;
    function setBand(bi, opts2) {
      assign(bands[bi], opts2);
    }
    function addBand(opts2, bi) {
      opts2.fill = fnOrSelf(opts2.fill || null);
      opts2.dir = ifNull(opts2.dir, -1);
      bi = bi == null ? bands.length : bi;
      bands.splice(bi, 0, opts2);
    }
    function delBand(bi) {
      if (bi == null)
        bands.length = 0;
      else
        bands.splice(bi, 1);
    }
    self2.addBand = addBand;
    self2.setBand = setBand;
    self2.delBand = delBand;
    function setAlpha(i, value) {
      series[i].alpha = value;
      if (cursor.show && cursorPts[i])
        cursorPts[i].style.opacity = value;
      if (showLegend && legendRows[i])
        legendRows[i].style.opacity = value;
    }
    let closestDist;
    let closestSeries;
    let focusedSeries;
    const FOCUS_TRUE = { focus: true };
    function setFocus(i) {
      if (i != focusedSeries) {
        let allFocused = i == null;
        let _setAlpha = focus.alpha != 1;
        series.forEach((s, i2) => {
          let isFocused = allFocused || i2 == 0 || i2 == i;
          s._focus = allFocused ? null : isFocused;
          _setAlpha && setAlpha(i2, isFocused ? 1 : focus.alpha);
        });
        focusedSeries = i;
        _setAlpha && commit();
      }
    }
    if (showLegend && cursorFocus) {
      on(mouseleave, legendEl, (e) => {
        if (cursor._lock)
          return;
        if (focusedSeries != null)
          setSeries(null, FOCUS_TRUE, true, syncOpts.setSeries);
      });
    }
    function posToVal(pos, scale, can2) {
      let sc = scales[scale];
      if (can2)
        pos = pos / pxRatio - (sc.ori == 1 ? plotTopCss : plotLftCss);
      let dim = plotWidCss;
      if (sc.ori == 1) {
        dim = plotHgtCss;
        pos = dim - pos;
      }
      if (sc.dir == -1)
        pos = dim - pos;
      let _min = sc._min, _max = sc._max, pct = pos / dim;
      let sv = _min + (_max - _min) * pct;
      let distr = sc.distr;
      return distr == 3 ? pow(10, sv) : distr == 4 ? sinh(sv, sc.asinh) : sv;
    }
    function closestIdxFromXpos(pos, can2) {
      let v = posToVal(pos, xScaleKey, can2);
      return closestIdx(v, data[0], i0, i1);
    }
    self2.valToIdx = (val) => closestIdx(val, data[0]);
    self2.posToIdx = closestIdxFromXpos;
    self2.posToVal = posToVal;
    self2.valToPos = (val, scale, can2) => scales[scale].ori == 0 ? getHPos(val, scales[scale], can2 ? plotWid : plotWidCss, can2 ? plotLft : 0) : getVPos(val, scales[scale], can2 ? plotHgt : plotHgtCss, can2 ? plotTop : 0);
    function batch(fn) {
      fn(self2);
      commit();
    }
    self2.batch = batch;
    self2.setCursor = (opts2, _fire, _pub) => {
      mouseLeft1 = opts2.left;
      mouseTop1 = opts2.top;
      updateCursor(null, _fire, _pub);
    };
    function setSelH(off2, dim) {
      setStylePx(selectDiv, LEFT, select.left = off2);
      setStylePx(selectDiv, WIDTH, select.width = dim);
    }
    function setSelV(off2, dim) {
      setStylePx(selectDiv, TOP, select.top = off2);
      setStylePx(selectDiv, HEIGHT, select.height = dim);
    }
    let setSelX = scaleX.ori == 0 ? setSelH : setSelV;
    let setSelY = scaleX.ori == 1 ? setSelH : setSelV;
    function syncLegend() {
      if (showLegend && legend.live) {
        for (let i = mode == 2 ? 1 : 0; i < series.length; i++) {
          if (i == 0 && multiValLegend)
            continue;
          let vals = legend.values[i];
          let j = 0;
          for (let k in vals)
            legendCells[i][j++].firstChild.nodeValue = vals[k];
        }
      }
    }
    function setLegend(opts2, _fire) {
      if (opts2 != null) {
        let idx = opts2.idx;
        legend.idx = idx;
        series.forEach((s, sidx) => {
          (sidx > 0 || !multiValLegend) && setLegendValues(sidx, idx);
        });
      }
      if (showLegend && legend.live)
        syncLegend();
      shouldSetLegend = false;
      _fire !== false && fire("setLegend");
    }
    self2.setLegend = setLegend;
    function setLegendValues(sidx, idx) {
      let val;
      if (idx == null)
        val = NULL_LEGEND_VALUES;
      else {
        let s = series[sidx];
        let src = sidx == 0 && xScaleDistr == 2 ? data0 : data[sidx];
        val = multiValLegend ? s.values(self2, sidx, idx) : { _: s.value(self2, src[idx], sidx, idx) };
      }
      legend.values[sidx] = val;
    }
    function updateCursor(src, _fire, _pub) {
      rawMouseLeft1 = mouseLeft1;
      rawMouseTop1 = mouseTop1;
      [mouseLeft1, mouseTop1] = cursor.move(self2, mouseLeft1, mouseTop1);
      if (cursor.show) {
        vCursor && elTrans(vCursor, round(mouseLeft1), 0, plotWidCss, plotHgtCss);
        hCursor && elTrans(hCursor, 0, round(mouseTop1), plotWidCss, plotHgtCss);
      }
      let idx;
      let noDataInRange = i0 > i1;
      closestDist = inf;
      let xDim = scaleX.ori == 0 ? plotWidCss : plotHgtCss;
      let yDim = scaleX.ori == 1 ? plotWidCss : plotHgtCss;
      if (mouseLeft1 < 0 || dataLen == 0 || noDataInRange) {
        idx = null;
        for (let i = 0; i < series.length; i++) {
          if (i > 0) {
            cursorPts.length > 1 && elTrans(cursorPts[i], -10, -10, plotWidCss, plotHgtCss);
          }
        }
        if (cursorFocus)
          setSeries(null, FOCUS_TRUE, true, src == null && syncOpts.setSeries);
        if (legend.live) {
          activeIdxs.fill(null);
          shouldSetLegend = true;
          for (let i = 0; i < series.length; i++)
            legend.values[i] = NULL_LEGEND_VALUES;
        }
      } else {
        let mouseXPos, valAtPosX, xPos;
        if (mode == 1) {
          mouseXPos = scaleX.ori == 0 ? mouseLeft1 : mouseTop1;
          valAtPosX = posToVal(mouseXPos, xScaleKey);
          idx = closestIdx(valAtPosX, data[0], i0, i1);
          xPos = incrRoundUp(valToPosX(data[0][idx], scaleX, xDim, 0), 0.5);
        }
        for (let i = mode == 2 ? 1 : 0; i < series.length; i++) {
          let s = series[i];
          let idx1 = activeIdxs[i];
          let yVal1 = mode == 1 ? data[i][idx1] : data[i][1][idx1];
          let idx2 = cursor.dataIdx(self2, i, idx, valAtPosX);
          let yVal2 = mode == 1 ? data[i][idx2] : data[i][1][idx2];
          shouldSetLegend = shouldSetLegend || yVal2 != yVal1 || idx2 != idx1;
          activeIdxs[i] = idx2;
          let xPos2 = idx2 == idx ? xPos : incrRoundUp(valToPosX(mode == 1 ? data[0][idx2] : data[i][0][idx2], scaleX, xDim, 0), 0.5);
          if (i > 0 && s.show) {
            let yPos = yVal2 == null ? -10 : incrRoundUp(valToPosY(yVal2, mode == 1 ? scales[s.scale] : scales[s.facets[1].scale], yDim, 0), 0.5);
            if (yPos > 0 && mode == 1) {
              let dist = abs(yPos - mouseTop1);
              if (dist <= closestDist) {
                closestDist = dist;
                closestSeries = i;
              }
            }
            let hPos, vPos;
            if (scaleX.ori == 0) {
              hPos = xPos2;
              vPos = yPos;
            } else {
              hPos = yPos;
              vPos = xPos2;
            }
            if (shouldSetLegend && cursorPts.length > 1) {
              elColor(cursorPts[i], cursor.points.fill(self2, i), cursor.points.stroke(self2, i));
              let ptWid, ptHgt, ptLft, ptTop, centered = true, getBBox = cursor.points.bbox;
              if (getBBox != null) {
                centered = false;
                let bbox = getBBox(self2, i);
                ptLft = bbox.left;
                ptTop = bbox.top;
                ptWid = bbox.width;
                ptHgt = bbox.height;
              } else {
                ptLft = hPos;
                ptTop = vPos;
                ptWid = ptHgt = cursor.points.size(self2, i);
              }
              elSize(cursorPts[i], ptWid, ptHgt, centered);
              elTrans(cursorPts[i], ptLft, ptTop, plotWidCss, plotHgtCss);
            }
          }
          if (legend.live) {
            if (!shouldSetLegend || i == 0 && multiValLegend)
              continue;
            setLegendValues(i, idx2);
          }
        }
      }
      cursor.idx = idx;
      cursor.left = mouseLeft1;
      cursor.top = mouseTop1;
      if (shouldSetLegend) {
        legend.idx = idx;
        setLegend();
      }
      if (select.show && dragging) {
        if (src != null) {
          let [xKey, yKey] = syncOpts.scales;
          let [matchXKeys, matchYKeys] = syncOpts.match;
          let [xKeySrc, yKeySrc] = src.cursor.sync.scales;
          let sdrag = src.cursor.drag;
          dragX = sdrag._x;
          dragY = sdrag._y;
          if (dragX || dragY) {
            let { left, top, width, height } = src.select;
            let sori = src.scales[xKey].ori;
            let sPosToVal = src.posToVal;
            let sOff, sDim, sc, a, b;
            let matchingX = xKey != null && matchXKeys(xKey, xKeySrc);
            let matchingY = yKey != null && matchYKeys(yKey, yKeySrc);
            if (matchingX && dragX) {
              if (sori == 0) {
                sOff = left;
                sDim = width;
              } else {
                sOff = top;
                sDim = height;
              }
              sc = scales[xKey];
              a = valToPosX(sPosToVal(sOff, xKeySrc), sc, xDim, 0);
              b = valToPosX(sPosToVal(sOff + sDim, xKeySrc), sc, xDim, 0);
              setSelX(min(a, b), abs(b - a));
            } else
              setSelX(0, xDim);
            if (matchingY && dragY) {
              if (sori == 1) {
                sOff = left;
                sDim = width;
              } else {
                sOff = top;
                sDim = height;
              }
              sc = scales[yKey];
              a = valToPosY(sPosToVal(sOff, yKeySrc), sc, yDim, 0);
              b = valToPosY(sPosToVal(sOff + sDim, yKeySrc), sc, yDim, 0);
              setSelY(min(a, b), abs(b - a));
            } else
              setSelY(0, yDim);
          } else
            hideSelect();
        } else {
          let rawDX = abs(rawMouseLeft1 - rawMouseLeft0);
          let rawDY = abs(rawMouseTop1 - rawMouseTop0);
          if (scaleX.ori == 1) {
            let _rawDX = rawDX;
            rawDX = rawDY;
            rawDY = _rawDX;
          }
          dragX = drag.x && rawDX >= drag.dist;
          dragY = drag.y && rawDY >= drag.dist;
          let uni = drag.uni;
          if (uni != null) {
            if (dragX && dragY) {
              dragX = rawDX >= uni;
              dragY = rawDY >= uni;
              if (!dragX && !dragY) {
                if (rawDY > rawDX)
                  dragY = true;
                else
                  dragX = true;
              }
            }
          } else if (drag.x && drag.y && (dragX || dragY))
            dragX = dragY = true;
          let p0, p1;
          if (dragX) {
            if (scaleX.ori == 0) {
              p0 = mouseLeft0;
              p1 = mouseLeft1;
            } else {
              p0 = mouseTop0;
              p1 = mouseTop1;
            }
            setSelX(min(p0, p1), abs(p1 - p0));
            if (!dragY)
              setSelY(0, yDim);
          }
          if (dragY) {
            if (scaleX.ori == 1) {
              p0 = mouseLeft0;
              p1 = mouseLeft1;
            } else {
              p0 = mouseTop0;
              p1 = mouseTop1;
            }
            setSelY(min(p0, p1), abs(p1 - p0));
            if (!dragX)
              setSelX(0, xDim);
          }
          if (!dragX && !dragY) {
            setSelX(0, 0);
            setSelY(0, 0);
          }
        }
      }
      drag._x = dragX;
      drag._y = dragY;
      if (src == null) {
        if (_pub) {
          if (syncKey != null) {
            let [xSyncKey, ySyncKey] = syncOpts.scales;
            syncOpts.values[0] = xSyncKey != null ? posToVal(scaleX.ori == 0 ? mouseLeft1 : mouseTop1, xSyncKey) : null;
            syncOpts.values[1] = ySyncKey != null ? posToVal(scaleX.ori == 1 ? mouseLeft1 : mouseTop1, ySyncKey) : null;
          }
          pubSync(mousemove, self2, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, idx);
        }
        if (cursorFocus) {
          let shouldPub = _pub && syncOpts.setSeries;
          let p = focus.prox;
          if (focusedSeries == null) {
            if (closestDist <= p)
              setSeries(closestSeries, FOCUS_TRUE, true, shouldPub);
          } else {
            if (closestDist > p)
              setSeries(null, FOCUS_TRUE, true, shouldPub);
            else if (closestSeries != focusedSeries)
              setSeries(closestSeries, FOCUS_TRUE, true, shouldPub);
          }
        }
      }
      ready && _fire !== false && fire("setCursor");
    }
    let rect2 = null;
    function syncRect(defer) {
      if (defer === true)
        rect2 = null;
      else {
        rect2 = over.getBoundingClientRect();
        fire("syncRect", rect2);
      }
    }
    function mouseMove(e, src, _l, _t, _w, _h, _i) {
      if (cursor._lock)
        return;
      cacheMouse(e, src, _l, _t, _w, _h, _i, false, e != null);
      if (e != null)
        updateCursor(null, true, true);
      else
        updateCursor(src, true, false);
    }
    function cacheMouse(e, src, _l, _t, _w, _h, _i, initial, snap) {
      if (rect2 == null)
        syncRect(false);
      if (e != null) {
        _l = e.clientX - rect2.left;
        _t = e.clientY - rect2.top;
      } else {
        if (_l < 0 || _t < 0) {
          mouseLeft1 = -10;
          mouseTop1 = -10;
          return;
        }
        let [xKey, yKey] = syncOpts.scales;
        let syncOptsSrc = src.cursor.sync;
        let [xValSrc, yValSrc] = syncOptsSrc.values;
        let [xKeySrc, yKeySrc] = syncOptsSrc.scales;
        let [matchXKeys, matchYKeys] = syncOpts.match;
        let rotSrc = src.axes[0].side % 2 == 1;
        let xDim = scaleX.ori == 0 ? plotWidCss : plotHgtCss, yDim = scaleX.ori == 1 ? plotWidCss : plotHgtCss, _xDim = rotSrc ? _h : _w, _yDim = rotSrc ? _w : _h, _xPos = rotSrc ? _t : _l, _yPos = rotSrc ? _l : _t;
        if (xKeySrc != null)
          _l = matchXKeys(xKey, xKeySrc) ? getPos(xValSrc, scales[xKey], xDim, 0) : -10;
        else
          _l = xDim * (_xPos / _xDim);
        if (yKeySrc != null)
          _t = matchYKeys(yKey, yKeySrc) ? getPos(yValSrc, scales[yKey], yDim, 0) : -10;
        else
          _t = yDim * (_yPos / _yDim);
        if (scaleX.ori == 1) {
          let __l = _l;
          _l = _t;
          _t = __l;
        }
      }
      if (snap) {
        if (_l <= 1 || _l >= plotWidCss - 1)
          _l = incrRound(_l, plotWidCss);
        if (_t <= 1 || _t >= plotHgtCss - 1)
          _t = incrRound(_t, plotHgtCss);
      }
      if (initial) {
        rawMouseLeft0 = _l;
        rawMouseTop0 = _t;
        [mouseLeft0, mouseTop0] = cursor.move(self2, _l, _t);
      } else {
        mouseLeft1 = _l;
        mouseTop1 = _t;
      }
    }
    const _hideProps = {
      width: 0,
      height: 0
    };
    function hideSelect() {
      setSelect(_hideProps, false);
    }
    function mouseDown(e, src, _l, _t, _w, _h, _i) {
      dragging = true;
      dragX = dragY = drag._x = drag._y = false;
      cacheMouse(e, src, _l, _t, _w, _h, _i, true, false);
      if (e != null) {
        onMouse(mouseup, doc2, mouseUp);
        pubSync(mousedown, self2, mouseLeft0, mouseTop0, plotWidCss, plotHgtCss, null);
      }
    }
    function mouseUp(e, src, _l, _t, _w, _h, _i) {
      dragging = drag._x = drag._y = false;
      cacheMouse(e, src, _l, _t, _w, _h, _i, false, true);
      let { left, top, width, height } = select;
      let hasSelect = width > 0 || height > 0;
      hasSelect && setSelect(select);
      if (drag.setScale && hasSelect) {
        let xOff = left, xDim = width, yOff = top, yDim = height;
        if (scaleX.ori == 1) {
          xOff = top, xDim = height, yOff = left, yDim = width;
        }
        if (dragX) {
          _setScale(xScaleKey, posToVal(xOff, xScaleKey), posToVal(xOff + xDim, xScaleKey));
        }
        if (dragY) {
          for (let k in scales) {
            let sc = scales[k];
            if (k != xScaleKey && sc.from == null && sc.min != inf) {
              _setScale(k, posToVal(yOff + yDim, k), posToVal(yOff, k));
            }
          }
        }
        hideSelect();
      } else if (cursor.lock) {
        cursor._lock = !cursor._lock;
        if (!cursor._lock)
          updateCursor(null, true, false);
      }
      if (e != null) {
        offMouse(mouseup, doc2);
        pubSync(mouseup, self2, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, null);
      }
    }
    function mouseLeave(e, src, _l, _t, _w, _h, _i) {
      if (!cursor._lock) {
        let _dragging = dragging;
        if (dragging) {
          let snapH = true;
          let snapV = true;
          let snapProx = 10;
          let dragH, dragV;
          if (scaleX.ori == 0) {
            dragH = dragX;
            dragV = dragY;
          } else {
            dragH = dragY;
            dragV = dragX;
          }
          if (dragH && dragV) {
            snapH = mouseLeft1 <= snapProx || mouseLeft1 >= plotWidCss - snapProx;
            snapV = mouseTop1 <= snapProx || mouseTop1 >= plotHgtCss - snapProx;
          }
          if (dragH && snapH)
            mouseLeft1 = mouseLeft1 < mouseLeft0 ? 0 : plotWidCss;
          if (dragV && snapV)
            mouseTop1 = mouseTop1 < mouseTop0 ? 0 : plotHgtCss;
          updateCursor(null, true, true);
          dragging = false;
        }
        mouseLeft1 = -10;
        mouseTop1 = -10;
        updateCursor(null, true, true);
        if (_dragging)
          dragging = _dragging;
      }
    }
    function dblClick(e, src, _l, _t, _w, _h, _i) {
      autoScaleX();
      hideSelect();
      if (e != null)
        pubSync(dblclick, self2, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, null);
    }
    function syncPxRatio() {
      axes.forEach(syncFontSize);
      _setSize(self2.width, self2.height, true);
    }
    on(dppxchange, win, syncPxRatio);
    const events = {};
    events.mousedown = mouseDown;
    events.mousemove = mouseMove;
    events.mouseup = mouseUp;
    events.dblclick = dblClick;
    events["setSeries"] = (e, src, idx, opts2) => {
      setSeries(idx, opts2, true, false);
    };
    if (cursor.show) {
      onMouse(mousedown, over, mouseDown);
      onMouse(mousemove, over, mouseMove);
      onMouse(mouseenter, over, syncRect);
      onMouse(mouseleave, over, mouseLeave);
      onMouse(dblclick, over, dblClick);
      cursorPlots.add(self2);
      self2.syncRect = syncRect;
    }
    const hooks = self2.hooks = opts.hooks || {};
    function fire(evName, a1, a2) {
      if (evName in hooks) {
        hooks[evName].forEach((fn) => {
          fn.call(null, self2, a1, a2);
        });
      }
    }
    (opts.plugins || []).forEach((p) => {
      for (let evName in p.hooks)
        hooks[evName] = (hooks[evName] || []).concat(p.hooks[evName]);
    });
    const syncOpts = assign({
      key: null,
      setSeries: false,
      filters: {
        pub: retTrue,
        sub: retTrue
      },
      scales: [xScaleKey, series[1] ? series[1].scale : null],
      match: [retEq, retEq],
      values: [null, null]
    }, cursor.sync);
    cursor.sync = syncOpts;
    const syncKey = syncOpts.key;
    const sync = _sync(syncKey);
    function pubSync(type, src, x, y, w, h, i) {
      if (syncOpts.filters.pub(type, src, x, y, w, h, i))
        sync.pub(type, src, x, y, w, h, i);
    }
    sync.sub(self2);
    function pub(type, src, x, y, w, h, i) {
      if (syncOpts.filters.sub(type, src, x, y, w, h, i))
        events[type](null, src, x, y, w, h, i);
    }
    self2.pub = pub;
    function destroy() {
      sync.unsub(self2);
      cursorPlots.delete(self2);
      mouseListeners.clear();
      off(dppxchange, win, syncPxRatio);
      root.remove();
      fire("destroy");
    }
    self2.destroy = destroy;
    function _init() {
      fire("init", opts, data);
      setData(data || opts.data, false);
      if (pendScales[xScaleKey])
        setScale(xScaleKey, pendScales[xScaleKey]);
      else
        autoScaleX();
      _setSize(opts.width, opts.height);
      updateCursor(null, true, false);
      setSelect(select, false);
    }
    series.forEach(initSeries);
    axes.forEach(initAxis);
    if (then) {
      if (then instanceof HTMLElement) {
        then.appendChild(root);
        _init();
      } else
        then(self2, _init);
    } else
      _init();
    return self2;
  }
  uPlot.assign = assign;
  uPlot.fmtNum = fmtNum;
  uPlot.rangeNum = rangeNum;
  uPlot.rangeLog = rangeLog;
  uPlot.rangeAsinh = rangeAsinh;
  uPlot.orient = orient;
  uPlot.pxRatio = pxRatio;
  {
    uPlot.join = join;
  }
  {
    uPlot.fmtDate = fmtDate;
    uPlot.tzDate = tzDate;
  }
  {
    uPlot.sync = _sync;
  }
  {
    uPlot.addGap = addGap;
    uPlot.clipGaps = clipGaps;
    let paths = uPlot.paths = {
      points
    };
    paths.linear = linear;
    paths.stepped = stepped;
    paths.bars = bars;
    paths.spline = monotoneCubic;
  }

  // js/chart.js
  var ChartHook = {
    mounted() {
      this.trades = [];
      this.plot = new uPlot(plotOptions(), [[], []], this.el);
    },
    updated() {
      let price = parseFloat(this.el.dataset.price), timestamp = parseInt(this.el.dataset.tradedAt);
      this.trades.push({
        timestamp,
        price
      });
      if (this.trades.length > 20) {
        this.trades.splice(0, 1);
      }
      this.updateChart();
    },
    updateChart() {
      let x = this.trades.map((t) => t.timestamp);
      let y = this.trades.map((t) => t.price);
      this.plot.setData([x, y]);
    }
  };
  function plotOptions() {
    return {
      width: 200,
      height: 80,
      class: "chart-container",
      cursor: { show: false },
      select: { show: false },
      legend: { show: false },
      scales: {},
      axes: [
        { show: false },
        { show: false }
      ],
      series: [
        {},
        {
          size: 0,
          width: 2,
          stroke: "white",
          fill: "rgb(45,85,150)"
        }
      ]
    };
  }

  // js/app.js
  var Hooks2 = {
    Chart: ChartHook
  };
  var timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  var csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content");
  var liveSocket = new LiveSocket("/live", Socket, { hooks: Hooks2, params: { _csrf_token: csrfToken, timezone } });
  import_topbar.default.config({ barColors: { 0: "#29d" }, shadowColor: "rgba(0, 0, 0, .3)" });
  window.addEventListener("phx:page-loading-start", (info) => import_topbar.default.show());
  window.addEventListener("phx:page-loading-stop", (info) => import_topbar.default.hide());
  liveSocket.connect();
  window.liveSocket = liveSocket;
})();
/**
 * @license MIT
 * topbar 1.0.0, 2021-01-06
 * https://buunguyen.github.io/topbar
 * Copyright (c) 2021 Buu Nguyen
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vYXNzZXRzL3ZlbmRvci90b3BiYXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2h0bWwvcHJpdi9zdGF0aWMvcGhvZW5peF9odG1sLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC91dGlscy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9wdXNoLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC90aW1lci5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvY2hhbm5lbC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvYWpheC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvbG9uZ3BvbGwuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3ByZXNlbmNlLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9zZXJpYWxpemVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9zb2NrZXQuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2VudHJ5X3VwbG9hZGVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3V0aWxzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2Jyb3dzZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3VwbG9hZF9lbnRyeS5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9saXZlX3VwbG9hZGVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2hvb2tzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2RvbV9wb3N0X21vcnBoX3Jlc3RvcmVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL25vZGVfbW9kdWxlcy9tb3JwaGRvbS9kaXN0L21vcnBoZG9tLWVzbS5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9kb21fcGF0Y2guanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvcmVuZGVyZWQuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvdmlld19ob29rLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2pzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3ZpZXcuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvbGl2ZV9zb2NrZXQuanMiLCAiLi4vLi4vLi4vYXNzZXRzL2pzL2FwcC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3VwbG90L2Rpc3QvdVBsb3QuZXNtLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9qcy9jaGFydC5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyoqXG4gKiBAbGljZW5zZSBNSVRcbiAqIHRvcGJhciAxLjAuMCwgMjAyMS0wMS0wNlxuICogaHR0cHM6Ly9idXVuZ3V5ZW4uZ2l0aHViLmlvL3RvcGJhclxuICogQ29weXJpZ2h0IChjKSAyMDIxIEJ1dSBOZ3V5ZW5cbiAqL1xuKGZ1bmN0aW9uICh3aW5kb3csIGRvY3VtZW50KSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICB2YXIgdmVuZG9ycyA9IFtcIm1zXCIsIFwibW96XCIsIFwid2Via2l0XCIsIFwib1wiXTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxuICAgICAgICB3aW5kb3dbdmVuZG9yc1t4XSArIFwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID1cbiAgICAgICAgd2luZG93W3ZlbmRvcnNbeF0gKyBcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCJdIHx8XG4gICAgICAgIHdpbmRvd1t2ZW5kb3JzW3hdICsgXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XG4gICAgfVxuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICAgICAgICB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgICAgICAgfSwgdGltZVRvQ2FsbCk7XG4gICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9O1xuICAgIGlmICghd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKVxuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICB9O1xuICB9KSgpO1xuXG4gIHZhciBjYW52YXMsXG4gICAgcHJvZ3Jlc3NUaW1lcklkLFxuICAgIGZhZGVUaW1lcklkLFxuICAgIGN1cnJlbnRQcm9ncmVzcyxcbiAgICBzaG93aW5nLFxuICAgIGFkZEV2ZW50ID0gZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICBlbHNlIGlmIChlbGVtLmF0dGFjaEV2ZW50KSBlbGVtLmF0dGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGhhbmRsZXIpO1xuICAgICAgZWxzZSBlbGVtW1wib25cIiArIHR5cGVdID0gaGFuZGxlcjtcbiAgICB9LFxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBhdXRvUnVuOiB0cnVlLFxuICAgICAgYmFyVGhpY2tuZXNzOiAzLFxuICAgICAgYmFyQ29sb3JzOiB7XG4gICAgICAgIDA6IFwicmdiYSgyNiwgIDE4OCwgMTU2LCAuOSlcIixcbiAgICAgICAgXCIuMjVcIjogXCJyZ2JhKDUyLCAgMTUyLCAyMTksIC45KVwiLFxuICAgICAgICBcIi41MFwiOiBcInJnYmEoMjQxLCAxOTYsIDE1LCAgLjkpXCIsXG4gICAgICAgIFwiLjc1XCI6IFwicmdiYSgyMzAsIDEyNiwgMzQsICAuOSlcIixcbiAgICAgICAgXCIxLjBcIjogXCJyZ2JhKDIxMSwgODQsICAwLCAgIC45KVwiLFxuICAgICAgfSxcbiAgICAgIHNoYWRvd0JsdXI6IDEwLFxuICAgICAgc2hhZG93Q29sb3I6IFwicmdiYSgwLCAgIDAsICAgMCwgICAuNilcIixcbiAgICAgIGNsYXNzTmFtZTogbnVsbCxcbiAgICB9LFxuICAgIHJlcGFpbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRpb25zLmJhclRoaWNrbmVzcyAqIDU7IC8vIG5lZWQgc3BhY2UgZm9yIHNoYWRvd1xuXG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gb3B0aW9ucy5zaGFkb3dCbHVyO1xuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gb3B0aW9ucy5zaGFkb3dDb2xvcjtcblxuICAgICAgdmFyIGxpbmVHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCBjYW52YXMud2lkdGgsIDApO1xuICAgICAgZm9yICh2YXIgc3RvcCBpbiBvcHRpb25zLmJhckNvbG9ycylcbiAgICAgICAgbGluZUdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLCBvcHRpb25zLmJhckNvbG9yc1tzdG9wXSk7XG4gICAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKDAsIG9wdGlvbnMuYmFyVGhpY2tuZXNzIC8gMik7XG4gICAgICBjdHgubGluZVRvKFxuICAgICAgICBNYXRoLmNlaWwoY3VycmVudFByb2dyZXNzICogY2FudmFzLndpZHRoKSxcbiAgICAgICAgb3B0aW9ucy5iYXJUaGlja25lc3MgLyAyXG4gICAgICApO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGluZUdyYWRpZW50O1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIHZhciBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcbiAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgICAgc3R5bGUudG9wID0gc3R5bGUubGVmdCA9IHN0eWxlLnJpZ2h0ID0gc3R5bGUubWFyZ2luID0gc3R5bGUucGFkZGluZyA9IDA7XG4gICAgICBzdHlsZS56SW5kZXggPSAxMDAwMDE7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBpZiAob3B0aW9ucy5jbGFzc05hbWUpIGNhbnZhcy5jbGFzc0xpc3QuYWRkKG9wdGlvbnMuY2xhc3NOYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIGFkZEV2ZW50KHdpbmRvdywgXCJyZXNpemVcIiwgcmVwYWludCk7XG4gICAgfSxcbiAgICB0b3BiYXIgPSB7XG4gICAgICBjb25maWc6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRzKVxuICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIG9wdGlvbnNba2V5XSA9IG9wdHNba2V5XTtcbiAgICAgIH0sXG4gICAgICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzaG93aW5nKSByZXR1cm47XG4gICAgICAgIHNob3dpbmcgPSB0cnVlO1xuICAgICAgICBpZiAoZmFkZVRpbWVySWQgIT09IG51bGwpIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShmYWRlVGltZXJJZCk7XG4gICAgICAgIGlmICghY2FudmFzKSBjcmVhdGVDYW52YXMoKTtcbiAgICAgICAgY2FudmFzLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBjYW52YXMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgdG9wYmFyLnByb2dyZXNzKDApO1xuICAgICAgICBpZiAob3B0aW9ucy5hdXRvUnVuKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICBwcm9ncmVzc1RpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgICAgICAgdG9wYmFyLnByb2dyZXNzKFxuICAgICAgICAgICAgICBcIitcIiArIDAuMDUgKiBNYXRoLnBvdygxIC0gTWF0aC5zcXJ0KGN1cnJlbnRQcm9ncmVzcyksIDIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9ncmVzczogZnVuY3Rpb24gKHRvKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBjdXJyZW50UHJvZ3Jlc3M7XG4gICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0byA9XG4gICAgICAgICAgICAodG8uaW5kZXhPZihcIitcIikgPj0gMCB8fCB0by5pbmRleE9mKFwiLVwiKSA+PSAwXG4gICAgICAgICAgICAgID8gY3VycmVudFByb2dyZXNzXG4gICAgICAgICAgICAgIDogMCkgKyBwYXJzZUZsb2F0KHRvKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UHJvZ3Jlc3MgPSB0byA+IDEgPyAxIDogdG87XG4gICAgICAgIHJlcGFpbnQoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQcm9ncmVzcztcbiAgICAgIH0sXG4gICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc2hvd2luZykgcmV0dXJuO1xuICAgICAgICBzaG93aW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9ncmVzc1RpbWVySWQgIT0gbnVsbCkge1xuICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShwcm9ncmVzc1RpbWVySWQpO1xuICAgICAgICAgIHByb2dyZXNzVGltZXJJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgKGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgaWYgKHRvcGJhci5wcm9ncmVzcyhcIisuMVwiKSA+PSAxKSB7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUub3BhY2l0eSAtPSAwLjA1O1xuICAgICAgICAgICAgaWYgKGNhbnZhcy5zdHlsZS5vcGFjaXR5IDw9IDAuMDUpIHtcbiAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgZmFkZVRpbWVySWQgPSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZhZGVUaW1lcklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH0sXG4gICAgfTtcblxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRvcGJhcjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdG9wYmFyO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudG9wYmFyID0gdG9wYmFyO1xuICB9XG59LmNhbGwodGhpcywgd2luZG93LCBkb2N1bWVudCkpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBQb2x5ZmlsbEV2ZW50ID0gZXZlbnRDb25zdHJ1Y3RvcigpO1xuXG4gIGZ1bmN0aW9uIGV2ZW50Q29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHdpbmRvdy5DdXN0b21FdmVudDtcbiAgICAvLyBJRTw9OSBTdXBwb3J0XG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHtidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdW5kZWZpbmVkfTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICByZXR1cm4gZXZ0O1xuICAgIH1cbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICAgIHJldHVybiBDdXN0b21FdmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkSGlkZGVuSW5wdXQobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgaW5wdXQubmFtZSA9IG5hbWU7XG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDbGljayhlbGVtZW50LCB0YXJnZXRNb2RpZmllcktleSkge1xuICAgIHZhciB0byA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10b1wiKSxcbiAgICAgICAgbWV0aG9kID0gYnVpbGRIaWRkZW5JbnB1dChcIl9tZXRob2RcIiwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSksXG4gICAgICAgIGNzcmYgPSBidWlsZEhpZGRlbklucHV0KFwiX2NzcmZfdG9rZW5cIiwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNzcmZcIikpLFxuICAgICAgICBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG4gICAgICAgIHRhcmdldCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpO1xuXG4gICAgZm9ybS5tZXRob2QgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSA9PT0gXCJnZXRcIikgPyBcImdldFwiIDogXCJwb3N0XCI7XG4gICAgZm9ybS5hY3Rpb24gPSB0bztcbiAgICBmb3JtLnN0eWxlLmRpc3BsYXkgPSBcImhpZGRlblwiO1xuXG4gICAgaWYgKHRhcmdldCkgZm9ybS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgZWxzZSBpZiAodGFyZ2V0TW9kaWZpZXJLZXkpIGZvcm0udGFyZ2V0ID0gXCJfYmxhbmtcIjtcblxuICAgIGZvcm0uYXBwZW5kQ2hpbGQoY3NyZik7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChtZXRob2QpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgZm9ybS5zdWJtaXQoKTtcbiAgfVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlbGVtZW50ID0gZS50YXJnZXQ7XG4gICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBwaG9lbml4TGlua0V2ZW50ID0gbmV3IFBvbHlmaWxsRXZlbnQoJ3Bob2VuaXgubGluay5jbGljaycsIHtcbiAgICAgICAgXCJidWJibGVzXCI6IHRydWUsIFwiY2FuY2VsYWJsZVwiOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFlbGVtZW50LmRpc3BhdGNoRXZlbnQocGhvZW5peExpbmtFdmVudCkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpKSB7XG4gICAgICAgIGhhbmRsZUNsaWNrKGVsZW1lbnQsIGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5KTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfSwgZmFsc2UpO1xuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwaG9lbml4LmxpbmsuY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtZXNzYWdlID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb25maXJtXCIpO1xuICAgIGlmKG1lc3NhZ2UgJiYgIXdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG59KSgpO1xuIiwgIi8vIHdyYXBzIHZhbHVlIGluIGNsb3N1cmUgb3IgcmV0dXJucyBjbG9zdXJlXG5leHBvcnQgbGV0IGNsb3N1cmUgPSAodmFsdWUpID0+IHtcbiAgaWYodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpe1xuICAgIHJldHVybiB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIGxldCBjbG9zdXJlID0gZnVuY3Rpb24gKCl7IHJldHVybiB2YWx1ZSB9XG4gICAgcmV0dXJuIGNsb3N1cmVcbiAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBnbG9iYWxTZWxmID0gdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogbnVsbFxuZXhwb3J0IGNvbnN0IHBoeFdpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBudWxsXG5leHBvcnQgY29uc3QgZ2xvYmFsID0gZ2xvYmFsU2VsZiB8fCBwaHhXaW5kb3cgfHwgZ2xvYmFsXG5leHBvcnQgY29uc3QgREVGQVVMVF9WU04gPSBcIjIuMC4wXCJcbmV4cG9ydCBjb25zdCBTT0NLRVRfU1RBVEVTID0ge2Nvbm5lY3Rpbmc6IDAsIG9wZW46IDEsIGNsb3Npbmc6IDIsIGNsb3NlZDogM31cbmV4cG9ydCBjb25zdCBERUZBVUxUX1RJTUVPVVQgPSAxMDAwMFxuZXhwb3J0IGNvbnN0IFdTX0NMT1NFX05PUk1BTCA9IDEwMDBcbmV4cG9ydCBjb25zdCBDSEFOTkVMX1NUQVRFUyA9IHtcbiAgY2xvc2VkOiBcImNsb3NlZFwiLFxuICBlcnJvcmVkOiBcImVycm9yZWRcIixcbiAgam9pbmVkOiBcImpvaW5lZFwiLFxuICBqb2luaW5nOiBcImpvaW5pbmdcIixcbiAgbGVhdmluZzogXCJsZWF2aW5nXCIsXG59XG5leHBvcnQgY29uc3QgQ0hBTk5FTF9FVkVOVFMgPSB7XG4gIGNsb3NlOiBcInBoeF9jbG9zZVwiLFxuICBlcnJvcjogXCJwaHhfZXJyb3JcIixcbiAgam9pbjogXCJwaHhfam9pblwiLFxuICByZXBseTogXCJwaHhfcmVwbHlcIixcbiAgbGVhdmU6IFwicGh4X2xlYXZlXCJcbn1cblxuZXhwb3J0IGNvbnN0IFRSQU5TUE9SVFMgPSB7XG4gIGxvbmdwb2xsOiBcImxvbmdwb2xsXCIsXG4gIHdlYnNvY2tldDogXCJ3ZWJzb2NrZXRcIlxufVxuZXhwb3J0IGNvbnN0IFhIUl9TVEFURVMgPSB7XG4gIGNvbXBsZXRlOiA0XG59XG4iLCAiLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgUHVzaFxuICogQHBhcmFtIHtDaGFubmVsfSBjaGFubmVsIC0gVGhlIENoYW5uZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIFRoZSBldmVudCwgZm9yIGV4YW1wbGUgYFwicGh4X2pvaW5cImBcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIC0gVGhlIHBheWxvYWQsIGZvciBleGFtcGxlIGB7dXNlcl9pZDogMTIzfWBcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IC0gVGhlIHB1c2ggdGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHVzaCB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWwsIGV2ZW50LCBwYXlsb2FkLCB0aW1lb3V0KXtcbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsXG4gICAgdGhpcy5ldmVudCA9IGV2ZW50XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZCB8fCBmdW5jdGlvbiAoKXsgcmV0dXJuIHt9IH1cbiAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSBudWxsXG4gICAgdGhpcy5yZWNIb29rcyA9IFtdXG4gICAgdGhpcy5zZW50ID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICAgKi9cbiAgcmVzZW5kKHRpbWVvdXQpe1xuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXRcbiAgICB0aGlzLnJlc2V0KClcbiAgICB0aGlzLnNlbmQoKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICBzZW5kKCl7XG4gICAgaWYodGhpcy5oYXNSZWNlaXZlZChcInRpbWVvdXRcIikpeyByZXR1cm4gfVxuICAgIHRoaXMuc3RhcnRUaW1lb3V0KClcbiAgICB0aGlzLnNlbnQgPSB0cnVlXG4gICAgdGhpcy5jaGFubmVsLnNvY2tldC5wdXNoKHtcbiAgICAgIHRvcGljOiB0aGlzLmNoYW5uZWwudG9waWMsXG4gICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZCgpLFxuICAgICAgcmVmOiB0aGlzLnJlZixcbiAgICAgIGpvaW5fcmVmOiB0aGlzLmNoYW5uZWwuam9pblJlZigpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHN0YXR1c1xuICAgKiBAcGFyYW0geyp9IGNhbGxiYWNrXG4gICAqL1xuICByZWNlaXZlKHN0YXR1cywgY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuaGFzUmVjZWl2ZWQoc3RhdHVzKSl7XG4gICAgICBjYWxsYmFjayh0aGlzLnJlY2VpdmVkUmVzcC5yZXNwb25zZSlcbiAgICB9XG5cbiAgICB0aGlzLnJlY0hvb2tzLnB1c2goe3N0YXR1cywgY2FsbGJhY2t9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlc2V0KCl7XG4gICAgdGhpcy5jYW5jZWxSZWZFdmVudCgpXG4gICAgdGhpcy5yZWYgPSBudWxsXG4gICAgdGhpcy5yZWZFdmVudCA9IG51bGxcbiAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IG51bGxcbiAgICB0aGlzLnNlbnQgPSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBtYXRjaFJlY2VpdmUoe3N0YXR1cywgcmVzcG9uc2UsIF9yZWZ9KXtcbiAgICB0aGlzLnJlY0hvb2tzLmZpbHRlcihoID0+IGguc3RhdHVzID09PSBzdGF0dXMpXG4gICAgICAuZm9yRWFjaChoID0+IGguY2FsbGJhY2socmVzcG9uc2UpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5jZWxSZWZFdmVudCgpe1xuICAgIGlmKCF0aGlzLnJlZkV2ZW50KXsgcmV0dXJuIH1cbiAgICB0aGlzLmNoYW5uZWwub2ZmKHRoaXMucmVmRXZlbnQpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbmNlbFRpbWVvdXQoKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0VGltZXIpXG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXJ0VGltZW91dCgpe1xuICAgIGlmKHRoaXMudGltZW91dFRpbWVyKXsgdGhpcy5jYW5jZWxUaW1lb3V0KCkgfVxuICAgIHRoaXMucmVmID0gdGhpcy5jaGFubmVsLnNvY2tldC5tYWtlUmVmKClcbiAgICB0aGlzLnJlZkV2ZW50ID0gdGhpcy5jaGFubmVsLnJlcGx5RXZlbnROYW1lKHRoaXMucmVmKVxuXG4gICAgdGhpcy5jaGFubmVsLm9uKHRoaXMucmVmRXZlbnQsIHBheWxvYWQgPT4ge1xuICAgICAgdGhpcy5jYW5jZWxSZWZFdmVudCgpXG4gICAgICB0aGlzLmNhbmNlbFRpbWVvdXQoKVxuICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBwYXlsb2FkXG4gICAgICB0aGlzLm1hdGNoUmVjZWl2ZShwYXlsb2FkKVxuICAgIH0pXG5cbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKFwidGltZW91dFwiLCB7fSlcbiAgICB9LCB0aGlzLnRpbWVvdXQpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhc1JlY2VpdmVkKHN0YXR1cyl7XG4gICAgcmV0dXJuIHRoaXMucmVjZWl2ZWRSZXNwICYmIHRoaXMucmVjZWl2ZWRSZXNwLnN0YXR1cyA9PT0gc3RhdHVzXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRyaWdnZXIoc3RhdHVzLCByZXNwb25zZSl7XG4gICAgdGhpcy5jaGFubmVsLnRyaWdnZXIodGhpcy5yZWZFdmVudCwge3N0YXR1cywgcmVzcG9uc2V9KVxuICB9XG59XG4iLCAiLyoqXG4gKlxuICogQ3JlYXRlcyBhIHRpbWVyIHRoYXQgYWNjZXB0cyBhIGB0aW1lckNhbGNgIGZ1bmN0aW9uIHRvIHBlcmZvcm1cbiAqIGNhbGN1bGF0ZWQgdGltZW91dCByZXRyaWVzLCBzdWNoIGFzIGV4cG9uZW50aWFsIGJhY2tvZmYuXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCByZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB0aGlzLmNvbm5lY3QoKSwgZnVuY3Rpb24odHJpZXMpe1xuICogICByZXR1cm4gWzEwMDAsIDUwMDAsIDEwMDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiB9KVxuICogcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICogcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgNTAwMFxuICogcmVjb25uZWN0VGltZXIucmVzZXQoKVxuICogcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0aW1lckNhbGNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZXIge1xuICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgdGltZXJDYWxjKXtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsY1xuICAgIHRoaXMudGltZXIgPSBudWxsXG4gICAgdGhpcy50cmllcyA9IDBcbiAgfVxuXG4gIHJlc2V0KCl7XG4gICAgdGhpcy50cmllcyA9IDBcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcilcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGFueSBwcmV2aW91cyBzY2hlZHVsZVRpbWVvdXQgYW5kIHNjaGVkdWxlcyBjYWxsYmFja1xuICAgKi9cbiAgc2NoZWR1bGVUaW1lb3V0KCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpXG5cbiAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyaWVzID0gdGhpcy50cmllcyArIDFcbiAgICAgIHRoaXMuY2FsbGJhY2soKVxuICAgIH0sIHRoaXMudGltZXJDYWxjKHRoaXMudHJpZXMgKyAxKSlcbiAgfVxufVxuIiwgImltcG9ydCB7Y2xvc3VyZX0gZnJvbSBcIi4vdXRpbHNcIlxuaW1wb3J0IHtcbiAgQ0hBTk5FTF9FVkVOVFMsXG4gIENIQU5ORUxfU1RBVEVTLFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQgUHVzaCBmcm9tIFwiLi9wdXNoXCJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi90aW1lclwiXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY1xuICogQHBhcmFtIHsoT2JqZWN0fGZ1bmN0aW9uKX0gcGFyYW1zXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYW5uZWwge1xuICBjb25zdHJ1Y3Rvcih0b3BpYywgcGFyYW1zLCBzb2NrZXQpe1xuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgICB0aGlzLnRvcGljID0gdG9waWNcbiAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUocGFyYW1zIHx8IHt9KVxuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0XG4gICAgdGhpcy5iaW5kaW5ncyA9IFtdXG4gICAgdGhpcy5iaW5kaW5nUmVmID0gMFxuICAgIHRoaXMudGltZW91dCA9IHRoaXMuc29ja2V0LnRpbWVvdXRcbiAgICB0aGlzLmpvaW5lZE9uY2UgPSBmYWxzZVxuICAgIHRoaXMuam9pblB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5qb2luLCB0aGlzLnBhcmFtcywgdGhpcy50aW1lb3V0KVxuICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdXG4gICAgdGhpcy5zdGF0ZUNoYW5nZVJlZnMgPSBbXVxuXG4gICAgdGhpcy5yZWpvaW5UaW1lciA9IG5ldyBUaW1lcigoKSA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5yZWpvaW4oKSB9XG4gICAgfSwgdGhpcy5zb2NrZXQucmVqb2luQWZ0ZXJNcylcbiAgICB0aGlzLnN0YXRlQ2hhbmdlUmVmcy5wdXNoKHRoaXMuc29ja2V0Lm9uRXJyb3IoKCkgPT4gdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpKSlcbiAgICB0aGlzLnN0YXRlQ2hhbmdlUmVmcy5wdXNoKHRoaXMuc29ja2V0Lm9uT3BlbigoKSA9PiB7XG4gICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICAgIGlmKHRoaXMuaXNFcnJvcmVkKCkpeyB0aGlzLnJlam9pbigpIH1cbiAgICB9KVxuICAgIClcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJva1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmVkXG4gICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICAgIHRoaXMucHVzaEJ1ZmZlci5mb3JFYWNoKHB1c2hFdmVudCA9PiBwdXNoRXZlbnQuc2VuZCgpKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW11cbiAgICB9KVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcImVycm9yXCIsICgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkXG4gICAgICBpZih0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKSB9XG4gICAgfSlcbiAgICB0aGlzLm9uQ2xvc2UoKCkgPT4ge1xuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgY2xvc2UgJHt0aGlzLnRvcGljfSAke3RoaXMuam9pblJlZigpfWApXG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkXG4gICAgICB0aGlzLnNvY2tldC5yZW1vdmUodGhpcylcbiAgICB9KVxuICAgIHRoaXMub25FcnJvcihyZWFzb24gPT4ge1xuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGVycm9yICR7dGhpcy50b3BpY31gLCByZWFzb24pXG4gICAgICBpZih0aGlzLmlzSm9pbmluZygpKXsgdGhpcy5qb2luUHVzaC5yZXNldCgpIH1cbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkXG4gICAgICBpZih0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKSB9XG4gICAgfSlcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGB0aW1lb3V0ICR7dGhpcy50b3BpY30gKCR7dGhpcy5qb2luUmVmKCl9KWAsIHRoaXMuam9pblB1c2gudGltZW91dClcbiAgICAgIGxldCBsZWF2ZVB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5sZWF2ZSwgY2xvc3VyZSh7fSksIHRoaXMudGltZW91dClcbiAgICAgIGxlYXZlUHVzaC5zZW5kKClcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkXG4gICAgICB0aGlzLmpvaW5QdXNoLnJlc2V0KClcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpIH1cbiAgICB9KVxuICAgIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMucmVwbHksIChwYXlsb2FkLCByZWYpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcih0aGlzLnJlcGx5RXZlbnROYW1lKHJlZiksIHBheWxvYWQpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBKb2luIHRoZSBjaGFubmVsXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gdGltZW91dFxuICAgKiBAcmV0dXJucyB7UHVzaH1cbiAgICovXG4gIGpvaW4odGltZW91dCA9IHRoaXMudGltZW91dCl7XG4gICAgaWYodGhpcy5qb2luZWRPbmNlKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInRyaWVkIHRvIGpvaW4gbXVsdGlwbGUgdGltZXMuICdqb2luJyBjYW4gb25seSBiZSBjYWxsZWQgYSBzaW5nbGUgdGltZSBwZXIgY2hhbm5lbCBpbnN0YW5jZVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgICB0aGlzLmpvaW5lZE9uY2UgPSB0cnVlXG4gICAgICB0aGlzLnJlam9pbigpXG4gICAgICByZXR1cm4gdGhpcy5qb2luUHVzaFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIb29rIGludG8gY2hhbm5lbCBjbG9zZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25DbG9zZShjYWxsYmFjayl7XG4gICAgdGhpcy5vbihDSEFOTkVMX0VWRU5UUy5jbG9zZSwgY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogSG9vayBpbnRvIGNoYW5uZWwgZXJyb3JzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbkVycm9yKGNhbGxiYWNrKXtcbiAgICByZXR1cm4gdGhpcy5vbihDSEFOTkVMX0VWRU5UUy5lcnJvciwgcmVhc29uID0+IGNhbGxiYWNrKHJlYXNvbikpXG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlcyBvbiBjaGFubmVsIGV2ZW50c1xuICAgKlxuICAgKiBTdWJzY3JpcHRpb24gcmV0dXJucyBhIHJlZiBjb3VudGVyLCB3aGljaCBjYW4gYmUgdXNlZCBsYXRlciB0b1xuICAgKiB1bnN1YnNjcmliZSB0aGUgZXhhY3QgZXZlbnQgbGlzdGVuZXJcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcmVmMSA9IGNoYW5uZWwub24oXCJldmVudFwiLCBkb19zdHVmZilcbiAgICogY29uc3QgcmVmMiA9IGNoYW5uZWwub24oXCJldmVudFwiLCBkb19vdGhlcl9zdHVmZilcbiAgICogY2hhbm5lbC5vZmYoXCJldmVudFwiLCByZWYxKVxuICAgKiAvLyBTaW5jZSB1bnN1YnNjcmlwdGlvbiwgZG9fc3R1ZmYgd29uJ3QgZmlyZSxcbiAgICogLy8gd2hpbGUgZG9fb3RoZXJfc3R1ZmYgd2lsbCBrZWVwIGZpcmluZyBvbiB0aGUgXCJldmVudFwiXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7aW50ZWdlcn0gcmVmXG4gICAqL1xuICBvbihldmVudCwgY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLmJpbmRpbmdSZWYrK1xuICAgIHRoaXMuYmluZGluZ3MucHVzaCh7ZXZlbnQsIHJlZiwgY2FsbGJhY2t9KVxuICAgIHJldHVybiByZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgb2ZmIG9mIGNoYW5uZWwgZXZlbnRzXG4gICAqXG4gICAqIFVzZSB0aGUgcmVmIHJldHVybmVkIGZyb20gYSBjaGFubmVsLm9uKCkgdG8gdW5zdWJzY3JpYmUgb25lXG4gICAqIGhhbmRsZXIsIG9yIHBhc3Mgbm90aGluZyBmb3IgdGhlIHJlZiB0byB1bnN1YnNjcmliZSBhbGxcbiAgICogaGFuZGxlcnMgZm9yIHRoZSBnaXZlbiBldmVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gVW5zdWJzY3JpYmUgdGhlIGRvX3N0dWZmIGhhbmRsZXJcbiAgICogY29uc3QgcmVmMSA9IGNoYW5uZWwub24oXCJldmVudFwiLCBkb19zdHVmZilcbiAgICogY2hhbm5lbC5vZmYoXCJldmVudFwiLCByZWYxKVxuICAgKlxuICAgKiAvLyBVbnN1YnNjcmliZSBhbGwgaGFuZGxlcnMgZnJvbSBldmVudFxuICAgKiBjaGFubmVsLm9mZihcImV2ZW50XCIpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHJlZlxuICAgKi9cbiAgb2ZmKGV2ZW50LCByZWYpe1xuICAgIHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgcmV0dXJuICEoYmluZC5ldmVudCA9PT0gZXZlbnQgJiYgKHR5cGVvZiByZWYgPT09IFwidW5kZWZpbmVkXCIgfHwgcmVmID09PSBiaW5kLnJlZikpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FuUHVzaCgpeyByZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLmlzSm9pbmVkKCkgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIG1lc3NhZ2UgYGV2ZW50YCB0byBwaG9lbml4IHdpdGggdGhlIHBheWxvYWQgYHBheWxvYWRgLlxuICAgKiBQaG9lbml4IHJlY2VpdmVzIHRoaXMgaW4gdGhlIGBoYW5kbGVfaW4oZXZlbnQsIHBheWxvYWQsIHNvY2tldClgXG4gICAqIGZ1bmN0aW9uLiBpZiBwaG9lbml4IHJlcGxpZXMgb3IgaXQgdGltZXMgb3V0IChkZWZhdWx0IDEwMDAwbXMpLFxuICAgKiB0aGVuIG9wdGlvbmFsbHkgdGhlIHJlcGx5IGNhbiBiZSByZWNlaXZlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY2hhbm5lbC5wdXNoKFwiZXZlbnRcIilcbiAgICogICAucmVjZWl2ZShcIm9rXCIsIHBheWxvYWQgPT4gY29uc29sZS5sb2coXCJwaG9lbml4IHJlcGxpZWQ6XCIsIHBheWxvYWQpKVxuICAgKiAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgZXJyID0+IGNvbnNvbGUubG9nKFwicGhvZW5peCBlcnJvcmVkXCIsIGVycikpXG4gICAqICAgLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IGNvbnNvbGUubG9nKFwidGltZWQgb3V0IHB1c2hpbmdcIikpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVvdXRdXG4gICAqIEByZXR1cm5zIHtQdXNofVxuICAgKi9cbiAgcHVzaChldmVudCwgcGF5bG9hZCwgdGltZW91dCA9IHRoaXMudGltZW91dCl7XG4gICAgcGF5bG9hZCA9IHBheWxvYWQgfHwge31cbiAgICBpZighdGhpcy5qb2luZWRPbmNlKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHJpZWQgdG8gcHVzaCAnJHtldmVudH0nIHRvICcke3RoaXMudG9waWN9JyBiZWZvcmUgam9pbmluZy4gVXNlIGNoYW5uZWwuam9pbigpIGJlZm9yZSBwdXNoaW5nIGV2ZW50c2ApXG4gICAgfVxuICAgIGxldCBwdXNoRXZlbnQgPSBuZXcgUHVzaCh0aGlzLCBldmVudCwgZnVuY3Rpb24gKCl7IHJldHVybiBwYXlsb2FkIH0sIHRpbWVvdXQpXG4gICAgaWYodGhpcy5jYW5QdXNoKCkpe1xuICAgICAgcHVzaEV2ZW50LnNlbmQoKVxuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoRXZlbnQuc3RhcnRUaW1lb3V0KClcbiAgICAgIHRoaXMucHVzaEJ1ZmZlci5wdXNoKHB1c2hFdmVudClcbiAgICB9XG5cbiAgICByZXR1cm4gcHVzaEV2ZW50XG4gIH1cblxuICAvKiogTGVhdmVzIHRoZSBjaGFubmVsXG4gICAqXG4gICAqIFVuc3Vic2NyaWJlcyBmcm9tIHNlcnZlciBldmVudHMsIGFuZFxuICAgKiBpbnN0cnVjdHMgY2hhbm5lbCB0byB0ZXJtaW5hdGUgb24gc2VydmVyXG4gICAqXG4gICAqIFRyaWdnZXJzIG9uQ2xvc2UoKSBob29rc1xuICAgKlxuICAgKiBUbyByZWNlaXZlIGxlYXZlIGFja25vd2xlZGdlbWVudHMsIHVzZSB0aGUgYHJlY2VpdmVgXG4gICAqIGhvb2sgdG8gYmluZCB0byB0aGUgc2VydmVyIGFjaywgaWU6XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNoYW5uZWwubGVhdmUoKS5yZWNlaXZlKFwib2tcIiwgKCkgPT4gYWxlcnQoXCJsZWZ0IVwiKSApXG4gICAqXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gdGltZW91dFxuICAgKiBAcmV0dXJucyB7UHVzaH1cbiAgICovXG4gIGxlYXZlKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpe1xuICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgIHRoaXMuam9pblB1c2guY2FuY2VsVGltZW91dCgpXG5cbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMubGVhdmluZ1xuICAgIGxldCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGxlYXZlICR7dGhpcy50b3BpY31gKVxuICAgICAgdGhpcy50cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmNsb3NlLCBcImxlYXZlXCIpXG4gICAgfVxuICAgIGxldCBsZWF2ZVB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5sZWF2ZSwgY2xvc3VyZSh7fSksIHRpbWVvdXQpXG4gICAgbGVhdmVQdXNoLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBvbkNsb3NlKCkpXG4gICAgICAucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4gb25DbG9zZSgpKVxuICAgIGxlYXZlUHVzaC5zZW5kKClcbiAgICBpZighdGhpcy5jYW5QdXNoKCkpeyBsZWF2ZVB1c2gudHJpZ2dlcihcIm9rXCIsIHt9KSB9XG5cbiAgICByZXR1cm4gbGVhdmVQdXNoXG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGFibGUgbWVzc2FnZSBob29rXG4gICAqXG4gICAqIFJlY2VpdmVzIGFsbCBldmVudHMgZm9yIHNwZWNpYWxpemVkIG1lc3NhZ2UgaGFuZGxpbmdcbiAgICogYmVmb3JlIGRpc3BhdGNoaW5nIHRvIHRoZSBjaGFubmVsIGNhbGxiYWNrcy5cbiAgICpcbiAgICogTXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gcmVmXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBvbk1lc3NhZ2UoX2V2ZW50LCBwYXlsb2FkLCBfcmVmKXsgcmV0dXJuIHBheWxvYWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNNZW1iZXIodG9waWMsIGV2ZW50LCBwYXlsb2FkLCBqb2luUmVmKXtcbiAgICBpZih0aGlzLnRvcGljICE9PSB0b3BpYyl7IHJldHVybiBmYWxzZSB9XG5cbiAgICBpZihqb2luUmVmICYmIGpvaW5SZWYgIT09IHRoaXMuam9pblJlZigpKXtcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIFwiZHJvcHBpbmcgb3V0ZGF0ZWQgbWVzc2FnZVwiLCB7dG9waWMsIGV2ZW50LCBwYXlsb2FkLCBqb2luUmVmfSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgam9pblJlZigpeyByZXR1cm4gdGhpcy5qb2luUHVzaC5yZWYgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpe1xuICAgIGlmKHRoaXMuaXNMZWF2aW5nKCkpeyByZXR1cm4gfVxuICAgIHRoaXMuc29ja2V0LmxlYXZlT3BlblRvcGljKHRoaXMudG9waWMpXG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5pbmdcbiAgICB0aGlzLmpvaW5QdXNoLnJlc2VuZCh0aW1lb3V0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5SZWYpe1xuICAgIGxldCBoYW5kbGVkUGF5bG9hZCA9IHRoaXMub25NZXNzYWdlKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5SZWYpXG4gICAgaWYocGF5bG9hZCAmJiAhaGFuZGxlZFBheWxvYWQpeyB0aHJvdyBuZXcgRXJyb3IoXCJjaGFubmVsIG9uTWVzc2FnZSBjYWxsYmFja3MgbXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWRcIikgfVxuXG4gICAgbGV0IGV2ZW50QmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmZpbHRlcihiaW5kID0+IGJpbmQuZXZlbnQgPT09IGV2ZW50KVxuXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGV2ZW50QmluZGluZ3MubGVuZ3RoOyBpKyspe1xuICAgICAgbGV0IGJpbmQgPSBldmVudEJpbmRpbmdzW2ldXG4gICAgICBiaW5kLmNhbGxiYWNrKGhhbmRsZWRQYXlsb2FkLCByZWYsIGpvaW5SZWYgfHwgdGhpcy5qb2luUmVmKCkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXBseUV2ZW50TmFtZShyZWYpeyByZXR1cm4gYGNoYW5fcmVwbHlfJHtyZWZ9YCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0Nsb3NlZCgpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzRXJyb3JlZCgpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0pvaW5lZCgpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmVkIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzSm9pbmluZygpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmluZyB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0xlYXZpbmcoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmxlYXZpbmcgfVxufVxuIiwgImltcG9ydCB7XG4gIGdsb2JhbCxcbiAgWEhSX1NUQVRFU1xufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBamF4IHtcblxuICBzdGF0aWMgcmVxdWVzdChtZXRob2QsIGVuZFBvaW50LCBhY2NlcHQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spe1xuICAgIGlmKGdsb2JhbC5YRG9tYWluUmVxdWVzdCl7XG4gICAgICBsZXQgcmVxID0gbmV3IGdsb2JhbC5YRG9tYWluUmVxdWVzdCgpIC8vIElFOCwgSUU5XG4gICAgICByZXR1cm4gdGhpcy54ZG9tYWluUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KCkgLy8gSUU3KywgRmlyZWZveCwgQ2hyb21lLCBPcGVyYSwgU2FmYXJpXG4gICAgICByZXR1cm4gdGhpcy54aHJSZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyB4ZG9tYWluUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spe1xuICAgIHJlcS50aW1lb3V0ID0gdGltZW91dFxuICAgIHJlcS5vcGVuKG1ldGhvZCwgZW5kUG9pbnQpXG4gICAgcmVxLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGxldCByZXNwb25zZSA9IHRoaXMucGFyc2VKU09OKHJlcS5yZXNwb25zZVRleHQpXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwb25zZSlcbiAgICB9XG4gICAgaWYob250aW1lb3V0KXsgcmVxLm9udGltZW91dCA9IG9udGltZW91dCB9XG5cbiAgICAvLyBXb3JrIGFyb3VuZCBidWcgaW4gSUU5IHRoYXQgcmVxdWlyZXMgYW4gYXR0YWNoZWQgb25wcm9ncmVzcyBoYW5kbGVyXG4gICAgcmVxLm9ucHJvZ3Jlc3MgPSAoKSA9PiB7IH1cblxuICAgIHJlcS5zZW5kKGJvZHkpXG4gICAgcmV0dXJuIHJlcVxuICB9XG5cbiAgc3RhdGljIHhoclJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBhY2NlcHQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spe1xuICAgIHJlcS5vcGVuKG1ldGhvZCwgZW5kUG9pbnQsIHRydWUpXG4gICAgcmVxLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgYWNjZXB0KVxuICAgIHJlcS5vbmVycm9yID0gKCkgPT4gY2FsbGJhY2sgJiYgY2FsbGJhY2sobnVsbClcbiAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYocmVxLnJlYWR5U3RhdGUgPT09IFhIUl9TVEFURVMuY29tcGxldGUgJiYgY2FsbGJhY2spe1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KVxuICAgICAgICBjYWxsYmFjayhyZXNwb25zZSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYob250aW1lb3V0KXsgcmVxLm9udGltZW91dCA9IG9udGltZW91dCB9XG5cbiAgICByZXEuc2VuZChib2R5KVxuICAgIHJldHVybiByZXFcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZUpTT04ocmVzcCl7XG4gICAgaWYoIXJlc3AgfHwgcmVzcCA9PT0gXCJcIil7IHJldHVybiBudWxsIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwKVxuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgY29uc29sZSAmJiBjb25zb2xlLmxvZyhcImZhaWxlZCB0byBwYXJzZSBKU09OIHJlc3BvbnNlXCIsIHJlc3ApXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBzZXJpYWxpemUob2JqLCBwYXJlbnRLZXkpe1xuICAgIGxldCBxdWVyeVN0ciA9IFtdXG4gICAgZm9yKHZhciBrZXkgaW4gb2JqKXtcbiAgICAgIGlmKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKXsgY29udGludWUgfVxuICAgICAgbGV0IHBhcmFtS2V5ID0gcGFyZW50S2V5ID8gYCR7cGFyZW50S2V5fVske2tleX1dYCA6IGtleVxuICAgICAgbGV0IHBhcmFtVmFsID0gb2JqW2tleV1cbiAgICAgIGlmKHR5cGVvZiBwYXJhbVZhbCA9PT0gXCJvYmplY3RcIil7XG4gICAgICAgIHF1ZXJ5U3RyLnB1c2godGhpcy5zZXJpYWxpemUocGFyYW1WYWwsIHBhcmFtS2V5KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5U3RyLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtS2V5KSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtVmFsKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5U3RyLmpvaW4oXCImXCIpXG4gIH1cblxuICBzdGF0aWMgYXBwZW5kUGFyYW1zKHVybCwgcGFyYW1zKXtcbiAgICBpZihPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMCl7IHJldHVybiB1cmwgfVxuXG4gICAgbGV0IHByZWZpeCA9IHVybC5tYXRjaCgvXFw/LykgPyBcIiZcIiA6IFwiP1wiXG4gICAgcmV0dXJuIGAke3VybH0ke3ByZWZpeH0ke3RoaXMuc2VyaWFsaXplKHBhcmFtcyl9YFxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgU09DS0VUX1NUQVRFUyxcbiAgVFJBTlNQT1JUU1xufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQgQWpheCBmcm9tIFwiLi9hamF4XCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9uZ1BvbGwge1xuXG4gIGNvbnN0cnVjdG9yKGVuZFBvaW50KXtcbiAgICB0aGlzLmVuZFBvaW50ID0gbnVsbFxuICAgIHRoaXMudG9rZW4gPSBudWxsXG4gICAgdGhpcy5za2lwSGVhcnRiZWF0ID0gdHJ1ZVxuICAgIHRoaXMucmVxcyA9IG5ldyBTZXQoKVxuICAgIHRoaXMub25vcGVuID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMub25lcnJvciA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICB0aGlzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICB0aGlzLm9uY2xvc2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5wb2xsRW5kcG9pbnQgPSB0aGlzLm5vcm1hbGl6ZUVuZHBvaW50KGVuZFBvaW50KVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZ1xuICAgIHRoaXMucG9sbCgpXG4gIH1cblxuICBub3JtYWxpemVFbmRwb2ludChlbmRQb2ludCl7XG4gICAgcmV0dXJuIChlbmRQb2ludFxuICAgICAgLnJlcGxhY2UoXCJ3czovL1wiLCBcImh0dHA6Ly9cIilcbiAgICAgIC5yZXBsYWNlKFwid3NzOi8vXCIsIFwiaHR0cHM6Ly9cIilcbiAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoLiopXFwvXCIgKyBUUkFOU1BPUlRTLndlYnNvY2tldCksIFwiJDEvXCIgKyBUUkFOU1BPUlRTLmxvbmdwb2xsKSlcbiAgfVxuXG4gIGVuZHBvaW50VVJMKCl7XG4gICAgcmV0dXJuIEFqYXguYXBwZW5kUGFyYW1zKHRoaXMucG9sbEVuZHBvaW50LCB7dG9rZW46IHRoaXMudG9rZW59KVxuICB9XG5cbiAgY2xvc2VBbmRSZXRyeShjb2RlLCByZWFzb24sIHdhc0NsZWFuKXtcbiAgICB0aGlzLmNsb3NlKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nXG4gIH1cblxuICBvbnRpbWVvdXQoKXtcbiAgICB0aGlzLm9uZXJyb3IoXCJ0aW1lb3V0XCIpXG4gICAgdGhpcy5jbG9zZUFuZFJldHJ5KDEwMDUsIFwidGltZW91dFwiLCBmYWxzZSlcbiAgfVxuXG4gIGlzQWN0aXZlKCl7IHJldHVybiB0aGlzLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMub3BlbiB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZyB9XG5cbiAgcG9sbCgpe1xuICAgIHRoaXMuYWpheChcIkdFVFwiLCBudWxsLCAoKSA9PiB0aGlzLm9udGltZW91dCgpLCByZXNwID0+IHtcbiAgICAgIGlmKHJlc3Ape1xuICAgICAgICB2YXIge3N0YXR1cywgdG9rZW4sIG1lc3NhZ2VzfSA9IHJlc3BcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0dXMgPSAwXG4gICAgICB9XG5cbiAgICAgIHN3aXRjaChzdGF0dXMpe1xuICAgICAgICBjYXNlIDIwMDpcbiAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKG1zZyA9PiB7XG4gICAgICAgICAgICAvLyBUYXNrcyBhcmUgd2hhdCB0aGluZ3MgbGlrZSBldmVudCBoYW5kbGVycywgc2V0VGltZW91dCBjYWxsYmFja3MsXG4gICAgICAgICAgICAvLyBwcm9taXNlIHJlc29sdmVzIGFuZCBtb3JlIGFyZSBydW4gd2l0aGluLlxuICAgICAgICAgICAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzLCB0aGVyZSBhcmUgdHdvIGRpZmZlcmVudCBraW5kcyBvZiB0YXNrcyxcbiAgICAgICAgICAgIC8vIG1pY3JvdGFza3MgYW5kIG1hY3JvdGFza3MuXG4gICAgICAgICAgICAvLyBNaWNyb3Rhc2tzIGFyZSBtYWlubHkgdXNlZCBmb3IgUHJvbWlzZXMsIHdoaWxlIG1hY3JvdGFza3MgYXJlXG4gICAgICAgICAgICAvLyB1c2VkIGZvciBldmVyeXRoaW5nIGVsc2UuXG4gICAgICAgICAgICAvLyBNaWNyb3Rhc2tzIGFsd2F5cyBoYXZlIHByaW9yaXR5IG92ZXIgbWFjcm90YXNrcy4gSWYgdGhlIEpTIGVuZ2luZVxuICAgICAgICAgICAgLy8gaXMgbG9va2luZyBmb3IgYSB0YXNrIHRvIHJ1biwgaXQgd2lsbCBhbHdheXMgdHJ5IHRvIGVtcHR5IHRoZVxuICAgICAgICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHJ1biBhbnl0aGluZyBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gbWFjcm90YXNrIHF1ZXVlLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEZvciB0aGUgV2ViU29ja2V0IHRyYW5zcG9ydCwgbWVzc2FnZXMgYWx3YXlzIGFycml2ZSBpbiB0aGVpciBvd25cbiAgICAgICAgICAgIC8vIGV2ZW50LiBUaGlzIG1lYW5zIHRoYXQgaWYgYW55IHByb21pc2VzIGFyZSByZXNvbHZlZCBmcm9tIHdpdGhpbixcbiAgICAgICAgICAgIC8vIHRoZWlyIGNhbGxiYWNrcyB3aWxsIGFsd2F5cyBmaW5pc2ggZXhlY3V0aW9uIGJ5IHRoZSB0aW1lIHRoZVxuICAgICAgICAgICAgLy8gbmV4dCBtZXNzYWdlIGV2ZW50IGhhbmRsZXIgaXMgcnVuLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIGVtdWxhdGUgdGhpcyBiZWhhdmlvdXIsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGVhY2hcbiAgICAgICAgICAgIC8vIG9ubWVzc2FnZSBoYW5kbGVyIGlzIHJ1biB3aXRoaW4gaXQncyBvd24gbWFjcm90YXNrLlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLm9ubWVzc2FnZSh7ZGF0YTogbXNnfSksIDApXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0aGlzLnBvbGwoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgIHRoaXMucG9sbCgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0MTA6XG4gICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5vcGVuXG4gICAgICAgICAgdGhpcy5vbm9wZW4oe30pXG4gICAgICAgICAgdGhpcy5wb2xsKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQwMzpcbiAgICAgICAgICB0aGlzLm9uZXJyb3IoNDAzKVxuICAgICAgICAgIHRoaXMuY2xvc2UoMTAwOCwgXCJmb3JiaWRkZW5cIiwgZmFsc2UpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDUwMDpcbiAgICAgICAgICB0aGlzLm9uZXJyb3IoNTAwKVxuICAgICAgICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgxMDExLCBcImludGVybmFsIHNlcnZlciBlcnJvclwiLCA1MDApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgcG9sbCBzdGF0dXMgJHtzdGF0dXN9YClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc2VuZChib2R5KXtcbiAgICB0aGlzLmFqYXgoXCJQT1NUXCIsIGJvZHksICgpID0+IHRoaXMub25lcnJvcihcInRpbWVvdXRcIiksIHJlc3AgPT4ge1xuICAgICAgaWYoIXJlc3AgfHwgcmVzcC5zdGF0dXMgIT09IDIwMCl7XG4gICAgICAgIHRoaXMub25lcnJvcihyZXNwICYmIHJlc3Auc3RhdHVzKVxuICAgICAgICB0aGlzLmNsb3NlQW5kUmV0cnkoMTAxMSwgXCJpbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIiwgZmFsc2UpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNsb3NlKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pe1xuICAgIGZvcihsZXQgcmVxIG9mIHRoaXMucmVxcyl7IHJlcS5hYm9ydCgpIH1cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNsb3NlZFxuICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7Y29kZTogMTAwMCwgcmVhc29uOiB1bmRlZmluZWQsIHdhc0NsZWFuOiB0cnVlfSwge2NvZGUsIHJlYXNvbiwgd2FzQ2xlYW59KVxuICAgIGlmKHR5cGVvZihDbG9zZUV2ZW50KSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICB0aGlzLm9uY2xvc2UobmV3IENsb3NlRXZlbnQoXCJjbG9zZVwiLCBvcHRzKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbmNsb3NlKG9wdHMpXG4gICAgfVxuICB9XG5cbiAgYWpheChtZXRob2QsIGJvZHksIG9uQ2FsbGVyVGltZW91dCwgY2FsbGJhY2spe1xuICAgIGxldCByZXFcbiAgICBsZXQgb250aW1lb3V0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5yZXFzLmRlbGV0ZShyZXEpXG4gICAgICBvbkNhbGxlclRpbWVvdXQoKVxuICAgIH1cbiAgICByZXEgPSBBamF4LnJlcXVlc3QobWV0aG9kLCB0aGlzLmVuZHBvaW50VVJMKCksIFwiYXBwbGljYXRpb24vanNvblwiLCBib2R5LCB0aGlzLnRpbWVvdXQsIG9udGltZW91dCwgcmVzcCA9PiB7XG4gICAgICB0aGlzLnJlcXMuZGVsZXRlKHJlcSlcbiAgICAgIGlmKHRoaXMuaXNBY3RpdmUoKSl7IGNhbGxiYWNrKHJlc3ApIH1cbiAgICB9KVxuICAgIHRoaXMucmVxcy5hZGQocmVxKVxuICB9XG59XG4iLCAiLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgUHJlc2VuY2VcbiAqIEBwYXJhbSB7Q2hhbm5lbH0gY2hhbm5lbCAtIFRoZSBDaGFubmVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBvcHRpb25zLFxuICogICAgICAgIGZvciBleGFtcGxlIGB7ZXZlbnRzOiB7c3RhdGU6IFwic3RhdGVcIiwgZGlmZjogXCJkaWZmXCJ9fWBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJlc2VuY2Uge1xuXG4gIGNvbnN0cnVjdG9yKGNoYW5uZWwsIG9wdHMgPSB7fSl7XG4gICAgbGV0IGV2ZW50cyA9IG9wdHMuZXZlbnRzIHx8IHtzdGF0ZTogXCJwcmVzZW5jZV9zdGF0ZVwiLCBkaWZmOiBcInByZXNlbmNlX2RpZmZcIn1cbiAgICB0aGlzLnN0YXRlID0ge31cbiAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdXG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbFxuICAgIHRoaXMuam9pblJlZiA9IG51bGxcbiAgICB0aGlzLmNhbGxlciA9IHtcbiAgICAgIG9uSm9pbjogZnVuY3Rpb24gKCl7IH0sXG4gICAgICBvbkxlYXZlOiBmdW5jdGlvbiAoKXsgfSxcbiAgICAgIG9uU3luYzogZnVuY3Rpb24gKCl7IH1cbiAgICB9XG5cbiAgICB0aGlzLmNoYW5uZWwub24oZXZlbnRzLnN0YXRlLCBuZXdTdGF0ZSA9PiB7XG4gICAgICBsZXQge29uSm9pbiwgb25MZWF2ZSwgb25TeW5jfSA9IHRoaXMuY2FsbGVyXG5cbiAgICAgIHRoaXMuam9pblJlZiA9IHRoaXMuY2hhbm5lbC5qb2luUmVmKClcbiAgICAgIHRoaXMuc3RhdGUgPSBQcmVzZW5jZS5zeW5jU3RhdGUodGhpcy5zdGF0ZSwgbmV3U3RhdGUsIG9uSm9pbiwgb25MZWF2ZSlcblxuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMuZm9yRWFjaChkaWZmID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFByZXNlbmNlLnN5bmNEaWZmKHRoaXMuc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSlcbiAgICAgIH0pXG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdXG4gICAgICBvblN5bmMoKVxuICAgIH0pXG5cbiAgICB0aGlzLmNoYW5uZWwub24oZXZlbnRzLmRpZmYsIGRpZmYgPT4ge1xuICAgICAgbGV0IHtvbkpvaW4sIG9uTGVhdmUsIG9uU3luY30gPSB0aGlzLmNhbGxlclxuXG4gICAgICBpZih0aGlzLmluUGVuZGluZ1N5bmNTdGF0ZSgpKXtcbiAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMucHVzaChkaWZmKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFByZXNlbmNlLnN5bmNEaWZmKHRoaXMuc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSlcbiAgICAgICAgb25TeW5jKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgb25Kb2luKGNhbGxiYWNrKXsgdGhpcy5jYWxsZXIub25Kb2luID0gY2FsbGJhY2sgfVxuXG4gIG9uTGVhdmUoY2FsbGJhY2speyB0aGlzLmNhbGxlci5vbkxlYXZlID0gY2FsbGJhY2sgfVxuXG4gIG9uU3luYyhjYWxsYmFjayl7IHRoaXMuY2FsbGVyLm9uU3luYyA9IGNhbGxiYWNrIH1cblxuICBsaXN0KGJ5KXsgcmV0dXJuIFByZXNlbmNlLmxpc3QodGhpcy5zdGF0ZSwgYnkpIH1cblxuICBpblBlbmRpbmdTeW5jU3RhdGUoKXtcbiAgICByZXR1cm4gIXRoaXMuam9pblJlZiB8fCAodGhpcy5qb2luUmVmICE9PSB0aGlzLmNoYW5uZWwuam9pblJlZigpKVxuICB9XG5cbiAgLy8gbG93ZXItbGV2ZWwgcHVibGljIHN0YXRpYyBBUElcblxuICAvKipcbiAgICogVXNlZCB0byBzeW5jIHRoZSBsaXN0IG9mIHByZXNlbmNlcyBvbiB0aGUgc2VydmVyXG4gICAqIHdpdGggdGhlIGNsaWVudCdzIHN0YXRlLiBBbiBvcHRpb25hbCBgb25Kb2luYCBhbmQgYG9uTGVhdmVgIGNhbGxiYWNrIGNhblxuICAgKiBiZSBwcm92aWRlZCB0byByZWFjdCB0byBjaGFuZ2VzIGluIHRoZSBjbGllbnQncyBsb2NhbCBwcmVzZW5jZXMgYWNyb3NzXG4gICAqIGRpc2Nvbm5lY3RzIGFuZCByZWNvbm5lY3RzIHdpdGggdGhlIHNlcnZlci5cbiAgICpcbiAgICogQHJldHVybnMge1ByZXNlbmNlfVxuICAgKi9cbiAgc3RhdGljIHN5bmNTdGF0ZShjdXJyZW50U3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpe1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuY2xvbmUoY3VycmVudFN0YXRlKVxuICAgIGxldCBqb2lucyA9IHt9XG4gICAgbGV0IGxlYXZlcyA9IHt9XG5cbiAgICB0aGlzLm1hcChzdGF0ZSwgKGtleSwgcHJlc2VuY2UpID0+IHtcbiAgICAgIGlmKCFuZXdTdGF0ZVtrZXldKXtcbiAgICAgICAgbGVhdmVzW2tleV0gPSBwcmVzZW5jZVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5tYXAobmV3U3RhdGUsIChrZXksIG5ld1ByZXNlbmNlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XVxuICAgICAgaWYoY3VycmVudFByZXNlbmNlKXtcbiAgICAgICAgbGV0IG5ld1JlZnMgPSBuZXdQcmVzZW5jZS5tZXRhcy5tYXAobSA9PiBtLnBoeF9yZWYpXG4gICAgICAgIGxldCBjdXJSZWZzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgICAgbGV0IGpvaW5lZE1ldGFzID0gbmV3UHJlc2VuY2UubWV0YXMuZmlsdGVyKG0gPT4gY3VyUmVmcy5pbmRleE9mKG0ucGh4X3JlZikgPCAwKVxuICAgICAgICBsZXQgbGVmdE1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcihtID0+IG5ld1JlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMClcbiAgICAgICAgaWYoam9pbmVkTWV0YXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgam9pbnNba2V5XSA9IG5ld1ByZXNlbmNlXG4gICAgICAgICAgam9pbnNba2V5XS5tZXRhcyA9IGpvaW5lZE1ldGFzXG4gICAgICAgIH1cbiAgICAgICAgaWYobGVmdE1ldGFzLmxlbmd0aCA+IDApe1xuICAgICAgICAgIGxlYXZlc1trZXldID0gdGhpcy5jbG9uZShjdXJyZW50UHJlc2VuY2UpXG4gICAgICAgICAgbGVhdmVzW2tleV0ubWV0YXMgPSBsZWZ0TWV0YXNcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgam9pbnNba2V5XSA9IG5ld1ByZXNlbmNlXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy5zeW5jRGlmZihzdGF0ZSwge2pvaW5zOiBqb2lucywgbGVhdmVzOiBsZWF2ZXN9LCBvbkpvaW4sIG9uTGVhdmUpXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogVXNlZCB0byBzeW5jIGEgZGlmZiBvZiBwcmVzZW5jZSBqb2luIGFuZCBsZWF2ZVxuICAgKiBldmVudHMgZnJvbSB0aGUgc2VydmVyLCBhcyB0aGV5IGhhcHBlbi4gTGlrZSBgc3luY1N0YXRlYCwgYHN5bmNEaWZmYFxuICAgKiBhY2NlcHRzIG9wdGlvbmFsIGBvbkpvaW5gIGFuZCBgb25MZWF2ZWAgY2FsbGJhY2tzIHRvIHJlYWN0IHRvIGEgdXNlclxuICAgKiBqb2luaW5nIG9yIGxlYXZpbmcgZnJvbSBhIGRldmljZS5cbiAgICpcbiAgICogQHJldHVybnMge1ByZXNlbmNlfVxuICAgKi9cbiAgc3RhdGljIHN5bmNEaWZmKHN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpe1xuICAgIGxldCB7am9pbnMsIGxlYXZlc30gPSB0aGlzLmNsb25lKGRpZmYpXG4gICAgaWYoIW9uSm9pbil7IG9uSm9pbiA9IGZ1bmN0aW9uICgpeyB9IH1cbiAgICBpZighb25MZWF2ZSl7IG9uTGVhdmUgPSBmdW5jdGlvbiAoKXsgfSB9XG5cbiAgICB0aGlzLm1hcChqb2lucywgKGtleSwgbmV3UHJlc2VuY2UpID0+IHtcbiAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldXG4gICAgICBzdGF0ZVtrZXldID0gdGhpcy5jbG9uZShuZXdQcmVzZW5jZSlcbiAgICAgIGlmKGN1cnJlbnRQcmVzZW5jZSl7XG4gICAgICAgIGxldCBqb2luZWRSZWZzID0gc3RhdGVba2V5XS5tZXRhcy5tYXAobSA9PiBtLnBoeF9yZWYpXG4gICAgICAgIGxldCBjdXJNZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIobSA9PiBqb2luZWRSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApXG4gICAgICAgIHN0YXRlW2tleV0ubWV0YXMudW5zaGlmdCguLi5jdXJNZXRhcylcbiAgICAgIH1cbiAgICAgIG9uSm9pbihrZXksIGN1cnJlbnRQcmVzZW5jZSwgbmV3UHJlc2VuY2UpXG4gICAgfSlcbiAgICB0aGlzLm1hcChsZWF2ZXMsIChrZXksIGxlZnRQcmVzZW5jZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZSA9IHN0YXRlW2tleV1cbiAgICAgIGlmKCFjdXJyZW50UHJlc2VuY2UpeyByZXR1cm4gfVxuICAgICAgbGV0IHJlZnNUb1JlbW92ZSA9IGxlZnRQcmVzZW5jZS5tZXRhcy5tYXAobSA9PiBtLnBoeF9yZWYpXG4gICAgICBjdXJyZW50UHJlc2VuY2UubWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKHAgPT4ge1xuICAgICAgICByZXR1cm4gcmVmc1RvUmVtb3ZlLmluZGV4T2YocC5waHhfcmVmKSA8IDBcbiAgICAgIH0pXG4gICAgICBvbkxlYXZlKGtleSwgY3VycmVudFByZXNlbmNlLCBsZWZ0UHJlc2VuY2UpXG4gICAgICBpZihjdXJyZW50UHJlc2VuY2UubWV0YXMubGVuZ3RoID09PSAwKXtcbiAgICAgICAgZGVsZXRlIHN0YXRlW2tleV1cbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBzdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFycmF5IG9mIHByZXNlbmNlcywgd2l0aCBzZWxlY3RlZCBtZXRhZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByZXNlbmNlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaG9vc2VyXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcmVzZW5jZX1cbiAgICovXG4gIHN0YXRpYyBsaXN0KHByZXNlbmNlcywgY2hvb3Nlcil7XG4gICAgaWYoIWNob29zZXIpeyBjaG9vc2VyID0gZnVuY3Rpb24gKGtleSwgcHJlcyl7IHJldHVybiBwcmVzIH0gfVxuXG4gICAgcmV0dXJuIHRoaXMubWFwKHByZXNlbmNlcywgKGtleSwgcHJlc2VuY2UpID0+IHtcbiAgICAgIHJldHVybiBjaG9vc2VyKGtleSwgcHJlc2VuY2UpXG4gICAgfSlcbiAgfVxuXG4gIC8vIHByaXZhdGVcblxuICBzdGF0aWMgbWFwKG9iaiwgZnVuYyl7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubWFwKGtleSA9PiBmdW5jKGtleSwgb2JqW2tleV0pKVxuICB9XG5cbiAgc3RhdGljIGNsb25lKG9iail7IHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpIH1cbn1cbiIsICIvKiBUaGUgZGVmYXVsdCBzZXJpYWxpemVyIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgbWVzc2FnZXMgKi9cbmltcG9ydCB7XG4gIENIQU5ORUxfRVZFTlRTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgSEVBREVSX0xFTkdUSDogMSxcbiAgTUVUQV9MRU5HVEg6IDQsXG4gIEtJTkRTOiB7cHVzaDogMCwgcmVwbHk6IDEsIGJyb2FkY2FzdDogMn0sXG5cbiAgZW5jb2RlKG1zZywgY2FsbGJhY2spe1xuICAgIGlmKG1zZy5wYXlsb2FkLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcil7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5iaW5hcnlFbmNvZGUobXNnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBheWxvYWQgPSBbbXNnLmpvaW5fcmVmLCBtc2cucmVmLCBtc2cudG9waWMsIG1zZy5ldmVudCwgbXNnLnBheWxvYWRdXG4gICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpXG4gICAgfVxuICB9LFxuXG4gIGRlY29kZShyYXdQYXlsb2FkLCBjYWxsYmFjayl7XG4gICAgaWYocmF3UGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpe1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuYmluYXJ5RGVjb2RlKHJhd1BheWxvYWQpKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgW2pvaW5fcmVmLCByZWYsIHRvcGljLCBldmVudCwgcGF5bG9hZF0gPSBKU09OLnBhcnNlKHJhd1BheWxvYWQpXG4gICAgICByZXR1cm4gY2FsbGJhY2soe2pvaW5fcmVmLCByZWYsIHRvcGljLCBldmVudCwgcGF5bG9hZH0pXG4gICAgfVxuICB9LFxuXG4gIC8vIHByaXZhdGVcblxuICBiaW5hcnlFbmNvZGUobWVzc2FnZSl7XG4gICAgbGV0IHtqb2luX3JlZiwgcmVmLCBldmVudCwgdG9waWMsIHBheWxvYWR9ID0gbWVzc2FnZVxuICAgIGxldCBtZXRhTGVuZ3RoID0gdGhpcy5NRVRBX0xFTkdUSCArIGpvaW5fcmVmLmxlbmd0aCArIHJlZi5sZW5ndGggKyB0b3BpYy5sZW5ndGggKyBldmVudC5sZW5ndGhcbiAgICBsZXQgaGVhZGVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuSEVBREVSX0xFTkdUSCArIG1ldGFMZW5ndGgpXG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoaGVhZGVyKVxuICAgIGxldCBvZmZzZXQgPSAwXG5cbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCB0aGlzLktJTkRTLnB1c2gpIC8vIGtpbmRcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBqb2luX3JlZi5sZW5ndGgpXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgcmVmLmxlbmd0aClcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCB0b3BpYy5sZW5ndGgpXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgZXZlbnQubGVuZ3RoKVxuICAgIEFycmF5LmZyb20oam9pbl9yZWYsIGNoYXIgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcbiAgICBBcnJheS5mcm9tKHJlZiwgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuICAgIEFycmF5LmZyb20odG9waWMsIGNoYXIgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcbiAgICBBcnJheS5mcm9tKGV2ZW50LCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG5cbiAgICB2YXIgY29tYmluZWQgPSBuZXcgVWludDhBcnJheShoZWFkZXIuYnl0ZUxlbmd0aCArIHBheWxvYWQuYnl0ZUxlbmd0aClcbiAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkoaGVhZGVyKSwgMClcbiAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIGhlYWRlci5ieXRlTGVuZ3RoKVxuXG4gICAgcmV0dXJuIGNvbWJpbmVkLmJ1ZmZlclxuICB9LFxuXG4gIGJpbmFyeURlY29kZShidWZmZXIpe1xuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcilcbiAgICBsZXQga2luZCA9IHZpZXcuZ2V0VWludDgoMClcbiAgICBsZXQgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSB0aGlzLktJTkRTLnB1c2g6IHJldHVybiB0aGlzLmRlY29kZVB1c2goYnVmZmVyLCB2aWV3LCBkZWNvZGVyKVxuICAgICAgY2FzZSB0aGlzLktJTkRTLnJlcGx5OiByZXR1cm4gdGhpcy5kZWNvZGVSZXBseShidWZmZXIsIHZpZXcsIGRlY29kZXIpXG4gICAgICBjYXNlIHRoaXMuS0lORFMuYnJvYWRjYXN0OiByZXR1cm4gdGhpcy5kZWNvZGVCcm9hZGNhc3QoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKVxuICAgIH1cbiAgfSxcblxuICBkZWNvZGVQdXNoKGJ1ZmZlciwgdmlldywgZGVjb2Rlcil7XG4gICAgbGV0IGpvaW5SZWZTaXplID0gdmlldy5nZXRVaW50OCgxKVxuICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDIpXG4gICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoMylcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgdGhpcy5NRVRBX0xFTkdUSCAtIDEgLy8gcHVzaGVzIGhhdmUgbm8gcmVmXG4gICAgbGV0IGpvaW5SZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBqb2luUmVmU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgam9pblJlZlNpemVcbiAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZVxuICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplXG4gICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aClcbiAgICByZXR1cm4ge2pvaW5fcmVmOiBqb2luUmVmLCByZWY6IG51bGwsIHRvcGljOiB0b3BpYywgZXZlbnQ6IGV2ZW50LCBwYXlsb2FkOiBkYXRhfVxuICB9LFxuXG4gIGRlY29kZVJlcGx5KGJ1ZmZlciwgdmlldywgZGVjb2Rlcil7XG4gICAgbGV0IGpvaW5SZWZTaXplID0gdmlldy5nZXRVaW50OCgxKVxuICAgIGxldCByZWZTaXplID0gdmlldy5nZXRVaW50OCgyKVxuICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDMpXG4gICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoNClcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgdGhpcy5NRVRBX0xFTkdUSFxuICAgIGxldCBqb2luUmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgam9pblJlZlNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGpvaW5SZWZTaXplXG4gICAgbGV0IHJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHJlZlNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIHJlZlNpemVcbiAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZVxuICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplXG4gICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aClcbiAgICBsZXQgcGF5bG9hZCA9IHtzdGF0dXM6IGV2ZW50LCByZXNwb25zZTogZGF0YX1cbiAgICByZXR1cm4ge2pvaW5fcmVmOiBqb2luUmVmLCByZWY6IHJlZiwgdG9waWM6IHRvcGljLCBldmVudDogQ0hBTk5FTF9FVkVOVFMucmVwbHksIHBheWxvYWQ6IHBheWxvYWR9XG4gIH0sXG5cbiAgZGVjb2RlQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2Rlcil7XG4gICAgbGV0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBsZXQgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCgyKVxuICAgIGxldCBvZmZzZXQgPSB0aGlzLkhFQURFUl9MRU5HVEggKyAyXG4gICAgbGV0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemVcbiAgICBsZXQgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZVxuICAgIGxldCBkYXRhID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpXG5cbiAgICByZXR1cm4ge2pvaW5fcmVmOiBudWxsLCByZWY6IG51bGwsIHRvcGljOiB0b3BpYywgZXZlbnQ6IGV2ZW50LCBwYXlsb2FkOiBkYXRhfVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgZ2xvYmFsLFxuICBwaHhXaW5kb3csXG4gIENIQU5ORUxfRVZFTlRTLFxuICBERUZBVUxUX1RJTUVPVVQsXG4gIERFRkFVTFRfVlNOLFxuICBTT0NLRVRfU1RBVEVTLFxuICBUUkFOU1BPUlRTLFxuICBXU19DTE9TRV9OT1JNQUxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgY2xvc3VyZVxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBBamF4IGZyb20gXCIuL2FqYXhcIlxuaW1wb3J0IENoYW5uZWwgZnJvbSBcIi4vY2hhbm5lbFwiXG5pbXBvcnQgTG9uZ1BvbGwgZnJvbSBcIi4vbG9uZ3BvbGxcIlxuaW1wb3J0IFNlcmlhbGl6ZXIgZnJvbSBcIi4vc2VyaWFsaXplclwiXG5pbXBvcnQgVGltZXIgZnJvbSBcIi4vdGltZXJcIlxuXG4vKiogSW5pdGlhbGl6ZXMgdGhlIFNvY2tldCAqXG4gKlxuICogRm9yIElFOCBzdXBwb3J0IHVzZSBhbiBFUzUtc2hpbSAoaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRQb2ludCAtIFRoZSBzdHJpbmcgV2ViU29ja2V0IGVuZHBvaW50LCBpZSwgYFwid3M6Ly9leGFtcGxlLmNvbS9zb2NrZXRcImAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFwid3NzOi8vZXhhbXBsZS5jb21cImBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXCIvc29ja2V0XCJgIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLnRyYW5zcG9ydF0gLSBUaGUgV2Vic29ja2V0IFRyYW5zcG9ydCwgZm9yIGV4YW1wbGUgV2ViU29ja2V0IG9yIFBob2VuaXguTG9uZ1BvbGwuXG4gKlxuICogRGVmYXVsdHMgdG8gV2ViU29ja2V0IHdpdGggYXV0b21hdGljIExvbmdQb2xsIGZhbGxiYWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMuZW5jb2RlXSAtIFRoZSBmdW5jdGlvbiB0byBlbmNvZGUgb3V0Z29pbmcgbWVzc2FnZXMuXG4gKlxuICogRGVmYXVsdHMgdG8gSlNPTiBlbmNvZGVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmRlY29kZV0gLSBUaGUgZnVuY3Rpb24gdG8gZGVjb2RlIGluY29taW5nIG1lc3NhZ2VzLlxuICpcbiAqIERlZmF1bHRzIHRvIEpTT046XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogKHBheWxvYWQsIGNhbGxiYWNrKSA9PiBjYWxsYmFjayhKU09OLnBhcnNlKHBheWxvYWQpKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVvdXRdIC0gVGhlIGRlZmF1bHQgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gdHJpZ2dlciBwdXNoIHRpbWVvdXRzLlxuICpcbiAqIERlZmF1bHRzIGBERUZBVUxUX1RJTUVPVVRgXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaGVhcnRiZWF0SW50ZXJ2YWxNc10gLSBUaGUgbWlsbGlzZWMgaW50ZXJ2YWwgdG8gc2VuZCBhIGhlYXJ0YmVhdCBtZXNzYWdlXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMucmVjb25uZWN0QWZ0ZXJNc10gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsc2VjXG4gKiBzb2NrZXQgcmVjb25uZWN0IGludGVydmFsLlxuICpcbiAqIERlZmF1bHRzIHRvIHN0ZXBwZWQgYmFja29mZiBvZjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBmdW5jdGlvbih0cmllcyl7XG4gKiAgIHJldHVybiBbMTAsIDUwLCAxMDAsIDE1MCwgMjAwLCAyNTAsIDUwMCwgMTAwMCwgMjAwMF1bdHJpZXMgLSAxXSB8fCA1MDAwXG4gKiB9XG4gKiBgYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnJlam9pbkFmdGVyTXNdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWlsbHNlY1xuICogcmVqb2luIGludGVydmFsIGZvciBpbmRpdmlkdWFsIGNoYW5uZWxzLlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMDAwLCAyMDAwLCA1MDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiB9XG4gKiBgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMubG9nZ2VyXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZywgaWU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZnVuY3Rpb24oa2luZCwgbXNnLCBkYXRhKSB7XG4gKiAgIGNvbnNvbGUubG9nKGAke2tpbmR9OiAke21zZ31gLCBkYXRhKVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmxvbmdwb2xsZXJUaW1lb3V0XSAtIFRoZSBtYXhpbXVtIHRpbWVvdXQgb2YgYSBsb25nIHBvbGwgQUpBWCByZXF1ZXN0LlxuICpcbiAqIERlZmF1bHRzIHRvIDIwcyAoZG91YmxlIHRoZSBzZXJ2ZXIgbG9uZyBwb2xsIHRpbWVyKS5cbiAqXG4gKiBAcGFyYW0geyhPYmplY3R8ZnVuY3Rpb24pfSBbb3B0cy5wYXJhbXNdIC0gVGhlIG9wdGlvbmFsIHBhcmFtcyB0byBwYXNzIHdoZW4gY29ubmVjdGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJpbmFyeVR5cGVdIC0gVGhlIGJpbmFyeSB0eXBlIHRvIHVzZSBmb3IgYmluYXJ5IFdlYlNvY2tldCBmcmFtZXMuXG4gKlxuICogRGVmYXVsdHMgdG8gXCJhcnJheWJ1ZmZlclwiXG4gKlxuICogQHBhcmFtIHt2c259IFtvcHRzLnZzbl0gLSBUaGUgc2VyaWFsaXplcidzIHByb3RvY29sIHZlcnNpb24gdG8gc2VuZCBvbiBjb25uZWN0LlxuICpcbiAqIERlZmF1bHRzIHRvIERFRkFVTFRfVlNOLlxuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNvY2tldCB7XG4gIGNvbnN0cnVjdG9yKGVuZFBvaW50LCBvcHRzID0ge30pe1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB7b3BlbjogW10sIGNsb3NlOiBbXSwgZXJyb3I6IFtdLCBtZXNzYWdlOiBbXX1cbiAgICB0aGlzLmNoYW5uZWxzID0gW11cbiAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXVxuICAgIHRoaXMucmVmID0gMFxuICAgIHRoaXMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCBERUZBVUxUX1RJTUVPVVRcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG9wdHMudHJhbnNwb3J0IHx8IGdsb2JhbC5XZWJTb2NrZXQgfHwgTG9uZ1BvbGxcbiAgICB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnMgPSAwXG4gICAgdGhpcy5kZWZhdWx0RW5jb2RlciA9IFNlcmlhbGl6ZXIuZW5jb2RlLmJpbmQoU2VyaWFsaXplcilcbiAgICB0aGlzLmRlZmF1bHREZWNvZGVyID0gU2VyaWFsaXplci5kZWNvZGUuYmluZChTZXJpYWxpemVyKVxuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgdGhpcy5iaW5hcnlUeXBlID0gb3B0cy5iaW5hcnlUeXBlIHx8IFwiYXJyYXlidWZmZXJcIlxuICAgIHRoaXMuY29ubmVjdENsb2NrID0gMVxuICAgIGlmKHRoaXMudHJhbnNwb3J0ICE9PSBMb25nUG9sbCl7XG4gICAgICB0aGlzLmVuY29kZSA9IG9wdHMuZW5jb2RlIHx8IHRoaXMuZGVmYXVsdEVuY29kZXJcbiAgICAgIHRoaXMuZGVjb2RlID0gb3B0cy5kZWNvZGUgfHwgdGhpcy5kZWZhdWx0RGVjb2RlclxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuY29kZSA9IHRoaXMuZGVmYXVsdEVuY29kZXJcbiAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWZhdWx0RGVjb2RlclxuICAgIH1cbiAgICBsZXQgYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9IG51bGxcbiAgICBpZihwaHhXaW5kb3cgJiYgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIpe1xuICAgICAgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfZSA9PiB7XG4gICAgICAgIGlmKHRoaXMuY29ubil7XG4gICAgICAgICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICAgICAgICBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gdGhpcy5jb25uZWN0Q2xvY2tcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZXNob3dcIiwgX2UgPT4ge1xuICAgICAgICBpZihhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID09PSB0aGlzLmNvbm5lY3RDbG9jayl7XG4gICAgICAgICAgYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9IG51bGxcbiAgICAgICAgICB0aGlzLmNvbm5lY3QoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMgPSBvcHRzLmhlYXJ0YmVhdEludGVydmFsTXMgfHwgMzAwMDBcbiAgICB0aGlzLnJlam9pbkFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgIGlmKG9wdHMucmVqb2luQWZ0ZXJNcyl7XG4gICAgICAgIHJldHVybiBvcHRzLnJlam9pbkFmdGVyTXModHJpZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzEwMDAsIDIwMDAsIDUwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZWNvbm5lY3RBZnRlck1zID0gKHRyaWVzKSA9PiB7XG4gICAgICBpZihvcHRzLnJlY29ubmVjdEFmdGVyTXMpe1xuICAgICAgICByZXR1cm4gb3B0cy5yZWNvbm5lY3RBZnRlck1zKHRyaWVzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFsxMCwgNTAsIDEwMCwgMTUwLCAyMDAsIDI1MCwgNTAwLCAxMDAwLCAyMDAwXVt0cmllcyAtIDFdIHx8IDUwMDBcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2dnZXIgPSBvcHRzLmxvZ2dlciB8fCBudWxsXG4gICAgdGhpcy5sb25ncG9sbGVyVGltZW91dCA9IG9wdHMubG9uZ3BvbGxlclRpbWVvdXQgfHwgMjAwMDBcbiAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUob3B0cy5wYXJhbXMgfHwge30pXG4gICAgdGhpcy5lbmRQb2ludCA9IGAke2VuZFBvaW50fS8ke1RSQU5TUE9SVFMud2Vic29ja2V0fWBcbiAgICB0aGlzLnZzbiA9IG9wdHMudnNuIHx8IERFRkFVTFRfVlNOXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IG51bGxcbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB7XG4gICAgICB0aGlzLnRlYXJkb3duKCgpID0+IHRoaXMuY29ubmVjdCgpKVxuICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBMb25nUG9sbCB0cmFuc3BvcnQgcmVmZXJlbmNlXG4gICAqL1xuICBnZXRMb25nUG9sbFRyYW5zcG9ydCgpeyByZXR1cm4gTG9uZ1BvbGwgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyBhbmQgcmVwbGFjZXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnRcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV3VHJhbnNwb3J0IC0gVGhlIG5ldyB0cmFuc3BvcnQgY2xhc3MgdG8gaW5zdGFudGlhdGVcbiAgICpcbiAgICovXG4gIHJlcGxhY2VUcmFuc3BvcnQobmV3VHJhbnNwb3J0KXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gdHJ1ZVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdXG4gICAgaWYodGhpcy5jb25uKXtcbiAgICAgIHRoaXMuY29ubi5jbG9zZSgpXG4gICAgICB0aGlzLmNvbm4gPSBudWxsXG4gICAgfVxuICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3VHJhbnNwb3J0XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc29ja2V0IHByb3RvY29sXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBwcm90b2NvbCgpeyByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wubWF0Y2goL15odHRwcy8pID8gXCJ3c3NcIiA6IFwid3NcIiB9XG5cbiAgLyoqXG4gICAqIFRoZSBmdWxseSBxdWFsaWZlZCBzb2NrZXQgdXJsXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBlbmRQb2ludFVSTCgpe1xuICAgIGxldCB1cmkgPSBBamF4LmFwcGVuZFBhcmFtcyhcbiAgICAgIEFqYXguYXBwZW5kUGFyYW1zKHRoaXMuZW5kUG9pbnQsIHRoaXMucGFyYW1zKCkpLCB7dnNuOiB0aGlzLnZzbn0pXG4gICAgaWYodXJpLmNoYXJBdCgwKSAhPT0gXCIvXCIpeyByZXR1cm4gdXJpIH1cbiAgICBpZih1cmkuY2hhckF0KDEpID09PSBcIi9cIil7IHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9OiR7dXJpfWAgfVxuXG4gICAgcmV0dXJuIGAke3RoaXMucHJvdG9jb2woKX06Ly8ke2xvY2F0aW9uLmhvc3R9JHt1cml9YFxuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXRcbiAgICpcbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50I1N0YXR1c19jb2RlcyBmb3IgdmFsaWQgc3RhdHVzIGNvZGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIE9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBzb2NrZXQgaXMgZGlzY29ubmVjdGVkLlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IGNvZGUgLSBBIHN0YXR1cyBjb2RlIGZvciBkaXNjb25uZWN0aW9uIChPcHRpb25hbCkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBBIHRleHR1YWwgZGVzY3JpcHRpb24gb2YgdGhlIHJlYXNvbiB0byBkaXNjb25uZWN0LiAoT3B0aW9uYWwpXG4gICAqL1xuICBkaXNjb25uZWN0KGNhbGxiYWNrLCBjb2RlLCByZWFzb24pe1xuICAgIHRoaXMuY29ubmVjdENsb2NrKytcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSB0cnVlXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgdGhpcy50ZWFyZG93bihjYWxsYmFjaywgY29kZSwgcmVhc29uKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1zIHRvIHNlbmQgd2hlbiBjb25uZWN0aW5nLCBmb3IgZXhhbXBsZSBge3VzZXJfaWQ6IHVzZXJUb2tlbn1gXG4gICAqXG4gICAqIFBhc3NpbmcgcGFyYW1zIHRvIGNvbm5lY3QgaXMgZGVwcmVjYXRlZDsgcGFzcyB0aGVtIGluIHRoZSBTb2NrZXQgY29uc3RydWN0b3IgaW5zdGVhZDpcbiAgICogYG5ldyBTb2NrZXQoXCIvc29ja2V0XCIsIHtwYXJhbXM6IHt1c2VyX2lkOiB1c2VyVG9rZW59fSlgLlxuICAgKi9cbiAgY29ubmVjdChwYXJhbXMpe1xuICAgIGlmKHBhcmFtcyl7XG4gICAgICBjb25zb2xlICYmIGNvbnNvbGUubG9nKFwicGFzc2luZyBwYXJhbXMgdG8gY29ubmVjdCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHBhc3MgOnBhcmFtcyB0byB0aGUgU29ja2V0IGNvbnN0cnVjdG9yXCIpXG4gICAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUocGFyYW1zKVxuICAgIH1cbiAgICBpZih0aGlzLmNvbm4peyByZXR1cm4gfVxuXG4gICAgdGhpcy5jb25uZWN0Q2xvY2srK1xuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgdGhpcy5jb25uID0gbmV3IHRoaXMudHJhbnNwb3J0KHRoaXMuZW5kUG9pbnRVUkwoKSlcbiAgICB0aGlzLmNvbm4uYmluYXJ5VHlwZSA9IHRoaXMuYmluYXJ5VHlwZVxuICAgIHRoaXMuY29ubi50aW1lb3V0ID0gdGhpcy5sb25ncG9sbGVyVGltZW91dFxuICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLm9uQ29ubk9wZW4oKVxuICAgIHRoaXMuY29ubi5vbmVycm9yID0gZXJyb3IgPT4gdGhpcy5vbkNvbm5FcnJvcihlcnJvcilcbiAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gZXZlbnQgPT4gdGhpcy5vbkNvbm5NZXNzYWdlKGV2ZW50KVxuICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZXZlbnQgPT4gdGhpcy5vbkNvbm5DbG9zZShldmVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIHRoZSBtZXNzYWdlLiBPdmVycmlkZSBgdGhpcy5sb2dnZXJgIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLiBub29wcyBieSBkZWZhdWx0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBraW5kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG4gIGxvZyhraW5kLCBtc2csIGRhdGEpeyB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgbG9nZ2VyIGhhcyBiZWVuIHNldCBvbiB0aGlzIHNvY2tldC5cbiAgICovXG4gIGhhc0xvZ2dlcigpeyByZXR1cm4gdGhpcy5sb2dnZXIgIT09IG51bGwgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGZvciBjb25uZWN0aW9uIG9wZW4gZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlIHNvY2tldC5vbk9wZW4oZnVuY3Rpb24oKXsgY29uc29sZS5pbmZvKFwidGhlIHNvY2tldCB3YXMgb3BlbmVkXCIpIH0pXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbk9wZW4oY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBjbG9zZSBldmVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uQ2xvc2UoY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgZm9yIGNvbm5lY3Rpb24gZXJyb3IgZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlIHNvY2tldC5vbkVycm9yKGZ1bmN0aW9uKGVycm9yKXsgYWxlcnQoXCJBbiBlcnJvciBvY2N1cnJlZFwiKSB9KVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25FcnJvcihjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBtZXNzYWdlIGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25NZXNzYWdlKGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFBpbmdzIHRoZSBzZXJ2ZXIgYW5kIGludm9rZXMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIFJUVCBpbiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwaW5nIHdhcyBwdXNoZWQgb3IgZmFsc2UgaWYgdW5hYmxlIHRvIGJlIHB1c2hlZC5cbiAgICovXG4gIHBpbmcoY2FsbGJhY2spe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gZmFsc2UgfVxuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIGxldCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgdGhpcy5wdXNoKHt0b3BpYzogXCJwaG9lbml4XCIsIGV2ZW50OiBcImhlYXJ0YmVhdFwiLCBwYXlsb2FkOiB7fSwgcmVmOiByZWZ9KVxuICAgIGxldCBvbk1zZ1JlZiA9IHRoaXMub25NZXNzYWdlKG1zZyA9PiB7XG4gICAgICBpZihtc2cucmVmID09PSByZWYpe1xuICAgICAgICB0aGlzLm9mZihbb25Nc2dSZWZdKVxuICAgICAgICBjYWxsYmFjayhEYXRlLm5vdygpIC0gc3RhcnRUaW1lKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25Db25uT3Blbigpe1xuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBjb25uZWN0ZWQgdG8gJHt0aGlzLmVuZFBvaW50VVJMKCl9YClcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucysrXG4gICAgdGhpcy5mbHVzaFNlbmRCdWZmZXIoKVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIHRoaXMucmVzZXRIZWFydGJlYXQoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5mb3JFYWNoKChbLCBjYWxsYmFja10pID0+IGNhbGxiYWNrKCkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgaGVhcnRiZWF0VGltZW91dCgpe1xuICAgIGlmKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZil7XG4gICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgICBpZih0aGlzLmhhc0xvZ2dlcigpKXsgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJoZWFydGJlYXQgdGltZW91dC4gQXR0ZW1wdGluZyB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvblwiKSB9XG4gICAgICB0aGlzLmFibm9ybWFsQ2xvc2UoXCJoZWFydGJlYXQgdGltZW91dFwiKVxuICAgIH1cbiAgfVxuXG4gIHJlc2V0SGVhcnRiZWF0KCl7XG4gICAgaWYodGhpcy5jb25uICYmIHRoaXMuY29ubi5za2lwSGVhcnRiZWF0KXsgcmV0dXJuIH1cbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbmRIZWFydGJlYXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKVxuICB9XG5cbiAgdGVhcmRvd24oY2FsbGJhY2ssIGNvZGUsIHJlYXNvbil7XG4gICAgaWYoIXRoaXMuY29ubil7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgIH1cblxuICAgIHRoaXMud2FpdEZvckJ1ZmZlckRvbmUoKCkgPT4ge1xuICAgICAgaWYodGhpcy5jb25uKXtcbiAgICAgICAgaWYoY29kZSl7IHRoaXMuY29ubi5jbG9zZShjb2RlLCByZWFzb24gfHwgXCJcIikgfSBlbHNlIHsgdGhpcy5jb25uLmNsb3NlKCkgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLndhaXRGb3JTb2NrZXRDbG9zZWQoKCkgPT4ge1xuICAgICAgICBpZih0aGlzLmNvbm4pe1xuICAgICAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgICAgICAgIHRoaXMuY29ubiA9IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHdhaXRGb3JCdWZmZXJEb25lKGNhbGxiYWNrLCB0cmllcyA9IDEpe1xuICAgIGlmKHRyaWVzID09PSA1IHx8ICF0aGlzLmNvbm4gfHwgIXRoaXMuY29ubi5idWZmZXJlZEFtb3VudCl7XG4gICAgICBjYWxsYmFjaygpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMud2FpdEZvckJ1ZmZlckRvbmUoY2FsbGJhY2ssIHRyaWVzICsgMSlcbiAgICB9LCAxNTAgKiB0cmllcylcbiAgfVxuXG4gIHdhaXRGb3JTb2NrZXRDbG9zZWQoY2FsbGJhY2ssIHRyaWVzID0gMSl7XG4gICAgaWYodHJpZXMgPT09IDUgfHwgIXRoaXMuY29ubiB8fCB0aGlzLmNvbm4ucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5jbG9zZWQpe1xuICAgICAgY2FsbGJhY2soKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLndhaXRGb3JTb2NrZXRDbG9zZWQoY2FsbGJhY2ssIHRyaWVzICsgMSlcbiAgICB9LCAxNTAgKiB0cmllcylcbiAgfVxuXG4gIG9uQ29ubkNsb3NlKGV2ZW50KXtcbiAgICBsZXQgY2xvc2VDb2RlID0gZXZlbnQgJiYgZXZlbnQuY29kZVxuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIFwiY2xvc2VcIiwgZXZlbnQpXG4gICAgdGhpcy50cmlnZ2VyQ2hhbkVycm9yKClcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFydGJlYXRUaW1lcilcbiAgICBpZighdGhpcy5jbG9zZVdhc0NsZWFuICYmIGNsb3NlQ29kZSAhPT0gMTAwMCl7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpXG4gICAgfVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UuZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiBjYWxsYmFjayhldmVudCkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uQ29ubkVycm9yKGVycm9yKXtcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBlcnJvcilcbiAgICBsZXQgdHJhbnNwb3J0QmVmb3JlID0gdGhpcy50cmFuc3BvcnRcbiAgICBsZXQgZXN0YWJsaXNoZWRCZWZvcmUgPSB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnNcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4ge1xuICAgICAgY2FsbGJhY2soZXJyb3IsIHRyYW5zcG9ydEJlZm9yZSwgZXN0YWJsaXNoZWRCZWZvcmUpXG4gICAgfSlcbiAgICBpZih0cmFuc3BvcnRCZWZvcmUgPT09IHRoaXMudHJhbnNwb3J0IHx8IGVzdGFibGlzaGVkQmVmb3JlID4gMCl7XG4gICAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlckNoYW5FcnJvcigpe1xuICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaChjaGFubmVsID0+IHtcbiAgICAgIGlmKCEoY2hhbm5lbC5pc0Vycm9yZWQoKSB8fCBjaGFubmVsLmlzTGVhdmluZygpIHx8IGNoYW5uZWwuaXNDbG9zZWQoKSkpe1xuICAgICAgICBjaGFubmVsLnRyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgY29ubmVjdGlvblN0YXRlKCl7XG4gICAgc3dpdGNoKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4ucmVhZHlTdGF0ZSl7XG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzogcmV0dXJuIFwiY29ubmVjdGluZ1wiXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMub3BlbjogcmV0dXJuIFwib3BlblwiXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY2xvc2luZzogcmV0dXJuIFwiY2xvc2luZ1wiXG4gICAgICBkZWZhdWx0OiByZXR1cm4gXCJjbG9zZWRcIlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ29ubmVjdGVkKCl7IHJldHVybiB0aGlzLmNvbm5lY3Rpb25TdGF0ZSgpID09PSBcIm9wZW5cIiB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Q2hhbm5lbH1cbiAgICovXG4gIHJlbW92ZShjaGFubmVsKXtcbiAgICB0aGlzLm9mZihjaGFubmVsLnN0YXRlQ2hhbmdlUmVmcylcbiAgICB0aGlzLmNoYW5uZWxzID0gdGhpcy5jaGFubmVscy5maWx0ZXIoYyA9PiBjLmpvaW5SZWYoKSAhPT0gY2hhbm5lbC5qb2luUmVmKCkpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBgb25PcGVuYCwgYG9uQ2xvc2VgLCBgb25FcnJvcixgIGFuZCBgb25NZXNzYWdlYCByZWdpc3RyYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge3JlZnN9IC0gbGlzdCBvZiByZWZzIHJldHVybmVkIGJ5IGNhbGxzIHRvXG4gICAqICAgICAgICAgICAgICAgICBgb25PcGVuYCwgYG9uQ2xvc2VgLCBgb25FcnJvcixgIGFuZCBgb25NZXNzYWdlYFxuICAgKi9cbiAgb2ZmKHJlZnMpe1xuICAgIGZvcihsZXQga2V5IGluIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mpe1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1trZXldID0gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1trZXldLmZpbHRlcigoW3JlZl0pID0+IHtcbiAgICAgICAgcmV0dXJuIHJlZnMuaW5kZXhPZihyZWYpID09PSAtMVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgbmV3IGNoYW5uZWwgZm9yIHRoZSBnaXZlbiB0b3BpY1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5QYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgY2hhbm5lbFxuICAgKiBAcmV0dXJucyB7Q2hhbm5lbH1cbiAgICovXG4gIGNoYW5uZWwodG9waWMsIGNoYW5QYXJhbXMgPSB7fSl7XG4gICAgbGV0IGNoYW4gPSBuZXcgQ2hhbm5lbCh0b3BpYywgY2hhblBhcmFtcywgdGhpcylcbiAgICB0aGlzLmNoYW5uZWxzLnB1c2goY2hhbilcbiAgICByZXR1cm4gY2hhblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICBwdXNoKGRhdGEpe1xuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpe1xuICAgICAgbGV0IHt0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWZ9ID0gZGF0YVxuICAgICAgdGhpcy5sb2coXCJwdXNoXCIsIGAke3RvcGljfSAke2V2ZW50fSAoJHtqb2luX3JlZn0sICR7cmVmfSlgLCBwYXlsb2FkKVxuICAgIH1cblxuICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQoKSl7XG4gICAgICB0aGlzLmVuY29kZShkYXRhLCByZXN1bHQgPT4gdGhpcy5jb25uLnNlbmQocmVzdWx0KSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2goKCkgPT4gdGhpcy5lbmNvZGUoZGF0YSwgcmVzdWx0ID0+IHRoaXMuY29ubi5zZW5kKHJlc3VsdCkpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5leHQgbWVzc2FnZSByZWYsIGFjY291bnRpbmcgZm9yIG92ZXJmbG93c1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgbWFrZVJlZigpe1xuICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZiArIDFcbiAgICBpZihuZXdSZWYgPT09IHRoaXMucmVmKXsgdGhpcy5yZWYgPSAwIH0gZWxzZSB7IHRoaXMucmVmID0gbmV3UmVmIH1cblxuICAgIHJldHVybiB0aGlzLnJlZi50b1N0cmluZygpXG4gIH1cblxuICBzZW5kSGVhcnRiZWF0KCl7XG4gICAgaWYodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmICYmICF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5wdXNoKHt0b3BpYzogXCJwaG9lbml4XCIsIGV2ZW50OiBcImhlYXJ0YmVhdFwiLCBwYXlsb2FkOiB7fSwgcmVmOiB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWZ9KVxuICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGVhcnRiZWF0VGltZW91dCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpXG4gIH1cblxuICBhYm5vcm1hbENsb3NlKHJlYXNvbil7XG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2VcbiAgICBpZih0aGlzLmlzQ29ubmVjdGVkKCkpeyB0aGlzLmNvbm4uY2xvc2UoV1NfQ0xPU0VfTk9STUFMLCByZWFzb24pIH1cbiAgfVxuXG4gIGZsdXNoU2VuZEJ1ZmZlcigpe1xuICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCl7XG4gICAgICB0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjaygpKVxuICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW11cbiAgICB9XG4gIH1cblxuICBvbkNvbm5NZXNzYWdlKHJhd01lc3NhZ2Upe1xuICAgIHRoaXMuZGVjb2RlKHJhd01lc3NhZ2UuZGF0YSwgbXNnID0+IHtcbiAgICAgIGxldCB7dG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5fcmVmfSA9IG1zZ1xuICAgICAgaWYocmVmICYmIHJlZiA9PT0gdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbmRIZWFydGJlYXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKVxuICAgICAgfVxuXG4gICAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInJlY2VpdmVcIiwgYCR7cGF5bG9hZC5zdGF0dXMgfHwgXCJcIn0gJHt0b3BpY30gJHtldmVudH0gJHtyZWYgJiYgXCIoXCIgKyByZWYgKyBcIilcIiB8fCBcIlwifWAsIHBheWxvYWQpXG5cbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbaV1cbiAgICAgICAgaWYoIWNoYW5uZWwuaXNNZW1iZXIodG9waWMsIGV2ZW50LCBwYXlsb2FkLCBqb2luX3JlZikpeyBjb250aW51ZSB9XG4gICAgICAgIGNoYW5uZWwudHJpZ2dlcihldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZilcbiAgICAgIH1cblxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGxldCBbLCBjYWxsYmFja10gPSB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2VbaV1cbiAgICAgICAgY2FsbGJhY2sobXNnKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBsZWF2ZU9wZW5Ub3BpYyh0b3BpYyl7XG4gICAgbGV0IGR1cENoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmZpbmQoYyA9PiBjLnRvcGljID09PSB0b3BpYyAmJiAoYy5pc0pvaW5lZCgpIHx8IGMuaXNKb2luaW5nKCkpKVxuICAgIGlmKGR1cENoYW5uZWwpe1xuICAgICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgYGxlYXZpbmcgZHVwbGljYXRlIHRvcGljIFwiJHt0b3BpY31cImApXG4gICAgICBkdXBDaGFubmVsLmxlYXZlKClcbiAgICB9XG4gIH1cbn1cbiIsICJcbmV4cG9ydCBjb25zdCBDT05TRUNVVElWRV9SRUxPQURTID0gXCJjb25zZWN1dGl2ZS1yZWxvYWRzXCJcbmV4cG9ydCBjb25zdCBNQVhfUkVMT0FEUyA9IDEwXG5leHBvcnQgY29uc3QgUkVMT0FEX0pJVFRFUl9NSU4gPSA1MDAwXG5leHBvcnQgY29uc3QgUkVMT0FEX0pJVFRFUl9NQVggPSAxMDAwMFxuZXhwb3J0IGNvbnN0IEZBSUxTQUZFX0pJVFRFUiA9IDMwMDAwXG5leHBvcnQgY29uc3QgUEhYX0VWRU5UX0NMQVNTRVMgPSBbXG4gIFwicGh4LWNsaWNrLWxvYWRpbmdcIiwgXCJwaHgtY2hhbmdlLWxvYWRpbmdcIiwgXCJwaHgtc3VibWl0LWxvYWRpbmdcIixcbiAgXCJwaHgta2V5ZG93bi1sb2FkaW5nXCIsIFwicGh4LWtleXVwLWxvYWRpbmdcIiwgXCJwaHgtYmx1ci1sb2FkaW5nXCIsIFwicGh4LWZvY3VzLWxvYWRpbmdcIlxuXVxuZXhwb3J0IGNvbnN0IFBIWF9DT01QT05FTlQgPSBcImRhdGEtcGh4LWNvbXBvbmVudFwiXG5leHBvcnQgY29uc3QgUEhYX0xJVkVfTElOSyA9IFwiZGF0YS1waHgtbGlua1wiXG5leHBvcnQgY29uc3QgUEhYX1RSQUNLX1NUQVRJQyA9IFwidHJhY2stc3RhdGljXCJcbmV4cG9ydCBjb25zdCBQSFhfTElOS19TVEFURSA9IFwiZGF0YS1waHgtbGluay1zdGF0ZVwiXG5leHBvcnQgY29uc3QgUEhYX1JFRiA9IFwiZGF0YS1waHgtcmVmXCJcbmV4cG9ydCBjb25zdCBQSFhfUkVGX1NSQyA9IFwiZGF0YS1waHgtcmVmLXNyY1wiXG5leHBvcnQgY29uc3QgUEhYX1RSQUNLX1VQTE9BRFMgPSBcInRyYWNrLXVwbG9hZHNcIlxuZXhwb3J0IGNvbnN0IFBIWF9VUExPQURfUkVGID0gXCJkYXRhLXBoeC11cGxvYWQtcmVmXCJcbmV4cG9ydCBjb25zdCBQSFhfUFJFRkxJR0hURURfUkVGUyA9IFwiZGF0YS1waHgtcHJlZmxpZ2h0ZWQtcmVmc1wiXG5leHBvcnQgY29uc3QgUEhYX0RPTkVfUkVGUyA9IFwiZGF0YS1waHgtZG9uZS1yZWZzXCJcbmV4cG9ydCBjb25zdCBQSFhfRFJPUF9UQVJHRVQgPSBcImRyb3AtdGFyZ2V0XCJcbmV4cG9ydCBjb25zdCBQSFhfQUNUSVZFX0VOVFJZX1JFRlMgPSBcImRhdGEtcGh4LWFjdGl2ZS1yZWZzXCJcbmV4cG9ydCBjb25zdCBQSFhfTElWRV9GSUxFX1VQREFURUQgPSBcInBoeDpsaXZlLWZpbGU6dXBkYXRlZFwiXG5leHBvcnQgY29uc3QgUEhYX1NLSVAgPSBcImRhdGEtcGh4LXNraXBcIlxuZXhwb3J0IGNvbnN0IFBIWF9QUlVORSA9IFwiZGF0YS1waHgtcHJ1bmVcIlxuZXhwb3J0IGNvbnN0IFBIWF9QQUdFX0xPQURJTkcgPSBcInBhZ2UtbG9hZGluZ1wiXG5leHBvcnQgY29uc3QgUEhYX0NPTk5FQ1RFRF9DTEFTUyA9IFwicGh4LWNvbm5lY3RlZFwiXG5leHBvcnQgY29uc3QgUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUyA9IFwicGh4LWxvYWRpbmdcIlxuZXhwb3J0IGNvbnN0IFBIWF9OT19GRUVEQkFDS19DTEFTUyA9IFwicGh4LW5vLWZlZWRiYWNrXCJcbmV4cG9ydCBjb25zdCBQSFhfRVJST1JfQ0xBU1MgPSBcInBoeC1lcnJvclwiXG5leHBvcnQgY29uc3QgUEhYX1BBUkVOVF9JRCA9IFwiZGF0YS1waHgtcGFyZW50LWlkXCJcbmV4cG9ydCBjb25zdCBQSFhfTUFJTiA9IFwiZGF0YS1waHgtbWFpblwiXG5leHBvcnQgY29uc3QgUEhYX1JPT1RfSUQgPSBcImRhdGEtcGh4LXJvb3QtaWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9UUklHR0VSX0FDVElPTiA9IFwidHJpZ2dlci1hY3Rpb25cIlxuZXhwb3J0IGNvbnN0IFBIWF9GRUVEQkFDS19GT1IgPSBcImZlZWRiYWNrLWZvclwiXG5leHBvcnQgY29uc3QgUEhYX0hBU19GT0NVU0VEID0gXCJwaHgtaGFzLWZvY3VzZWRcIlxuZXhwb3J0IGNvbnN0IEZPQ1VTQUJMRV9JTlBVVFMgPSBbXCJ0ZXh0XCIsIFwidGV4dGFyZWFcIiwgXCJudW1iZXJcIiwgXCJlbWFpbFwiLCBcInBhc3N3b3JkXCIsIFwic2VhcmNoXCIsIFwidGVsXCIsIFwidXJsXCIsIFwiZGF0ZVwiLCBcInRpbWVcIiwgXCJkYXRldGltZS1sb2NhbFwiLCBcImNvbG9yXCIsIFwicmFuZ2VcIl1cbmV4cG9ydCBjb25zdCBDSEVDS0FCTEVfSU5QVVRTID0gW1wiY2hlY2tib3hcIiwgXCJyYWRpb1wiXVxuZXhwb3J0IGNvbnN0IFBIWF9IQVNfU1VCTUlUVEVEID0gXCJwaHgtaGFzLXN1Ym1pdHRlZFwiXG5leHBvcnQgY29uc3QgUEhYX1NFU1NJT04gPSBcImRhdGEtcGh4LXNlc3Npb25cIlxuZXhwb3J0IGNvbnN0IFBIWF9WSUVXX1NFTEVDVE9SID0gYFske1BIWF9TRVNTSU9OfV1gXG5leHBvcnQgY29uc3QgUEhYX1NUSUNLWSA9IFwiZGF0YS1waHgtc3RpY2t5XCJcbmV4cG9ydCBjb25zdCBQSFhfU1RBVElDID0gXCJkYXRhLXBoeC1zdGF0aWNcIlxuZXhwb3J0IGNvbnN0IFBIWF9SRUFET05MWSA9IFwiZGF0YS1waHgtcmVhZG9ubHlcIlxuZXhwb3J0IGNvbnN0IFBIWF9ESVNBQkxFRCA9IFwiZGF0YS1waHgtZGlzYWJsZWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9ESVNBQkxFX1dJVEggPSBcImRpc2FibGUtd2l0aFwiXG5leHBvcnQgY29uc3QgUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFID0gXCJkYXRhLXBoeC1kaXNhYmxlLXdpdGgtcmVzdG9yZVwiXG5leHBvcnQgY29uc3QgUEhYX0hPT0sgPSBcImhvb2tcIlxuZXhwb3J0IGNvbnN0IFBIWF9ERUJPVU5DRSA9IFwiZGVib3VuY2VcIlxuZXhwb3J0IGNvbnN0IFBIWF9USFJPVFRMRSA9IFwidGhyb3R0bGVcIlxuZXhwb3J0IGNvbnN0IFBIWF9VUERBVEUgPSBcInVwZGF0ZVwiXG5leHBvcnQgY29uc3QgUEhYX0tFWSA9IFwia2V5XCJcbmV4cG9ydCBjb25zdCBQSFhfUFJJVkFURSA9IFwicGh4UHJpdmF0ZVwiXG5leHBvcnQgY29uc3QgUEhYX0FVVE9fUkVDT1ZFUiA9IFwiYXV0by1yZWNvdmVyXCJcbmV4cG9ydCBjb25zdCBQSFhfTFZfREVCVUcgPSBcInBoeDpsaXZlLXNvY2tldDpkZWJ1Z1wiXG5leHBvcnQgY29uc3QgUEhYX0xWX1BST0ZJTEUgPSBcInBoeDpsaXZlLXNvY2tldDpwcm9maWxpbmdcIlxuZXhwb3J0IGNvbnN0IFBIWF9MVl9MQVRFTkNZX1NJTSA9IFwicGh4OmxpdmUtc29ja2V0OmxhdGVuY3ktc2ltXCJcbmV4cG9ydCBjb25zdCBQSFhfUFJPR1JFU1MgPSBcInByb2dyZXNzXCJcbmV4cG9ydCBjb25zdCBMT0FERVJfVElNRU9VVCA9IDFcbmV4cG9ydCBjb25zdCBCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VUID0gMjAwXG5leHBvcnQgY29uc3QgQklORElOR19QUkVGSVggPSBcInBoeC1cIlxuZXhwb3J0IGNvbnN0IFBVU0hfVElNRU9VVCA9IDMwMDAwXG5leHBvcnQgY29uc3QgTElOS19IRUFERVIgPSBcIngtcmVxdWVzdGVkLXdpdGhcIlxuZXhwb3J0IGNvbnN0IFJFU1BPTlNFX1VSTF9IRUFERVIgPSBcIngtcmVzcG9uc2UtdXJsXCJcbmV4cG9ydCBjb25zdCBERUJPVU5DRV9UUklHR0VSID0gXCJkZWJvdW5jZS10cmlnZ2VyXCJcbmV4cG9ydCBjb25zdCBUSFJPVFRMRUQgPSBcInRocm90dGxlZFwiXG5leHBvcnQgY29uc3QgREVCT1VOQ0VfUFJFVl9LRVkgPSBcImRlYm91bmNlLXByZXYta2V5XCJcbmV4cG9ydCBjb25zdCBERUZBVUxUUyA9IHtcbiAgZGVib3VuY2U6IDMwMCxcbiAgdGhyb3R0bGU6IDMwMFxufVxuXG4vLyBSZW5kZXJlZFxuZXhwb3J0IGNvbnN0IERZTkFNSUNTID0gXCJkXCJcbmV4cG9ydCBjb25zdCBTVEFUSUMgPSBcInNcIlxuZXhwb3J0IGNvbnN0IENPTVBPTkVOVFMgPSBcImNcIlxuZXhwb3J0IGNvbnN0IEVWRU5UUyA9IFwiZVwiXG5leHBvcnQgY29uc3QgUkVQTFkgPSBcInJcIlxuZXhwb3J0IGNvbnN0IFRJVExFID0gXCJ0XCJcbmV4cG9ydCBjb25zdCBURU1QTEFURVMgPSBcInBcIlxuIiwgImltcG9ydCB7XG4gIGxvZ0Vycm9yXG59IGZyb20gXCIuL3V0aWxzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50cnlVcGxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGVudHJ5LCBjaHVua1NpemUsIGxpdmVTb2NrZXQpe1xuICAgIHRoaXMubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXRcbiAgICB0aGlzLmVudHJ5ID0gZW50cnlcbiAgICB0aGlzLm9mZnNldCA9IDBcbiAgICB0aGlzLmNodW5rU2l6ZSA9IGNodW5rU2l6ZVxuICAgIHRoaXMuY2h1bmtUaW1lciA9IG51bGxcbiAgICB0aGlzLnVwbG9hZENoYW5uZWwgPSBsaXZlU29ja2V0LmNoYW5uZWwoYGx2dToke2VudHJ5LnJlZn1gLCB7dG9rZW46IGVudHJ5Lm1ldGFkYXRhKCl9KVxuICB9XG5cbiAgZXJyb3IocmVhc29uKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5jaHVua1RpbWVyKVxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5sZWF2ZSgpXG4gICAgdGhpcy5lbnRyeS5lcnJvcihyZWFzb24pXG4gIH1cblxuICB1cGxvYWQoKXtcbiAgICB0aGlzLnVwbG9hZENoYW5uZWwub25FcnJvcihyZWFzb24gPT4gdGhpcy5lcnJvcihyZWFzb24pKVxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5qb2luKClcbiAgICAgIC5yZWNlaXZlKFwib2tcIiwgX2RhdGEgPT4gdGhpcy5yZWFkTmV4dENodW5rKCkpXG4gICAgICAucmVjZWl2ZShcImVycm9yXCIsIHJlYXNvbiA9PiB0aGlzLmVycm9yKHJlYXNvbikpXG4gIH1cblxuICBpc0RvbmUoKXsgcmV0dXJuIHRoaXMub2Zmc2V0ID49IHRoaXMuZW50cnkuZmlsZS5zaXplIH1cblxuICByZWFkTmV4dENodW5rKCl7XG4gICAgbGV0IHJlYWRlciA9IG5ldyB3aW5kb3cuRmlsZVJlYWRlcigpXG4gICAgbGV0IGJsb2IgPSB0aGlzLmVudHJ5LmZpbGUuc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMuY2h1bmtTaXplICsgdGhpcy5vZmZzZXQpXG4gICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICBpZihlLnRhcmdldC5lcnJvciA9PT0gbnVsbCl7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IGUudGFyZ2V0LnJlc3VsdC5ieXRlTGVuZ3RoXG4gICAgICAgIHRoaXMucHVzaENodW5rKGUudGFyZ2V0LnJlc3VsdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2dFcnJvcihcIlJlYWQgZXJyb3I6IFwiICsgZS50YXJnZXQuZXJyb3IpXG4gICAgICB9XG4gICAgfVxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICB9XG5cbiAgcHVzaENodW5rKGNodW5rKXtcbiAgICBpZighdGhpcy51cGxvYWRDaGFubmVsLmlzSm9pbmVkKCkpeyByZXR1cm4gfVxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5wdXNoKFwiY2h1bmtcIiwgY2h1bmspXG4gICAgICAucmVjZWl2ZShcIm9rXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5lbnRyeS5wcm9ncmVzcygodGhpcy5vZmZzZXQgLyB0aGlzLmVudHJ5LmZpbGUuc2l6ZSkgKiAxMDApXG4gICAgICAgIGlmKCF0aGlzLmlzRG9uZSgpKXtcbiAgICAgICAgICB0aGlzLmNodW5rVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVhZE5leHRDaHVuaygpLCB0aGlzLmxpdmVTb2NrZXQuZ2V0TGF0ZW5jeVNpbSgpIHx8IDApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBQSFhfVklFV19TRUxFQ1RPUlxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQgRW50cnlVcGxvYWRlciBmcm9tIFwiLi9lbnRyeV91cGxvYWRlclwiXG5cbmV4cG9ydCBsZXQgbG9nRXJyb3IgPSAobXNnLCBvYmopID0+IGNvbnNvbGUuZXJyb3IgJiYgY29uc29sZS5lcnJvcihtc2csIG9iailcblxuZXhwb3J0IGxldCBpc0NpZCA9IChjaWQpID0+IHtcbiAgbGV0IHR5cGUgPSB0eXBlb2YoY2lkKVxuICByZXR1cm4gdHlwZSA9PT0gXCJudW1iZXJcIiB8fCAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAvXigwfFsxLTldXFxkKikkLy50ZXN0KGNpZCkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3REdXBsaWNhdGVJZHMoKXtcbiAgbGV0IGlkcyA9IG5ldyBTZXQoKVxuICBsZXQgZWxlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiKltpZF1cIilcbiAgZm9yKGxldCBpID0gMCwgbGVuID0gZWxlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgIGlmKGlkcy5oYXMoZWxlbXNbaV0uaWQpKXtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYE11bHRpcGxlIElEcyBkZXRlY3RlZDogJHtlbGVtc1tpXS5pZH0uIEVuc3VyZSB1bmlxdWUgZWxlbWVudCBpZHMuYClcbiAgICB9IGVsc2Uge1xuICAgICAgaWRzLmFkZChlbGVtc1tpXS5pZClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGxldCBkZWJ1ZyA9ICh2aWV3LCBraW5kLCBtc2csIG9iaikgPT4ge1xuICBpZih2aWV3LmxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSl7XG4gICAgY29uc29sZS5sb2coYCR7dmlldy5pZH0gJHtraW5kfTogJHttc2d9IC0gYCwgb2JqKVxuICB9XG59XG5cbi8vIHdyYXBzIHZhbHVlIGluIGNsb3N1cmUgb3IgcmV0dXJucyBjbG9zdXJlXG5leHBvcnQgbGV0IGNsb3N1cmUgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCIgPyB2YWwgOiBmdW5jdGlvbiAoKXsgcmV0dXJuIHZhbCB9XG5cbmV4cG9ydCBsZXQgY2xvbmUgPSAob2JqKSA9PiB7IHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpIH1cblxuZXhwb3J0IGxldCBjbG9zZXN0UGh4QmluZGluZyA9IChlbCwgYmluZGluZywgYm9yZGVyRWwpID0+IHtcbiAgZG8ge1xuICAgIGlmKGVsLm1hdGNoZXMoYFske2JpbmRpbmd9XWApKXsgcmV0dXJuIGVsIH1cbiAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQgfHwgZWwucGFyZW50Tm9kZVxuICB9IHdoaWxlKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxICYmICEoKGJvcmRlckVsICYmIGJvcmRlckVsLmlzU2FtZU5vZGUoZWwpKSB8fCBlbC5tYXRjaGVzKFBIWF9WSUVXX1NFTEVDVE9SKSkpXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBsZXQgaXNPYmplY3QgPSAob2JqKSA9PiB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiAhKG9iaiBpbnN0YW5jZW9mIEFycmF5KVxufVxuXG5leHBvcnQgbGV0IGlzRXF1YWxPYmogPSAob2JqMSwgb2JqMikgPT4gSlNPTi5zdHJpbmdpZnkob2JqMSkgPT09IEpTT04uc3RyaW5naWZ5KG9iajIpXG5cbmV4cG9ydCBsZXQgaXNFbXB0eSA9IChvYmopID0+IHtcbiAgZm9yKGxldCB4IGluIG9iail7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBsZXQgbWF5YmUgPSAoZWwsIGNhbGxiYWNrKSA9PiBlbCAmJiBjYWxsYmFjayhlbClcblxuZXhwb3J0IGxldCBjaGFubmVsVXBsb2FkZXIgPSBmdW5jdGlvbiAoZW50cmllcywgb25FcnJvciwgcmVzcCwgbGl2ZVNvY2tldCl7XG4gIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgbGV0IGVudHJ5VXBsb2FkZXIgPSBuZXcgRW50cnlVcGxvYWRlcihlbnRyeSwgcmVzcC5jb25maWcuY2h1bmtfc2l6ZSwgbGl2ZVNvY2tldClcbiAgICBlbnRyeVVwbG9hZGVyLnVwbG9hZCgpXG4gIH0pXG59XG4iLCAibGV0IEJyb3dzZXIgPSB7XG4gIGNhblB1c2hTdGF0ZSgpeyByZXR1cm4gKHR5cGVvZiAoaGlzdG9yeS5wdXNoU3RhdGUpICE9PSBcInVuZGVmaW5lZFwiKSB9LFxuXG4gIGRyb3BMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KXtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5sb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSkpXG4gIH0sXG5cbiAgdXBkYXRlTG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSwgaW5pdGlhbCwgZnVuYyl7XG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLmdldExvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXkpXG4gICAgbGV0IGtleSA9IHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpXG4gICAgbGV0IG5ld1ZhbCA9IGN1cnJlbnQgPT09IG51bGwgPyBpbml0aWFsIDogZnVuYyhjdXJyZW50KVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkobmV3VmFsKSlcbiAgICByZXR1cm4gbmV3VmFsXG4gIH0sXG5cbiAgZ2V0TG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSl7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5sb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSkpKVxuICB9LFxuXG4gIHVwZGF0ZUN1cnJlbnRTdGF0ZShjYWxsYmFjayl7XG4gICAgaWYoIXRoaXMuY2FuUHVzaFN0YXRlKCkpeyByZXR1cm4gfVxuICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKGNhbGxiYWNrKGhpc3Rvcnkuc3RhdGUgfHwge30pLCBcIlwiLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgfSxcblxuICBwdXNoU3RhdGUoa2luZCwgbWV0YSwgdG8pe1xuICAgIGlmKHRoaXMuY2FuUHVzaFN0YXRlKCkpe1xuICAgICAgaWYodG8gIT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmKXtcbiAgICAgICAgaWYobWV0YS50eXBlID09IFwicmVkaXJlY3RcIiAmJiBtZXRhLnNjcm9sbCl7XG4gICAgICAgICAgLy8gSWYgd2UncmUgcmVkaXJlY3Rpbmcgc3RvcmUgdGhlIGN1cnJlbnQgc2Nyb2xsWSBmb3IgdGhlIGN1cnJlbnQgaGlzdG9yeSBzdGF0ZS5cbiAgICAgICAgICBsZXQgY3VycmVudFN0YXRlID0gaGlzdG9yeS5zdGF0ZSB8fCB7fVxuICAgICAgICAgIGN1cnJlbnRTdGF0ZS5zY3JvbGwgPSBtZXRhLnNjcm9sbFxuICAgICAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKGN1cnJlbnRTdGF0ZSwgXCJcIiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgbWV0YS5zY3JvbGwgLy8gT25seSBzdG9yZSB0aGUgc2Nyb2xsIGluIHRoZSByZWRpcmVjdCBjYXNlLlxuICAgICAgICBoaXN0b3J5W2tpbmQgKyBcIlN0YXRlXCJdKG1ldGEsIFwiXCIsIHRvIHx8IG51bGwpIC8vIElFIHdpbGwgY29lcmNlIHVuZGVmaW5lZCB0byBzdHJpbmdcbiAgICAgICAgbGV0IGhhc2hFbCA9IHRoaXMuZ2V0SGFzaFRhcmdldEVsKHdpbmRvdy5sb2NhdGlvbi5oYXNoKVxuXG4gICAgICAgIGlmKGhhc2hFbCl7XG4gICAgICAgICAgaGFzaEVsLnNjcm9sbEludG9WaWV3KClcbiAgICAgICAgfSBlbHNlIGlmKG1ldGEudHlwZSA9PT0gXCJyZWRpcmVjdFwiKXtcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsKDAsIDApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWRpcmVjdCh0bylcbiAgICB9XG4gIH0sXG5cbiAgc2V0Q29va2llKG5hbWUsIHZhbHVlKXtcbiAgICBkb2N1bWVudC5jb29raWUgPSBgJHtuYW1lfT0ke3ZhbHVlfWBcbiAgfSxcblxuICBnZXRDb29raWUobmFtZSl7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNvb2tpZS5yZXBsYWNlKG5ldyBSZWdFeHAoYCg/Oig/Ol58Lio7XFxzKikke25hbWV9XFxzKlxcPVxccyooW147XSopLiokKXxeLiokYCksIFwiJDFcIilcbiAgfSxcblxuICByZWRpcmVjdCh0b1VSTCwgZmxhc2gpe1xuICAgIGlmKGZsYXNoKXsgQnJvd3Nlci5zZXRDb29raWUoXCJfX3Bob2VuaXhfZmxhc2hfX1wiLCBmbGFzaCArIFwiOyBtYXgtYWdlPTYwMDAwOyBwYXRoPS9cIikgfVxuICAgIHdpbmRvdy5sb2NhdGlvbiA9IHRvVVJMXG4gIH0sXG5cbiAgbG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpeyByZXR1cm4gYCR7bmFtZXNwYWNlfS0ke3N1YmtleX1gIH0sXG5cbiAgZ2V0SGFzaFRhcmdldEVsKG1heWJlSGFzaCl7XG4gICAgbGV0IGhhc2ggPSBtYXliZUhhc2gudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSlcbiAgICBpZihoYXNoID09PSBcIlwiKXsgcmV0dXJuIH1cbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaCkgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgYVtuYW1lPVwiJHtoYXNofVwiXWApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnJvd3NlclxuIiwgImltcG9ydCB7XG4gIENIRUNLQUJMRV9JTlBVVFMsXG4gIERFQk9VTkNFX1BSRVZfS0VZLFxuICBERUJPVU5DRV9UUklHR0VSLFxuICBGT0NVU0FCTEVfSU5QVVRTLFxuICBQSFhfQ09NUE9ORU5ULFxuICBQSFhfRVZFTlRfQ0xBU1NFUyxcbiAgUEhYX0hBU19GT0NVU0VELFxuICBQSFhfSEFTX1NVQk1JVFRFRCxcbiAgUEhYX01BSU4sXG4gIFBIWF9OT19GRUVEQkFDS19DTEFTUyxcbiAgUEhYX1BBUkVOVF9JRCxcbiAgUEhYX1BSSVZBVEUsXG4gIFBIWF9SRUYsXG4gIFBIWF9SRUZfU1JDLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1NFU1NJT04sXG4gIFBIWF9TVEFUSUMsXG4gIFBIWF9VUExPQURfUkVGLFxuICBQSFhfVklFV19TRUxFQ1RPUixcbiAgUEhYX1NUSUNLWSxcbiAgVEhST1RUTEVEXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGxvZ0Vycm9yXG59IGZyb20gXCIuL3V0aWxzXCJcblxubGV0IERPTSA9IHtcbiAgYnlJZChpZCl7IHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgfHwgbG9nRXJyb3IoYG5vIGlkIGZvdW5kIGZvciAke2lkfWApIH0sXG5cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNsYXNzTmFtZSl7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpXG4gICAgaWYoZWwuY2xhc3NMaXN0Lmxlbmd0aCA9PT0gMCl7IGVsLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpIH1cbiAgfSxcblxuICBhbGwobm9kZSwgcXVlcnksIGNhbGxiYWNrKXtcbiAgICBpZighbm9kZSl7IHJldHVybiBbXSB9XG4gICAgbGV0IGFycmF5ID0gQXJyYXkuZnJvbShub2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKVxuICAgIHJldHVybiBjYWxsYmFjayA/IGFycmF5LmZvckVhY2goY2FsbGJhY2spIDogYXJyYXlcbiAgfSxcblxuICBjaGlsZE5vZGVMZW5ndGgoaHRtbCl7XG4gICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpXG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbFxuICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmNoaWxkRWxlbWVudENvdW50XG4gIH0sXG5cbiAgaXNVcGxvYWRJbnB1dChlbCl7IHJldHVybiBlbC50eXBlID09PSBcImZpbGVcIiAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpICE9PSBudWxsIH0sXG5cbiAgZmluZFVwbG9hZElucHV0cyhub2RlKXsgcmV0dXJuIHRoaXMuYWxsKG5vZGUsIGBpbnB1dFt0eXBlPVwiZmlsZVwiXVske1BIWF9VUExPQURfUkVGfV1gKSB9LFxuXG4gIGZpbmRDb21wb25lbnROb2RlTGlzdChub2RlLCBjaWQpe1xuICAgIHJldHVybiB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChub2RlLCBgWyR7UEhYX0NPTVBPTkVOVH09XCIke2NpZH1cIl1gKSwgbm9kZSlcbiAgfSxcblxuICBpc1BoeERlc3Ryb3llZChub2RlKXtcbiAgICByZXR1cm4gbm9kZS5pZCAmJiBET00ucHJpdmF0ZShub2RlLCBcImRlc3Ryb3llZFwiKSA/IHRydWUgOiBmYWxzZVxuICB9LFxuXG4gIG1hcmtQaHhDaGlsZERlc3Ryb3llZChlbCl7XG4gICAgaWYodGhpcy5pc1BoeENoaWxkKGVsKSl7IGVsLnNldEF0dHJpYnV0ZShQSFhfU0VTU0lPTiwgXCJcIikgfVxuICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgXCJkZXN0cm95ZWRcIiwgdHJ1ZSlcbiAgfSxcblxuICBmaW5kUGh4Q2hpbGRyZW5JbkZyYWdtZW50KGh0bWwsIHBhcmVudElkKXtcbiAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIilcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sXG4gICAgcmV0dXJuIHRoaXMuZmluZFBoeENoaWxkcmVuKHRlbXBsYXRlLmNvbnRlbnQsIHBhcmVudElkKVxuICB9LFxuXG4gIGlzSWdub3JlZChlbCwgcGh4VXBkYXRlKXtcbiAgICByZXR1cm4gKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpIHx8IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXVwZGF0ZVwiKSkgPT09IFwiaWdub3JlXCJcbiAgfSxcblxuICBpc1BoeFVwZGF0ZShlbCwgcGh4VXBkYXRlLCB1cGRhdGVUeXBlcyl7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiB1cGRhdGVUeXBlcy5pbmRleE9mKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpKSA+PSAwXG4gIH0sXG5cbiAgZmluZFBoeFN0aWNreShlbCl7IHJldHVybiB0aGlzLmFsbChlbCwgYFske1BIWF9TVElDS1l9XWApIH0sXG5cbiAgZmluZFBoeENoaWxkcmVuKGVsLCBwYXJlbnRJZCl7XG4gICAgcmV0dXJuIHRoaXMuYWxsKGVsLCBgJHtQSFhfVklFV19TRUxFQ1RPUn1bJHtQSFhfUEFSRU5UX0lEfT1cIiR7cGFyZW50SWR9XCJdYClcbiAgfSxcblxuICBmaW5kUGFyZW50Q0lEcyhub2RlLCBjaWRzKXtcbiAgICBsZXQgaW5pdGlhbCA9IG5ldyBTZXQoY2lkcylcbiAgICByZXR1cm4gY2lkcy5yZWR1Y2UoKGFjYywgY2lkKSA9PiB7XG4gICAgICBsZXQgc2VsZWN0b3IgPSBgWyR7UEhYX0NPTVBPTkVOVH09XCIke2NpZH1cIl0gWyR7UEhYX0NPTVBPTkVOVH1dYFxuXG4gICAgICB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChub2RlLCBzZWxlY3RvciksIG5vZGUpXG4gICAgICAgIC5tYXAoZWwgPT4gcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpKSlcbiAgICAgICAgLmZvckVhY2goY2hpbGRDSUQgPT4gYWNjLmRlbGV0ZShjaGlsZENJRCkpXG5cbiAgICAgIHJldHVybiBhY2NcbiAgICB9LCBpbml0aWFsKVxuICB9LFxuXG4gIGZpbHRlcldpdGhpblNhbWVMaXZlVmlldyhub2RlcywgcGFyZW50KXtcbiAgICBpZihwYXJlbnQucXVlcnlTZWxlY3RvcihQSFhfVklFV19TRUxFQ1RPUikpe1xuICAgICAgcmV0dXJuIG5vZGVzLmZpbHRlcihlbCA9PiB0aGlzLndpdGhpblNhbWVMaXZlVmlldyhlbCwgcGFyZW50KSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGVzXG4gICAgfVxuICB9LFxuXG4gIHdpdGhpblNhbWVMaXZlVmlldyhub2RlLCBwYXJlbnQpe1xuICAgIHdoaWxlKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpe1xuICAgICAgaWYobm9kZS5pc1NhbWVOb2RlKHBhcmVudCkpeyByZXR1cm4gdHJ1ZSB9XG4gICAgICBpZihub2RlLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTikgIT09IG51bGwpeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgfSxcblxuICBwcml2YXRlKGVsLCBrZXkpeyByZXR1cm4gZWxbUEhYX1BSSVZBVEVdICYmIGVsW1BIWF9QUklWQVRFXVtrZXldIH0sXG5cbiAgZGVsZXRlUHJpdmF0ZShlbCwga2V5KXsgZWxbUEhYX1BSSVZBVEVdICYmIGRlbGV0ZSAoZWxbUEhYX1BSSVZBVEVdW2tleV0pIH0sXG5cbiAgcHV0UHJpdmF0ZShlbCwga2V5LCB2YWx1ZSl7XG4gICAgaWYoIWVsW1BIWF9QUklWQVRFXSl7IGVsW1BIWF9QUklWQVRFXSA9IHt9IH1cbiAgICBlbFtQSFhfUFJJVkFURV1ba2V5XSA9IHZhbHVlXG4gIH0sXG5cbiAgdXBkYXRlUHJpdmF0ZShlbCwga2V5LCBkZWZhdWx0VmFsLCB1cGRhdGVGdW5jKXtcbiAgICBsZXQgZXhpc3RpbmcgPSB0aGlzLnByaXZhdGUoZWwsIGtleSlcbiAgICBpZihleGlzdGluZyA9PT0gdW5kZWZpbmVkKXtcbiAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwga2V5LCB1cGRhdGVGdW5jKGRlZmF1bHRWYWwpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdXBkYXRlRnVuYyhleGlzdGluZykpXG4gICAgfVxuICB9LFxuXG4gIGNvcHlQcml2YXRlcyh0YXJnZXQsIHNvdXJjZSl7XG4gICAgaWYoc291cmNlW1BIWF9QUklWQVRFXSl7XG4gICAgICB0YXJnZXRbUEhYX1BSSVZBVEVdID0gc291cmNlW1BIWF9QUklWQVRFXVxuICAgIH1cbiAgfSxcblxuICBwdXRUaXRsZShzdHIpe1xuICAgIGxldCB0aXRsZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInRpdGxlXCIpXG4gICAgbGV0IHtwcmVmaXgsIHN1ZmZpeH0gPSB0aXRsZUVsLmRhdGFzZXRcbiAgICBkb2N1bWVudC50aXRsZSA9IGAke3ByZWZpeCB8fCBcIlwifSR7c3RyfSR7c3VmZml4IHx8IFwiXCJ9YFxuICB9LFxuXG4gIGRlYm91bmNlKGVsLCBldmVudCwgcGh4RGVib3VuY2UsIGRlZmF1bHREZWJvdW5jZSwgcGh4VGhyb3R0bGUsIGRlZmF1bHRUaHJvdHRsZSwgYXN5bmNGaWx0ZXIsIGNhbGxiYWNrKXtcbiAgICBsZXQgZGVib3VuY2UgPSBlbC5nZXRBdHRyaWJ1dGUocGh4RGVib3VuY2UpXG4gICAgbGV0IHRocm90dGxlID0gZWwuZ2V0QXR0cmlidXRlKHBoeFRocm90dGxlKVxuICAgIGlmKGRlYm91bmNlID09PSBcIlwiKXsgZGVib3VuY2UgPSBkZWZhdWx0RGVib3VuY2UgfVxuICAgIGlmKHRocm90dGxlID09PSBcIlwiKXsgdGhyb3R0bGUgPSBkZWZhdWx0VGhyb3R0bGUgfVxuICAgIGxldCB2YWx1ZSA9IGRlYm91bmNlIHx8IHRocm90dGxlXG4gICAgc3dpdGNoKHZhbHVlKXtcbiAgICAgIGNhc2UgbnVsbDogcmV0dXJuIGNhbGxiYWNrKClcblxuICAgICAgY2FzZSBcImJsdXJcIjpcbiAgICAgICAgaWYodGhpcy5vbmNlKGVsLCBcImRlYm91bmNlLWJsdXJcIikpe1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IGNhbGxiYWNrKCkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxldCB0aW1lb3V0ID0gcGFyc2VJbnQodmFsdWUpXG4gICAgICAgIGxldCB0cmlnZ2VyID0gKCkgPT4gdGhyb3R0bGUgPyB0aGlzLmRlbGV0ZVByaXZhdGUoZWwsIFRIUk9UVExFRCkgOiBjYWxsYmFjaygpXG4gICAgICAgIGxldCBjdXJyZW50Q3ljbGUgPSB0aGlzLmluY0N5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSLCB0cmlnZ2VyKVxuICAgICAgICBpZihpc05hTih0aW1lb3V0KSl7IHJldHVybiBsb2dFcnJvcihgaW52YWxpZCB0aHJvdHRsZS9kZWJvdW5jZSB2YWx1ZTogJHt2YWx1ZX1gKSB9XG4gICAgICAgIGlmKHRocm90dGxlKXtcbiAgICAgICAgICBsZXQgbmV3S2V5RG93biA9IGZhbHNlXG4gICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gXCJrZXlkb3duXCIpe1xuICAgICAgICAgICAgbGV0IHByZXZLZXkgPSB0aGlzLnByaXZhdGUoZWwsIERFQk9VTkNFX1BSRVZfS0VZKVxuICAgICAgICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBERUJPVU5DRV9QUkVWX0tFWSwgZXZlbnQua2V5KVxuICAgICAgICAgICAgbmV3S2V5RG93biA9IHByZXZLZXkgIT09IGV2ZW50LmtleVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCFuZXdLZXlEb3duICYmIHRoaXMucHJpdmF0ZShlbCwgVEhST1RUTEVEKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBUSFJPVFRMRUQsIHRydWUpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYoYXN5bmNGaWx0ZXIoKSl7IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSKSB9XG4gICAgICAgICAgICB9LCB0aW1lb3V0KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmKGFzeW5jRmlsdGVyKCkpeyB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUiwgY3VycmVudEN5Y2xlKSB9XG4gICAgICAgICAgfSwgdGltZW91dClcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmb3JtID0gZWwuZm9ybVxuICAgICAgICBpZihmb3JtICYmIHRoaXMub25jZShmb3JtLCBcImJpbmQtZGVib3VuY2VcIikpe1xuICAgICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKChuZXcgRm9ybURhdGEoZm9ybSkpLmVudHJpZXMoKSwgKFtuYW1lXSkgPT4ge1xuICAgICAgICAgICAgICBsZXQgaW5wdXQgPSBmb3JtLnF1ZXJ5U2VsZWN0b3IoYFtuYW1lPVwiJHtuYW1lfVwiXWApXG4gICAgICAgICAgICAgIHRoaXMuaW5jQ3ljbGUoaW5wdXQsIERFQk9VTkNFX1RSSUdHRVIpXG4gICAgICAgICAgICAgIHRoaXMuZGVsZXRlUHJpdmF0ZShpbnB1dCwgVEhST1RUTEVEKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMub25jZShlbCwgXCJiaW5kLWRlYm91bmNlXCIpKXtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUikpXG4gICAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJpZ2dlckN5Y2xlKGVsLCBrZXksIGN1cnJlbnRDeWNsZSl7XG4gICAgbGV0IFtjeWNsZSwgdHJpZ2dlcl0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSlcbiAgICBpZighY3VycmVudEN5Y2xlKXsgY3VycmVudEN5Y2xlID0gY3ljbGUgfVxuICAgIGlmKGN1cnJlbnRDeWNsZSA9PT0gY3ljbGUpe1xuICAgICAgdGhpcy5pbmNDeWNsZShlbCwga2V5KVxuICAgICAgdHJpZ2dlcigpXG4gICAgfVxuICB9LFxuXG4gIG9uY2UoZWwsIGtleSl7XG4gICAgaWYodGhpcy5wcml2YXRlKGVsLCBrZXkpID09PSB0cnVlKXsgcmV0dXJuIGZhbHNlIH1cbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdHJ1ZSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9LFxuXG4gIGluY0N5Y2xlKGVsLCBrZXksIHRyaWdnZXIgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgbGV0IFtjdXJyZW50Q3ljbGVdID0gdGhpcy5wcml2YXRlKGVsLCBrZXkpIHx8IFswLCB0cmlnZ2VyXVxuICAgIGN1cnJlbnRDeWNsZSsrXG4gICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIFtjdXJyZW50Q3ljbGUsIHRyaWdnZXJdKVxuICAgIHJldHVybiBjdXJyZW50Q3ljbGVcbiAgfSxcblxuICBkaXNjYXJkRXJyb3IoY29udGFpbmVyLCBlbCwgcGh4RmVlZGJhY2tGb3Ipe1xuICAgIGxldCBmaWVsZCA9IGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUocGh4RmVlZGJhY2tGb3IpXG4gICAgLy8gVE9ETzogUmVtb3ZlIGlkIGxvb2t1cCBhZnRlciB3ZSB1cGRhdGUgUGhvZW5peCB0byB1c2UgaW5wdXRfbmFtZSBpbnN0ZWFkIG9mIGlucHV0X2lkXG4gICAgbGV0IGlucHV0ID0gZmllbGQgJiYgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYFtpZD1cIiR7ZmllbGR9XCJdLCBbbmFtZT1cIiR7ZmllbGR9XCJdYClcbiAgICBpZighaW5wdXQpeyByZXR1cm4gfVxuXG4gICAgaWYoISh0aGlzLnByaXZhdGUoaW5wdXQsIFBIWF9IQVNfRk9DVVNFRCkgfHwgdGhpcy5wcml2YXRlKGlucHV0LmZvcm0sIFBIWF9IQVNfU1VCTUlUVEVEKSkpe1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChQSFhfTk9fRkVFREJBQ0tfQ0xBU1MpXG4gICAgfVxuICB9LFxuXG4gIHNob3dFcnJvcihpbnB1dEVsLCBwaHhGZWVkYmFja0Zvcil7XG4gICAgaWYoaW5wdXRFbC5pZCB8fCBpbnB1dEVsLm5hbWUpe1xuICAgICAgdGhpcy5hbGwoaW5wdXRFbC5mb3JtLCBgWyR7cGh4RmVlZGJhY2tGb3J9PVwiJHtpbnB1dEVsLmlkfVwiXSwgWyR7cGh4RmVlZGJhY2tGb3J9PVwiJHtpbnB1dEVsLm5hbWV9XCJdYCwgKGVsKSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoZWwsIFBIWF9OT19GRUVEQkFDS19DTEFTUylcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIGlzUGh4Q2hpbGQobm9kZSl7XG4gICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKFBIWF9QQVJFTlRfSUQpXG4gIH0sXG5cbiAgaXNQaHhTdGlja3kobm9kZSl7XG4gICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKFBIWF9TVElDS1kpICE9PSBudWxsXG4gIH0sXG5cbiAgZmlyc3RQaHhDaGlsZChlbCl7XG4gICAgcmV0dXJuIHRoaXMuaXNQaHhDaGlsZChlbCkgPyBlbCA6IHRoaXMuYWxsKGVsLCBgWyR7UEhYX1BBUkVOVF9JRH1dYClbMF1cbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50KHRhcmdldCwgbmFtZSwgb3B0cyA9IHt9KXtcbiAgICBsZXQgYnViYmxlcyA9IG9wdHMuYnViYmxlcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhb3B0cy5idWJibGVzXG4gICAgbGV0IGV2ZW50T3B0cyA9IHtidWJibGVzOiBidWJibGVzLCBjYW5jZWxhYmxlOiB0cnVlLCBkZXRhaWw6IG9wdHMuZGV0YWlsIHx8IHt9fVxuICAgIGxldCBldmVudCA9IG5hbWUgPT09IFwiY2xpY2tcIiA/IG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIiwgZXZlbnRPcHRzKSA6IG5ldyBDdXN0b21FdmVudChuYW1lLCBldmVudE9wdHMpXG4gICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gIH0sXG5cbiAgY2xvbmVOb2RlKG5vZGUsIGh0bWwpe1xuICAgIGlmKHR5cGVvZiAoaHRtbCkgPT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjbG9uZWQgPSBub2RlLmNsb25lTm9kZShmYWxzZSlcbiAgICAgIGNsb25lZC5pbm5lckhUTUwgPSBodG1sXG4gICAgICByZXR1cm4gY2xvbmVkXG4gICAgfVxuICB9LFxuXG4gIG1lcmdlQXR0cnModGFyZ2V0LCBzb3VyY2UsIG9wdHMgPSB7fSl7XG4gICAgbGV0IGV4Y2x1ZGUgPSBvcHRzLmV4Y2x1ZGUgfHwgW11cbiAgICBsZXQgaXNJZ25vcmVkID0gb3B0cy5pc0lnbm9yZWRcbiAgICBsZXQgc291cmNlQXR0cnMgPSBzb3VyY2UuYXR0cmlidXRlc1xuICAgIGZvcihsZXQgaSA9IHNvdXJjZUF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcbiAgICAgIGxldCBuYW1lID0gc291cmNlQXR0cnNbaV0ubmFtZVxuICAgICAgaWYoZXhjbHVkZS5pbmRleE9mKG5hbWUpIDwgMCl7IHRhcmdldC5zZXRBdHRyaWJ1dGUobmFtZSwgc291cmNlLmdldEF0dHJpYnV0ZShuYW1lKSkgfVxuICAgIH1cblxuICAgIGxldCB0YXJnZXRBdHRycyA9IHRhcmdldC5hdHRyaWJ1dGVzXG4gICAgZm9yKGxldCBpID0gdGFyZ2V0QXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgbGV0IG5hbWUgPSB0YXJnZXRBdHRyc1tpXS5uYW1lXG4gICAgICBpZihpc0lnbm9yZWQpe1xuICAgICAgICBpZihuYW1lLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKSAmJiAhc291cmNlLmhhc0F0dHJpYnV0ZShuYW1lKSl7IHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUobmFtZSkgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoIXNvdXJjZS5oYXNBdHRyaWJ1dGUobmFtZSkpeyB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbWVyZ2VGb2N1c2VkSW5wdXQodGFyZ2V0LCBzb3VyY2Upe1xuICAgIC8vIHNraXAgc2VsZWN0cyBiZWNhdXNlIEZGIHdpbGwgcmVzZXQgaGlnaGxpZ2h0ZWQgaW5kZXggZm9yIGFueSBzZXRBdHRyaWJ1dGVcbiAgICBpZighKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50KSl7IERPTS5tZXJnZUF0dHJzKHRhcmdldCwgc291cmNlLCB7ZXhjbHVkZTogW1widmFsdWVcIl19KSB9XG4gICAgaWYoc291cmNlLnJlYWRPbmx5KXtcbiAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCB0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwicmVhZG9ubHlcIilcbiAgICB9XG4gIH0sXG5cbiAgaGFzU2VsZWN0aW9uUmFuZ2UoZWwpe1xuICAgIHJldHVybiBlbC5zZXRTZWxlY3Rpb25SYW5nZSAmJiAoZWwudHlwZSA9PT0gXCJ0ZXh0XCIgfHwgZWwudHlwZSA9PT0gXCJ0ZXh0YXJlYVwiKVxuICB9LFxuXG4gIHJlc3RvcmVGb2N1cyhmb2N1c2VkLCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKXtcbiAgICBpZighRE9NLmlzVGV4dHVhbElucHV0KGZvY3VzZWQpKXsgcmV0dXJuIH1cbiAgICBsZXQgd2FzRm9jdXNlZCA9IGZvY3VzZWQubWF0Y2hlcyhcIjpmb2N1c1wiKVxuICAgIGlmKGZvY3VzZWQucmVhZE9ubHkpeyBmb2N1c2VkLmJsdXIoKSB9XG4gICAgaWYoIXdhc0ZvY3VzZWQpeyBmb2N1c2VkLmZvY3VzKCkgfVxuICAgIGlmKHRoaXMuaGFzU2VsZWN0aW9uUmFuZ2UoZm9jdXNlZCkpe1xuICAgICAgZm9jdXNlZC5zZXRTZWxlY3Rpb25SYW5nZShzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKVxuICAgIH1cbiAgfSxcblxuICBpc0Zvcm1JbnB1dChlbCl7IHJldHVybiAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYSkkL2kudGVzdChlbC50YWdOYW1lKSAmJiBlbC50eXBlICE9PSBcImJ1dHRvblwiIH0sXG5cbiAgc3luY0F0dHJzVG9Qcm9wcyhlbCl7XG4gICAgaWYoZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmIENIRUNLQUJMRV9JTlBVVFMuaW5kZXhPZihlbC50eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkpID49IDApe1xuICAgICAgZWwuY2hlY2tlZCA9IGVsLmdldEF0dHJpYnV0ZShcImNoZWNrZWRcIikgIT09IG51bGxcbiAgICB9XG4gIH0sXG5cbiAgaXNUZXh0dWFsSW5wdXQoZWwpeyByZXR1cm4gRk9DVVNBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUpID49IDAgfSxcblxuICBpc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWwoZWwsIHBoeFRyaWdnZXJFeHRlcm5hbCl7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUocGh4VHJpZ2dlckV4dGVybmFsKSAhPT0gbnVsbFxuICB9LFxuXG4gIHN5bmNQZW5kaW5nUmVmKGZyb21FbCwgdG9FbCwgZGlzYWJsZVdpdGgpe1xuICAgIGxldCByZWYgPSBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9SRUYpXG4gICAgaWYocmVmID09PSBudWxsKXsgcmV0dXJuIHRydWUgfVxuICAgIGxldCByZWZTcmMgPSBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9SRUZfU1JDKVxuXG4gICAgaWYoRE9NLmlzRm9ybUlucHV0KGZyb21FbCkgfHwgZnJvbUVsLmdldEF0dHJpYnV0ZShkaXNhYmxlV2l0aCkgIT09IG51bGwpe1xuICAgICAgaWYoRE9NLmlzVXBsb2FkSW5wdXQoZnJvbUVsKSl7IERPTS5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwge2lzSWdub3JlZDogdHJ1ZX0pIH1cbiAgICAgIERPTS5wdXRQcml2YXRlKGZyb21FbCwgUEhYX1JFRiwgdG9FbClcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICBQSFhfRVZFTlRfQ0xBU1NFUy5mb3JFYWNoKGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIGZyb21FbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSAmJiB0b0VsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKVxuICAgICAgfSlcbiAgICAgIHRvRWwuc2V0QXR0cmlidXRlKFBIWF9SRUYsIHJlZilcbiAgICAgIHRvRWwuc2V0QXR0cmlidXRlKFBIWF9SRUZfU1JDLCByZWZTcmMpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfSxcblxuICBjbGVhbkNoaWxkTm9kZXMoY29udGFpbmVyLCBwaHhVcGRhdGUpe1xuICAgIGlmKERPTS5pc1BoeFVwZGF0ZShjb250YWluZXIsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkpe1xuICAgICAgbGV0IHRvUmVtb3ZlID0gW11cbiAgICAgIGNvbnRhaW5lci5jaGlsZE5vZGVzLmZvckVhY2goY2hpbGROb2RlID0+IHtcbiAgICAgICAgaWYoIWNoaWxkTm9kZS5pZCl7XG4gICAgICAgICAgLy8gU2tpcCB3YXJuaW5nIGlmIGl0J3MgYW4gZW1wdHkgdGV4dCBub2RlIChlLmcuIGEgbmV3LWxpbmUpXG4gICAgICAgICAgbGV0IGlzRW1wdHlUZXh0Tm9kZSA9IGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgY2hpbGROb2RlLm5vZGVWYWx1ZS50cmltKCkgPT09IFwiXCJcbiAgICAgICAgICBpZighaXNFbXB0eVRleHROb2RlKXtcbiAgICAgICAgICAgIGxvZ0Vycm9yKFwib25seSBIVE1MIGVsZW1lbnQgdGFncyB3aXRoIGFuIGlkIGFyZSBhbGxvd2VkIGluc2lkZSBjb250YWluZXJzIHdpdGggcGh4LXVwZGF0ZS5cXG5cXG5cIiArXG4gICAgICAgICAgICAgIGByZW1vdmluZyBpbGxlZ2FsIG5vZGU6IFwiJHsoY2hpbGROb2RlLm91dGVySFRNTCB8fCBjaGlsZE5vZGUubm9kZVZhbHVlKS50cmltKCl9XCJcXG5cXG5gKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0b1JlbW92ZS5wdXNoKGNoaWxkTm9kZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRvUmVtb3ZlLmZvckVhY2goY2hpbGROb2RlID0+IGNoaWxkTm9kZS5yZW1vdmUoKSlcbiAgICB9XG4gIH0sXG5cbiAgcmVwbGFjZVJvb3RDb250YWluZXIoY29udGFpbmVyLCB0YWdOYW1lLCBhdHRycyl7XG4gICAgbGV0IHJldGFpbmVkQXR0cnMgPSBuZXcgU2V0KFtcImlkXCIsIFBIWF9TRVNTSU9OLCBQSFhfU1RBVElDLCBQSFhfTUFJTiwgUEhYX1JPT1RfSURdKVxuICAgIGlmKGNvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHRhZ05hbWUudG9Mb3dlckNhc2UoKSl7XG4gICAgICBBcnJheS5mcm9tKGNvbnRhaW5lci5hdHRyaWJ1dGVzKVxuICAgICAgICAuZmlsdGVyKGF0dHIgPT4gIXJldGFpbmVkQXR0cnMuaGFzKGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgLmZvckVhY2goYXR0ciA9PiBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKGF0dHIubmFtZSkpXG5cbiAgICAgIE9iamVjdC5rZXlzKGF0dHJzKVxuICAgICAgICAuZmlsdGVyKG5hbWUgPT4gIXJldGFpbmVkQXR0cnMuaGFzKG5hbWUudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgIC5mb3JFYWNoKGF0dHIgPT4gY29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSkpXG5cbiAgICAgIHJldHVybiBjb250YWluZXJcblxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKVxuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goYXR0ciA9PiBuZXdDb250YWluZXIuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKSlcbiAgICAgIHJldGFpbmVkQXR0cnMuZm9yRWFjaChhdHRyID0+IG5ld0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoYXR0ciwgY29udGFpbmVyLmdldEF0dHJpYnV0ZShhdHRyKSkpXG4gICAgICBuZXdDb250YWluZXIuaW5uZXJIVE1MID0gY29udGFpbmVyLmlubmVySFRNTFxuICAgICAgY29udGFpbmVyLnJlcGxhY2VXaXRoKG5ld0NvbnRhaW5lcilcbiAgICAgIHJldHVybiBuZXdDb250YWluZXJcbiAgICB9XG4gIH0sXG5cbiAgZ2V0U3RpY2t5KGVsLCBuYW1lLCBkZWZhdWx0VmFsKXtcbiAgICBsZXQgb3AgPSAoRE9NLnByaXZhdGUoZWwsIFwic3RpY2t5XCIpIHx8IFtdKS5maW5kKChbZXhpc3RpbmdOYW1lLCBdKSA9PiBuYW1lID09PSBleGlzdGluZ05hbWUpXG4gICAgaWYob3Ape1xuICAgICAgbGV0IFtfbmFtZSwgX29wLCBzdGFzaGVkUmVzdWx0XSA9IG9wXG4gICAgICByZXR1cm4gc3Rhc2hlZFJlc3VsdFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHlwZW9mKGRlZmF1bHRWYWwpID09PSBcImZ1bmN0aW9uXCIgPyBkZWZhdWx0VmFsKCkgOiBkZWZhdWx0VmFsXG4gICAgfVxuICB9LFxuXG4gIGRlbGV0ZVN0aWNreShlbCwgbmFtZSl7XG4gICAgdGhpcy51cGRhdGVQcml2YXRlKGVsLCBcInN0aWNreVwiLCBbXSwgb3BzID0+IHtcbiAgICAgIHJldHVybiBvcHMuZmlsdGVyKChbZXhpc3RpbmdOYW1lLCBfXSkgPT4gZXhpc3RpbmdOYW1lICE9PSBuYW1lKVxuICAgIH0pXG4gIH0sXG5cbiAgcHV0U3RpY2t5KGVsLCBuYW1lLCBvcCl7XG4gICAgbGV0IHN0YXNoZWRSZXN1bHQgPSBvcChlbClcbiAgICB0aGlzLnVwZGF0ZVByaXZhdGUoZWwsIFwic3RpY2t5XCIsIFtdLCBvcHMgPT4ge1xuICAgICAgbGV0IGV4aXN0aW5nSW5kZXggPSBvcHMuZmluZEluZGV4KChbZXhpc3RpbmdOYW1lLCBdKSA9PiBuYW1lID09PSBleGlzdGluZ05hbWUpXG4gICAgICBpZihleGlzdGluZ0luZGV4ID49IDApe1xuICAgICAgICBvcHNbZXhpc3RpbmdJbmRleF0gPSBbbmFtZSwgb3AsIHN0YXNoZWRSZXN1bHRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHMucHVzaChbbmFtZSwgb3AsIHN0YXNoZWRSZXN1bHRdKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9wc1xuICAgIH0pXG4gIH0sXG5cbiAgYXBwbHlTdGlja3lPcGVyYXRpb25zKGVsKXtcbiAgICBsZXQgb3BzID0gRE9NLnByaXZhdGUoZWwsIFwic3RpY2t5XCIpXG4gICAgaWYoIW9wcyl7IHJldHVybiB9XG5cbiAgICBvcHMuZm9yRWFjaCgoW25hbWUsIG9wLCBfc3Rhc2hlZF0pID0+IHRoaXMucHV0U3RpY2t5KGVsLCBuYW1lLCBvcCkpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRE9NXG4iLCAiaW1wb3J0IHtcbiAgUEhYX0FDVElWRV9FTlRSWV9SRUZTLFxuICBQSFhfTElWRV9GSUxFX1VQREFURUQsXG4gIFBIWF9QUkVGTElHSFRFRF9SRUZTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNoYW5uZWxVcGxvYWRlcixcbiAgbG9nRXJyb3Jcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgTGl2ZVVwbG9hZGVyIGZyb20gXCIuL2xpdmVfdXBsb2FkZXJcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVcGxvYWRFbnRyeSB7XG4gIHN0YXRpYyBpc0FjdGl2ZShmaWxlRWwsIGZpbGUpe1xuICAgIGxldCBpc05ldyA9IGZpbGUuX3BoeFJlZiA9PT0gdW5kZWZpbmVkXG4gICAgbGV0IGFjdGl2ZVJlZnMgPSBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykuc3BsaXQoXCIsXCIpXG4gICAgbGV0IGlzQWN0aXZlID0gYWN0aXZlUmVmcy5pbmRleE9mKExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpKSA+PSAwXG4gICAgcmV0dXJuIGZpbGUuc2l6ZSA+IDAgJiYgKGlzTmV3IHx8IGlzQWN0aXZlKVxuICB9XG5cbiAgc3RhdGljIGlzUHJlZmxpZ2h0ZWQoZmlsZUVsLCBmaWxlKXtcbiAgICBsZXQgcHJlZmxpZ2h0ZWRSZWZzID0gZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykuc3BsaXQoXCIsXCIpXG4gICAgbGV0IGlzUHJlZmxpZ2h0ZWQgPSBwcmVmbGlnaHRlZFJlZnMuaW5kZXhPZihMaXZlVXBsb2FkZXIuZ2VuRmlsZVJlZihmaWxlKSkgPj0gMFxuICAgIHJldHVybiBpc1ByZWZsaWdodGVkICYmIHRoaXMuaXNBY3RpdmUoZmlsZUVsLCBmaWxlKVxuICB9XG5cbiAgY29uc3RydWN0b3IoZmlsZUVsLCBmaWxlLCB2aWV3KXtcbiAgICB0aGlzLnJlZiA9IExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpXG4gICAgdGhpcy5maWxlRWwgPSBmaWxlRWxcbiAgICB0aGlzLmZpbGUgPSBmaWxlXG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMubWV0YSA9IG51bGxcbiAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IGZhbHNlXG4gICAgdGhpcy5faXNEb25lID0gZmFsc2VcbiAgICB0aGlzLl9wcm9ncmVzcyA9IDBcbiAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50ID0gLTFcbiAgICB0aGlzLl9vbkRvbmUgPSBmdW5jdGlvbiAoKXsgfVxuICAgIHRoaXMuX29uRWxVcGRhdGVkID0gdGhpcy5vbkVsVXBkYXRlZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5maWxlRWwuYWRkRXZlbnRMaXN0ZW5lcihQSFhfTElWRV9GSUxFX1VQREFURUQsIHRoaXMuX29uRWxVcGRhdGVkKVxuICB9XG5cbiAgbWV0YWRhdGEoKXsgcmV0dXJuIHRoaXMubWV0YSB9XG5cbiAgcHJvZ3Jlc3MocHJvZ3Jlc3Mpe1xuICAgIHRoaXMuX3Byb2dyZXNzID0gTWF0aC5mbG9vcihwcm9ncmVzcylcbiAgICBpZih0aGlzLl9wcm9ncmVzcyA+IHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQpe1xuICAgICAgaWYodGhpcy5fcHJvZ3Jlc3MgPj0gMTAwKXtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSAxMDBcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IDEwMFxuICAgICAgICB0aGlzLl9pc0RvbmUgPSB0cnVlXG4gICAgICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwgMTAwLCAoKSA9PiB7XG4gICAgICAgICAgTGl2ZVVwbG9hZGVyLnVudHJhY2tGaWxlKHRoaXMuZmlsZUVsLCB0aGlzLmZpbGUpXG4gICAgICAgICAgdGhpcy5fb25Eb25lKClcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQgPSB0aGlzLl9wcm9ncmVzc1xuICAgICAgICB0aGlzLnZpZXcucHVzaEZpbGVQcm9ncmVzcyh0aGlzLmZpbGVFbCwgdGhpcy5yZWYsIHRoaXMuX3Byb2dyZXNzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNhbmNlbCgpe1xuICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gdHJ1ZVxuICAgIHRoaXMuX2lzRG9uZSA9IHRydWVcbiAgICB0aGlzLl9vbkRvbmUoKVxuICB9XG5cbiAgaXNEb25lKCl7IHJldHVybiB0aGlzLl9pc0RvbmUgfVxuXG4gIGVycm9yKHJlYXNvbiA9IFwiZmFpbGVkXCIpe1xuICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwge2Vycm9yOiByZWFzb259KVxuICAgIExpdmVVcGxvYWRlci5jbGVhckZpbGVzKHRoaXMuZmlsZUVsKVxuICB9XG5cbiAgLy9wcml2YXRlXG5cbiAgb25Eb25lKGNhbGxiYWNrKXtcbiAgICB0aGlzLl9vbkRvbmUgPSAoKSA9PiB7XG4gICAgICB0aGlzLmZpbGVFbC5yZW1vdmVFdmVudExpc3RlbmVyKFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCwgdGhpcy5fb25FbFVwZGF0ZWQpXG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgb25FbFVwZGF0ZWQoKXtcbiAgICBsZXQgYWN0aXZlUmVmcyA9IHRoaXMuZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfQUNUSVZFX0VOVFJZX1JFRlMpLnNwbGl0KFwiLFwiKVxuICAgIGlmKGFjdGl2ZVJlZnMuaW5kZXhPZih0aGlzLnJlZikgPT09IC0xKXsgdGhpcy5jYW5jZWwoKSB9XG4gIH1cblxuICB0b1ByZWZsaWdodFBheWxvYWQoKXtcbiAgICByZXR1cm4ge1xuICAgICAgbGFzdF9tb2RpZmllZDogdGhpcy5maWxlLmxhc3RNb2RpZmllZCxcbiAgICAgIG5hbWU6IHRoaXMuZmlsZS5uYW1lLFxuICAgICAgc2l6ZTogdGhpcy5maWxlLnNpemUsXG4gICAgICB0eXBlOiB0aGlzLmZpbGUudHlwZSxcbiAgICAgIHJlZjogdGhpcy5yZWZcbiAgICB9XG4gIH1cblxuICB1cGxvYWRlcih1cGxvYWRlcnMpe1xuICAgIGlmKHRoaXMubWV0YS51cGxvYWRlcil7XG4gICAgICBsZXQgY2FsbGJhY2sgPSB1cGxvYWRlcnNbdGhpcy5tZXRhLnVwbG9hZGVyXSB8fCBsb2dFcnJvcihgbm8gdXBsb2FkZXIgY29uZmlndXJlZCBmb3IgJHt0aGlzLm1ldGEudXBsb2FkZXJ9YClcbiAgICAgIHJldHVybiB7bmFtZTogdGhpcy5tZXRhLnVwbG9hZGVyLCBjYWxsYmFjazogY2FsbGJhY2t9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7bmFtZTogXCJjaGFubmVsXCIsIGNhbGxiYWNrOiBjaGFubmVsVXBsb2FkZXJ9XG4gICAgfVxuICB9XG5cbiAgemlwUG9zdEZsaWdodChyZXNwKXtcbiAgICB0aGlzLm1ldGEgPSByZXNwLmVudHJpZXNbdGhpcy5yZWZdXG4gICAgaWYoIXRoaXMubWV0YSl7IGxvZ0Vycm9yKGBubyBwcmVmbGlnaHQgdXBsb2FkIHJlc3BvbnNlIHJldHVybmVkIHdpdGggcmVmICR7dGhpcy5yZWZ9YCwge2lucHV0OiB0aGlzLmZpbGVFbCwgcmVzcG9uc2U6IHJlc3B9KSB9XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBQSFhfRE9ORV9SRUZTLFxuICBQSFhfUFJFRkxJR0hURURfUkVGUyxcbiAgUEhYX1VQTE9BRF9SRUZcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgVXBsb2FkRW50cnkgZnJvbSBcIi4vdXBsb2FkX2VudHJ5XCJcblxubGV0IGxpdmVVcGxvYWRlckZpbGVSZWYgPSAwXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpdmVVcGxvYWRlciB7XG4gIHN0YXRpYyBnZW5GaWxlUmVmKGZpbGUpe1xuICAgIGxldCByZWYgPSBmaWxlLl9waHhSZWZcbiAgICBpZihyZWYgIT09IHVuZGVmaW5lZCl7XG4gICAgICByZXR1cm4gcmVmXG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGUuX3BoeFJlZiA9IChsaXZlVXBsb2FkZXJGaWxlUmVmKyspLnRvU3RyaW5nKClcbiAgICAgIHJldHVybiBmaWxlLl9waHhSZWZcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0RW50cnlEYXRhVVJMKGlucHV0RWwsIHJlZiwgY2FsbGJhY2spe1xuICAgIGxldCBmaWxlID0gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKS5maW5kKGZpbGUgPT4gdGhpcy5nZW5GaWxlUmVmKGZpbGUpID09PSByZWYpXG4gICAgY2FsbGJhY2soVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKSlcbiAgfVxuXG4gIHN0YXRpYyBoYXNVcGxvYWRzSW5Qcm9ncmVzcyhmb3JtRWwpe1xuICAgIGxldCBhY3RpdmUgPSAwXG4gICAgRE9NLmZpbmRVcGxvYWRJbnB1dHMoZm9ybUVsKS5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgIGlmKGlucHV0LmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykgIT09IGlucHV0LmdldEF0dHJpYnV0ZShQSFhfRE9ORV9SRUZTKSl7XG4gICAgICAgIGFjdGl2ZSsrXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gYWN0aXZlID4gMFxuICB9XG5cbiAgc3RhdGljIHNlcmlhbGl6ZVVwbG9hZHMoaW5wdXRFbCl7XG4gICAgbGV0IGZpbGVzID0gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKVxuICAgIGxldCBmaWxlRGF0YSA9IHt9XG4gICAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgIGxldCBlbnRyeSA9IHtwYXRoOiBpbnB1dEVsLm5hbWV9XG4gICAgICBsZXQgdXBsb2FkUmVmID0gaW5wdXRFbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpXG4gICAgICBmaWxlRGF0YVt1cGxvYWRSZWZdID0gZmlsZURhdGFbdXBsb2FkUmVmXSB8fCBbXVxuICAgICAgZW50cnkucmVmID0gdGhpcy5nZW5GaWxlUmVmKGZpbGUpXG4gICAgICBlbnRyeS5uYW1lID0gZmlsZS5uYW1lIHx8IGVudHJ5LnJlZlxuICAgICAgZW50cnkudHlwZSA9IGZpbGUudHlwZVxuICAgICAgZW50cnkuc2l6ZSA9IGZpbGUuc2l6ZVxuICAgICAgZmlsZURhdGFbdXBsb2FkUmVmXS5wdXNoKGVudHJ5KVxuICAgIH0pXG4gICAgcmV0dXJuIGZpbGVEYXRhXG4gIH1cblxuICBzdGF0aWMgY2xlYXJGaWxlcyhpbnB1dEVsKXtcbiAgICBpbnB1dEVsLnZhbHVlID0gbnVsbFxuICAgIGlucHV0RWwucmVtb3ZlQXR0cmlidXRlKFBIWF9VUExPQURfUkVGKVxuICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgW10pXG4gIH1cblxuICBzdGF0aWMgdW50cmFja0ZpbGUoaW5wdXRFbCwgZmlsZSl7XG4gICAgRE9NLnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCBET00ucHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIpLmZpbHRlcihmID0+ICFPYmplY3QuaXMoZiwgZmlsZSkpKVxuICB9XG5cbiAgc3RhdGljIHRyYWNrRmlsZXMoaW5wdXRFbCwgZmlsZXMpe1xuICAgIGlmKGlucHV0RWwuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikgIT09IG51bGwpe1xuICAgICAgbGV0IG5ld0ZpbGVzID0gZmlsZXMuZmlsdGVyKGZpbGUgPT4gIXRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuZmluZChmID0+IE9iamVjdC5pcyhmLCBmaWxlKSkpXG4gICAgICBET00ucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIHRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuY29uY2F0KG5ld0ZpbGVzKSlcbiAgICAgIGlucHV0RWwudmFsdWUgPSBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgZmlsZXMpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFjdGl2ZUZpbGVJbnB1dHMoZm9ybUVsKXtcbiAgICBsZXQgZmlsZUlucHV0cyA9IERPTS5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbClcbiAgICByZXR1cm4gQXJyYXkuZnJvbShmaWxlSW5wdXRzKS5maWx0ZXIoZWwgPT4gZWwuZmlsZXMgJiYgdGhpcy5hY3RpdmVGaWxlcyhlbCkubGVuZ3RoID4gMClcbiAgfVxuXG4gIHN0YXRpYyBhY3RpdmVGaWxlcyhpbnB1dCl7XG4gICAgcmV0dXJuIChET00ucHJpdmF0ZShpbnB1dCwgXCJmaWxlc1wiKSB8fCBbXSkuZmlsdGVyKGYgPT4gVXBsb2FkRW50cnkuaXNBY3RpdmUoaW5wdXQsIGYpKVxuICB9XG5cbiAgc3RhdGljIGlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0KGZvcm1FbCl7XG4gICAgbGV0IGZpbGVJbnB1dHMgPSBET00uZmluZFVwbG9hZElucHV0cyhmb3JtRWwpXG4gICAgcmV0dXJuIEFycmF5LmZyb20oZmlsZUlucHV0cykuZmlsdGVyKGlucHV0ID0+IHRoaXMuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dCkubGVuZ3RoID4gMClcbiAgfVxuXG4gIHN0YXRpYyBmaWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0KXtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dCkuZmlsdGVyKGYgPT4gIVVwbG9hZEVudHJ5LmlzUHJlZmxpZ2h0ZWQoaW5wdXQsIGYpKVxuICB9XG5cbiAgY29uc3RydWN0b3IoaW5wdXRFbCwgdmlldywgb25Db21wbGV0ZSl7XG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMub25Db21wbGV0ZSA9IG9uQ29tcGxldGVcbiAgICB0aGlzLl9lbnRyaWVzID1cbiAgICAgIEFycmF5LmZyb20oTGl2ZVVwbG9hZGVyLmZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXRFbCkgfHwgW10pXG4gICAgICAgIC5tYXAoZmlsZSA9PiBuZXcgVXBsb2FkRW50cnkoaW5wdXRFbCwgZmlsZSwgdmlldykpXG5cbiAgICB0aGlzLm51bUVudHJpZXNJblByb2dyZXNzID0gdGhpcy5fZW50cmllcy5sZW5ndGhcbiAgfVxuXG4gIGVudHJpZXMoKXsgcmV0dXJuIHRoaXMuX2VudHJpZXMgfVxuXG4gIGluaXRBZGFwdGVyVXBsb2FkKHJlc3AsIG9uRXJyb3IsIGxpdmVTb2NrZXQpe1xuICAgIHRoaXMuX2VudHJpZXMgPVxuICAgICAgdGhpcy5fZW50cmllcy5tYXAoZW50cnkgPT4ge1xuICAgICAgICBlbnRyeS56aXBQb3N0RmxpZ2h0KHJlc3ApXG4gICAgICAgIGVudHJ5Lm9uRG9uZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcy0tXG4gICAgICAgICAgaWYodGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcyA9PT0gMCl7IHRoaXMub25Db21wbGV0ZSgpIH1cbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIGVudHJ5XG4gICAgICB9KVxuXG4gICAgbGV0IGdyb3VwZWRFbnRyaWVzID0gdGhpcy5fZW50cmllcy5yZWR1Y2UoKGFjYywgZW50cnkpID0+IHtcbiAgICAgIGxldCB7bmFtZSwgY2FsbGJhY2t9ID0gZW50cnkudXBsb2FkZXIobGl2ZVNvY2tldC51cGxvYWRlcnMpXG4gICAgICBhY2NbbmFtZV0gPSBhY2NbbmFtZV0gfHwge2NhbGxiYWNrOiBjYWxsYmFjaywgZW50cmllczogW119XG4gICAgICBhY2NbbmFtZV0uZW50cmllcy5wdXNoKGVudHJ5KVxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIHt9KVxuXG4gICAgZm9yKGxldCBuYW1lIGluIGdyb3VwZWRFbnRyaWVzKXtcbiAgICAgIGxldCB7Y2FsbGJhY2ssIGVudHJpZXN9ID0gZ3JvdXBlZEVudHJpZXNbbmFtZV1cbiAgICAgIGNhbGxiYWNrKGVudHJpZXMsIG9uRXJyb3IsIHJlc3AsIGxpdmVTb2NrZXQpXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgUEhYX0FDVElWRV9FTlRSWV9SRUZTLFxuICBQSFhfTElWRV9GSUxFX1VQREFURUQsXG4gIFBIWF9QUkVGTElHSFRFRF9SRUZTLFxuICBQSFhfVVBMT0FEX1JFRlxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQgTGl2ZVVwbG9hZGVyIGZyb20gXCIuL2xpdmVfdXBsb2FkZXJcIlxuXG5sZXQgSG9va3MgPSB7XG4gIExpdmVGaWxlVXBsb2FkOiB7XG4gICAgYWN0aXZlUmVmcygpeyByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX0FDVElWRV9FTlRSWV9SRUZTKSB9LFxuXG4gICAgcHJlZmxpZ2h0ZWRSZWZzKCl7IHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykgfSxcblxuICAgIG1vdW50ZWQoKXsgdGhpcy5wcmVmbGlnaHRlZFdhcyA9IHRoaXMucHJlZmxpZ2h0ZWRSZWZzKCkgfSxcblxuICAgIHVwZGF0ZWQoKXtcbiAgICAgIGxldCBuZXdQcmVmbGlnaHRzID0gdGhpcy5wcmVmbGlnaHRlZFJlZnMoKVxuICAgICAgaWYodGhpcy5wcmVmbGlnaHRlZFdhcyAhPT0gbmV3UHJlZmxpZ2h0cyl7XG4gICAgICAgIHRoaXMucHJlZmxpZ2h0ZWRXYXMgPSBuZXdQcmVmbGlnaHRzXG4gICAgICAgIGlmKG5ld1ByZWZsaWdodHMgPT09IFwiXCIpe1xuICAgICAgICAgIHRoaXMuX192aWV3LmNhbmNlbFN1Ym1pdCh0aGlzLmVsLmZvcm0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYodGhpcy5hY3RpdmVSZWZzKCkgPT09IFwiXCIpeyB0aGlzLmVsLnZhbHVlID0gbnVsbCB9XG4gICAgICB0aGlzLmVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCkpXG4gICAgfVxuICB9LFxuXG4gIExpdmVJbWdQcmV2aWV3OiB7XG4gICAgbW91bnRlZCgpe1xuICAgICAgdGhpcy5yZWYgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWVudHJ5LXJlZlwiKVxuICAgICAgdGhpcy5pbnB1dEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpKVxuICAgICAgTGl2ZVVwbG9hZGVyLmdldEVudHJ5RGF0YVVSTCh0aGlzLmlucHV0RWwsIHRoaXMucmVmLCB1cmwgPT4ge1xuICAgICAgICB0aGlzLnVybCA9IHVybFxuICAgICAgICB0aGlzLmVsLnNyYyA9IHVybFxuICAgICAgfSlcbiAgICB9LFxuICAgIGRlc3Ryb3llZCgpe1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLnVybClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSG9va3NcbiIsICJpbXBvcnQge1xuICBtYXliZVxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRE9NUG9zdE1vcnBoUmVzdG9yZXIge1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXJCZWZvcmUsIGNvbnRhaW5lckFmdGVyLCB1cGRhdGVUeXBlKXtcbiAgICBsZXQgaWRzQmVmb3JlID0gbmV3IFNldCgpXG4gICAgbGV0IGlkc0FmdGVyID0gbmV3IFNldChbLi4uY29udGFpbmVyQWZ0ZXIuY2hpbGRyZW5dLm1hcChjaGlsZCA9PiBjaGlsZC5pZCkpXG5cbiAgICBsZXQgZWxlbWVudHNUb01vZGlmeSA9IFtdXG5cbiAgICBBcnJheS5mcm9tKGNvbnRhaW5lckJlZm9yZS5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBpZihjaGlsZC5pZCl7IC8vIGFsbCBvZiBvdXIgY2hpbGRyZW4gc2hvdWxkIGJlIGVsZW1lbnRzIHdpdGggaWRzXG4gICAgICAgIGlkc0JlZm9yZS5hZGQoY2hpbGQuaWQpXG4gICAgICAgIGlmKGlkc0FmdGVyLmhhcyhjaGlsZC5pZCkpe1xuICAgICAgICAgIGxldCBwcmV2aW91c0VsZW1lbnRJZCA9IGNoaWxkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgY2hpbGQucHJldmlvdXNFbGVtZW50U2libGluZy5pZFxuICAgICAgICAgIGVsZW1lbnRzVG9Nb2RpZnkucHVzaCh7ZWxlbWVudElkOiBjaGlsZC5pZCwgcHJldmlvdXNFbGVtZW50SWQ6IHByZXZpb3VzRWxlbWVudElkfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmNvbnRhaW5lcklkID0gY29udGFpbmVyQWZ0ZXIuaWRcbiAgICB0aGlzLnVwZGF0ZVR5cGUgPSB1cGRhdGVUeXBlXG4gICAgdGhpcy5lbGVtZW50c1RvTW9kaWZ5ID0gZWxlbWVudHNUb01vZGlmeVxuICAgIHRoaXMuZWxlbWVudElkc1RvQWRkID0gWy4uLmlkc0FmdGVyXS5maWx0ZXIoaWQgPT4gIWlkc0JlZm9yZS5oYXMoaWQpKVxuICB9XG5cbiAgLy8gV2UgZG8gdGhlIGZvbGxvd2luZyB0byBvcHRpbWl6ZSBhcHBlbmQvcHJlcGVuZCBvcGVyYXRpb25zOlxuICAvLyAgIDEpIFRyYWNrIGlkcyBvZiBtb2RpZmllZCBlbGVtZW50cyAmIG9mIG5ldyBlbGVtZW50c1xuICAvLyAgIDIpIEFsbCB0aGUgbW9kaWZpZWQgZWxlbWVudHMgYXJlIHB1dCBiYWNrIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluIHRoZSBET00gdHJlZVxuICAvLyAgICAgIGJ5IHN0b3JpbmcgdGhlIGlkIG9mIHRoZWlyIHByZXZpb3VzIHNpYmxpbmdcbiAgLy8gICAzKSBOZXcgZWxlbWVudHMgYXJlIGdvaW5nIHRvIGJlIHB1dCBpbiB0aGUgcmlnaHQgcGxhY2UgYnkgbW9ycGhkb20gZHVyaW5nIGFwcGVuZC5cbiAgLy8gICAgICBGb3IgcHJlcGVuZCwgd2UgbW92ZSB0aGVtIHRvIHRoZSBmaXJzdCBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyXG4gIHBlcmZvcm0oKXtcbiAgICBsZXQgY29udGFpbmVyID0gRE9NLmJ5SWQodGhpcy5jb250YWluZXJJZClcbiAgICB0aGlzLmVsZW1lbnRzVG9Nb2RpZnkuZm9yRWFjaChlbGVtZW50VG9Nb2RpZnkgPT4ge1xuICAgICAgaWYoZWxlbWVudFRvTW9kaWZ5LnByZXZpb3VzRWxlbWVudElkKXtcbiAgICAgICAgbWF5YmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudFRvTW9kaWZ5LnByZXZpb3VzRWxlbWVudElkKSwgcHJldmlvdXNFbGVtID0+IHtcbiAgICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkuZWxlbWVudElkKSwgZWxlbSA9PiB7XG4gICAgICAgICAgICBsZXQgaXNJblJpZ2h0UGxhY2UgPSBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmlkID09IHByZXZpb3VzRWxlbS5pZFxuICAgICAgICAgICAgaWYoIWlzSW5SaWdodFBsYWNlKXtcbiAgICAgICAgICAgICAgcHJldmlvdXNFbGVtLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIGVsZW0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGNvbnRhaW5lclxuICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkuZWxlbWVudElkKSwgZWxlbSA9PiB7XG4gICAgICAgICAgbGV0IGlzSW5SaWdodFBsYWNlID0gZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nID09IG51bGxcbiAgICAgICAgICBpZighaXNJblJpZ2h0UGxhY2Upe1xuICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIiwgZWxlbSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmKHRoaXMudXBkYXRlVHlwZSA9PSBcInByZXBlbmRcIil7XG4gICAgICB0aGlzLmVsZW1lbnRJZHNUb0FkZC5yZXZlcnNlKCkuZm9yRWFjaChlbGVtSWQgPT4ge1xuICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtSWQpLCBlbGVtID0+IGNvbnRhaW5lci5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsIGVsZW0pKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cbiIsICJ2YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuXG5mdW5jdGlvbiBtb3JwaEF0dHJzKGZyb21Ob2RlLCB0b05vZGUpIHtcbiAgICB2YXIgdG9Ob2RlQXR0cnMgPSB0b05vZGUuYXR0cmlidXRlcztcbiAgICB2YXIgYXR0cjtcbiAgICB2YXIgYXR0ck5hbWU7XG4gICAgdmFyIGF0dHJOYW1lc3BhY2VVUkk7XG4gICAgdmFyIGF0dHJWYWx1ZTtcbiAgICB2YXIgZnJvbVZhbHVlO1xuXG4gICAgLy8gZG9jdW1lbnQtZnJhZ21lbnRzIGRvbnQgaGF2ZSBhdHRyaWJ1dGVzIHNvIGxldHMgbm90IGRvIGFueXRoaW5nXG4gICAgaWYgKHRvTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBmcm9tTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBhdHRyaWJ1dGVzIG9uIG9yaWdpbmFsIERPTSBlbGVtZW50XG4gICAgZm9yICh2YXIgaSA9IHRvTm9kZUF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGF0dHIgPSB0b05vZGVBdHRyc1tpXTtcbiAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgIGF0dHJOYW1lc3BhY2VVUkkgPSBhdHRyLm5hbWVzcGFjZVVSSTtcbiAgICAgICAgYXR0clZhbHVlID0gYXR0ci52YWx1ZTtcblxuICAgICAgICBpZiAoYXR0ck5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLmxvY2FsTmFtZSB8fCBhdHRyTmFtZTtcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIucHJlZml4ID09PSAneG1sbnMnKXtcbiAgICAgICAgICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7IC8vIEl0J3Mgbm90IGFsbG93ZWQgdG8gc2V0IGFuIGF0dHJpYnV0ZSB3aXRoIHRoZSBYTUxOUyBuYW1lc3BhY2Ugd2l0aG91dCBzcGVjaWZ5aW5nIHRoZSBgeG1sbnNgIHByZWZpeFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChmcm9tVmFsdWUgIT09IGF0dHJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgZXh0cmEgYXR0cmlidXRlcyBmb3VuZCBvbiB0aGUgb3JpZ2luYWwgRE9NIGVsZW1lbnQgdGhhdFxuICAgIC8vIHdlcmVuJ3QgZm91bmQgb24gdGhlIHRhcmdldCBlbGVtZW50LlxuICAgIHZhciBmcm9tTm9kZUF0dHJzID0gZnJvbU5vZGUuYXR0cmlidXRlcztcblxuICAgIGZvciAodmFyIGQgPSBmcm9tTm9kZUF0dHJzLmxlbmd0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGF0dHIgPSBmcm9tTm9kZUF0dHJzW2RdO1xuICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuXG4gICAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubG9jYWxOYW1lIHx8IGF0dHJOYW1lO1xuXG4gICAgICAgICAgICBpZiAoIXRvTm9kZS5oYXNBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5yZW1vdmVBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRvTm9kZS5oYXNBdHRyaWJ1dGUoYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHJhbmdlOyAvLyBDcmVhdGUgYSByYW5nZSBvYmplY3QgZm9yIGVmZmljZW50bHkgcmVuZGVyaW5nIHN0cmluZ3MgdG8gZWxlbWVudHMuXG52YXIgTlNfWEhUTUwgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5cbnZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZG9jdW1lbnQ7XG52YXIgSEFTX1RFTVBMQVRFX1NVUFBPUlQgPSAhIWRvYyAmJiAnY29udGVudCcgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG52YXIgSEFTX1JBTkdFX1NVUFBPUlQgPSAhIWRvYyAmJiBkb2MuY3JlYXRlUmFuZ2UgJiYgJ2NyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCcgaW4gZG9jLmNyZWF0ZVJhbmdlKCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVRlbXBsYXRlKHN0cikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IGRvYy5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHN0cjtcbiAgICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21SYW5nZShzdHIpIHtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJhbmdlID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGUoZG9jLmJvZHkpO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudCA9IHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChzdHIpO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21XcmFwKHN0cikge1xuICAgIHZhciBmcmFnbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KCdib2R5Jyk7XG4gICAgZnJhZ21lbnQuaW5uZXJIVE1MID0gc3RyO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYWJvdXQgdGhlIHNhbWVcbiAqIHZhciBodG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdHIsICd0ZXh0L2h0bWwnKTtcbiAqIHJldHVybiBodG1sLmJvZHkuZmlyc3RDaGlsZDtcbiAqXG4gKiBAbWV0aG9kIHRvRWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiB0b0VsZW1lbnQoc3RyKSB7XG4gICAgc3RyID0gc3RyLnRyaW0oKTtcbiAgICBpZiAoSEFTX1RFTVBMQVRFX1NVUFBPUlQpIHtcbiAgICAgIC8vIGF2b2lkIHJlc3RyaWN0aW9ucyBvbiBjb250ZW50IGZvciB0aGluZ3MgbGlrZSBgPHRyPjx0aD5IaTwvdGg+PC90cj5gIHdoaWNoXG4gICAgICAvLyBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQgZG9lc24ndCBzdXBwb3J0XG4gICAgICAvLyA8dGVtcGxhdGU+IHN1cHBvcnQgbm90IGF2YWlsYWJsZSBpbiBJRVxuICAgICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVRlbXBsYXRlKHN0cik7XG4gICAgfSBlbHNlIGlmIChIQVNfUkFOR0VfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVJhbmdlKHN0cik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVdyYXAoc3RyKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdHdvIG5vZGUncyBuYW1lcyBhcmUgdGhlIHNhbWUuXG4gKlxuICogTk9URTogV2UgZG9uJ3QgYm90aGVyIGNoZWNraW5nIGBuYW1lc3BhY2VVUklgIGJlY2F1c2UgeW91IHdpbGwgbmV2ZXIgZmluZCB0d28gSFRNTCBlbGVtZW50cyB3aXRoIHRoZSBzYW1lXG4gKiAgICAgICBub2RlTmFtZSBhbmQgZGlmZmVyZW50IG5hbWVzcGFjZSBVUklzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiIFRoZSB0YXJnZXQgZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29tcGFyZU5vZGVOYW1lcyhmcm9tRWwsIHRvRWwpIHtcbiAgICB2YXIgZnJvbU5vZGVOYW1lID0gZnJvbUVsLm5vZGVOYW1lO1xuICAgIHZhciB0b05vZGVOYW1lID0gdG9FbC5ub2RlTmFtZTtcbiAgICB2YXIgZnJvbUNvZGVTdGFydCwgdG9Db2RlU3RhcnQ7XG5cbiAgICBpZiAoZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZyb21Db2RlU3RhcnQgPSBmcm9tTm9kZU5hbWUuY2hhckNvZGVBdCgwKTtcbiAgICB0b0NvZGVTdGFydCA9IHRvTm9kZU5hbWUuY2hhckNvZGVBdCgwKTtcblxuICAgIC8vIElmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIHZpcnR1YWwgRE9NIG5vZGUgb3IgU1ZHIG5vZGUgdGhlbiB3ZSBtYXlcbiAgICAvLyBuZWVkIHRvIG5vcm1hbGl6ZSB0aGUgdGFnIG5hbWUgYmVmb3JlIGNvbXBhcmluZy4gTm9ybWFsIEhUTUwgZWxlbWVudHMgdGhhdCBhcmVcbiAgICAvLyBpbiB0aGUgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCJcbiAgICAvLyBhcmUgY29udmVydGVkIHRvIHVwcGVyIGNhc2VcbiAgICBpZiAoZnJvbUNvZGVTdGFydCA8PSA5MCAmJiB0b0NvZGVTdGFydCA+PSA5NykgeyAvLyBmcm9tIGlzIHVwcGVyIGFuZCB0byBpcyBsb3dlclxuICAgICAgICByZXR1cm4gZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmICh0b0NvZGVTdGFydCA8PSA5MCAmJiBmcm9tQ29kZVN0YXJ0ID49IDk3KSB7IC8vIHRvIGlzIHVwcGVyIGFuZCBmcm9tIGlzIGxvd2VyXG4gICAgICAgIHJldHVybiB0b05vZGVOYW1lID09PSBmcm9tTm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBlbGVtZW50LCBvcHRpb25hbGx5IHdpdGggYSBrbm93biBuYW1lc3BhY2UgVVJJLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBlbGVtZW50IG5hbWUsIGUuZy4gJ2Rpdicgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZXNwYWNlVVJJXSB0aGUgZWxlbWVudCdzIG5hbWVzcGFjZSBVUkksIGkuZS4gdGhlIHZhbHVlIG9mXG4gKiBpdHMgYHhtbG5zYCBhdHRyaWJ1dGUgb3IgaXRzIGluZmVycmVkIG5hbWVzcGFjZS5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZSwgbmFtZXNwYWNlVVJJKSB7XG4gICAgcmV0dXJuICFuYW1lc3BhY2VVUkkgfHwgbmFtZXNwYWNlVVJJID09PSBOU19YSFRNTCA/XG4gICAgICAgIGRvYy5jcmVhdGVFbGVtZW50KG5hbWUpIDpcbiAgICAgICAgZG9jLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIG5hbWUpO1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgY2hpbGRyZW4gb2Ygb25lIERPTSBlbGVtZW50IHRvIGFub3RoZXIgRE9NIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gbW92ZUNoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgIHZhciBjdXJDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICB2YXIgbmV4dENoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIHRvRWwuYXBwZW5kQ2hpbGQoY3VyQ2hpbGQpO1xuICAgICAgICBjdXJDaGlsZCA9IG5leHRDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIHRvRWw7XG59XG5cbmZ1bmN0aW9uIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCBuYW1lKSB7XG4gICAgaWYgKGZyb21FbFtuYW1lXSAhPT0gdG9FbFtuYW1lXSkge1xuICAgICAgICBmcm9tRWxbbmFtZV0gPSB0b0VsW25hbWVdO1xuICAgICAgICBpZiAoZnJvbUVsW25hbWVdKSB7XG4gICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBzcGVjaWFsRWxIYW5kbGVycyA9IHtcbiAgICBPUFRJT046IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGZyb21FbC5wYXJlbnROb2RlO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudE5hbWUgPSBwYXJlbnROb2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZSA9PT0gJ09QVEdST1VQJykge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgcGFyZW50TmFtZSA9IHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudE5hbWUgPT09ICdTRUxFQ1QnICYmICFwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSkge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tRWwuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpICYmICF0b0VsLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIE1TIEVkZ2UgYnVnIHdoZXJlIHRoZSAnc2VsZWN0ZWQnIGF0dHJpYnV0ZSBjYW4gb25seSBiZVxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmVkIGlmIHNldCB0byBhIG5vbi1lbXB0eSB2YWx1ZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTIwODc2NzkvXG4gICAgICAgICAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gcmVzZXQgc2VsZWN0IGVsZW1lbnQncyBzZWxlY3RlZEluZGV4IHRvIC0xLCBvdGhlcndpc2Ugc2V0dGluZ1xuICAgICAgICAgICAgICAgIC8vIGZyb21FbC5zZWxlY3RlZCB1c2luZyB0aGUgc3luY0Jvb2xlYW5BdHRyUHJvcCBiZWxvdyBoYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgICAgIC8vIFRoZSBjb3JyZWN0IHNlbGVjdGVkSW5kZXggd2lsbCBiZSBzZXQgaW4gdGhlIFNFTEVDVCBzcGVjaWFsIGhhbmRsZXIgYmVsb3cuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdzZWxlY3RlZCcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIFwidmFsdWVcIiBhdHRyaWJ1dGUgaXMgc3BlY2lhbCBmb3IgdGhlIDxpbnB1dD4gZWxlbWVudCBzaW5jZSBpdCBzZXRzXG4gICAgICogdGhlIGluaXRpYWwgdmFsdWUuIENoYW5naW5nIHRoZSBcInZhbHVlXCIgYXR0cmlidXRlIHdpdGhvdXQgY2hhbmdpbmcgdGhlXG4gICAgICogXCJ2YWx1ZVwiIHByb3BlcnR5IHdpbGwgaGF2ZSBubyBlZmZlY3Qgc2luY2UgaXQgaXMgb25seSB1c2VkIHRvIHRoZSBzZXQgdGhlXG4gICAgICogaW5pdGlhbCB2YWx1ZS4gIFNpbWlsYXIgZm9yIHRoZSBcImNoZWNrZWRcIiBhdHRyaWJ1dGUsIGFuZCBcImRpc2FibGVkXCIuXG4gICAgICovXG4gICAgSU5QVVQ6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ2NoZWNrZWQnKTtcbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdkaXNhYmxlZCcpO1xuXG4gICAgICAgIGlmIChmcm9tRWwudmFsdWUgIT09IHRvRWwudmFsdWUpIHtcbiAgICAgICAgICAgIGZyb21FbC52YWx1ZSA9IHRvRWwudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRvRWwuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICBmcm9tRWwucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIFRFWFRBUkVBOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgICAgaWYgKGZyb21FbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGZyb21FbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIE5lZWRlZCBmb3IgSUUuIEFwcGFyZW50bHkgSUUgc2V0cyB0aGUgcGxhY2Vob2xkZXIgYXMgdGhlXG4gICAgICAgICAgICAvLyBub2RlIHZhbHVlIGFuZCB2aXNlIHZlcnNhLiBUaGlzIGlnbm9yZXMgYW4gZW1wdHkgdXBkYXRlLlxuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gZmlyc3RDaGlsZC5ub2RlVmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSA9PSBuZXdWYWx1ZSB8fCAoIW5ld1ZhbHVlICYmIG9sZFZhbHVlID09IGZyb21FbC5wbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFNFTEVDVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIGlmICghdG9FbC5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJykpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGxvb3AgdGhyb3VnaCBjaGlsZHJlbiBvZiBmcm9tRWwsIG5vdCB0b0VsIHNpbmNlIG5vZGVzIGNhbiBiZSBtb3ZlZFxuICAgICAgICAgICAgLy8gZnJvbSB0b0VsIHRvIGZyb21FbCBkaXJlY3RseSB3aGVuIG1vcnBoaW5nLlxuICAgICAgICAgICAgLy8gQXQgdGhlIHRpbWUgdGhpcyBzcGVjaWFsIGhhbmRsZXIgaXMgaW52b2tlZCwgYWxsIGNoaWxkcmVuIGhhdmUgYWxyZWFkeSBiZWVuIG1vcnBoZWRcbiAgICAgICAgICAgIC8vIGFuZCBhcHBlbmRlZCB0byAvIHJlbW92ZWQgZnJvbSBmcm9tRWwsIHNvIHVzaW5nIGZyb21FbCBoZXJlIGlzIHNhZmUgYW5kIGNvcnJlY3QuXG4gICAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBvcHRncm91cDtcbiAgICAgICAgICAgIHZhciBub2RlTmFtZTtcbiAgICAgICAgICAgIHdoaWxlKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgbm9kZU5hbWUgPSBjdXJDaGlsZC5ub2RlTmFtZSAmJiBjdXJDaGlsZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ09QVEdST1VQJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cCA9IGN1ckNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IG9wdGdyb3VwLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnT1BUSU9OJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckNoaWxkLmhhc0F0dHJpYnV0ZSgnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VyQ2hpbGQgJiYgb3B0Z3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRncm91cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZyb21FbC5zZWxlY3RlZEluZGV4ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBFTEVNRU5UX05PREUgPSAxO1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUkMSA9IDExO1xudmFyIFRFWFRfTk9ERSA9IDM7XG52YXIgQ09NTUVOVF9OT0RFID0gODtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXROb2RlS2V5KG5vZGUpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJykpIHx8IG5vZGUuaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9ycGhkb21GYWN0b3J5KG1vcnBoQXR0cnMpIHtcblxuICAgIHJldHVybiBmdW5jdGlvbiBtb3JwaGRvbShmcm9tTm9kZSwgdG9Ob2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0b05vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoZnJvbU5vZGUubm9kZU5hbWUgPT09ICcjZG9jdW1lbnQnIHx8IGZyb21Ob2RlLm5vZGVOYW1lID09PSAnSFRNTCcgfHwgZnJvbU5vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICAgICAgICAgIHZhciB0b05vZGVIdG1sID0gdG9Ob2RlO1xuICAgICAgICAgICAgICAgIHRvTm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdodG1sJyk7XG4gICAgICAgICAgICAgICAgdG9Ob2RlLmlubmVySFRNTCA9IHRvTm9kZUh0bWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvTm9kZSA9IHRvRWxlbWVudCh0b05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdldE5vZGVLZXkgPSBvcHRpb25zLmdldE5vZGVLZXkgfHwgZGVmYXVsdEdldE5vZGVLZXk7XG4gICAgICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlQWRkZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uTm9kZUFkZGVkID0gb3B0aW9ucy5vbk5vZGVBZGRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25CZWZvcmVFbFVwZGF0ZWQgPSBvcHRpb25zLm9uQmVmb3JlRWxVcGRhdGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbkVsVXBkYXRlZCA9IG9wdGlvbnMub25FbFVwZGF0ZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uQmVmb3JlTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbk5vZGVEaXNjYXJkZWQgPSBvcHRpb25zLm9uTm9kZURpc2NhcmRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZCA9IG9wdGlvbnMub25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZCB8fCBub29wO1xuICAgICAgICB2YXIgY2hpbGRyZW5Pbmx5ID0gb3B0aW9ucy5jaGlsZHJlbk9ubHkgPT09IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBvYmplY3QgaXMgdXNlZCBhcyBhIGxvb2t1cCB0byBxdWlja2x5IGZpbmQgYWxsIGtleWVkIGVsZW1lbnRzIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS5cbiAgICAgICAgdmFyIGZyb21Ob2Rlc0xvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZhciBrZXllZFJlbW92YWxMaXN0ID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkS2V5ZWRSZW1vdmFsKGtleSkge1xuICAgICAgICAgICAga2V5ZWRSZW1vdmFsTGlzdC5wdXNoKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB3YWxrRGlzY2FyZGVkQ2hpbGROb2Rlcyhub2RlLCBza2lwS2V5ZWROb2Rlcykge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lwS2V5ZWROb2RlcyAmJiAoa2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgc2tpcHBpbmcga2V5ZWQgbm9kZXMgdGhlbiB3ZSBhZGQgdGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYSBsaXN0IHNvIHRoYXQgaXQgY2FuIGJlIGhhbmRsZWQgYXQgdGhlIHZlcnkgZW5kLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHJlcG9ydCB0aGUgbm9kZSBhcyBkaXNjYXJkZWQgaWYgaXQgaXMgbm90IGtleWVkLiBXZSBkbyB0aGlzIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0IHRoZSBlbmQgd2UgbG9vcCB0aHJvdWdoIGFsbCBrZXllZCBlbGVtZW50cyB0aGF0IHdlcmUgdW5tYXRjaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlbiBkaXNjYXJkIHRoZW0gaW4gb25lIGZpbmFsIHBhc3MuXG4gICAgICAgICAgICAgICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckNoaWxkLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxrRGlzY2FyZGVkQ2hpbGROb2RlcyhjdXJDaGlsZCwgc2tpcEtleWVkTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIERPTSBub2RlIG91dCBvZiB0aGUgb3JpZ2luYWwgRE9NXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gICAgICAgICAqIEBwYXJhbSAge05vZGV9IHBhcmVudE5vZGUgVGhlIG5vZGVzIHBhcmVudFxuICAgICAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBza2lwS2V5ZWROb2RlcyBJZiB0cnVlIHRoZW4gZWxlbWVudHMgd2l0aCBrZXlzIHdpbGwgYmUgc2tpcHBlZCBhbmQgbm90IGRpc2NhcmRlZC5cbiAgICAgICAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlLCBwYXJlbnROb2RlLCBza2lwS2V5ZWROb2Rlcykge1xuICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZURpc2NhcmRlZChub2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKG5vZGUpO1xuICAgICAgICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMobm9kZSwgc2tpcEtleWVkTm9kZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLy8gVHJlZVdhbGtlciBpbXBsZW1lbnRhdGlvbiBpcyBubyBmYXN0ZXIsIGJ1dCBrZWVwaW5nIHRoaXMgYXJvdW5kIGluIGNhc2UgdGhpcyBjaGFuZ2VzIGluIHRoZSBmdXR1cmVcbiAgICAgICAgLy8gZnVuY3Rpb24gaW5kZXhUcmVlKHJvb3QpIHtcbiAgICAgICAgLy8gICAgIHZhciB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcbiAgICAgICAgLy8gICAgICAgICByb290LFxuICAgICAgICAvLyAgICAgICAgIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIHZhciBlbDtcbiAgICAgICAgLy8gICAgIHdoaWxlKChlbCA9IHRyZWVXYWxrZXIubmV4dE5vZGUoKSkpIHtcbiAgICAgICAgLy8gICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShlbCk7XG4gICAgICAgIC8vICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAvLyAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGVsO1xuICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIC8vIE5vZGVJdGVyYXRvciBpbXBsZW1lbnRhdGlvbiBpcyBubyBmYXN0ZXIsIGJ1dCBrZWVwaW5nIHRoaXMgYXJvdW5kIGluIGNhc2UgdGhpcyBjaGFuZ2VzIGluIHRoZSBmdXR1cmVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gZnVuY3Rpb24gaW5kZXhUcmVlKG5vZGUpIHtcbiAgICAgICAgLy8gICAgIHZhciBub2RlSXRlcmF0b3IgPSBkb2N1bWVudC5jcmVhdGVOb2RlSXRlcmF0b3Iobm9kZSwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQpO1xuICAgICAgICAvLyAgICAgdmFyIGVsO1xuICAgICAgICAvLyAgICAgd2hpbGUoKGVsID0gbm9kZUl0ZXJhdG9yLm5leHROb2RlKCkpKSB7XG4gICAgICAgIC8vICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoZWwpO1xuICAgICAgICAvLyAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBlbDtcbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICBmdW5jdGlvbiBpbmRleFRyZWUobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFJDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBjdXJDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdhbGsgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhUcmVlKGN1ckNoaWxkKTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4VHJlZShmcm9tTm9kZSk7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTm9kZUFkZGVkKGVsKSB7XG4gICAgICAgICAgICBvbk5vZGVBZGRlZChlbCk7XG5cbiAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IGVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjdXJDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1bm1hdGNoZWRGcm9tRWwgPSBmcm9tTm9kZXNMb29rdXBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZmluZCBhIGR1cGxpY2F0ZSAjaWQgbm9kZSBpbiBjYWNoZSwgcmVwbGFjZSBgZWxgIHdpdGggY2FjaGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG1vcnBoIGl0IHRvIHRoZSBjaGlsZCBub2RlLlxuICAgICAgICAgICAgICAgICAgICBpZiAodW5tYXRjaGVkRnJvbUVsICYmIGNvbXBhcmVOb2RlTmFtZXMoY3VyQ2hpbGQsIHVubWF0Y2hlZEZyb21FbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhFbCh1bm1hdGNoZWRGcm9tRWwsIGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNhbGwgZm9yIGN1ckNoaWxkIGFuZCBpdCdzIGNoaWxkcmVuIHRvIHNlZSBpZiB3ZSBmaW5kIHNvbWV0aGluZyBpblxuICAgICAgICAgICAgICAgICAgLy8gZnJvbU5vZGVzTG9va3VwXG4gICAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gbmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjbGVhbnVwRnJvbUVsKGZyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCwgY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBvZiB0aGUgXCJ0byBub2Rlc1wiLiBJZiBjdXJGcm9tTm9kZUNoaWxkIGlzXG4gICAgICAgICAgICAvLyBub24tbnVsbCB0aGVuIHdlIHN0aWxsIGhhdmUgc29tZSBmcm9tIG5vZGVzIGxlZnQgb3ZlciB0aGF0IG5lZWRcbiAgICAgICAgICAgIC8vIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgaWYgKChjdXJGcm9tTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyRnJvbU5vZGVDaGlsZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbW9ycGhFbChmcm9tRWwsIHRvRWwsIGNoaWxkcmVuT25seSkge1xuICAgICAgICAgICAgdmFyIHRvRWxLZXkgPSBnZXROb2RlS2V5KHRvRWwpO1xuXG4gICAgICAgICAgICBpZiAodG9FbEtleSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGFuIGVsZW1lbnQgd2l0aCBhbiBJRCBpcyBiZWluZyBtb3JwaGVkIHRoZW4gaXQgd2lsbCBiZSBpbiB0aGUgZmluYWxcbiAgICAgICAgICAgICAgICAvLyBET00gc28gY2xlYXIgaXQgb3V0IG9mIHRoZSBzYXZlZCBlbGVtZW50cyBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgZGVsZXRlIGZyb21Ob2Rlc0xvb2t1cFt0b0VsS2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk9ubHkpIHtcbiAgICAgICAgICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICAgICAgICAgIGlmIChvbkJlZm9yZUVsVXBkYXRlZChmcm9tRWwsIHRvRWwpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGF0dHJpYnV0ZXMgb24gb3JpZ2luYWwgRE9NIGVsZW1lbnQgZmlyc3RcbiAgICAgICAgICAgICAgICBtb3JwaEF0dHJzKGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW9uYWxcbiAgICAgICAgICAgICAgICBvbkVsVXBkYXRlZChmcm9tRWwpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQoZnJvbUVsLCB0b0VsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZyb21FbC5ub2RlTmFtZSAhPT0gJ1RFWFRBUkVBJykge1xuICAgICAgICAgICAgICBtb3JwaENoaWxkcmVuKGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzcGVjaWFsRWxIYW5kbGVycy5URVhUQVJFQShmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbW9ycGhDaGlsZHJlbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgICAgIHZhciBjdXJUb05vZGVDaGlsZCA9IHRvRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB2YXIgY3VyVG9Ob2RlS2V5O1xuICAgICAgICAgICAgdmFyIGN1ckZyb21Ob2RlS2V5O1xuXG4gICAgICAgICAgICB2YXIgZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgdmFyIHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdGcm9tRWw7XG5cbiAgICAgICAgICAgIC8vIHdhbGsgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICBvdXRlcjogd2hpbGUgKGN1clRvTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdG9OZXh0U2libGluZyA9IGN1clRvTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGN1clRvTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyVG9Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgLy8gd2FsayB0aGUgZnJvbU5vZGUgY2hpbGRyZW4gYWxsIHRoZSB3YXkgdGhyb3VnaFxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUNoaWxkLmlzU2FtZU5vZGUgJiYgY3VyVG9Ob2RlQ2hpbGQuaXNTYW1lTm9kZShjdXJGcm9tTm9kZUNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJGcm9tTm9kZVR5cGUgPSBjdXJGcm9tTm9kZUNoaWxkLm5vZGVUeXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgaWYgdGhlIGN1ckZyb21Ob2RlQ2hpbGQgZG9lc250IGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJUb05vZGVDaGlsZFxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNDb21wYXRpYmxlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IGN1clRvTm9kZUNoaWxkLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCb3RoIG5vZGVzIGJlaW5nIGNvbXBhcmVkIGFyZSBFbGVtZW50IG5vZGVzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgbm9kZSBoYXMgYSBrZXkgc28gd2Ugd2FudCB0byBtYXRjaCBpdCB1cCB3aXRoIHRoZSBjb3JyZWN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkgIT09IGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCBET00gdHJlZSBkb2VzIG5vdCBoYXZlIGEgbWF0Y2hpbmcga2V5IHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBjaGVjayBvdXIgbG9va3VwIHRvIHNlZSBpZiB0aGVyZSBpcyBhIG1hdGNoaW5nIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBET00gdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tTmV4dFNpYmxpbmcgPT09IG1hdGNoaW5nRnJvbUVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3Igc2luZ2xlIGVsZW1lbnQgcmVtb3ZhbHMuIFRvIGF2b2lkIHJlbW92aW5nIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBET00gbm9kZSBvdXQgb2YgdGhlIHRyZWUgKHNpbmNlIHRoYXQgY2FuIGJyZWFrIENTUyB0cmFuc2l0aW9ucywgZXRjLiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHdpbGwgaW5zdGVhZCBkaXNjYXJkIHRoZSBjdXJyZW50IG5vZGUgYW5kIHdhaXQgdW50aWwgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0aW9uIHRvIHByb3Blcmx5IG1hdGNoIHVwIHRoZSBrZXllZCB0YXJnZXQgZWxlbWVudCB3aXRoIGl0cyBtYXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgbWF0Y2hpbmcga2V5ZWQgZWxlbWVudCBzb21ld2hlcmUgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZXQncyBtb3ZlIHRoZSBvcmlnaW5hbCBET00gbm9kZSBpbnRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBtb3JwaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdC5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBXZSB1c2UgaW5zZXJ0QmVmb3JlIGluc3RlYWQgb2YgcmVwbGFjZUNoaWxkIGJlY2F1c2Ugd2Ugd2FudCB0byBnbyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBgcmVtb3ZlTm9kZSgpYCBmdW5jdGlvbiBmb3IgdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBkaXNjYXJkZWQgc28gdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgbGlmZWN5Y2xlIGhvb2tzIGFyZSBjb3JyZWN0bHkgaW52b2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tRWwuaW5zZXJ0QmVmb3JlKG1hdGNoaW5nRnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gbWF0Y2hpbmdGcm9tRWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbm9kZXMgYXJlIG5vdCBjb21wYXRpYmxlIHNpbmNlIHRoZSBcInRvXCIgbm9kZSBoYXMgYSBrZXkgYW5kIHRoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm8gbWF0Y2hpbmcga2V5ZWQgbm9kZSBpbiB0aGUgc291cmNlIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9yaWdpbmFsIGhhcyBhIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBpc0NvbXBhdGlibGUgIT09IGZhbHNlICYmIGNvbXBhcmVOb2RlTmFtZXMoY3VyRnJvbU5vZGVDaGlsZCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgY29tcGF0aWJsZSBET00gZWxlbWVudHMgc28gdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IFwiZnJvbVwiIG5vZGUgdG8gbWF0Y2ggdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFyZ2V0IERPTSBub2RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNT1JQSFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3JwaEVsKGN1ckZyb21Ob2RlQ2hpbGQsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBURVhUX05PREUgfHwgY3VyRnJvbU5vZGVUeXBlID09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvdGggbm9kZXMgYmVpbmcgY29tcGFyZWQgYXJlIFRleHQgb3IgQ29tbWVudCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2ltcGx5IHVwZGF0ZSBub2RlVmFsdWUgb24gdGhlIG9yaWdpbmFsIG5vZGUgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIHRleHQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVDaGlsZC5ub2RlVmFsdWUgIT09IGN1clRvTm9kZUNoaWxkLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkLm5vZGVWYWx1ZSA9IGN1clRvTm9kZUNoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgYm90aCB0aGUgXCJ0b1wiIGNoaWxkIGFuZCB0aGUgXCJmcm9tXCIgY2hpbGQgc2luY2Ugd2UgZm91bmQgYSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBlbHNlIHRvIGRvIGFzIHdlIGFscmVhZHkgcmVjdXJzaXZlbHkgY2FsbGVkIG1vcnBoQ2hpbGRyZW4gYWJvdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGNvbXBhdGlibGUgbWF0Y2ggc28gcmVtb3ZlIHRoZSBvbGQgbm9kZSBmcm9tIHRoZSBET00gYW5kIGNvbnRpbnVlIHRyeWluZyB0byBmaW5kIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2ggaW4gdGhlIG9yaWdpbmFsIERPTS4gSG93ZXZlciwgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSBmcm9tIG5vZGUgaXMgbm90IGtleWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0IGlzIHBvc3NpYmxlIHRoYXQgYSBrZXllZCBub2RlIG1pZ2h0IG1hdGNoIHVwIHdpdGggYSBub2RlIHNvbWV3aGVyZSBlbHNlIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB0YXJnZXQgdHJlZSBhbmQgd2UgZG9uJ3Qgd2FudCB0byBkaXNjYXJkIGl0IGp1c3QgeWV0IHNpbmNlIGl0IHN0aWxsIG1pZ2h0IGZpbmQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBob21lIGluIHRoZSBmaW5hbCBET00gdHJlZS4gQWZ0ZXIgZXZlcnl0aGluZyBpcyBkb25lIHdlIHdpbGwgcmVtb3ZlIGFueSBrZXllZCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGRpZG4ndCBmaW5kIGEgaG9tZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgcmVtb3ZhbCB0byBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIHNraXAgbmVzdGVkIGtleWVkIG5vZGVzIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc3RpbGwgYSBjaGFuY2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgdXAgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9IC8vIEVORDogd2hpbGUoY3VyRnJvbU5vZGVDaGlsZCkge31cblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGdvdCB0aGlzIGZhciB0aGVuIHdlIGRpZCBub3QgZmluZCBhIGNhbmRpZGF0ZSBtYXRjaCBmb3JcbiAgICAgICAgICAgICAgICAvLyBvdXIgXCJ0byBub2RlXCIgYW5kIHdlIGV4aGF1c3RlZCBhbGwgb2YgdGhlIGNoaWxkcmVuIFwiZnJvbVwiXG4gICAgICAgICAgICAgICAgLy8gbm9kZXMuIFRoZXJlZm9yZSwgd2Ugd2lsbCBqdXN0IGFwcGVuZCB0aGUgY3VycmVudCBcInRvXCIgbm9kZVxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBlbmRcbiAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5ICYmIChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSAmJiBjb21wYXJlTm9kZU5hbWVzKG1hdGNoaW5nRnJvbUVsLCBjdXJUb05vZGVDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUVsLmFwcGVuZENoaWxkKG1hdGNoaW5nRnJvbUVsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTU9SUEhcbiAgICAgICAgICAgICAgICAgICAgbW9ycGhFbChtYXRjaGluZ0Zyb21FbCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCA9IG9uQmVmb3JlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUNoaWxkLmFjdHVhbGl6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gY3VyVG9Ob2RlQ2hpbGQuYWN0dWFsaXplKGZyb21FbC5vd25lckRvY3VtZW50IHx8IGRvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tRWwuYXBwZW5kQ2hpbGQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbGVhbnVwRnJvbUVsKGZyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCwgY3VyRnJvbU5vZGVLZXkpO1xuXG4gICAgICAgICAgICB2YXIgc3BlY2lhbEVsSGFuZGxlciA9IHNwZWNpYWxFbEhhbmRsZXJzW2Zyb21FbC5ub2RlTmFtZV07XG4gICAgICAgICAgICBpZiAoc3BlY2lhbEVsSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHNwZWNpYWxFbEhhbmRsZXIoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBFTkQ6IG1vcnBoQ2hpbGRyZW4oLi4uKVxuXG4gICAgICAgIHZhciBtb3JwaGVkTm9kZSA9IGZyb21Ob2RlO1xuICAgICAgICB2YXIgbW9ycGhlZE5vZGVUeXBlID0gbW9ycGhlZE5vZGUubm9kZVR5cGU7XG4gICAgICAgIHZhciB0b05vZGVUeXBlID0gdG9Ob2RlLm5vZGVUeXBlO1xuXG4gICAgICAgIGlmICghY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgYXJlIGdpdmVuIHR3byBET00gbm9kZXMgdGhhdCBhcmUgbm90XG4gICAgICAgICAgICAvLyBjb21wYXRpYmxlIChlLmcuIDxkaXY+IC0tPiA8c3Bhbj4gb3IgPGRpdj4gLS0+IFRFWFQpXG4gICAgICAgICAgICBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9Ob2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGFyZU5vZGVOYW1lcyhmcm9tTm9kZSwgdG9Ob2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gbW92ZUNoaWxkcmVuKGZyb21Ob2RlLCBjcmVhdGVFbGVtZW50TlModG9Ob2RlLm5vZGVOYW1lLCB0b05vZGUubmFtZXNwYWNlVVJJKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBHb2luZyBmcm9tIGFuIGVsZW1lbnQgbm9kZSB0byBhIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZSA9IHRvTm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vcnBoZWROb2RlVHlwZSA9PT0gVEVYVF9OT0RFIHx8IG1vcnBoZWROb2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7IC8vIFRleHQgb3IgY29tbWVudCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT09IG1vcnBoZWROb2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9ycGhlZE5vZGUubm9kZVZhbHVlICE9PSB0b05vZGUubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZS5ub2RlVmFsdWUgPSB0b05vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRleHQgbm9kZSB0byBzb21ldGhpbmcgZWxzZVxuICAgICAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZSA9IHRvTm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9ycGhlZE5vZGUgPT09IHRvTm9kZSkge1xuICAgICAgICAgICAgLy8gVGhlIFwidG8gbm9kZVwiIHdhcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBcImZyb20gbm9kZVwiIHNvIHdlIGhhZCB0b1xuICAgICAgICAgICAgLy8gdG9zcyBvdXQgdGhlIFwiZnJvbSBub2RlXCIgYW5kIHVzZSB0aGUgXCJ0byBub2RlXCJcbiAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChmcm9tTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodG9Ob2RlLmlzU2FtZU5vZGUgJiYgdG9Ob2RlLmlzU2FtZU5vZGUobW9ycGhlZE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb3JwaEVsKG1vcnBoZWROb2RlLCB0b05vZGUsIGNoaWxkcmVuT25seSk7XG5cbiAgICAgICAgICAgIC8vIFdlIG5vdyBuZWVkIHRvIGxvb3Agb3ZlciBhbnkga2V5ZWQgbm9kZXMgdGhhdCBtaWdodCBuZWVkIHRvIGJlXG4gICAgICAgICAgICAvLyByZW1vdmVkLiBXZSBvbmx5IGRvIHRoZSByZW1vdmFsIGlmIHdlIGtub3cgdGhhdCB0aGUga2V5ZWQgbm9kZVxuICAgICAgICAgICAgLy8gbmV2ZXIgZm91bmQgYSBtYXRjaC4gV2hlbiBhIGtleWVkIG5vZGUgaXMgbWF0Y2hlZCB1cCB3ZSByZW1vdmVcbiAgICAgICAgICAgIC8vIGl0IG91dCBvZiBmcm9tTm9kZXNMb29rdXAgYW5kIHdlIHVzZSBmcm9tTm9kZXNMb29rdXAgdG8gZGV0ZXJtaW5lXG4gICAgICAgICAgICAvLyBpZiBhIGtleWVkIG5vZGUgaGFzIGJlZW4gbWF0Y2hlZCB1cCBvciBub3RcbiAgICAgICAgICAgIGlmIChrZXllZFJlbW92YWxMaXN0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBsZW49a2V5ZWRSZW1vdmFsTGlzdC5sZW5ndGg7IGk8bGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsVG9SZW1vdmUgPSBmcm9tTm9kZXNMb29rdXBba2V5ZWRSZW1vdmFsTGlzdFtpXV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbFRvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGVsVG9SZW1vdmUsIGVsVG9SZW1vdmUucGFyZW50Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjaGlsZHJlbk9ubHkgJiYgbW9ycGhlZE5vZGUgIT09IGZyb21Ob2RlICYmIGZyb21Ob2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChtb3JwaGVkTm9kZS5hY3R1YWxpemUpIHtcbiAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZSA9IG1vcnBoZWROb2RlLmFjdHVhbGl6ZShmcm9tTm9kZS5vd25lckRvY3VtZW50IHx8IGRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYWQgdG8gc3dhcCBvdXQgdGhlIGZyb20gbm9kZSB3aXRoIGEgbmV3IG5vZGUgYmVjYXVzZSB0aGUgb2xkXG4gICAgICAgICAgICAvLyBub2RlIHdhcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSB0YXJnZXQgbm9kZSB0aGVuIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIG9sZCBET00gbm9kZSBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuIFRoaXMgaXMgb25seVxuICAgICAgICAgICAgLy8gcG9zc2libGUgaWYgdGhlIG9yaWdpbmFsIERPTSBub2RlIHdhcyBwYXJ0IG9mIGEgRE9NIHRyZWUgd2hpY2hcbiAgICAgICAgICAgIC8vIHdlIGtub3cgaXMgdGhlIGNhc2UgaWYgaXQgaGFzIGEgcGFyZW50IG5vZGUuXG4gICAgICAgICAgICBmcm9tTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChtb3JwaGVkTm9kZSwgZnJvbU5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICAgIH07XG59XG5cbnZhciBtb3JwaGRvbSA9IG1vcnBoZG9tRmFjdG9yeShtb3JwaEF0dHJzKTtcblxuZXhwb3J0IGRlZmF1bHQgbW9ycGhkb207XG4iLCAiaW1wb3J0IHtcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX0RJU0FCTEVfV0lUSCxcbiAgUEhYX0ZFRURCQUNLX0ZPUixcbiAgUEhYX1BSVU5FLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1NFU1NJT04sXG4gIFBIWF9TS0lQLFxuICBQSFhfU1RBVElDLFxuICBQSFhfVFJJR0dFUl9BQ1RJT04sXG4gIFBIWF9VUERBVEVcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgZGV0ZWN0RHVwbGljYXRlSWRzLFxuICBpc0NpZFxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcbmltcG9ydCBET01Qb3N0TW9ycGhSZXN0b3JlciBmcm9tIFwiLi9kb21fcG9zdF9tb3JwaF9yZXN0b3JlclwiXG5pbXBvcnQgbW9ycGhkb20gZnJvbSBcIm1vcnBoZG9tXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRE9NUGF0Y2gge1xuICBzdGF0aWMgcGF0Y2hFbChmcm9tRWwsIHRvRWwsIGFjdGl2ZUVsZW1lbnQpe1xuICAgIG1vcnBoZG9tKGZyb21FbCwgdG9FbCwge1xuICAgICAgY2hpbGRyZW5Pbmx5OiBmYWxzZSxcbiAgICAgIG9uQmVmb3JlRWxVcGRhdGVkOiAoZnJvbUVsLCB0b0VsKSA9PiB7XG4gICAgICAgIGlmKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC5pc1NhbWVOb2RlKGZyb21FbCkgJiYgRE9NLmlzRm9ybUlucHV0KGZyb21FbCkpe1xuICAgICAgICAgIERPTS5tZXJnZUZvY3VzZWRJbnB1dChmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgY29uc3RydWN0b3IodmlldywgY29udGFpbmVyLCBpZCwgaHRtbCwgdGFyZ2V0Q0lEKXtcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5saXZlU29ja2V0ID0gdmlldy5saXZlU29ja2V0XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXJcbiAgICB0aGlzLmlkID0gaWRcbiAgICB0aGlzLnJvb3RJRCA9IHZpZXcucm9vdC5pZFxuICAgIHRoaXMuaHRtbCA9IGh0bWxcbiAgICB0aGlzLnRhcmdldENJRCA9IHRhcmdldENJRFxuICAgIHRoaXMuY2lkUGF0Y2ggPSBpc0NpZCh0aGlzLnRhcmdldENJRClcbiAgICB0aGlzLmNhbGxiYWNrcyA9IHtcbiAgICAgIGJlZm9yZWFkZGVkOiBbXSwgYmVmb3JldXBkYXRlZDogW10sIGJlZm9yZXBoeENoaWxkQWRkZWQ6IFtdLFxuICAgICAgYWZ0ZXJhZGRlZDogW10sIGFmdGVydXBkYXRlZDogW10sIGFmdGVyZGlzY2FyZGVkOiBbXSwgYWZ0ZXJwaHhDaGlsZEFkZGVkOiBbXSxcbiAgICAgIGFmdGVydHJhbnNpdGlvbnNEaXNjYXJkZWQ6IFtdXG4gICAgfVxuICB9XG5cbiAgYmVmb3JlKGtpbmQsIGNhbGxiYWNrKXsgdGhpcy5jYWxsYmFja3NbYGJlZm9yZSR7a2luZH1gXS5wdXNoKGNhbGxiYWNrKSB9XG4gIGFmdGVyKGtpbmQsIGNhbGxiYWNrKXsgdGhpcy5jYWxsYmFja3NbYGFmdGVyJHtraW5kfWBdLnB1c2goY2FsbGJhY2spIH1cblxuICB0cmFja0JlZm9yZShraW5kLCAuLi5hcmdzKXtcbiAgICB0aGlzLmNhbGxiYWNrc1tgYmVmb3JlJHtraW5kfWBdLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soLi4uYXJncykpXG4gIH1cblxuICB0cmFja0FmdGVyKGtpbmQsIC4uLmFyZ3Mpe1xuICAgIHRoaXMuY2FsbGJhY2tzW2BhZnRlciR7a2luZH1gXS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKC4uLmFyZ3MpKVxuICB9XG5cbiAgbWFya1BydW5hYmxlQ29udGVudEZvclJlbW92YWwoKXtcbiAgICBET00uYWxsKHRoaXMuY29udGFpbmVyLCBcIltwaHgtdXBkYXRlPWFwcGVuZF0gPiAqLCBbcGh4LXVwZGF0ZT1wcmVwZW5kXSA+ICpcIiwgZWwgPT4ge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9QUlVORSwgXCJcIilcbiAgICB9KVxuICB9XG5cbiAgcGVyZm9ybSgpe1xuICAgIGxldCB7dmlldywgbGl2ZVNvY2tldCwgY29udGFpbmVyLCBodG1sfSA9IHRoaXNcbiAgICBsZXQgdGFyZ2V0Q29udGFpbmVyID0gdGhpcy5pc0NJRFBhdGNoKCkgPyB0aGlzLnRhcmdldENJRENvbnRhaW5lcihodG1sKSA6IGNvbnRhaW5lclxuICAgIGlmKHRoaXMuaXNDSURQYXRjaCgpICYmICF0YXJnZXRDb250YWluZXIpeyByZXR1cm4gfVxuXG4gICAgbGV0IGZvY3VzZWQgPSBsaXZlU29ja2V0LmdldEFjdGl2ZUVsZW1lbnQoKVxuICAgIGxldCB7c2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZH0gPSBmb2N1c2VkICYmIERPTS5oYXNTZWxlY3Rpb25SYW5nZShmb2N1c2VkKSA/IGZvY3VzZWQgOiB7fVxuICAgIGxldCBwaHhVcGRhdGUgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX1VQREFURSlcbiAgICBsZXQgcGh4RmVlZGJhY2tGb3IgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX0ZFRURCQUNLX0ZPUilcbiAgICBsZXQgZGlzYWJsZVdpdGggPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX0RJU0FCTEVfV0lUSClcbiAgICBsZXQgcGh4VHJpZ2dlckV4dGVybmFsID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9UUklHR0VSX0FDVElPTilcbiAgICBsZXQgcGh4UmVtb3ZlID0gbGl2ZVNvY2tldC5iaW5kaW5nKFwicmVtb3ZlXCIpXG4gICAgbGV0IGFkZGVkID0gW11cbiAgICBsZXQgdXBkYXRlcyA9IFtdXG4gICAgbGV0IGFwcGVuZFByZXBlbmRVcGRhdGVzID0gW11cbiAgICBsZXQgcGVuZGluZ1JlbW92ZXMgPSBbXVxuICAgIGxldCBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBudWxsXG5cbiAgICBsZXQgZGlmZkhUTUwgPSBsaXZlU29ja2V0LnRpbWUoXCJwcmVtb3JwaCBjb250YWluZXIgcHJlcFwiLCAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5idWlsZERpZmZIVE1MKGNvbnRhaW5lciwgaHRtbCwgcGh4VXBkYXRlLCB0YXJnZXRDb250YWluZXIpXG4gICAgfSlcblxuICAgIHRoaXMudHJhY2tCZWZvcmUoXCJhZGRlZFwiLCBjb250YWluZXIpXG4gICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgY29udGFpbmVyLCBjb250YWluZXIpXG5cbiAgICBsaXZlU29ja2V0LnRpbWUoXCJtb3JwaGRvbVwiLCAoKSA9PiB7XG4gICAgICBtb3JwaGRvbSh0YXJnZXRDb250YWluZXIsIGRpZmZIVE1MLCB7XG4gICAgICAgIGNoaWxkcmVuT25seTogdGFyZ2V0Q29udGFpbmVyLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSA9PT0gbnVsbCxcbiAgICAgICAgZ2V0Tm9kZUtleTogKG5vZGUpID0+IHtcbiAgICAgICAgICByZXR1cm4gRE9NLmlzUGh4RGVzdHJveWVkKG5vZGUpID8gbnVsbCA6IG5vZGUuaWRcbiAgICAgICAgfSxcbiAgICAgICAgb25CZWZvcmVOb2RlQWRkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJhZGRlZFwiLCBlbClcbiAgICAgICAgICByZXR1cm4gZWxcbiAgICAgICAgfSxcbiAgICAgICAgb25Ob2RlQWRkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIC8vIGhhY2sgdG8gZml4IFNhZmFyaSBoYW5kbGluZyBvZiBpbWcgc3Jjc2V0IGFuZCB2aWRlbyB0YWdzXG4gICAgICAgICAgaWYoZWwgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ICYmIGVsLnNyY3NldCl7XG4gICAgICAgICAgICBlbC5zcmNzZXQgPSBlbC5zcmNzZXRcbiAgICAgICAgICB9IGVsc2UgaWYoZWwgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ICYmIGVsLmF1dG9wbGF5KXtcbiAgICAgICAgICAgIGVsLnBsYXkoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihET00uaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKGVsLCBwaHhUcmlnZ2VyRXh0ZXJuYWwpKXtcbiAgICAgICAgICAgIGV4dGVybmFsRm9ybVRyaWdnZXJlZCA9IGVsXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vaW5wdXQgaGFuZGxpbmdcbiAgICAgICAgICBET00uZGlzY2FyZEVycm9yKHRhcmdldENvbnRhaW5lciwgZWwsIHBoeEZlZWRiYWNrRm9yKVxuICAgICAgICAgIC8vIG5lc3RlZCB2aWV3IGhhbmRsaW5nXG4gICAgICAgICAgaWYoKERPTS5pc1BoeENoaWxkKGVsKSAmJiB2aWV3Lm93bnNFbGVtZW50KGVsKSkgfHwgRE9NLmlzUGh4U3RpY2t5KGVsKSAmJiB2aWV3Lm93bnNFbGVtZW50KGVsLnBhcmVudE5vZGUpKXtcbiAgICAgICAgICAgIHRoaXMudHJhY2tBZnRlcihcInBoeENoaWxkQWRkZWRcIiwgZWwpXG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZGVkLnB1c2goZWwpXG4gICAgICAgIH0sXG4gICAgICAgIG9uTm9kZURpc2NhcmRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgLy8gbmVzdGVkIHZpZXcgaGFuZGxpbmdcbiAgICAgICAgICBpZihET00uaXNQaHhDaGlsZChlbCkgfHwgRE9NLmlzUGh4U3RpY2t5KGVsKSl7IGxpdmVTb2NrZXQuZGVzdHJveVZpZXdCeUVsKGVsKSB9XG4gICAgICAgICAgdGhpcy50cmFja0FmdGVyKFwiZGlzY2FyZGVkXCIsIGVsKVxuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZU5vZGVEaXNjYXJkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIGlmKGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1BSVU5FKSAhPT0gbnVsbCl7IHJldHVybiB0cnVlIH1cbiAgICAgICAgICBpZihlbC5wYXJlbnROb2RlICE9PSBudWxsICYmIERPTS5pc1BoeFVwZGF0ZShlbC5wYXJlbnROb2RlLCBwaHhVcGRhdGUsIFtcImFwcGVuZFwiLCBcInByZXBlbmRcIl0pICYmIGVsLmlkKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICBpZihlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKHBoeFJlbW92ZSkpe1xuICAgICAgICAgICAgcGVuZGluZ1JlbW92ZXMucHVzaChlbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZih0aGlzLnNraXBDSURTaWJsaW5nKGVsKSl7IHJldHVybiBmYWxzZSB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgb25FbFVwZGF0ZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIGlmKERPTS5pc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWwoZWwsIHBoeFRyaWdnZXJFeHRlcm5hbCkpe1xuICAgICAgICAgICAgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkID0gZWxcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlcy5wdXNoKGVsKVxuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZUVsVXBkYXRlZDogKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgICAgIERPTS5jbGVhbkNoaWxkTm9kZXModG9FbCwgcGh4VXBkYXRlKVxuICAgICAgICAgIGlmKHRoaXMuc2tpcENJRFNpYmxpbmcodG9FbCkpeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIGlmKERPTS5pc1BoeFN0aWNreShmcm9tRWwpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICBpZihET00uaXNJZ25vcmVkKGZyb21FbCwgcGh4VXBkYXRlKSl7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICBET00ubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHtpc0lnbm9yZWQ6IHRydWV9KVxuICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbClcbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGZyb21FbC50eXBlID09PSBcIm51bWJlclwiICYmIChmcm9tRWwudmFsaWRpdHkgJiYgZnJvbUVsLnZhbGlkaXR5LmJhZElucHV0KSl7IHJldHVybiBmYWxzZSB9XG4gICAgICAgICAgaWYoIURPTS5zeW5jUGVuZGluZ1JlZihmcm9tRWwsIHRvRWwsIGRpc2FibGVXaXRoKSl7XG4gICAgICAgICAgICBpZihET00uaXNVcGxvYWRJbnB1dChmcm9tRWwpKXtcbiAgICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgICB1cGRhdGVzLnB1c2goZnJvbUVsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBuZXN0ZWQgdmlldyBoYW5kbGluZ1xuICAgICAgICAgIGlmKERPTS5pc1BoeENoaWxkKHRvRWwpKXtcbiAgICAgICAgICAgIGxldCBwcmV2U2Vzc2lvbiA9IGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pXG4gICAgICAgICAgICBET00ubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHtleGNsdWRlOiBbUEhYX1NUQVRJQ119KVxuICAgICAgICAgICAgaWYocHJldlNlc3Npb24gIT09IFwiXCIpeyBmcm9tRWwuc2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OLCBwcmV2U2Vzc2lvbikgfVxuICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCwgdGhpcy5yb290SUQpXG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlucHV0IGhhbmRsaW5nXG4gICAgICAgICAgRE9NLmNvcHlQcml2YXRlcyh0b0VsLCBmcm9tRWwpXG4gICAgICAgICAgRE9NLmRpc2NhcmRFcnJvcih0YXJnZXRDb250YWluZXIsIHRvRWwsIHBoeEZlZWRiYWNrRm9yKVxuXG4gICAgICAgICAgbGV0IGlzRm9jdXNlZEZvcm1FbCA9IGZvY3VzZWQgJiYgZnJvbUVsLmlzU2FtZU5vZGUoZm9jdXNlZCkgJiYgRE9NLmlzRm9ybUlucHV0KGZyb21FbClcbiAgICAgICAgICBpZihpc0ZvY3VzZWRGb3JtRWwpe1xuICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgRE9NLm1lcmdlRm9jdXNlZElucHV0KGZyb21FbCwgdG9FbClcbiAgICAgICAgICAgIERPTS5zeW5jQXR0cnNUb1Byb3BzKGZyb21FbClcbiAgICAgICAgICAgIHVwZGF0ZXMucHVzaChmcm9tRWwpXG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZihET00uaXNQaHhVcGRhdGUodG9FbCwgcGh4VXBkYXRlLCBbXCJhcHBlbmRcIiwgXCJwcmVwZW5kXCJdKSl7XG4gICAgICAgICAgICAgIGFwcGVuZFByZXBlbmRVcGRhdGVzLnB1c2gobmV3IERPTVBvc3RNb3JwaFJlc3RvcmVyKGZyb21FbCwgdG9FbCwgdG9FbC5nZXRBdHRyaWJ1dGUocGh4VXBkYXRlKSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBET00uc3luY0F0dHJzVG9Qcm9wcyh0b0VsKVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyh0b0VsKVxuICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGlmKGxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSl7IGRldGVjdER1cGxpY2F0ZUlkcygpIH1cblxuICAgIGlmKGFwcGVuZFByZXBlbmRVcGRhdGVzLmxlbmd0aCA+IDApe1xuICAgICAgbGl2ZVNvY2tldC50aW1lKFwicG9zdC1tb3JwaCBhcHBlbmQvcHJlcGVuZCByZXN0b3JhdGlvblwiLCAoKSA9PiB7XG4gICAgICAgIGFwcGVuZFByZXBlbmRVcGRhdGVzLmZvckVhY2godXBkYXRlID0+IHVwZGF0ZS5wZXJmb3JtKCkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGxpdmVTb2NrZXQuc2lsZW5jZUV2ZW50cygoKSA9PiBET00ucmVzdG9yZUZvY3VzKGZvY3VzZWQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpKVxuICAgIERPTS5kaXNwYXRjaEV2ZW50KGRvY3VtZW50LCBcInBoeDp1cGRhdGVcIilcbiAgICBhZGRlZC5mb3JFYWNoKGVsID0+IHRoaXMudHJhY2tBZnRlcihcImFkZGVkXCIsIGVsKSlcbiAgICB1cGRhdGVzLmZvckVhY2goZWwgPT4gdGhpcy50cmFja0FmdGVyKFwidXBkYXRlZFwiLCBlbCkpXG5cbiAgICBpZihwZW5kaW5nUmVtb3Zlcy5sZW5ndGggPiAwKXtcbiAgICAgIGxpdmVTb2NrZXQudHJhbnNpdGlvblJlbW92ZXMocGVuZGluZ1JlbW92ZXMpXG4gICAgICBsaXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBwZW5kaW5nUmVtb3Zlcy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBsZXQgY2hpbGQgPSBET00uZmlyc3RQaHhDaGlsZChlbClcbiAgICAgICAgICBpZihjaGlsZCl7IGxpdmVTb2NrZXQuZGVzdHJveVZpZXdCeUVsKGNoaWxkKSB9XG4gICAgICAgICAgZWwucmVtb3ZlKClcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy50cmFja0FmdGVyKFwidHJhbnNpdGlvbnNEaXNjYXJkZWRcIiwgcGVuZGluZ1JlbW92ZXMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmKGV4dGVybmFsRm9ybVRyaWdnZXJlZCl7XG4gICAgICBsaXZlU29ja2V0LmRpc2Nvbm5lY3QoKVxuICAgICAgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkLnN1Ym1pdCgpXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpc0NJRFBhdGNoKCl7IHJldHVybiB0aGlzLmNpZFBhdGNoIH1cblxuICBza2lwQ0lEU2libGluZyhlbCl7XG4gICAgcmV0dXJuIGVsLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1NLSVApICE9PSBudWxsXG4gIH1cblxuICB0YXJnZXRDSURDb250YWluZXIoaHRtbCl7XG4gICAgaWYoIXRoaXMuaXNDSURQYXRjaCgpKXsgcmV0dXJuIH1cbiAgICBsZXQgW2ZpcnN0LCAuLi5yZXN0XSA9IERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5jb250YWluZXIsIHRoaXMudGFyZ2V0Q0lEKVxuICAgIGlmKHJlc3QubGVuZ3RoID09PSAwICYmIERPTS5jaGlsZE5vZGVMZW5ndGgoaHRtbCkgPT09IDEpe1xuICAgICAgcmV0dXJuIGZpcnN0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC5wYXJlbnROb2RlXG4gICAgfVxuICB9XG5cbiAgLy8gYnVpbGRzIEhUTUwgZm9yIG1vcnBoZG9tIHBhdGNoXG4gIC8vIC0gZm9yIGZ1bGwgcGF0Y2hlcyBvZiBMaXZlVmlldyBvciBhIGNvbXBvbmVudCB3aXRoIGEgc2luZ2xlXG4gIC8vICAgcm9vdCBub2RlLCBzaW1wbHkgcmV0dXJucyB0aGUgSFRNTFxuICAvLyAtIGZvciBwYXRjaGVzIG9mIGEgY29tcG9uZW50IHdpdGggbXVsdGlwbGUgcm9vdCBub2RlcywgdGhlXG4gIC8vICAgcGFyZW50IG5vZGUgYmVjb21lcyB0aGUgdGFyZ2V0IGNvbnRhaW5lciBhbmQgbm9uLWNvbXBvbmVudFxuICAvLyAgIHNpYmxpbmdzIGFyZSBtYXJrZWQgYXMgc2tpcC5cbiAgYnVpbGREaWZmSFRNTChjb250YWluZXIsIGh0bWwsIHBoeFVwZGF0ZSwgdGFyZ2V0Q29udGFpbmVyKXtcbiAgICBsZXQgaXNDSURQYXRjaCA9IHRoaXMuaXNDSURQYXRjaCgpXG4gICAgbGV0IGlzQ0lEV2l0aFNpbmdsZVJvb3QgPSBpc0NJRFBhdGNoICYmIHRhcmdldENvbnRhaW5lci5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkgPT09IHRoaXMudGFyZ2V0Q0lELnRvU3RyaW5nKClcbiAgICBpZighaXNDSURQYXRjaCB8fCBpc0NJRFdpdGhTaW5nbGVSb290KXtcbiAgICAgIHJldHVybiBodG1sXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBvbmVudCBwYXRjaCB3aXRoIG11bHRpcGxlIENJRCByb290c1xuICAgICAgbGV0IGRpZmZDb250YWluZXIgPSBudWxsXG4gICAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIilcbiAgICAgIGRpZmZDb250YWluZXIgPSBET00uY2xvbmVOb2RlKHRhcmdldENvbnRhaW5lcilcbiAgICAgIGxldCBbZmlyc3RDb21wb25lbnQsIC4uLnJlc3RdID0gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdChkaWZmQ29udGFpbmVyLCB0aGlzLnRhcmdldENJRClcbiAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWxcbiAgICAgIHJlc3QuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSlcbiAgICAgIEFycmF5LmZyb20oZGlmZkNvbnRhaW5lci5jaGlsZE5vZGVzKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgLy8gd2UgY2FuIG9ubHkgc2tpcCB0cmFja2FibGUgbm9kZXMgd2l0aCBhbiBJRFxuICAgICAgICBpZihjaGlsZC5pZCAmJiBjaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgY2hpbGQuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpICE9PSB0aGlzLnRhcmdldENJRC50b1N0cmluZygpKXtcbiAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoUEhYX1NLSVAsIFwiXCIpXG4gICAgICAgICAgY2hpbGQuaW5uZXJIVE1MID0gXCJcIlxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgQXJyYXkuZnJvbSh0ZW1wbGF0ZS5jb250ZW50LmNoaWxkTm9kZXMpLmZvckVhY2goZWwgPT4gZGlmZkNvbnRhaW5lci5pbnNlcnRCZWZvcmUoZWwsIGZpcnN0Q29tcG9uZW50KSlcbiAgICAgIGZpcnN0Q29tcG9uZW50LnJlbW92ZSgpXG4gICAgICByZXR1cm4gZGlmZkNvbnRhaW5lci5vdXRlckhUTUxcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBDT01QT05FTlRTLFxuICBEWU5BTUlDUyxcbiAgVEVNUExBVEVTLFxuICBFVkVOVFMsXG4gIFBIWF9DT01QT05FTlQsXG4gIFBIWF9TS0lQLFxuICBSRVBMWSxcbiAgU1RBVElDLFxuICBUSVRMRVxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBpc09iamVjdCxcbiAgbG9nRXJyb3IsXG4gIGlzQ2lkLFxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmVkIHtcbiAgc3RhdGljIGV4dHJhY3QoZGlmZil7XG4gICAgbGV0IHtbUkVQTFldOiByZXBseSwgW0VWRU5UU106IGV2ZW50cywgW1RJVExFXTogdGl0bGV9ID0gZGlmZlxuICAgIGRlbGV0ZSBkaWZmW1JFUExZXVxuICAgIGRlbGV0ZSBkaWZmW0VWRU5UU11cbiAgICBkZWxldGUgZGlmZltUSVRMRV1cbiAgICByZXR1cm4ge2RpZmYsIHRpdGxlLCByZXBseTogcmVwbHkgfHwgbnVsbCwgZXZlbnRzOiBldmVudHMgfHwgW119XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih2aWV3SWQsIHJlbmRlcmVkKXtcbiAgICB0aGlzLnZpZXdJZCA9IHZpZXdJZFxuICAgIHRoaXMucmVuZGVyZWQgPSB7fVxuICAgIHRoaXMubWVyZ2VEaWZmKHJlbmRlcmVkKVxuICB9XG5cbiAgcGFyZW50Vmlld0lkKCl7IHJldHVybiB0aGlzLnZpZXdJZCB9XG5cbiAgdG9TdHJpbmcob25seUNpZHMpe1xuICAgIHJldHVybiB0aGlzLnJlY3Vyc2l2ZVRvU3RyaW5nKHRoaXMucmVuZGVyZWQsIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10sIG9ubHlDaWRzKVxuICB9XG5cbiAgcmVjdXJzaXZlVG9TdHJpbmcocmVuZGVyZWQsIGNvbXBvbmVudHMgPSByZW5kZXJlZFtDT01QT05FTlRTXSwgb25seUNpZHMpe1xuICAgIG9ubHlDaWRzID0gb25seUNpZHMgPyBuZXcgU2V0KG9ubHlDaWRzKSA6IG51bGxcbiAgICBsZXQgb3V0cHV0ID0ge2J1ZmZlcjogXCJcIiwgY29tcG9uZW50czogY29tcG9uZW50cywgb25seUNpZHM6IG9ubHlDaWRzfVxuICAgIHRoaXMudG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIG51bGwsIG91dHB1dClcbiAgICByZXR1cm4gb3V0cHV0LmJ1ZmZlclxuICB9XG5cbiAgY29tcG9uZW50Q0lEcyhkaWZmKXsgcmV0dXJuIE9iamVjdC5rZXlzKGRpZmZbQ09NUE9ORU5UU10gfHwge30pLm1hcChpID0+IHBhcnNlSW50KGkpKSB9XG5cbiAgaXNDb21wb25lbnRPbmx5RGlmZihkaWZmKXtcbiAgICBpZighZGlmZltDT01QT05FTlRTXSl7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGRpZmYpLmxlbmd0aCA9PT0gMVxuICB9XG5cbiAgZ2V0Q29tcG9uZW50KGRpZmYsIGNpZCl7IHJldHVybiBkaWZmW0NPTVBPTkVOVFNdW2NpZF0gfVxuXG4gIG1lcmdlRGlmZihkaWZmKXtcbiAgICBsZXQgbmV3YyA9IGRpZmZbQ09NUE9ORU5UU11cbiAgICBsZXQgY2FjaGUgPSB7fVxuICAgIGRlbGV0ZSBkaWZmW0NPTVBPTkVOVFNdXG4gICAgdGhpcy5yZW5kZXJlZCA9IHRoaXMubXV0YWJsZU1lcmdlKHRoaXMucmVuZGVyZWQsIGRpZmYpXG4gICAgdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSA9IHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10gfHwge31cblxuICAgIGlmKG5ld2Mpe1xuICAgICAgbGV0IG9sZGMgPSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdXG5cbiAgICAgIGZvcihsZXQgY2lkIGluIG5ld2Mpe1xuICAgICAgICBuZXdjW2NpZF0gPSB0aGlzLmNhY2hlZEZpbmRDb21wb25lbnQoY2lkLCBuZXdjW2NpZF0sIG9sZGMsIG5ld2MsIGNhY2hlKVxuICAgICAgfVxuXG4gICAgICBmb3IobGV0IGNpZCBpbiBuZXdjKXsgb2xkY1tjaWRdID0gbmV3Y1tjaWRdIH1cbiAgICAgIGRpZmZbQ09NUE9ORU5UU10gPSBuZXdjXG4gICAgfVxuICB9XG5cbiAgY2FjaGVkRmluZENvbXBvbmVudChjaWQsIGNkaWZmLCBvbGRjLCBuZXdjLCBjYWNoZSl7XG4gICAgaWYoY2FjaGVbY2lkXSl7XG4gICAgICByZXR1cm4gY2FjaGVbY2lkXVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmRpZmYsIHN0YXQsIHNjaWQgPSBjZGlmZltTVEFUSUNdXG5cbiAgICAgIGlmKGlzQ2lkKHNjaWQpKXtcbiAgICAgICAgbGV0IHRkaWZmXG5cbiAgICAgICAgaWYoc2NpZCA+IDApe1xuICAgICAgICAgIHRkaWZmID0gdGhpcy5jYWNoZWRGaW5kQ29tcG9uZW50KHNjaWQsIG5ld2Nbc2NpZF0sIG9sZGMsIG5ld2MsIGNhY2hlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRkaWZmID0gb2xkY1stc2NpZF1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXQgPSB0ZGlmZltTVEFUSUNdXG4gICAgICAgIG5kaWZmID0gdGhpcy5jbG9uZU1lcmdlKHRkaWZmLCBjZGlmZilcbiAgICAgICAgbmRpZmZbU1RBVElDXSA9IHN0YXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5kaWZmID0gY2RpZmZbU1RBVElDXSAhPT0gdW5kZWZpbmVkID8gY2RpZmYgOiB0aGlzLmNsb25lTWVyZ2Uob2xkY1tjaWRdIHx8IHt9LCBjZGlmZilcbiAgICAgIH1cblxuICAgICAgY2FjaGVbY2lkXSA9IG5kaWZmXG4gICAgICByZXR1cm4gbmRpZmZcbiAgICB9XG4gIH1cblxuICBtdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2Upe1xuICAgIGlmKHNvdXJjZVtTVEFUSUNdICE9PSB1bmRlZmluZWQpe1xuICAgICAgcmV0dXJuIHNvdXJjZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvTXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKVxuICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH1cbiAgfVxuXG4gIGRvTXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKXtcbiAgICBmb3IobGV0IGtleSBpbiBzb3VyY2Upe1xuICAgICAgbGV0IHZhbCA9IHNvdXJjZVtrZXldXG4gICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV1cbiAgICAgIGlmKGlzT2JqZWN0KHZhbCkgJiYgdmFsW1NUQVRJQ10gPT09IHVuZGVmaW5lZCAmJiBpc09iamVjdCh0YXJnZXRWYWwpKXtcbiAgICAgICAgdGhpcy5kb011dGFibGVNZXJnZSh0YXJnZXRWYWwsIHZhbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xvbmVNZXJnZSh0YXJnZXQsIHNvdXJjZSl7XG4gICAgbGV0IG1lcmdlZCA9IHsuLi50YXJnZXQsIC4uLnNvdXJjZX1cbiAgICBmb3IobGV0IGtleSBpbiBtZXJnZWQpe1xuICAgICAgbGV0IHZhbCA9IHNvdXJjZVtrZXldXG4gICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV1cbiAgICAgIGlmKGlzT2JqZWN0KHZhbCkgJiYgdmFsW1NUQVRJQ10gPT09IHVuZGVmaW5lZCAmJiBpc09iamVjdCh0YXJnZXRWYWwpKXtcbiAgICAgICAgbWVyZ2VkW2tleV0gPSB0aGlzLmNsb25lTWVyZ2UodGFyZ2V0VmFsLCB2YWwpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRcbiAgfVxuXG4gIGNvbXBvbmVudFRvU3RyaW5nKGNpZCl7IHJldHVybiB0aGlzLnJlY3Vyc2l2ZUNJRFRvU3RyaW5nKHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10sIGNpZCkgfVxuXG4gIHBydW5lQ0lEcyhjaWRzKXtcbiAgICBjaWRzLmZvckVhY2goY2lkID0+IGRlbGV0ZSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdW2NpZF0pXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgZ2V0KCl7IHJldHVybiB0aGlzLnJlbmRlcmVkIH1cblxuICBpc05ld0ZpbmdlcnByaW50KGRpZmYgPSB7fSl7IHJldHVybiAhIWRpZmZbU1RBVElDXSB9XG5cbiAgdGVtcGxhdGVTdGF0aWMocGFydCwgdGVtcGxhdGVzKXtcbiAgICBpZih0eXBlb2YgKHBhcnQpID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdGVtcGxhdGVzW3BhcnRdXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJ0XG4gICAgfVxuICB9XG5cbiAgdG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KXtcbiAgICBpZihyZW5kZXJlZFtEWU5BTUlDU10peyByZXR1cm4gdGhpcy5jb21wcmVoZW5zaW9uVG9CdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KSB9XG4gICAgbGV0IHtbU1RBVElDXTogc3RhdGljc30gPSByZW5kZXJlZFxuICAgIHN0YXRpY3MgPSB0aGlzLnRlbXBsYXRlU3RhdGljKHN0YXRpY3MsIHRlbXBsYXRlcylcblxuICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1swXVxuICAgIGZvcihsZXQgaSA9IDE7IGkgPCBzdGF0aWNzLmxlbmd0aDsgaSsrKXtcbiAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKHJlbmRlcmVkW2kgLSAxXSwgdGVtcGxhdGVzLCBvdXRwdXQpXG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbaV1cbiAgICB9XG4gIH1cblxuICBjb21wcmVoZW5zaW9uVG9CdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KXtcbiAgICBsZXQge1tEWU5BTUlDU106IGR5bmFtaWNzLCBbU1RBVElDXTogc3RhdGljc30gPSByZW5kZXJlZFxuICAgIHN0YXRpY3MgPSB0aGlzLnRlbXBsYXRlU3RhdGljKHN0YXRpY3MsIHRlbXBsYXRlcylcbiAgICBsZXQgY29tcFRlbXBsYXRlcyA9IHRlbXBsYXRlcyB8fCByZW5kZXJlZFtURU1QTEFURVNdXG5cbiAgICBmb3IobGV0IGQgPSAwOyBkIDwgZHluYW1pY3MubGVuZ3RoOyBkKyspe1xuICAgICAgbGV0IGR5bmFtaWMgPSBkeW5hbWljc1tkXVxuICAgICAgb3V0cHV0LmJ1ZmZlciArPSBzdGF0aWNzWzBdXG4gICAgICBmb3IobGV0IGkgPSAxOyBpIDwgc3RhdGljcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKGR5bmFtaWNbaSAtIDFdLCBjb21wVGVtcGxhdGVzLCBvdXRwdXQpXG4gICAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1tpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGR5bmFtaWNUb0J1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpe1xuICAgIGlmKHR5cGVvZiAocmVuZGVyZWQpID09PSBcIm51bWJlclwiKXtcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyhvdXRwdXQuY29tcG9uZW50cywgcmVuZGVyZWQsIG91dHB1dC5vbmx5Q2lkcylcbiAgICB9IGVsc2UgaWYoaXNPYmplY3QocmVuZGVyZWQpKXtcbiAgICAgIHRoaXMudG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHJlbmRlcmVkXG4gICAgfVxuICB9XG5cbiAgcmVjdXJzaXZlQ0lEVG9TdHJpbmcoY29tcG9uZW50cywgY2lkLCBvbmx5Q2lkcyl7XG4gICAgbGV0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY2lkXSB8fCBsb2dFcnJvcihgbm8gY29tcG9uZW50IGZvciBDSUQgJHtjaWR9YCwgY29tcG9uZW50cylcbiAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIilcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0aGlzLnJlY3Vyc2l2ZVRvU3RyaW5nKGNvbXBvbmVudCwgY29tcG9uZW50cywgb25seUNpZHMpXG4gICAgbGV0IGNvbnRhaW5lciA9IHRlbXBsYXRlLmNvbnRlbnRcbiAgICBsZXQgc2tpcCA9IG9ubHlDaWRzICYmICFvbmx5Q2lkcy5oYXMoY2lkKVxuXG4gICAgbGV0IFtoYXNDaGlsZE5vZGVzLCBoYXNDaGlsZENvbXBvbmVudHNdID1cbiAgICAgIEFycmF5LmZyb20oY29udGFpbmVyLmNoaWxkTm9kZXMpLnJlZHVjZSgoW2hhc05vZGVzLCBoYXNDb21wb25lbnRzXSwgY2hpbGQsIGkpID0+IHtcbiAgICAgICAgaWYoY2hpbGQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKXtcbiAgICAgICAgICBpZihjaGlsZC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkpe1xuICAgICAgICAgICAgcmV0dXJuIFtoYXNOb2RlcywgdHJ1ZV1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQsIGNpZClcbiAgICAgICAgICBpZighY2hpbGQuaWQpeyBjaGlsZC5pZCA9IGAke3RoaXMucGFyZW50Vmlld0lkKCl9LSR7Y2lkfS0ke2l9YCB9XG4gICAgICAgICAgaWYoc2tpcCl7XG4gICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoUEhYX1NLSVAsIFwiXCIpXG4gICAgICAgICAgICBjaGlsZC5pbm5lckhUTUwgPSBcIlwiXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbdHJ1ZSwgaGFzQ29tcG9uZW50c11cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZihjaGlsZC5ub2RlVmFsdWUudHJpbSgpICE9PSBcIlwiKXtcbiAgICAgICAgICAgIGxvZ0Vycm9yKFwib25seSBIVE1MIGVsZW1lbnQgdGFncyBhcmUgYWxsb3dlZCBhdCB0aGUgcm9vdCBvZiBjb21wb25lbnRzLlxcblxcblwiICtcbiAgICAgICAgICAgICAgYGdvdDogXCIke2NoaWxkLm5vZGVWYWx1ZS50cmltKCl9XCJcXG5cXG5gICtcbiAgICAgICAgICAgICAgXCJ3aXRoaW46XFxuXCIsIHRlbXBsYXRlLmlubmVySFRNTC50cmltKCkpXG4gICAgICAgICAgICBjaGlsZC5yZXBsYWNlV2l0aCh0aGlzLmNyZWF0ZVNwYW4oY2hpbGQubm9kZVZhbHVlLCBjaWQpKVxuICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCBoYXNDb21wb25lbnRzXVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZC5yZW1vdmUoKVxuICAgICAgICAgICAgcmV0dXJuIFtoYXNOb2RlcywgaGFzQ29tcG9uZW50c11cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIFtmYWxzZSwgZmFsc2VdKVxuXG4gICAgaWYoIWhhc0NoaWxkTm9kZXMgJiYgIWhhc0NoaWxkQ29tcG9uZW50cyl7XG4gICAgICBsb2dFcnJvcihcImV4cGVjdGVkIGF0IGxlYXN0IG9uZSBIVE1MIGVsZW1lbnQgdGFnIGluc2lkZSBhIGNvbXBvbmVudCwgYnV0IHRoZSBjb21wb25lbnQgaXMgZW1wdHk6XFxuXCIsXG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTC50cmltKCkpXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVTcGFuKFwiXCIsIGNpZCkub3V0ZXJIVE1MXG4gICAgfSBlbHNlIGlmKCFoYXNDaGlsZE5vZGVzICYmIGhhc0NoaWxkQ29tcG9uZW50cyl7XG4gICAgICBsb2dFcnJvcihcImV4cGVjdGVkIGF0IGxlYXN0IG9uZSBIVE1MIGVsZW1lbnQgdGFnIGRpcmVjdGx5IGluc2lkZSBhIGNvbXBvbmVudCwgYnV0IG9ubHkgc3ViY29tcG9uZW50cyB3ZXJlIGZvdW5kLiBBIGNvbXBvbmVudCBtdXN0IHJlbmRlciBhdCBsZWFzdCBvbmUgSFRNTCB0YWcgZGlyZWN0bHkgaW5zaWRlIGl0c2VsZi5cIixcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MLnRyaW0oKSlcbiAgICAgIHJldHVybiB0ZW1wbGF0ZS5pbm5lckhUTUxcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRlbXBsYXRlLmlubmVySFRNTFxuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZVNwYW4odGV4dCwgY2lkKXtcbiAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgc3Bhbi5pbm5lclRleHQgPSB0ZXh0XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCwgY2lkKVxuICAgIHJldHVybiBzcGFuXG4gIH1cbn1cbiIsICJsZXQgdmlld0hvb2tJRCA9IDFcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdIb29rIHtcbiAgc3RhdGljIG1ha2VJRCgpeyByZXR1cm4gdmlld0hvb2tJRCsrIH1cbiAgc3RhdGljIGVsZW1lbnRJRChlbCl7IHJldHVybiBlbC5waHhIb29rSWQgfVxuXG4gIGNvbnN0cnVjdG9yKHZpZXcsIGVsLCBjYWxsYmFja3Mpe1xuICAgIHRoaXMuX192aWV3ID0gdmlld1xuICAgIHRoaXMubGl2ZVNvY2tldCA9IHZpZXcubGl2ZVNvY2tldFxuICAgIHRoaXMuX19jYWxsYmFja3MgPSBjYWxsYmFja3NcbiAgICB0aGlzLl9fbGlzdGVuZXJzID0gbmV3IFNldCgpXG4gICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gZmFsc2VcbiAgICB0aGlzLmVsID0gZWxcbiAgICB0aGlzLmVsLnBoeEhvb2tJZCA9IHRoaXMuY29uc3RydWN0b3IubWFrZUlEKClcbiAgICBmb3IobGV0IGtleSBpbiB0aGlzLl9fY2FsbGJhY2tzKXsgdGhpc1trZXldID0gdGhpcy5fX2NhbGxiYWNrc1trZXldIH1cbiAgfVxuXG4gIF9fbW91bnRlZCgpeyB0aGlzLm1vdW50ZWQgJiYgdGhpcy5tb3VudGVkKCkgfVxuICBfX3VwZGF0ZWQoKXsgdGhpcy51cGRhdGVkICYmIHRoaXMudXBkYXRlZCgpIH1cbiAgX19iZWZvcmVVcGRhdGUoKXsgdGhpcy5iZWZvcmVVcGRhdGUgJiYgdGhpcy5iZWZvcmVVcGRhdGUoKSB9XG4gIF9fZGVzdHJveWVkKCl7IHRoaXMuZGVzdHJveWVkICYmIHRoaXMuZGVzdHJveWVkKCkgfVxuICBfX3JlY29ubmVjdGVkKCl7XG4gICAgaWYodGhpcy5fX2lzRGlzY29ubmVjdGVkKXtcbiAgICAgIHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgICB0aGlzLnJlY29ubmVjdGVkICYmIHRoaXMucmVjb25uZWN0ZWQoKVxuICAgIH1cbiAgfVxuICBfX2Rpc2Nvbm5lY3RlZCgpe1xuICAgIHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCA9IHRydWVcbiAgICB0aGlzLmRpc2Nvbm5lY3RlZCAmJiB0aGlzLmRpc2Nvbm5lY3RlZCgpXG4gIH1cblxuICBwdXNoRXZlbnQoZXZlbnQsIHBheWxvYWQgPSB7fSwgb25SZXBseSA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcucHVzaEhvb2tFdmVudChudWxsLCBldmVudCwgcGF5bG9hZCwgb25SZXBseSlcbiAgfVxuXG4gIHB1c2hFdmVudFRvKHBoeFRhcmdldCwgZXZlbnQsIHBheWxvYWQgPSB7fSwgb25SZXBseSA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcud2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsICh2aWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIHJldHVybiB2aWV3LnB1c2hIb29rRXZlbnQodGFyZ2V0Q3R4LCBldmVudCwgcGF5bG9hZCwgb25SZXBseSlcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlRXZlbnQoZXZlbnQsIGNhbGxiYWNrKXtcbiAgICBsZXQgY2FsbGJhY2tSZWYgPSAoY3VzdG9tRXZlbnQsIGJ5cGFzcykgPT4gYnlwYXNzID8gZXZlbnQgOiBjYWxsYmFjayhjdXN0b21FdmVudC5kZXRhaWwpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoYHBoeDoke2V2ZW50fWAsIGNhbGxiYWNrUmVmKVxuICAgIHRoaXMuX19saXN0ZW5lcnMuYWRkKGNhbGxiYWNrUmVmKVxuICAgIHJldHVybiBjYWxsYmFja1JlZlxuICB9XG5cbiAgcmVtb3ZlSGFuZGxlRXZlbnQoY2FsbGJhY2tSZWYpe1xuICAgIGxldCBldmVudCA9IGNhbGxiYWNrUmVmKG51bGwsIHRydWUpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoYHBoeDoke2V2ZW50fWAsIGNhbGxiYWNrUmVmKVxuICAgIHRoaXMuX19saXN0ZW5lcnMuZGVsZXRlKGNhbGxiYWNrUmVmKVxuICB9XG5cbiAgdXBsb2FkKG5hbWUsIGZpbGVzKXtcbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcuZGlzcGF0Y2hVcGxvYWRzKG5hbWUsIGZpbGVzKVxuICB9XG5cbiAgdXBsb2FkVG8ocGh4VGFyZ2V0LCBuYW1lLCBmaWxlcyl7XG4gICAgcmV0dXJuIHRoaXMuX192aWV3LndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCB2aWV3ID0+IHZpZXcuZGlzcGF0Y2hVcGxvYWRzKG5hbWUsIGZpbGVzKSlcbiAgfVxuXG4gIF9fY2xlYW51cF9fKCl7XG4gICAgdGhpcy5fX2xpc3RlbmVycy5mb3JFYWNoKGNhbGxiYWNrUmVmID0+IHRoaXMucmVtb3ZlSGFuZGxlRXZlbnQoY2FsbGJhY2tSZWYpKVxuICB9XG59XG4iLCAiaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuXG5sZXQgSlMgPSB7XG4gIGV4ZWMoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGRlZmF1bHRzKXtcbiAgICBsZXQgW2RlZmF1bHRLaW5kLCBkZWZhdWx0QXJnc10gPSBkZWZhdWx0cyB8fCBbbnVsbCwge31dXG4gICAgbGV0IGNvbW1hbmRzID0gcGh4RXZlbnQuY2hhckF0KDApID09PSBcIltcIiA/XG4gICAgICBKU09OLnBhcnNlKHBoeEV2ZW50KSA6IFtbZGVmYXVsdEtpbmQsIGRlZmF1bHRBcmdzXV1cblxuICAgIGNvbW1hbmRzLmZvckVhY2goKFtraW5kLCBhcmdzXSkgPT4ge1xuICAgICAgaWYoa2luZCA9PT0gZGVmYXVsdEtpbmQgJiYgZGVmYXVsdEFyZ3MuZGF0YSl7XG4gICAgICAgIGFyZ3MuZGF0YSA9IE9iamVjdC5hc3NpZ24oYXJncy5kYXRhIHx8IHt9LCBkZWZhdWx0QXJncy5kYXRhKVxuICAgICAgfVxuICAgICAgdGhpcy5maWx0ZXJUb0Vscyhzb3VyY2VFbCwgYXJncykuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIHRoaXNbYGV4ZWNfJHtraW5kfWBdKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgYXJncylcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcblxuICBpc1Zpc2libGUoZWwpe1xuICAgIHJldHVybiAhIShlbC5vZmZzZXRXaWR0aCB8fCBlbC5vZmZzZXRIZWlnaHQgfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPiAwKVxuICB9LFxuXG4gIC8vIHByaXZhdGVcblxuICAvLyBjb21tYW5kc1xuXG4gIGV4ZWNfZGlzcGF0Y2goZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7dG8sIGV2ZW50LCBkZXRhaWwsIGJ1YmJsZXN9KXtcbiAgICBkZXRhaWwgPSBkZXRhaWwgfHwge31cbiAgICBkZXRhaWwuZGlzcGF0Y2hlciA9IHNvdXJjZUVsXG4gICAgRE9NLmRpc3BhdGNoRXZlbnQoZWwsIGV2ZW50LCB7ZGV0YWlsLCBidWJibGVzfSlcbiAgfSxcblxuICBleGVjX3B1c2goZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCBhcmdzKXtcbiAgICBpZighdmlldy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIH1cblxuICAgIGxldCB7ZXZlbnQsIGRhdGEsIHRhcmdldCwgcGFnZV9sb2FkaW5nLCBsb2FkaW5nLCB2YWx1ZSwgZGlzcGF0Y2hlcn0gPSBhcmdzXG4gICAgbGV0IHB1c2hPcHRzID0ge2xvYWRpbmcsIHZhbHVlLCB0YXJnZXQsIHBhZ2VfbG9hZGluZzogISFwYWdlX2xvYWRpbmd9XG4gICAgbGV0IHRhcmdldFNyYyA9IGV2ZW50VHlwZSA9PT0gXCJjaGFuZ2VcIiAmJiBkaXNwYXRjaGVyID8gZGlzcGF0Y2hlciA6IHNvdXJjZUVsXG4gICAgbGV0IHBoeFRhcmdldCA9IHRhcmdldCB8fCB0YXJnZXRTcmMuZ2V0QXR0cmlidXRlKHZpZXcuYmluZGluZyhcInRhcmdldFwiKSkgfHwgdGFyZ2V0U3JjXG4gICAgdmlldy53aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgKHRhcmdldFZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgaWYoZXZlbnRUeXBlID09PSBcImNoYW5nZVwiKXtcbiAgICAgICAgbGV0IHtuZXdDaWQsIF90YXJnZXQsIGNhbGxiYWNrfSA9IGFyZ3NcbiAgICAgICAgX3RhcmdldCA9IF90YXJnZXQgfHwgKHNvdXJjZUVsIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCA/IHNvdXJjZUVsLm5hbWUgOiB1bmRlZmluZWQpXG4gICAgICAgIGlmKF90YXJnZXQpeyBwdXNoT3B0cy5fdGFyZ2V0ID0gX3RhcmdldCB9XG4gICAgICAgIHRhcmdldFZpZXcucHVzaElucHV0KHNvdXJjZUVsLCB0YXJnZXRDdHgsIG5ld0NpZCwgZXZlbnQgfHwgcGh4RXZlbnQsIHB1c2hPcHRzLCBjYWxsYmFjaylcbiAgICAgIH0gZWxzZSBpZihldmVudFR5cGUgPT09IFwic3VibWl0XCIpe1xuICAgICAgICB0YXJnZXRWaWV3LnN1Ym1pdEZvcm0oc291cmNlRWwsIHRhcmdldEN0eCwgZXZlbnQgfHwgcGh4RXZlbnQsIHB1c2hPcHRzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Vmlldy5wdXNoRXZlbnQoZXZlbnRUeXBlLCBzb3VyY2VFbCwgdGFyZ2V0Q3R4LCBldmVudCB8fCBwaHhFdmVudCwgZGF0YSwgcHVzaE9wdHMpXG4gICAgICB9XG4gICAgfSlcbiAgfSxcblxuICBleGVjX2FkZF9jbGFzcyhldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtuYW1lcywgdHJhbnNpdGlvbiwgdGltZX0pe1xuICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBuYW1lcywgW10sIHRyYW5zaXRpb24sIHRpbWUsIHZpZXcpXG4gIH0sXG5cbiAgZXhlY19yZW1vdmVfY2xhc3MoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7bmFtZXMsIHRyYW5zaXRpb24sIHRpbWV9KXtcbiAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIG5hbWVzLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3KVxuICB9LFxuXG4gIGV4ZWNfdHJhbnNpdGlvbihldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHt0aW1lLCB0cmFuc2l0aW9ufSl7XG4gICAgbGV0IFt0cmFuc2l0aW9uX3N0YXJ0LCBydW5uaW5nLCB0cmFuc2l0aW9uX2VuZF0gPSB0cmFuc2l0aW9uXG4gICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgdHJhbnNpdGlvbl9zdGFydC5jb25jYXQocnVubmluZyksIFtdKVxuICAgIGxldCBvbkRvbmUgPSAoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgdHJhbnNpdGlvbl9lbmQsIHRyYW5zaXRpb25fc3RhcnQuY29uY2F0KHJ1bm5pbmcpKVxuICAgIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpXG4gIH0sXG5cbiAgZXhlY190b2dnbGUoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7ZGlzcGxheSwgaW5zLCBvdXRzLCB0aW1lfSl7XG4gICAgdGhpcy50b2dnbGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgaW5zLCBvdXRzLCB0aW1lKVxuICB9LFxuXG4gIGV4ZWNfc2hvdyhldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lfSl7XG4gICAgdGhpcy5zaG93KGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUpXG4gIH0sXG5cbiAgZXhlY19oaWRlKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2Rpc3BsYXksIHRyYW5zaXRpb24sIHRpbWV9KXtcbiAgICB0aGlzLmhpZGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSlcbiAgfSxcblxuICBleGVjX3NldF9hdHRyKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2F0dHI6IFthdHRyLCB2YWxdfSl7XG4gICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbF1dLCBbXSlcbiAgfSxcblxuICBleGVjX3JlbW92ZV9hdHRyKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2F0dHJ9KXtcbiAgICB0aGlzLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtdLCBbYXR0cl0pXG4gIH0sXG5cbiAgLy8gdXRpbHMgZm9yIGNvbW1hbmRzXG5cbiAgc2hvdyhldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lKXtcbiAgICBpZighdGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgIHRoaXMudG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIG51bGwsIHRpbWUpXG4gICAgfVxuICB9LFxuXG4gIGhpZGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSl7XG4gICAgaWYodGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgIHRoaXMudG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIG51bGwsIHRyYW5zaXRpb24sIHRpbWUpXG4gICAgfVxuICB9LFxuXG4gIHRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCBpbnMsIG91dHMsIHRpbWUpe1xuICAgIGxldCBbaW5DbGFzc2VzLCBpblN0YXJ0Q2xhc3NlcywgaW5FbmRDbGFzc2VzXSA9IGlucyB8fCBbW10sIFtdLCBbXV1cbiAgICBsZXQgW291dENsYXNzZXMsIG91dFN0YXJ0Q2xhc3Nlcywgb3V0RW5kQ2xhc3Nlc10gPSBvdXRzIHx8IFtbXSwgW10sIFtdXVxuICAgIGlmKGluQ2xhc3Nlcy5sZW5ndGggPiAwIHx8IG91dENsYXNzZXMubGVuZ3RoID4gMCl7XG4gICAgICBpZih0aGlzLmlzVmlzaWJsZShlbCkpe1xuICAgICAgICBsZXQgb25TdGFydCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgb3V0U3RhcnRDbGFzc2VzLCBpbkNsYXNzZXMuY29uY2F0KGluU3RhcnRDbGFzc2VzKS5jb25jYXQoaW5FbmRDbGFzc2VzKSlcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBvdXRDbGFzc2VzLCBbXSlcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG91dEVuZENsYXNzZXMsIG91dFN0YXJ0Q2xhc3NlcykpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpoaWRlLXN0YXJ0XCIpKVxuICAgICAgICB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBbXSwgb3V0Q2xhc3Nlcy5jb25jYXQob3V0RW5kQ2xhc3NlcykpXG4gICAgICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgY3VycmVudEVsID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1lbmRcIikpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZihldmVudFR5cGUgPT09IFwicmVtb3ZlXCIpeyByZXR1cm4gfVxuICAgICAgICBsZXQgb25TdGFydCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgaW5TdGFydENsYXNzZXMsIG91dENsYXNzZXMuY29uY2F0KG91dFN0YXJ0Q2xhc3NlcykuY29uY2F0KG91dEVuZENsYXNzZXMpKVxuICAgICAgICAgIERPTS5wdXRTdGlja3koZWwsIFwidG9nZ2xlXCIsIGN1cnJlbnRFbCA9PiBjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IChkaXNwbGF5IHx8IFwiYmxvY2tcIikpXG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgaW5DbGFzc2VzLCBbXSlcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGluRW5kQ2xhc3NlcywgaW5TdGFydENsYXNzZXMpKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1zdGFydFwiKSlcbiAgICAgICAgdmlldy50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIGluQ2xhc3Nlcy5jb25jYXQoaW5FbmRDbGFzc2VzKSlcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LWVuZFwiKSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYodGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1zdGFydFwiKSlcbiAgICAgICAgICBET00ucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCBjdXJyZW50RWwgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIilcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpoaWRlLWVuZFwiKSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OnNob3ctc3RhcnRcIikpXG4gICAgICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgY3VycmVudEVsID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheSB8fCBcImJsb2NrXCIpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1lbmRcIikpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgYWRkcywgcmVtb3ZlcywgdHJhbnNpdGlvbiwgdGltZSwgdmlldyl7XG4gICAgbGV0IFt0cmFuc2l0aW9uX3J1biwgdHJhbnNpdGlvbl9zdGFydCwgdHJhbnNpdGlvbl9lbmRdID0gdHJhbnNpdGlvbiB8fCBbW10sIFtdLCBbXV1cbiAgICBpZih0cmFuc2l0aW9uX3J1bi5sZW5ndGggPiAwKXtcbiAgICAgIGxldCBvblN0YXJ0ID0gKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIHRyYW5zaXRpb25fc3RhcnQuY29uY2F0KHRyYW5zaXRpb25fcnVuKSwgW10pXG4gICAgICBsZXQgb25Eb25lID0gKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGFkZHMuY29uY2F0KHRyYW5zaXRpb25fZW5kKSwgcmVtb3Zlcy5jb25jYXQodHJhbnNpdGlvbl9ydW4pLmNvbmNhdCh0cmFuc2l0aW9uX3N0YXJ0KSlcbiAgICAgIHJldHVybiB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKVxuICAgIH1cbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGxldCBbcHJldkFkZHMsIHByZXZSZW1vdmVzXSA9IERPTS5nZXRTdGlja3koZWwsIFwiY2xhc3Nlc1wiLCBbW10sIFtdXSlcbiAgICAgIGxldCBrZWVwQWRkcyA9IGFkZHMuZmlsdGVyKG5hbWUgPT4gcHJldkFkZHMuaW5kZXhPZihuYW1lKSA8IDAgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSlcbiAgICAgIGxldCBrZWVwUmVtb3ZlcyA9IHJlbW92ZXMuZmlsdGVyKG5hbWUgPT4gcHJldlJlbW92ZXMuaW5kZXhPZihuYW1lKSA8IDAgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKVxuICAgICAgbGV0IG5ld0FkZHMgPSBwcmV2QWRkcy5maWx0ZXIobmFtZSA9PiByZW1vdmVzLmluZGV4T2YobmFtZSkgPCAwKS5jb25jYXQoa2VlcEFkZHMpXG4gICAgICBsZXQgbmV3UmVtb3ZlcyA9IHByZXZSZW1vdmVzLmZpbHRlcihuYW1lID0+IGFkZHMuaW5kZXhPZihuYW1lKSA8IDApLmNvbmNhdChrZWVwUmVtb3ZlcylcblxuICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJjbGFzc2VzXCIsIGN1cnJlbnRFbCA9PiB7XG4gICAgICAgIGN1cnJlbnRFbC5jbGFzc0xpc3QucmVtb3ZlKC4uLm5ld1JlbW92ZXMpXG4gICAgICAgIGN1cnJlbnRFbC5jbGFzc0xpc3QuYWRkKC4uLm5ld0FkZHMpXG4gICAgICAgIHJldHVybiBbbmV3QWRkcywgbmV3UmVtb3Zlc11cbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcblxuICBzZXRPclJlbW92ZUF0dHJzKGVsLCBzZXRzLCByZW1vdmVzKXtcbiAgICBsZXQgW3ByZXZTZXRzLCBwcmV2UmVtb3Zlc10gPSBET00uZ2V0U3RpY2t5KGVsLCBcImF0dHJzXCIsIFtbXSwgW11dKVxuXG4gICAgbGV0IGFsdGVyZWRBdHRycyA9IHNldHMubWFwKChbYXR0ciwgX3ZhbF0pID0+IGF0dHIpLmNvbmNhdChyZW1vdmVzKTtcbiAgICBsZXQgbmV3U2V0cyA9IHByZXZTZXRzLmZpbHRlcigoW2F0dHIsIF92YWxdKSA9PiAhYWx0ZXJlZEF0dHJzLmluY2x1ZGVzKGF0dHIpKS5jb25jYXQoc2V0cyk7XG4gICAgbGV0IG5ld1JlbW92ZXMgPSBwcmV2UmVtb3Zlcy5maWx0ZXIoKGF0dHIpID0+ICFhbHRlcmVkQXR0cnMuaW5jbHVkZXMoYXR0cikpLmNvbmNhdChyZW1vdmVzKTtcblxuICAgIERPTS5wdXRTdGlja3koZWwsIFwiYXR0cnNcIiwgY3VycmVudEVsID0+IHtcbiAgICAgIG5ld1JlbW92ZXMuZm9yRWFjaChhdHRyID0+IGN1cnJlbnRFbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cikpXG4gICAgICBuZXdTZXRzLmZvckVhY2goKFthdHRyLCB2YWxdKSA9PiBjdXJyZW50RWwuc2V0QXR0cmlidXRlKGF0dHIsIHZhbCkpXG4gICAgICByZXR1cm4gW25ld1NldHMsIG5ld1JlbW92ZXNdXG4gICAgfSlcbiAgfSxcblxuICBoYXNBbGxDbGFzc2VzKGVsLCBjbGFzc2VzKXsgcmV0dXJuIGNsYXNzZXMuZXZlcnkobmFtZSA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSkpIH0sXG5cbiAgaXNUb2dnbGVkT3V0KGVsLCBvdXRDbGFzc2VzKXtcbiAgICByZXR1cm4gIXRoaXMuaXNWaXNpYmxlKGVsKSB8fCB0aGlzLmhhc0FsbENsYXNzZXMoZWwsIG91dENsYXNzZXMpXG4gIH0sXG5cbiAgZmlsdGVyVG9FbHMoc291cmNlRWwsIHt0b30pe1xuICAgIHJldHVybiB0byA/IERPTS5hbGwoZG9jdW1lbnQsIHRvKSA6IFtzb3VyY2VFbF1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBKU1xuIiwgImltcG9ydCB7XG4gIEJFRk9SRV9VTkxPQURfTE9BREVSX1RJTUVPVVQsXG4gIENIRUNLQUJMRV9JTlBVVFMsXG4gIENPTlNFQ1VUSVZFX1JFTE9BRFMsXG4gIFBIWF9BVVRPX1JFQ09WRVIsXG4gIFBIWF9DT01QT05FTlQsXG4gIFBIWF9DT05ORUNURURfQ0xBU1MsXG4gIFBIWF9ESVNBQkxFX1dJVEgsXG4gIFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSxcbiAgUEhYX0RJU0FCTEVELFxuICBQSFhfRElTQ09OTkVDVEVEX0NMQVNTLFxuICBQSFhfRVZFTlRfQ0xBU1NFUyxcbiAgUEhYX0VSUk9SX0NMQVNTLFxuICBQSFhfRkVFREJBQ0tfRk9SLFxuICBQSFhfSEFTX1NVQk1JVFRFRCxcbiAgUEhYX0hPT0ssXG4gIFBIWF9QQUdFX0xPQURJTkcsXG4gIFBIWF9QQVJFTlRfSUQsXG4gIFBIWF9QUk9HUkVTUyxcbiAgUEhYX1JFQURPTkxZLFxuICBQSFhfUkVGLFxuICBQSFhfUkVGX1NSQyxcbiAgUEhYX1JPT1RfSUQsXG4gIFBIWF9TRVNTSU9OLFxuICBQSFhfU1RBVElDLFxuICBQSFhfVFJBQ0tfU1RBVElDLFxuICBQSFhfVFJBQ0tfVVBMT0FEUyxcbiAgUEhYX1VQREFURSxcbiAgUEhYX1VQTE9BRF9SRUYsXG4gIFBIWF9WSUVXX1NFTEVDVE9SLFxuICBQVVNIX1RJTUVPVVQsXG4gIFBIWF9NQUlOLFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBjbG9uZSxcbiAgY2xvc2VzdFBoeEJpbmRpbmcsXG4gIGlzRW1wdHksXG4gIGlzRXF1YWxPYmosXG4gIGxvZ0Vycm9yLFxuICBtYXliZSxcbiAgaXNDaWQsXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IEJyb3dzZXIgZnJvbSBcIi4vYnJvd3NlclwiXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgRE9NUGF0Y2ggZnJvbSBcIi4vZG9tX3BhdGNoXCJcbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5pbXBvcnQgUmVuZGVyZWQgZnJvbSBcIi4vcmVuZGVyZWRcIlxuaW1wb3J0IFZpZXdIb29rIGZyb20gXCIuL3ZpZXdfaG9va1wiXG5pbXBvcnQgSlMgZnJvbSBcIi4vanNcIlxuXG5sZXQgc2VyaWFsaXplRm9ybSA9IChmb3JtLCBtZXRhLCBvbmx5TmFtZXMgPSBbXSkgPT4ge1xuICBsZXQgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoZm9ybSlcbiAgbGV0IHRvUmVtb3ZlID0gW11cblxuICBmb3JtRGF0YS5mb3JFYWNoKCh2YWwsIGtleSwgX2luZGV4KSA9PiB7XG4gICAgaWYodmFsIGluc3RhbmNlb2YgRmlsZSl7IHRvUmVtb3ZlLnB1c2goa2V5KSB9XG4gIH0pXG5cbiAgLy8gQ2xlYW51cCBhZnRlciBidWlsZGluZyBmaWxlRGF0YVxuICB0b1JlbW92ZS5mb3JFYWNoKGtleSA9PiBmb3JtRGF0YS5kZWxldGUoa2V5KSlcblxuICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG4gIGZvcihsZXQgW2tleSwgdmFsXSBvZiBmb3JtRGF0YS5lbnRyaWVzKCkpe1xuICAgIGlmKG9ubHlOYW1lcy5sZW5ndGggPT09IDAgfHwgb25seU5hbWVzLmluZGV4T2Yoa2V5KSA+PSAwKXtcbiAgICAgIHBhcmFtcy5hcHBlbmQoa2V5LCB2YWwpXG4gICAgfVxuICB9XG4gIGZvcihsZXQgbWV0YUtleSBpbiBtZXRhKXsgcGFyYW1zLmFwcGVuZChtZXRhS2V5LCBtZXRhW21ldGFLZXldKSB9XG5cbiAgcmV0dXJuIHBhcmFtcy50b1N0cmluZygpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXcge1xuICBjb25zdHJ1Y3RvcihlbCwgbGl2ZVNvY2tldCwgcGFyZW50VmlldywgZmxhc2gpe1xuICAgIHRoaXMubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXRcbiAgICB0aGlzLmZsYXNoID0gZmxhc2hcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudFZpZXdcbiAgICB0aGlzLnJvb3QgPSBwYXJlbnRWaWV3ID8gcGFyZW50Vmlldy5yb290IDogdGhpc1xuICAgIHRoaXMuZWwgPSBlbFxuICAgIHRoaXMuaWQgPSB0aGlzLmVsLmlkXG4gICAgdGhpcy5yZWYgPSAwXG4gICAgdGhpcy5jaGlsZEpvaW5zID0gMFxuICAgIHRoaXMubG9hZGVyVGltZXIgPSBudWxsXG4gICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgIHRoaXMucHJ1bmluZ0NJRHMgPSBbXVxuICAgIHRoaXMucmVkaXJlY3QgPSBmYWxzZVxuICAgIHRoaXMuaHJlZiA9IG51bGxcbiAgICB0aGlzLmpvaW5Db3VudCA9IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuam9pbkNvdW50IC0gMSA6IDBcbiAgICB0aGlzLmpvaW5QZW5kaW5nID0gdHJ1ZVxuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcbiAgICB0aGlzLmpvaW5DYWxsYmFjayA9IGZ1bmN0aW9uKG9uRG9uZSl7IG9uRG9uZSAmJiBvbkRvbmUoKSB9XG4gICAgdGhpcy5zdG9wQ2FsbGJhY2sgPSBmdW5jdGlvbigpeyB9XG4gICAgdGhpcy5wZW5kaW5nSm9pbk9wcyA9IHRoaXMucGFyZW50ID8gbnVsbCA6IFtdXG4gICAgdGhpcy52aWV3SG9va3MgPSB7fVxuICAgIHRoaXMudXBsb2FkZXJzID0ge31cbiAgICB0aGlzLmZvcm1TdWJtaXRzID0gW11cbiAgICB0aGlzLmNoaWxkcmVuID0gdGhpcy5wYXJlbnQgPyBudWxsIDoge31cbiAgICB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF0gPSB7fVxuICAgIHRoaXMuY2hhbm5lbCA9IHRoaXMubGl2ZVNvY2tldC5jaGFubmVsKGBsdjoke3RoaXMuaWR9YCwgKCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVkaXJlY3Q6IHRoaXMucmVkaXJlY3QgPyB0aGlzLmhyZWYgOiB1bmRlZmluZWQsXG4gICAgICAgIHVybDogdGhpcy5yZWRpcmVjdCA/IHVuZGVmaW5lZCA6IHRoaXMuaHJlZiB8fCB1bmRlZmluZWQsXG4gICAgICAgIHBhcmFtczogdGhpcy5jb25uZWN0UGFyYW1zKCksXG4gICAgICAgIHNlc3Npb246IHRoaXMuZ2V0U2Vzc2lvbigpLFxuICAgICAgICBzdGF0aWM6IHRoaXMuZ2V0U3RhdGljKCksXG4gICAgICAgIGZsYXNoOiB0aGlzLmZsYXNoXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLnNob3dMb2FkZXIodGhpcy5saXZlU29ja2V0LmxvYWRlclRpbWVvdXQpXG4gICAgdGhpcy5iaW5kQ2hhbm5lbCgpXG4gIH1cblxuICBzZXRIcmVmKGhyZWYpeyB0aGlzLmhyZWYgPSBocmVmIH1cblxuICBzZXRSZWRpcmVjdChocmVmKXtcbiAgICB0aGlzLnJlZGlyZWN0ID0gdHJ1ZVxuICAgIHRoaXMuaHJlZiA9IGhyZWZcbiAgfVxuXG4gIGlzTWFpbigpeyByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX01BSU4pICE9PSBudWxsIH1cblxuICBjb25uZWN0UGFyYW1zKCl7XG4gICAgbGV0IHBhcmFtcyA9IHRoaXMubGl2ZVNvY2tldC5wYXJhbXModGhpcy5lbClcbiAgICBsZXQgbWFuaWZlc3QgPVxuICAgICAgRE9NLmFsbChkb2N1bWVudCwgYFske3RoaXMuYmluZGluZyhQSFhfVFJBQ0tfU1RBVElDKX1dYClcbiAgICAgICAgLm1hcChub2RlID0+IG5vZGUuc3JjIHx8IG5vZGUuaHJlZikuZmlsdGVyKHVybCA9PiB0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpXG5cbiAgICBpZihtYW5pZmVzdC5sZW5ndGggPiAwKXsgcGFyYW1zW1wiX3RyYWNrX3N0YXRpY1wiXSA9IG1hbmlmZXN0IH1cbiAgICBwYXJhbXNbXCJfbW91bnRzXCJdID0gdGhpcy5qb2luQ291bnRcblxuICAgIHJldHVybiBwYXJhbXNcbiAgfVxuXG4gIGlzQ29ubmVjdGVkKCl7IHJldHVybiB0aGlzLmNoYW5uZWwuY2FuUHVzaCgpIH1cblxuICBnZXRTZXNzaW9uKCl7IHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTikgfVxuXG4gIGdldFN0YXRpYygpe1xuICAgIGxldCB2YWwgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfU1RBVElDKVxuICAgIHJldHVybiB2YWwgPT09IFwiXCIgPyBudWxsIDogdmFsXG4gIH1cblxuICBkZXN0cm95KGNhbGxiYWNrID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIHRoaXMuZGVzdHJveUFsbENoaWxkcmVuKClcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcbiAgICBkZWxldGUgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdXG4gICAgaWYodGhpcy5wYXJlbnQpeyBkZWxldGUgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMucGFyZW50LmlkXVt0aGlzLmlkXSB9XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpXG4gICAgbGV0IG9uRmluaXNoZWQgPSAoKSA9PiB7XG4gICAgICBjYWxsYmFjaygpXG4gICAgICBmb3IobGV0IGlkIGluIHRoaXMudmlld0hvb2tzKXtcbiAgICAgICAgdGhpcy5kZXN0cm95SG9vayh0aGlzLnZpZXdIb29rc1tpZF0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgRE9NLm1hcmtQaHhDaGlsZERlc3Ryb3llZCh0aGlzLmVsKVxuXG4gICAgdGhpcy5sb2coXCJkZXN0cm95ZWRcIiwgKCkgPT4gW1widGhlIGNoaWxkIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50XCJdKVxuICAgIHRoaXMuY2hhbm5lbC5sZWF2ZSgpXG4gICAgICAucmVjZWl2ZShcIm9rXCIsIG9uRmluaXNoZWQpXG4gICAgICAucmVjZWl2ZShcImVycm9yXCIsIG9uRmluaXNoZWQpXG4gICAgICAucmVjZWl2ZShcInRpbWVvdXRcIiwgb25GaW5pc2hlZClcbiAgfVxuXG4gIHNldENvbnRhaW5lckNsYXNzZXMoLi4uY2xhc3Nlcyl7XG4gICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgUEhYX0NPTk5FQ1RFRF9DTEFTUyxcbiAgICAgIFBIWF9ESVNDT05ORUNURURfQ0xBU1MsXG4gICAgICBQSFhfRVJST1JfQ0xBU1NcbiAgICApXG4gICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXMpXG4gIH1cblxuICBzaG93TG9hZGVyKHRpbWVvdXQpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmxvYWRlclRpbWVyKVxuICAgIGlmKHRpbWVvdXQpe1xuICAgICAgdGhpcy5sb2FkZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zaG93TG9hZGVyKCksIHRpbWVvdXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcihsZXQgaWQgaW4gdGhpcy52aWV3SG9va3MpeyB0aGlzLnZpZXdIb29rc1tpZF0uX19kaXNjb25uZWN0ZWQoKSB9XG4gICAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUylcbiAgICB9XG4gIH1cblxuICBoaWRlTG9hZGVyKCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpXG4gICAgdGhpcy5zZXRDb250YWluZXJDbGFzc2VzKFBIWF9DT05ORUNURURfQ0xBU1MpXG4gIH1cblxuICB0cmlnZ2VyUmVjb25uZWN0ZWQoKXtcbiAgICBmb3IobGV0IGlkIGluIHRoaXMudmlld0hvb2tzKXsgdGhpcy52aWV3SG9va3NbaWRdLl9fcmVjb25uZWN0ZWQoKSB9XG4gIH1cblxuICBsb2coa2luZCwgbXNnQ2FsbGJhY2spe1xuICAgIHRoaXMubGl2ZVNvY2tldC5sb2codGhpcywga2luZCwgbXNnQ2FsbGJhY2spXG4gIH1cblxuICB0cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSA9IGZ1bmN0aW9uKCl7fSl7XG4gICAgdGhpcy5saXZlU29ja2V0LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKVxuICB9XG5cbiAgd2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsIGNhbGxiYWNrKXtcbiAgICBpZihwaHhUYXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBwaHhUYXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KXtcbiAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQub3duZXIocGh4VGFyZ2V0LCB2aWV3ID0+IGNhbGxiYWNrKHZpZXcsIHBoeFRhcmdldCkpXG4gICAgfVxuXG4gICAgaWYoaXNDaWQocGh4VGFyZ2V0KSl7XG4gICAgICBsZXQgdGFyZ2V0cyA9IERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgcGh4VGFyZ2V0KVxuICAgICAgaWYodGFyZ2V0cy5sZW5ndGggPT09IDApe1xuICAgICAgICBsb2dFcnJvcihgbm8gY29tcG9uZW50IGZvdW5kIG1hdGNoaW5nIHBoeC10YXJnZXQgb2YgJHtwaHhUYXJnZXR9YClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMsIHBhcnNlSW50KHBoeFRhcmdldCkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB0YXJnZXRzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHBoeFRhcmdldCkpXG4gICAgICBpZih0YXJnZXRzLmxlbmd0aCA9PT0gMCl7IGxvZ0Vycm9yKGBub3RoaW5nIGZvdW5kIG1hdGNoaW5nIHRoZSBwaHgtdGFyZ2V0IHNlbGVjdG9yIFwiJHtwaHhUYXJnZXR9XCJgKSB9XG4gICAgICB0YXJnZXRzLmZvckVhY2godGFyZ2V0ID0+IHRoaXMubGl2ZVNvY2tldC5vd25lcih0YXJnZXQsIHZpZXcgPT4gY2FsbGJhY2sodmlldywgdGFyZ2V0KSkpXG4gICAgfVxuICB9XG5cbiAgYXBwbHlEaWZmKHR5cGUsIHJhd0RpZmYsIGNhbGxiYWNrKXtcbiAgICB0aGlzLmxvZyh0eXBlLCAoKSA9PiBbXCJcIiwgY2xvbmUocmF3RGlmZildKVxuICAgIGxldCB7ZGlmZiwgcmVwbHksIGV2ZW50cywgdGl0bGV9ID0gUmVuZGVyZWQuZXh0cmFjdChyYXdEaWZmKVxuICAgIGlmKHRpdGxlKXsgRE9NLnB1dFRpdGxlKHRpdGxlKSB9XG5cbiAgICBjYWxsYmFjayh7ZGlmZiwgcmVwbHksIGV2ZW50c30pXG4gICAgcmV0dXJuIHJlcGx5XG4gIH1cblxuICBvbkpvaW4ocmVzcCl7XG4gICAgbGV0IHtyZW5kZXJlZCwgY29udGFpbmVyfSA9IHJlc3BcbiAgICBpZihjb250YWluZXIpe1xuICAgICAgbGV0IFt0YWcsIGF0dHJzXSA9IGNvbnRhaW5lclxuICAgICAgdGhpcy5lbCA9IERPTS5yZXBsYWNlUm9vdENvbnRhaW5lcih0aGlzLmVsLCB0YWcsIGF0dHJzKVxuICAgIH1cbiAgICB0aGlzLmNoaWxkSm9pbnMgPSAwXG4gICAgdGhpcy5qb2luUGVuZGluZyA9IHRydWVcbiAgICB0aGlzLmZsYXNoID0gbnVsbFxuXG4gICAgQnJvd3Nlci5kcm9wTG9jYWwodGhpcy5saXZlU29ja2V0LmxvY2FsU3RvcmFnZSwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLCBDT05TRUNVVElWRV9SRUxPQURTKVxuICAgIHRoaXMuYXBwbHlEaWZmKFwibW91bnRcIiwgcmVuZGVyZWQsICh7ZGlmZiwgZXZlbnRzfSkgPT4ge1xuICAgICAgdGhpcy5yZW5kZXJlZCA9IG5ldyBSZW5kZXJlZCh0aGlzLmlkLCBkaWZmKVxuICAgICAgbGV0IGh0bWwgPSB0aGlzLnJlbmRlckNvbnRhaW5lcihudWxsLCBcImpvaW5cIilcbiAgICAgIHRoaXMuZHJvcFBlbmRpbmdSZWZzKClcbiAgICAgIGxldCBmb3JtcyA9IHRoaXMuZm9ybXNGb3JSZWNvdmVyeShodG1sKVxuICAgICAgdGhpcy5qb2luQ291bnQrK1xuXG4gICAgICBpZihmb3Jtcy5sZW5ndGggPiAwKXtcbiAgICAgICAgZm9ybXMuZm9yRWFjaCgoW2Zvcm0sIG5ld0Zvcm0sIG5ld0NpZF0sIGkpID0+IHtcbiAgICAgICAgICB0aGlzLnB1c2hGb3JtUmVjb3ZlcnkoZm9ybSwgbmV3Q2lkLCByZXNwID0+IHtcbiAgICAgICAgICAgIGlmKGkgPT09IGZvcm1zLmxlbmd0aCAtIDEpe1xuICAgICAgICAgICAgICB0aGlzLm9uSm9pbkNvbXBsZXRlKHJlc3AsIGh0bWwsIGV2ZW50cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkpvaW5Db21wbGV0ZShyZXNwLCBodG1sLCBldmVudHMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGRyb3BQZW5kaW5nUmVmcygpe1xuICAgIERPTS5hbGwoZG9jdW1lbnQsIGBbJHtQSFhfUkVGX1NSQ309XCIke3RoaXMuaWR9XCJdWyR7UEhYX1JFRn1dYCwgZWwgPT4ge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUYpXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpXG4gICAgfSlcbiAgfVxuXG4gIG9uSm9pbkNvbXBsZXRlKHtsaXZlX3BhdGNofSwgaHRtbCwgZXZlbnRzKXtcbiAgICAvLyBJbiBvcmRlciB0byBwcm92aWRlIGEgYmV0dGVyIGV4cGVyaWVuY2UsIHdlIHdhbnQgdG8gam9pblxuICAgIC8vIGFsbCBMaXZlVmlld3MgZmlyc3QgYW5kIG9ubHkgdGhlbiBhcHBseSB0aGVpciBwYXRjaGVzLlxuICAgIGlmKHRoaXMuam9pbkNvdW50ID4gMSB8fCAodGhpcy5wYXJlbnQgJiYgIXRoaXMucGFyZW50LmlzSm9pblBlbmRpbmcoKSkpe1xuICAgICAgcmV0dXJuIHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgZXZlbnRzKVxuICAgIH1cblxuICAgIC8vIE9uZSBkb3duc2lkZSBvZiB0aGlzIGFwcHJvYWNoIGlzIHRoYXQgd2UgbmVlZCB0byBmaW5kIHBoeENoaWxkcmVuXG4gICAgLy8gaW4gdGhlIGh0bWwgZnJhZ21lbnQsIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIERPTS4gVGhlIGZyYWdtZW50XG4gICAgLy8gYWxzbyBkb2VzIG5vdCBpbmNsdWRlIFBIWF9TVEFUSUMsIHNvIHdlIG5lZWQgdG8gY29weSBpdCBvdmVyIGZyb21cbiAgICAvLyB0aGUgRE9NLlxuICAgIGxldCBuZXdDaGlsZHJlbiA9IERPTS5maW5kUGh4Q2hpbGRyZW5JbkZyYWdtZW50KGh0bWwsIHRoaXMuaWQpLmZpbHRlcih0b0VsID0+IHtcbiAgICAgIGxldCBmcm9tRWwgPSB0b0VsLmlkICYmIHRoaXMuZWwucXVlcnlTZWxlY3RvcihgW2lkPVwiJHt0b0VsLmlkfVwiXWApXG4gICAgICBsZXQgcGh4U3RhdGljID0gZnJvbUVsICYmIGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQylcbiAgICAgIGlmKHBoeFN0YXRpYyl7IHRvRWwuc2V0QXR0cmlidXRlKFBIWF9TVEFUSUMsIHBoeFN0YXRpYykgfVxuICAgICAgcmV0dXJuIHRoaXMuam9pbkNoaWxkKHRvRWwpXG4gICAgfSlcblxuICAgIGlmKG5ld0NoaWxkcmVuLmxlbmd0aCA9PT0gMCl7XG4gICAgICBpZih0aGlzLnBhcmVudCl7XG4gICAgICAgIHRoaXMucm9vdC5wZW5kaW5nSm9pbk9wcy5wdXNoKFt0aGlzLCAoKSA9PiB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIGV2ZW50cyldKVxuICAgICAgICB0aGlzLnBhcmVudC5hY2tKb2luKHRoaXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKClcbiAgICAgICAgdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucm9vdC5wZW5kaW5nSm9pbk9wcy5wdXNoKFt0aGlzLCAoKSA9PiB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIGV2ZW50cyldKVxuICAgIH1cbiAgfVxuXG4gIGF0dGFjaFRydWVEb2NFbCgpe1xuICAgIHRoaXMuZWwgPSBET00uYnlJZCh0aGlzLmlkKVxuICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKFBIWF9ST09UX0lELCB0aGlzLnJvb3QuaWQpXG4gIH1cblxuICBhcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpe1xuICAgIHRoaXMuYXR0YWNoVHJ1ZURvY0VsKClcbiAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgbnVsbClcbiAgICBwYXRjaC5tYXJrUHJ1bmFibGVDb250ZW50Rm9yUmVtb3ZhbCgpXG4gICAgdGhpcy5wZXJmb3JtUGF0Y2gocGF0Y2gsIGZhbHNlKVxuICAgIHRoaXMuam9pbk5ld0NoaWxkcmVuKClcbiAgICBET00uYWxsKHRoaXMuZWwsIGBbJHt0aGlzLmJpbmRpbmcoUEhYX0hPT0spfV0sIFtkYXRhLXBoeC0ke1BIWF9IT09LfV1gLCBob29rRWwgPT4ge1xuICAgICAgbGV0IGhvb2sgPSB0aGlzLmFkZEhvb2soaG9va0VsKVxuICAgICAgaWYoaG9vayl7IGhvb2suX19tb3VudGVkKCkgfVxuICAgIH0pXG5cbiAgICB0aGlzLmpvaW5QZW5kaW5nID0gZmFsc2VcbiAgICB0aGlzLmxpdmVTb2NrZXQuZGlzcGF0Y2hFdmVudHMoZXZlbnRzKVxuICAgIHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpXG5cbiAgICBpZihsaXZlX3BhdGNoKXtcbiAgICAgIGxldCB7a2luZCwgdG99ID0gbGl2ZV9wYXRjaFxuICAgICAgdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlQYXRjaCh0bywga2luZClcbiAgICB9XG4gICAgdGhpcy5oaWRlTG9hZGVyKClcbiAgICBpZih0aGlzLmpvaW5Db3VudCA+IDEpeyB0aGlzLnRyaWdnZXJSZWNvbm5lY3RlZCgpIH1cbiAgICB0aGlzLnN0b3BDYWxsYmFjaygpXG4gIH1cblxuICB0cmlnZ2VyQmVmb3JlVXBkYXRlSG9vayhmcm9tRWwsIHRvRWwpe1xuICAgIHRoaXMubGl2ZVNvY2tldC50cmlnZ2VyRE9NKFwib25CZWZvcmVFbFVwZGF0ZWRcIiwgW2Zyb21FbCwgdG9FbF0pXG4gICAgbGV0IGhvb2sgPSB0aGlzLmdldEhvb2soZnJvbUVsKVxuICAgIGxldCBpc0lnbm9yZWQgPSBob29rICYmIERPTS5pc0lnbm9yZWQoZnJvbUVsLCB0aGlzLmJpbmRpbmcoUEhYX1VQREFURSkpXG4gICAgaWYoaG9vayAmJiAhZnJvbUVsLmlzRXF1YWxOb2RlKHRvRWwpICYmICEoaXNJZ25vcmVkICYmIGlzRXF1YWxPYmooZnJvbUVsLmRhdGFzZXQsIHRvRWwuZGF0YXNldCkpKXtcbiAgICAgIGhvb2suX19iZWZvcmVVcGRhdGUoKVxuICAgICAgcmV0dXJuIGhvb2tcbiAgICB9XG4gIH1cblxuICBwZXJmb3JtUGF0Y2gocGF0Y2gsIHBydW5lQ2lkcyl7XG4gICAgbGV0IHJlbW92ZWRFbHMgPSBbXVxuICAgIGxldCBwaHhDaGlsZHJlbkFkZGVkID0gZmFsc2VcbiAgICBsZXQgdXBkYXRlZEhvb2tJZHMgPSBuZXcgU2V0KClcblxuICAgIHBhdGNoLmFmdGVyKFwiYWRkZWRcIiwgZWwgPT4ge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnRyaWdnZXJET00oXCJvbk5vZGVBZGRlZFwiLCBbZWxdKVxuXG4gICAgICBsZXQgbmV3SG9vayA9IHRoaXMuYWRkSG9vayhlbClcbiAgICAgIGlmKG5ld0hvb2speyBuZXdIb29rLl9fbW91bnRlZCgpIH1cbiAgICB9KVxuXG4gICAgcGF0Y2guYWZ0ZXIoXCJwaHhDaGlsZEFkZGVkXCIsIGVsID0+IHtcbiAgICAgIGlmKERPTS5pc1BoeFN0aWNreShlbCkpe1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQuam9pblJvb3RWaWV3cygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaHhDaGlsZHJlbkFkZGVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5iZWZvcmUoXCJ1cGRhdGVkXCIsIChmcm9tRWwsIHRvRWwpID0+IHtcbiAgICAgIGxldCBob29rID0gdGhpcy50cmlnZ2VyQmVmb3JlVXBkYXRlSG9vayhmcm9tRWwsIHRvRWwpXG4gICAgICBpZihob29rKXsgdXBkYXRlZEhvb2tJZHMuYWRkKGZyb21FbC5pZCkgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5hZnRlcihcInVwZGF0ZWRcIiwgZWwgPT4ge1xuICAgICAgaWYodXBkYXRlZEhvb2tJZHMuaGFzKGVsLmlkKSl7IHRoaXMuZ2V0SG9vayhlbCkuX191cGRhdGVkKCkgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5hZnRlcihcImRpc2NhcmRlZFwiLCAoZWwpID0+IHtcbiAgICAgIGlmKGVsLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSl7IHJlbW92ZWRFbHMucHVzaChlbCkgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5hZnRlcihcInRyYW5zaXRpb25zRGlzY2FyZGVkXCIsIGVscyA9PiB0aGlzLmFmdGVyRWxlbWVudHNSZW1vdmVkKGVscywgcHJ1bmVDaWRzKSlcbiAgICBwYXRjaC5wZXJmb3JtKClcbiAgICB0aGlzLmFmdGVyRWxlbWVudHNSZW1vdmVkKHJlbW92ZWRFbHMsIHBydW5lQ2lkcylcblxuICAgIHJldHVybiBwaHhDaGlsZHJlbkFkZGVkXG4gIH1cblxuICBhZnRlckVsZW1lbnRzUmVtb3ZlZChlbGVtZW50cywgcHJ1bmVDaWRzKXtcbiAgICBsZXQgZGVzdHJveWVkQ0lEcyA9IFtdXG4gICAgZWxlbWVudHMuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgbGV0IGNvbXBvbmVudHMgPSBET00uYWxsKHBhcmVudCwgYFske1BIWF9DT01QT05FTlR9XWApXG4gICAgICBsZXQgaG9va3MgPSBET00uYWxsKHBhcmVudCwgYFske3RoaXMuYmluZGluZyhQSFhfSE9PSyl9XWApXG4gICAgICBjb21wb25lbnRzLmNvbmNhdChwYXJlbnQpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBsZXQgY2lkID0gdGhpcy5jb21wb25lbnRJRChlbClcbiAgICAgICAgaWYoaXNDaWQoY2lkKSAmJiBkZXN0cm95ZWRDSURzLmluZGV4T2YoY2lkKSA9PT0gLTEpeyBkZXN0cm95ZWRDSURzLnB1c2goY2lkKSB9XG4gICAgICB9KVxuICAgICAgaG9va3MuY29uY2F0KHBhcmVudCkuZm9yRWFjaChob29rRWwgPT4ge1xuICAgICAgICBsZXQgaG9vayA9IHRoaXMuZ2V0SG9vayhob29rRWwpXG4gICAgICAgIGhvb2sgJiYgdGhpcy5kZXN0cm95SG9vayhob29rKVxuICAgICAgfSlcbiAgICB9KVxuICAgIC8vIFdlIHNob3VsZCBub3QgcHJ1bmVDaWRzIG9uIGpvaW5zLiBPdGhlcndpc2UsIGluIGNhc2Ugb2ZcbiAgICAvLyByZWpvaW5zLCB3ZSBtYXkgbm90aWZ5IGNpZHMgdGhhdCBubyBsb25nZXIgYmVsb25nIHRvIHRoZVxuICAgIC8vIGN1cnJlbnQgTGl2ZVZpZXcgdG8gYmUgcmVtb3ZlZC5cbiAgICBpZihwcnVuZUNpZHMpe1xuICAgICAgdGhpcy5tYXliZVB1c2hDb21wb25lbnRzRGVzdHJveWVkKGRlc3Ryb3llZENJRHMpXG4gICAgfVxuICB9XG5cbiAgam9pbk5ld0NoaWxkcmVuKCl7XG4gICAgRE9NLmZpbmRQaHhDaGlsZHJlbih0aGlzLmVsLCB0aGlzLmlkKS5mb3JFYWNoKGVsID0+IHRoaXMuam9pbkNoaWxkKGVsKSlcbiAgfVxuXG4gIGdldENoaWxkQnlJZChpZCl7IHJldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1baWRdIH1cblxuICBnZXREZXNjZW5kZW50QnlFbChlbCl7XG4gICAgaWYoZWwuaWQgPT09IHRoaXMuaWQpe1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bZWwuZ2V0QXR0cmlidXRlKFBIWF9QQVJFTlRfSUQpXVtlbC5pZF1cbiAgICB9XG4gIH1cblxuICBkZXN0cm95RGVzY2VuZGVudChpZCl7XG4gICAgZm9yKGxldCBwYXJlbnRJZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW4pe1xuICAgICAgZm9yKGxldCBjaGlsZElkIGluIHRoaXMucm9vdC5jaGlsZHJlbltwYXJlbnRJZF0pe1xuICAgICAgICBpZihjaGlsZElkID09PSBpZCl7IHJldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bcGFyZW50SWRdW2NoaWxkSWRdLmRlc3Ryb3koKSB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgam9pbkNoaWxkKGVsKXtcbiAgICBsZXQgY2hpbGQgPSB0aGlzLmdldENoaWxkQnlJZChlbC5pZClcbiAgICBpZighY2hpbGQpe1xuICAgICAgbGV0IHZpZXcgPSBuZXcgVmlldyhlbCwgdGhpcy5saXZlU29ja2V0LCB0aGlzKVxuICAgICAgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdW3ZpZXcuaWRdID0gdmlld1xuICAgICAgdmlldy5qb2luKClcbiAgICAgIHRoaXMuY2hpbGRKb2lucysrXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGlzSm9pblBlbmRpbmcoKXsgcmV0dXJuIHRoaXMuam9pblBlbmRpbmcgfVxuXG4gIGFja0pvaW4oX2NoaWxkKXtcbiAgICB0aGlzLmNoaWxkSm9pbnMtLVxuXG4gICAgaWYodGhpcy5jaGlsZEpvaW5zID09PSAwKXtcbiAgICAgIGlmKHRoaXMucGFyZW50KXtcbiAgICAgICAgdGhpcy5wYXJlbnQuYWNrSm9pbih0aGlzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkFsbENoaWxkSm9pbnNDb21wbGV0ZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKXtcbiAgICB0aGlzLmpvaW5DYWxsYmFjaygoKSA9PiB7XG4gICAgICB0aGlzLnBlbmRpbmdKb2luT3BzLmZvckVhY2goKFt2aWV3LCBvcF0pID0+IHtcbiAgICAgICAgaWYoIXZpZXcuaXNEZXN0cm95ZWQoKSl7IG9wKCkgfVxuICAgICAgfSlcbiAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMgPSBbXVxuICAgIH0pXG4gIH1cblxuICB1cGRhdGUoZGlmZiwgZXZlbnRzKXtcbiAgICBpZih0aGlzLmlzSm9pblBlbmRpbmcoKSB8fCAodGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkgJiYgIURPTS5pc1BoeFN0aWNreSh0aGlzLmVsKSkpe1xuICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goe2RpZmYsIGV2ZW50c30pXG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlZC5tZXJnZURpZmYoZGlmZilcbiAgICBsZXQgcGh4Q2hpbGRyZW5BZGRlZCA9IGZhbHNlXG5cbiAgICAvLyBXaGVuIHRoZSBkaWZmIG9ubHkgY29udGFpbnMgY29tcG9uZW50IGRpZmZzLCB0aGVuIHdhbGsgY29tcG9uZW50c1xuICAgIC8vIGFuZCBwYXRjaCBvbmx5IHRoZSBwYXJlbnQgY29tcG9uZW50IGNvbnRhaW5lcnMgZm91bmQgaW4gdGhlIGRpZmYuXG4gICAgLy8gT3RoZXJ3aXNlLCBwYXRjaCBlbnRpcmUgTFYgY29udGFpbmVyLlxuICAgIGlmKHRoaXMucmVuZGVyZWQuaXNDb21wb25lbnRPbmx5RGlmZihkaWZmKSl7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudGltZShcImNvbXBvbmVudCBwYXRjaCBjb21wbGV0ZVwiLCAoKSA9PiB7XG4gICAgICAgIGxldCBwYXJlbnRDaWRzID0gRE9NLmZpbmRQYXJlbnRDSURzKHRoaXMuZWwsIHRoaXMucmVuZGVyZWQuY29tcG9uZW50Q0lEcyhkaWZmKSlcbiAgICAgICAgcGFyZW50Q2lkcy5mb3JFYWNoKHBhcmVudENJRCA9PiB7XG4gICAgICAgICAgaWYodGhpcy5jb21wb25lbnRQYXRjaCh0aGlzLnJlbmRlcmVkLmdldENvbXBvbmVudChkaWZmLCBwYXJlbnRDSUQpLCBwYXJlbnRDSUQpKXsgcGh4Q2hpbGRyZW5BZGRlZCA9IHRydWUgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYoIWlzRW1wdHkoZGlmZikpe1xuICAgICAgdGhpcy5saXZlU29ja2V0LnRpbWUoXCJmdWxsIHBhdGNoIGNvbXBsZXRlXCIsICgpID0+IHtcbiAgICAgICAgbGV0IGh0bWwgPSB0aGlzLnJlbmRlckNvbnRhaW5lcihkaWZmLCBcInVwZGF0ZVwiKVxuICAgICAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgbnVsbClcbiAgICAgICAgcGh4Q2hpbGRyZW5BZGRlZCA9IHRoaXMucGVyZm9ybVBhdGNoKHBhdGNoLCB0cnVlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmxpdmVTb2NrZXQuZGlzcGF0Y2hFdmVudHMoZXZlbnRzKVxuICAgIGlmKHBoeENoaWxkcmVuQWRkZWQpeyB0aGlzLmpvaW5OZXdDaGlsZHJlbigpIH1cbiAgfVxuXG4gIHJlbmRlckNvbnRhaW5lcihkaWZmLCBraW5kKXtcbiAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LnRpbWUoYHRvU3RyaW5nIGRpZmYgKCR7a2luZH0pYCwgKCkgPT4ge1xuICAgICAgbGV0IHRhZyA9IHRoaXMuZWwudGFnTmFtZVxuICAgICAgLy8gRG9uJ3Qgc2tpcCBhbnkgY29tcG9uZW50IGluIHRoZSBkaWZmIG5vciBhbnkgbWFya2VkIGFzIHBydW5lZFxuICAgICAgLy8gKGFzIHRoZXkgbWF5IGhhdmUgYmVlbiBhZGRlZCBiYWNrKVxuICAgICAgbGV0IGNpZHMgPSBkaWZmID8gdGhpcy5yZW5kZXJlZC5jb21wb25lbnRDSURzKGRpZmYpLmNvbmNhdCh0aGlzLnBydW5pbmdDSURzKSA6IG51bGxcbiAgICAgIGxldCBodG1sID0gdGhpcy5yZW5kZXJlZC50b1N0cmluZyhjaWRzKVxuICAgICAgcmV0dXJuIGA8JHt0YWd9PiR7aHRtbH08LyR7dGFnfT5gXG4gICAgfSlcbiAgfVxuXG4gIGNvbXBvbmVudFBhdGNoKGRpZmYsIGNpZCl7XG4gICAgaWYoaXNFbXB0eShkaWZmKSkgcmV0dXJuIGZhbHNlXG4gICAgbGV0IGh0bWwgPSB0aGlzLnJlbmRlcmVkLmNvbXBvbmVudFRvU3RyaW5nKGNpZClcbiAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgY2lkKVxuICAgIGxldCBjaGlsZHJlbkFkZGVkID0gdGhpcy5wZXJmb3JtUGF0Y2gocGF0Y2gsIHRydWUpXG4gICAgcmV0dXJuIGNoaWxkcmVuQWRkZWRcbiAgfVxuXG4gIGdldEhvb2soZWwpeyByZXR1cm4gdGhpcy52aWV3SG9va3NbVmlld0hvb2suZWxlbWVudElEKGVsKV0gfVxuXG4gIGFkZEhvb2soZWwpe1xuICAgIGlmKFZpZXdIb29rLmVsZW1lbnRJRChlbCkgfHwgIWVsLmdldEF0dHJpYnV0ZSl7IHJldHVybiB9XG4gICAgbGV0IGhvb2tOYW1lID0gZWwuZ2V0QXR0cmlidXRlKGBkYXRhLXBoeC0ke1BIWF9IT09LfWApIHx8IGVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0hPT0spKVxuICAgIGlmKGhvb2tOYW1lICYmICF0aGlzLm93bnNFbGVtZW50KGVsKSl7IHJldHVybiB9XG4gICAgbGV0IGNhbGxiYWNrcyA9IHRoaXMubGl2ZVNvY2tldC5nZXRIb29rQ2FsbGJhY2tzKGhvb2tOYW1lKVxuXG4gICAgaWYoY2FsbGJhY2tzKXtcbiAgICAgIGlmKCFlbC5pZCl7IGxvZ0Vycm9yKGBubyBET00gSUQgZm9yIGhvb2sgXCIke2hvb2tOYW1lfVwiLiBIb29rcyByZXF1aXJlIGEgdW5pcXVlIElEIG9uIGVhY2ggZWxlbWVudC5gLCBlbCkgfVxuICAgICAgbGV0IGhvb2sgPSBuZXcgVmlld0hvb2sodGhpcywgZWwsIGNhbGxiYWNrcylcbiAgICAgIHRoaXMudmlld0hvb2tzW1ZpZXdIb29rLmVsZW1lbnRJRChob29rLmVsKV0gPSBob29rXG4gICAgICByZXR1cm4gaG9va1xuICAgIH0gZWxzZSBpZihob29rTmFtZSAhPT0gbnVsbCl7XG4gICAgICBsb2dFcnJvcihgdW5rbm93biBob29rIGZvdW5kIGZvciBcIiR7aG9va05hbWV9XCJgLCBlbClcbiAgICB9XG4gIH1cblxuICBkZXN0cm95SG9vayhob29rKXtcbiAgICBob29rLl9fZGVzdHJveWVkKClcbiAgICBob29rLl9fY2xlYW51cF9fKClcbiAgICBkZWxldGUgdGhpcy52aWV3SG9va3NbVmlld0hvb2suZWxlbWVudElEKGhvb2suZWwpXVxuICB9XG5cbiAgYXBwbHlQZW5kaW5nVXBkYXRlcygpe1xuICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goKHtkaWZmLCBldmVudHN9KSA9PiB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpKVxuICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cbiAgfVxuXG4gIG9uQ2hhbm5lbChldmVudCwgY2Ipe1xuICAgIHRoaXMubGl2ZVNvY2tldC5vbkNoYW5uZWwodGhpcy5jaGFubmVsLCBldmVudCwgcmVzcCA9PiB7XG4gICAgICBpZih0aGlzLmlzSm9pblBlbmRpbmcoKSl7XG4gICAgICAgIHRoaXMucm9vdC5wZW5kaW5nSm9pbk9wcy5wdXNoKFt0aGlzLCAoKSA9PiBjYihyZXNwKV0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiBjYihyZXNwKSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgYmluZENoYW5uZWwoKXtcbiAgICAvLyBUaGUgZGlmZiBldmVudCBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGUgcmVndWxhciB1cGRhdGUgb3BlcmF0aW9ucy5cbiAgICAvLyBBbGwgb3RoZXIgb3BlcmF0aW9ucyBhcmUgcXVldWVkIHRvIGJlIGFwcGxpZWQgb25seSBhZnRlciBqb2luLlxuICAgIHRoaXMubGl2ZVNvY2tldC5vbkNoYW5uZWwodGhpcy5jaGFubmVsLCBcImRpZmZcIiwgKHJhd0RpZmYpID0+IHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgdGhpcy5hcHBseURpZmYoXCJ1cGRhdGVcIiwgcmF3RGlmZiwgKHtkaWZmLCBldmVudHN9KSA9PiB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpKVxuICAgICAgfSlcbiAgICB9KVxuICAgIHRoaXMub25DaGFubmVsKFwicmVkaXJlY3RcIiwgKHt0bywgZmxhc2h9KSA9PiB0aGlzLm9uUmVkaXJlY3Qoe3RvLCBmbGFzaH0pKVxuICAgIHRoaXMub25DaGFubmVsKFwibGl2ZV9wYXRjaFwiLCAocmVkaXIpID0+IHRoaXMub25MaXZlUGF0Y2gocmVkaXIpKVxuICAgIHRoaXMub25DaGFubmVsKFwibGl2ZV9yZWRpcmVjdFwiLCAocmVkaXIpID0+IHRoaXMub25MaXZlUmVkaXJlY3QocmVkaXIpKVxuICAgIHRoaXMuY2hhbm5lbC5vbkVycm9yKHJlYXNvbiA9PiB0aGlzLm9uRXJyb3IocmVhc29uKSlcbiAgICB0aGlzLmNoYW5uZWwub25DbG9zZShyZWFzb24gPT4gdGhpcy5vbkNsb3NlKHJlYXNvbikpXG4gIH1cblxuICBkZXN0cm95QWxsQ2hpbGRyZW4oKXtcbiAgICBmb3IobGV0IGlkIGluIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXSl7XG4gICAgICB0aGlzLmdldENoaWxkQnlJZChpZCkuZGVzdHJveSgpXG4gICAgfVxuICB9XG5cbiAgb25MaXZlUmVkaXJlY3QocmVkaXIpe1xuICAgIGxldCB7dG8sIGtpbmQsIGZsYXNofSA9IHJlZGlyXG4gICAgbGV0IHVybCA9IHRoaXMuZXhwYW5kVVJMKHRvKVxuICAgIHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UmVkaXJlY3QodXJsLCBraW5kLCBmbGFzaClcbiAgfVxuXG4gIG9uTGl2ZVBhdGNoKHJlZGlyKXtcbiAgICBsZXQge3RvLCBraW5kfSA9IHJlZGlyXG4gICAgdGhpcy5ocmVmID0gdGhpcy5leHBhbmRVUkwodG8pXG4gICAgdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlQYXRjaCh0bywga2luZClcbiAgfVxuXG4gIGV4cGFuZFVSTCh0byl7XG4gICAgcmV0dXJuIHRvLnN0YXJ0c1dpdGgoXCIvXCIpID8gYCR7d2luZG93LmxvY2F0aW9uLnByb3RvY29sfS8vJHt3aW5kb3cubG9jYXRpb24uaG9zdH0ke3RvfWAgOiB0b1xuICB9XG5cbiAgb25SZWRpcmVjdCh7dG8sIGZsYXNofSl7IHRoaXMubGl2ZVNvY2tldC5yZWRpcmVjdCh0bywgZmxhc2gpIH1cblxuICBpc0Rlc3Ryb3llZCgpeyByZXR1cm4gdGhpcy5kZXN0cm95ZWQgfVxuXG4gIGpvaW4oY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuaXNNYWluKCkpe1xuICAgICAgdGhpcy5zdG9wQ2FsbGJhY2sgPSB0aGlzLmxpdmVTb2NrZXQud2l0aFBhZ2VMb2FkaW5nKHt0bzogdGhpcy5ocmVmLCBraW5kOiBcImluaXRpYWxcIn0pXG4gICAgfVxuICAgIHRoaXMuam9pbkNhbGxiYWNrID0gKG9uRG9uZSkgPT4ge1xuICAgICAgb25Eb25lID0gb25Eb25lIHx8IGZ1bmN0aW9uKCl7fVxuICAgICAgY2FsbGJhY2sgPyBjYWxsYmFjayh0aGlzLmpvaW5Db3VudCwgb25Eb25lKSA6IG9uRG9uZSgpXG4gICAgfVxuICAgIHRoaXMubGl2ZVNvY2tldC53cmFwUHVzaCh0aGlzLCB7dGltZW91dDogZmFsc2V9LCAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFubmVsLmpvaW4oKVxuICAgICAgICAucmVjZWl2ZShcIm9rXCIsIGRhdGEgPT4ge1xuICAgICAgICAgIGlmKCF0aGlzLmlzRGVzdHJveWVkKCkpe1xuICAgICAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4gdGhpcy5vbkpvaW4oZGF0YSkpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAucmVjZWl2ZShcImVycm9yXCIsIHJlc3AgPT4gIXRoaXMuaXNEZXN0cm95ZWQoKSAmJiB0aGlzLm9uSm9pbkVycm9yKHJlc3ApKVxuICAgICAgICAucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4gIXRoaXMuaXNEZXN0cm95ZWQoKSAmJiB0aGlzLm9uSm9pbkVycm9yKHtyZWFzb246IFwidGltZW91dFwifSkpXG4gICAgfSlcbiAgfVxuXG4gIG9uSm9pbkVycm9yKHJlc3Ape1xuICAgIGlmKHJlc3AucmVhc29uID09PSBcInVuYXV0aG9yaXplZFwiIHx8IHJlc3AucmVhc29uID09PSBcInN0YWxlXCIpe1xuICAgICAgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ1bmF1dGhvcml6ZWQgbGl2ZV9yZWRpcmVjdC4gRmFsbGluZyBiYWNrIHRvIHBhZ2UgcmVxdWVzdFwiLCByZXNwXSlcbiAgICAgIHJldHVybiB0aGlzLm9uUmVkaXJlY3Qoe3RvOiB0aGlzLmhyZWZ9KVxuICAgIH1cbiAgICBpZihyZXNwLnJlZGlyZWN0IHx8IHJlc3AubGl2ZV9yZWRpcmVjdCl7XG4gICAgICB0aGlzLmpvaW5QZW5kaW5nID0gZmFsc2VcbiAgICAgIHRoaXMuY2hhbm5lbC5sZWF2ZSgpXG4gICAgfVxuICAgIGlmKHJlc3AucmVkaXJlY3QpeyByZXR1cm4gdGhpcy5vblJlZGlyZWN0KHJlc3AucmVkaXJlY3QpIH1cbiAgICBpZihyZXNwLmxpdmVfcmVkaXJlY3QpeyByZXR1cm4gdGhpcy5vbkxpdmVSZWRpcmVjdChyZXNwLmxpdmVfcmVkaXJlY3QpIH1cbiAgICB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtcInVuYWJsZSB0byBqb2luXCIsIHJlc3BdKVxuICAgIGlmKHRoaXMubGl2ZVNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5saXZlU29ja2V0LnJlbG9hZFdpdGhKaXR0ZXIodGhpcykgfVxuICB9XG5cbiAgb25DbG9zZShyZWFzb24pe1xuICAgIGlmKHRoaXMuaXNEZXN0cm95ZWQoKSl7IHJldHVybiB9XG4gICAgaWYodGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkgJiYgcmVhc29uICE9PSBcImxlYXZlXCIpe1xuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5yZWxvYWRXaXRoSml0dGVyKHRoaXMpXG4gICAgfVxuICAgIHRoaXMuZGVzdHJveUFsbENoaWxkcmVuKClcbiAgICB0aGlzLmxpdmVTb2NrZXQuZHJvcEFjdGl2ZUVsZW1lbnQodGhpcylcbiAgICAvLyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiBiZSBudWxsIGluIEludGVybmV0IEV4cGxvcmVyIDExXG4gICAgaWYoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCl7IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpIH1cbiAgICBpZih0aGlzLmxpdmVTb2NrZXQuaXNVbmxvYWRlZCgpKXtcbiAgICAgIHRoaXMuc2hvd0xvYWRlcihCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VUKVxuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IocmVhc29uKXtcbiAgICB0aGlzLm9uQ2xvc2UocmVhc29uKVxuICAgIGlmKHRoaXMubGl2ZVNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ2aWV3IGNyYXNoZWRcIiwgcmVhc29uXSkgfVxuICAgIGlmKCF0aGlzLmxpdmVTb2NrZXQuaXNVbmxvYWRlZCgpKXsgdGhpcy5kaXNwbGF5RXJyb3IoKSB9XG4gIH1cblxuICBkaXNwbGF5RXJyb3IoKXtcbiAgICBpZih0aGlzLmlzTWFpbigpKXsgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIiwge2RldGFpbDoge3RvOiB0aGlzLmhyZWYsIGtpbmQ6IFwiZXJyb3JcIn19KSB9XG4gICAgdGhpcy5zaG93TG9hZGVyKClcbiAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUywgUEhYX0VSUk9SX0NMQVNTKVxuICB9XG5cbiAgcHVzaFdpdGhSZXBseShyZWZHZW5lcmF0b3IsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5ID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuXG4gICAgbGV0IFtyZWYsIFtlbF0sIG9wdHNdID0gcmVmR2VuZXJhdG9yID8gcmVmR2VuZXJhdG9yKCkgOiBbbnVsbCwgW10sIHt9XVxuICAgIGxldCBvbkxvYWRpbmdEb25lID0gZnVuY3Rpb24oKXsgfVxuICAgIGlmKG9wdHMucGFnZV9sb2FkaW5nIHx8IChlbCAmJiAoZWwuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfUEFHRV9MT0FESU5HKSkgIT09IG51bGwpKSl7XG4gICAgICBvbkxvYWRpbmdEb25lID0gdGhpcy5saXZlU29ja2V0LndpdGhQYWdlTG9hZGluZyh7a2luZDogXCJlbGVtZW50XCIsIHRhcmdldDogZWx9KVxuICAgIH1cblxuICAgIGlmKHR5cGVvZiAocGF5bG9hZC5jaWQpICE9PSBcIm51bWJlclwiKXsgZGVsZXRlIHBheWxvYWQuY2lkIH1cbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5saXZlU29ja2V0LndyYXBQdXNoKHRoaXMsIHt0aW1lb3V0OiB0cnVlfSwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsLnB1c2goZXZlbnQsIHBheWxvYWQsIFBVU0hfVElNRU9VVCkucmVjZWl2ZShcIm9rXCIsIHJlc3AgPT4ge1xuICAgICAgICAgIGlmKHJlZiAhPT0gbnVsbCl7IHRoaXMudW5kb1JlZnMocmVmKSB9XG4gICAgICAgICAgbGV0IGZpbmlzaCA9IChob29rUmVwbHkpID0+IHtcbiAgICAgICAgICAgIGlmKHJlc3AucmVkaXJlY3QpeyB0aGlzLm9uUmVkaXJlY3QocmVzcC5yZWRpcmVjdCkgfVxuICAgICAgICAgICAgaWYocmVzcC5saXZlX3BhdGNoKXsgdGhpcy5vbkxpdmVQYXRjaChyZXNwLmxpdmVfcGF0Y2gpIH1cbiAgICAgICAgICAgIGlmKHJlc3AubGl2ZV9yZWRpcmVjdCl7IHRoaXMub25MaXZlUmVkaXJlY3QocmVzcC5saXZlX3JlZGlyZWN0KSB9XG4gICAgICAgICAgICBvbkxvYWRpbmdEb25lKClcbiAgICAgICAgICAgIG9uUmVwbHkocmVzcCwgaG9va1JlcGx5KVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXNwLmRpZmYpe1xuICAgICAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICBsZXQgaG9va1JlcGx5ID0gdGhpcy5hcHBseURpZmYoXCJ1cGRhdGVcIiwgcmVzcC5kaWZmLCAoe2RpZmYsIGV2ZW50c30pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIGZpbmlzaChob29rUmVwbHkpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaW5pc2gobnVsbClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIHVuZG9SZWZzKHJlZil7XG4gICAgRE9NLmFsbChkb2N1bWVudCwgYFske1BIWF9SRUZfU1JDfT1cIiR7dGhpcy5pZH1cIl1bJHtQSFhfUkVGfT1cIiR7cmVmfVwiXWAsIGVsID0+IHtcbiAgICAgIGxldCBkaXNhYmxlZFZhbCA9IGVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRUQpXG4gICAgICAvLyByZW1vdmUgcmVmc1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUYpXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpXG4gICAgICAvLyByZXN0b3JlIGlucHV0c1xuICAgICAgaWYoZWwuZ2V0QXR0cmlidXRlKFBIWF9SRUFET05MWSkgIT09IG51bGwpe1xuICAgICAgICBlbC5yZWFkT25seSA9IGZhbHNlXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVBRE9OTFkpXG4gICAgICB9XG4gICAgICBpZihkaXNhYmxlZFZhbCAhPT0gbnVsbCl7XG4gICAgICAgIGVsLmRpc2FibGVkID0gZGlzYWJsZWRWYWwgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfRElTQUJMRUQpXG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgY2xhc3Nlc1xuICAgICAgUEhYX0VWRU5UX0NMQVNTRVMuZm9yRWFjaChjbGFzc05hbWUgPT4gRE9NLnJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpKVxuICAgICAgLy8gcmVzdG9yZSBkaXNhYmxlc1xuICAgICAgbGV0IGRpc2FibGVSZXN0b3JlID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSlcbiAgICAgIGlmKGRpc2FibGVSZXN0b3JlICE9PSBudWxsKXtcbiAgICAgICAgZWwuaW5uZXJUZXh0ID0gZGlzYWJsZVJlc3RvcmVcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSlcbiAgICAgIH1cbiAgICAgIGxldCB0b0VsID0gRE9NLnByaXZhdGUoZWwsIFBIWF9SRUYpXG4gICAgICBpZih0b0VsKXtcbiAgICAgICAgbGV0IGhvb2sgPSB0aGlzLnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGVsLCB0b0VsKVxuICAgICAgICBET01QYXRjaC5wYXRjaEVsKGVsLCB0b0VsLCB0aGlzLmxpdmVTb2NrZXQuZ2V0QWN0aXZlRWxlbWVudCgpKVxuICAgICAgICBpZihob29rKXsgaG9vay5fX3VwZGF0ZWQoKSB9XG4gICAgICAgIERPTS5kZWxldGVQcml2YXRlKGVsLCBQSFhfUkVGKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBwdXRSZWYoZWxlbWVudHMsIGV2ZW50LCBvcHRzID0ge30pe1xuICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZisrXG4gICAgbGV0IGRpc2FibGVXaXRoID0gdGhpcy5iaW5kaW5nKFBIWF9ESVNBQkxFX1dJVEgpXG4gICAgaWYob3B0cy5sb2FkaW5nKXsgZWxlbWVudHMgPSBlbGVtZW50cy5jb25jYXQoRE9NLmFsbChkb2N1bWVudCwgb3B0cy5sb2FkaW5nKSl9XG5cbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoYHBoeC0ke2V2ZW50fS1sb2FkaW5nYClcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfUkVGLCBuZXdSZWYpXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRl9TUkMsIHRoaXMuZWwuaWQpXG4gICAgICBsZXQgZGlzYWJsZVRleHQgPSBlbC5nZXRBdHRyaWJ1dGUoZGlzYWJsZVdpdGgpXG4gICAgICBpZihkaXNhYmxlVGV4dCAhPT0gbnVsbCl7XG4gICAgICAgIGlmKCFlbC5nZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFKSl7XG4gICAgICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSwgZWwuaW5uZXJUZXh0KVxuICAgICAgICB9XG4gICAgICAgIGlmKGRpc2FibGVUZXh0ICE9PSBcIlwiKXsgZWwuaW5uZXJUZXh0ID0gZGlzYWJsZVRleHQgfVxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIFtuZXdSZWYsIGVsZW1lbnRzLCBvcHRzXVxuICB9XG5cbiAgY29tcG9uZW50SUQoZWwpe1xuICAgIGxldCBjaWQgPSBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpXG4gICAgcmV0dXJuIGNpZCA/IHBhcnNlSW50KGNpZCkgOiBudWxsXG4gIH1cblxuICB0YXJnZXRDb21wb25lbnRJRCh0YXJnZXQsIHRhcmdldEN0eCwgb3B0cyA9IHt9KXtcbiAgICBpZihpc0NpZCh0YXJnZXRDdHgpKXsgcmV0dXJuIHRhcmdldEN0eCB9XG5cbiAgICBsZXQgY2lkT3JTZWxlY3RvciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwidGFyZ2V0XCIpKVxuICAgIGlmKGlzQ2lkKGNpZE9yU2VsZWN0b3IpKXtcbiAgICAgIHJldHVybiBwYXJzZUludChjaWRPclNlbGVjdG9yKVxuICAgIH0gZWxzZSBpZih0YXJnZXRDdHggJiYgKGNpZE9yU2VsZWN0b3IgIT09IG51bGwgfHwgb3B0cy50YXJnZXQpKXtcbiAgICAgIHJldHVybiB0aGlzLmNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eCl7XG4gICAgaWYoaXNDaWQodGFyZ2V0Q3R4KSl7XG4gICAgICByZXR1cm4gdGFyZ2V0Q3R4XG4gICAgfSBlbHNlIGlmKHRhcmdldEN0eCl7XG4gICAgICByZXR1cm4gbWF5YmUodGFyZ2V0Q3R4LmNsb3Nlc3QoYFske1BIWF9DT01QT05FTlR9XWApLCBlbCA9PiB0aGlzLm93bnNFbGVtZW50KGVsKSAmJiB0aGlzLmNvbXBvbmVudElEKGVsKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBwdXNoSG9va0V2ZW50KHRhcmdldEN0eCwgZXZlbnQsIHBheWxvYWQsIG9uUmVwbHkpe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpe1xuICAgICAgdGhpcy5sb2coXCJob29rXCIsICgpID0+IFtcInVuYWJsZSB0byBwdXNoIGhvb2sgZXZlbnQuIExpdmVWaWV3IG5vdCBjb25uZWN0ZWRcIiwgZXZlbnQsIHBheWxvYWRdKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGxldCBbcmVmLCBlbHMsIG9wdHNdID0gdGhpcy5wdXRSZWYoW10sIFwiaG9va1wiKVxuICAgIHRoaXMucHVzaFdpdGhSZXBseSgoKSA9PiBbcmVmLCBlbHMsIG9wdHNdLCBcImV2ZW50XCIsIHtcbiAgICAgIHR5cGU6IFwiaG9va1wiLFxuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgdmFsdWU6IHBheWxvYWQsXG4gICAgICBjaWQ6IHRoaXMuY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eClcbiAgICB9LCAocmVzcCwgcmVwbHkpID0+IG9uUmVwbHkocmVwbHksIHJlZikpXG5cbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICBleHRyYWN0TWV0YShlbCwgbWV0YSwgdmFsdWUpe1xuICAgIGxldCBwcmVmaXggPSB0aGlzLmJpbmRpbmcoXCJ2YWx1ZS1cIilcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZWwuYXR0cmlidXRlcy5sZW5ndGg7IGkrKyl7XG4gICAgICBpZighbWV0YSl7IG1ldGEgPSB7fSB9XG4gICAgICBsZXQgbmFtZSA9IGVsLmF0dHJpYnV0ZXNbaV0ubmFtZVxuICAgICAgaWYobmFtZS5zdGFydHNXaXRoKHByZWZpeCkpeyBtZXRhW25hbWUucmVwbGFjZShwcmVmaXgsIFwiXCIpXSA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKSB9XG4gICAgfVxuICAgIGlmKGVsLnZhbHVlICE9PSB1bmRlZmluZWQpe1xuICAgICAgaWYoIW1ldGEpeyBtZXRhID0ge30gfVxuICAgICAgbWV0YS52YWx1ZSA9IGVsLnZhbHVlXG5cbiAgICAgIGlmKGVsLnRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiBDSEVDS0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZSkgPj0gMCAmJiAhZWwuY2hlY2tlZCl7XG4gICAgICAgIGRlbGV0ZSBtZXRhLnZhbHVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmKHZhbHVlKXtcbiAgICAgIGlmKCFtZXRhKXsgbWV0YSA9IHt9IH1cbiAgICAgIGZvcihsZXQga2V5IGluIHZhbHVlKXsgbWV0YVtrZXldID0gdmFsdWVba2V5XSB9XG4gICAgfVxuICAgIHJldHVybiBtZXRhXG4gIH1cblxuICBwdXNoRXZlbnQodHlwZSwgZWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIG1ldGEsIG9wdHMgPSB7fSl7XG4gICAgdGhpcy5wdXNoV2l0aFJlcGx5KCgpID0+IHRoaXMucHV0UmVmKFtlbF0sIHR5cGUsIG9wdHMpLCBcImV2ZW50XCIsIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICB2YWx1ZTogdGhpcy5leHRyYWN0TWV0YShlbCwgbWV0YSwgb3B0cy52YWx1ZSksXG4gICAgICBjaWQ6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoZWwsIHRhcmdldEN0eCwgb3B0cylcbiAgICB9KVxuICB9XG5cbiAgcHVzaEZpbGVQcm9ncmVzcyhmaWxlRWwsIGVudHJ5UmVmLCBwcm9ncmVzcywgb25SZXBseSA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICB0aGlzLmxpdmVTb2NrZXQud2l0aGluT3duZXJzKGZpbGVFbC5mb3JtLCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICB2aWV3LnB1c2hXaXRoUmVwbHkobnVsbCwgXCJwcm9ncmVzc1wiLCB7XG4gICAgICAgIGV2ZW50OiBmaWxlRWwuZ2V0QXR0cmlidXRlKHZpZXcuYmluZGluZyhQSFhfUFJPR1JFU1MpKSxcbiAgICAgICAgcmVmOiBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSxcbiAgICAgICAgZW50cnlfcmVmOiBlbnRyeVJlZixcbiAgICAgICAgcHJvZ3Jlc3M6IHByb2dyZXNzLFxuICAgICAgICBjaWQ6IHZpZXcudGFyZ2V0Q29tcG9uZW50SUQoZmlsZUVsLmZvcm0sIHRhcmdldEN0eClcbiAgICAgIH0sIG9uUmVwbHkpXG4gICAgfSlcbiAgfVxuXG4gIHB1c2hJbnB1dChpbnB1dEVsLCB0YXJnZXRDdHgsIGZvcmNlQ2lkLCBwaHhFdmVudCwgb3B0cywgY2FsbGJhY2spe1xuICAgIGxldCB1cGxvYWRzXG4gICAgbGV0IGNpZCA9IGlzQ2lkKGZvcmNlQ2lkKSA/IGZvcmNlQ2lkIDogdGhpcy50YXJnZXRDb21wb25lbnRJRChpbnB1dEVsLmZvcm0sIHRhcmdldEN0eClcbiAgICBsZXQgcmVmR2VuZXJhdG9yID0gKCkgPT4gdGhpcy5wdXRSZWYoW2lucHV0RWwsIGlucHV0RWwuZm9ybV0sIFwiY2hhbmdlXCIsIG9wdHMpXG4gICAgbGV0IGZvcm1EYXRhXG4gICAgaWYoaW5wdXRFbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpKSl7XG4gICAgICBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oaW5wdXRFbC5mb3JtLCB7X3RhcmdldDogb3B0cy5fdGFyZ2V0fSwgW2lucHV0RWwubmFtZV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShpbnB1dEVsLmZvcm0sIHtfdGFyZ2V0OiBvcHRzLl90YXJnZXR9KVxuICAgIH1cbiAgICBpZihET00uaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBpbnB1dEVsLmZpbGVzICYmIGlucHV0RWwuZmlsZXMubGVuZ3RoID4gMCl7XG4gICAgICBMaXZlVXBsb2FkZXIudHJhY2tGaWxlcyhpbnB1dEVsLCBBcnJheS5mcm9tKGlucHV0RWwuZmlsZXMpKVxuICAgIH1cbiAgICB1cGxvYWRzID0gTGl2ZVVwbG9hZGVyLnNlcmlhbGl6ZVVwbG9hZHMoaW5wdXRFbClcbiAgICBsZXQgZXZlbnQgPSB7XG4gICAgICB0eXBlOiBcImZvcm1cIixcbiAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgIHVwbG9hZHM6IHVwbG9hZHMsXG4gICAgICBjaWQ6IGNpZFxuICAgIH1cbiAgICB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuZXJhdG9yLCBcImV2ZW50XCIsIGV2ZW50LCByZXNwID0+IHtcbiAgICAgIERPTS5zaG93RXJyb3IoaW5wdXRFbCwgdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoUEhYX0ZFRURCQUNLX0ZPUikpXG4gICAgICBpZihET00uaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBpbnB1dEVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWF1dG8tdXBsb2FkXCIpICE9PSBudWxsKXtcbiAgICAgICAgaWYoTGl2ZVVwbG9hZGVyLmZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXRFbCkubGVuZ3RoID4gMCl7XG4gICAgICAgICAgbGV0IFtyZWYsIF9lbHNdID0gcmVmR2VuZXJhdG9yKClcbiAgICAgICAgICB0aGlzLnVwbG9hZEZpbGVzKGlucHV0RWwuZm9ybSwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgKF91cGxvYWRzKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwKVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQXdhaXRpbmdTdWJtaXQoaW5wdXRFbC5mb3JtKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3ApXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHRyaWdnZXJBd2FpdGluZ1N1Ym1pdChmb3JtRWwpe1xuICAgIGxldCBhd2FpdGluZ1N1Ym1pdCA9IHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbClcbiAgICBpZihhd2FpdGluZ1N1Ym1pdCl7XG4gICAgICBsZXQgW19lbCwgX3JlZiwgX29wdHMsIGNhbGxiYWNrXSA9IGF3YWl0aW5nU3VibWl0XG4gICAgICB0aGlzLmNhbmNlbFN1Ym1pdChmb3JtRWwpXG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbCl7XG4gICAgcmV0dXJuIHRoaXMuZm9ybVN1Ym1pdHMuZmluZCgoW2VsLCBfcmVmLCBfb3B0cywgX2NhbGxiYWNrXSkgPT4gZWwuaXNTYW1lTm9kZShmb3JtRWwpKVxuICB9XG5cbiAgc2NoZWR1bGVTdWJtaXQoZm9ybUVsLCByZWYsIG9wdHMsIGNhbGxiYWNrKXtcbiAgICBpZih0aGlzLmdldFNjaGVkdWxlZFN1Ym1pdChmb3JtRWwpKXsgcmV0dXJuIHRydWUgfVxuICAgIHRoaXMuZm9ybVN1Ym1pdHMucHVzaChbZm9ybUVsLCByZWYsIG9wdHMsIGNhbGxiYWNrXSlcbiAgfVxuXG4gIGNhbmNlbFN1Ym1pdChmb3JtRWwpe1xuICAgIHRoaXMuZm9ybVN1Ym1pdHMgPSB0aGlzLmZvcm1TdWJtaXRzLmZpbHRlcigoW2VsLCByZWYsIF9jYWxsYmFja10pID0+IHtcbiAgICAgIGlmKGVsLmlzU2FtZU5vZGUoZm9ybUVsKSl7XG4gICAgICAgIHRoaXMudW5kb1JlZnMocmVmKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHB1c2hGb3JtU3VibWl0KGZvcm1FbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgb3B0cywgb25SZXBseSl7XG4gICAgbGV0IGZpbHRlcklnbm9yZWQgPSBlbCA9PiB7XG4gICAgICBsZXQgdXNlcklnbm9yZWQgPSBjbG9zZXN0UGh4QmluZGluZyhlbCwgYCR7dGhpcy5iaW5kaW5nKFBIWF9VUERBVEUpfT1pZ25vcmVgLCBlbC5mb3JtKVxuICAgICAgcmV0dXJuICEodXNlcklnbm9yZWQgfHwgY2xvc2VzdFBoeEJpbmRpbmcoZWwsIFwiZGF0YS1waHgtdXBkYXRlPWlnbm9yZVwiLCBlbC5mb3JtKSlcbiAgICB9XG4gICAgbGV0IGZpbHRlckRpc2FibGVzID0gZWwgPT4ge1xuICAgICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0RJU0FCTEVfV0lUSCkpXG4gICAgfVxuICAgIGxldCBmaWx0ZXJCdXR0b24gPSBlbCA9PiBlbC50YWdOYW1lID09IFwiQlVUVE9OXCJcblxuICAgIGxldCBmaWx0ZXJJbnB1dCA9IGVsID0+IFtcIklOUFVUXCIsIFwiVEVYVEFSRUFcIiwgXCJTRUxFQ1RcIl0uaW5jbHVkZXMoZWwudGFnTmFtZSlcblxuICAgIGxldCByZWZHZW5lcmF0b3IgPSAoKSA9PiB7XG4gICAgICBsZXQgZm9ybUVsZW1lbnRzID0gQXJyYXkuZnJvbShmb3JtRWwuZWxlbWVudHMpXG4gICAgICBsZXQgZGlzYWJsZXMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlckRpc2FibGVzKVxuICAgICAgbGV0IGJ1dHRvbnMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlckJ1dHRvbikuZmlsdGVyKGZpbHRlcklnbm9yZWQpXG4gICAgICBsZXQgaW5wdXRzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJJbnB1dCkuZmlsdGVyKGZpbHRlcklnbm9yZWQpXG5cbiAgICAgIGJ1dHRvbnMuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRCwgYnV0dG9uLmRpc2FibGVkKVxuICAgICAgICBidXR0b24uZGlzYWJsZWQgPSB0cnVlXG4gICAgICB9KVxuICAgICAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX1JFQURPTkxZLCBpbnB1dC5yZWFkT25seSlcbiAgICAgICAgaW5wdXQucmVhZE9ubHkgPSB0cnVlXG4gICAgICAgIGlmKGlucHV0LmZpbGVzKXtcbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBpbnB1dC5kaXNhYmxlZClcbiAgICAgICAgICBpbnB1dC5kaXNhYmxlZCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGZvcm1FbC5zZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9QQUdFX0xPQURJTkcpLCBcIlwiKVxuICAgICAgcmV0dXJuIHRoaXMucHV0UmVmKFtmb3JtRWxdLmNvbmNhdChkaXNhYmxlcykuY29uY2F0KGJ1dHRvbnMpLmNvbmNhdChpbnB1dHMpLCBcInN1Ym1pdFwiLCBvcHRzKVxuICAgIH1cblxuICAgIGxldCBjaWQgPSB0aGlzLnRhcmdldENvbXBvbmVudElEKGZvcm1FbCwgdGFyZ2V0Q3R4KVxuICAgIGlmKExpdmVVcGxvYWRlci5oYXNVcGxvYWRzSW5Qcm9ncmVzcyhmb3JtRWwpKXtcbiAgICAgIGxldCBbcmVmLCBfZWxzXSA9IHJlZkdlbmVyYXRvcigpXG4gICAgICBsZXQgcHVzaCA9ICgpID0+IHRoaXMucHVzaEZvcm1TdWJtaXQoZm9ybUVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzLCBvblJlcGx5KVxuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVTdWJtaXQoZm9ybUVsLCByZWYsIG9wdHMsIHB1c2gpXG4gICAgfSBlbHNlIGlmKExpdmVVcGxvYWRlci5pbnB1dHNBd2FpdGluZ1ByZWZsaWdodChmb3JtRWwpLmxlbmd0aCA+IDApe1xuICAgICAgbGV0IFtyZWYsIGVsc10gPSByZWZHZW5lcmF0b3IoKVxuICAgICAgbGV0IHByb3h5UmVmR2VuID0gKCkgPT4gW3JlZiwgZWxzLCBvcHRzXVxuICAgICAgdGhpcy51cGxvYWRGaWxlcyhmb3JtRWwsIHRhcmdldEN0eCwgcmVmLCBjaWQsIChfdXBsb2FkcykgPT4ge1xuICAgICAgICBsZXQgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGZvcm1FbCwge30pXG4gICAgICAgIHRoaXMucHVzaFdpdGhSZXBseShwcm94eVJlZkdlbiwgXCJldmVudFwiLCB7XG4gICAgICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgICBjaWQ6IGNpZFxuICAgICAgICB9LCBvblJlcGx5KVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShmb3JtRWwsIHt9KVxuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgXCJldmVudFwiLCB7XG4gICAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgY2lkOiBjaWRcbiAgICAgIH0sIG9uUmVwbHkpXG4gICAgfVxuICB9XG5cbiAgdXBsb2FkRmlsZXMoZm9ybUVsLCB0YXJnZXRDdHgsIHJlZiwgY2lkLCBvbkNvbXBsZXRlKXtcbiAgICBsZXQgam9pbkNvdW50QXRVcGxvYWQgPSB0aGlzLmpvaW5Db3VudFxuICAgIGxldCBpbnB1dEVscyA9IExpdmVVcGxvYWRlci5hY3RpdmVGaWxlSW5wdXRzKGZvcm1FbClcbiAgICBsZXQgbnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MgPSBpbnB1dEVscy5sZW5ndGhcblxuICAgIC8vIGdldCBlYWNoIGZpbGUgaW5wdXRcbiAgICBpbnB1dEVscy5mb3JFYWNoKGlucHV0RWwgPT4ge1xuICAgICAgbGV0IHVwbG9hZGVyID0gbmV3IExpdmVVcGxvYWRlcihpbnB1dEVsLCB0aGlzLCAoKSA9PiB7XG4gICAgICAgIG51bUZpbGVJbnB1dHNJblByb2dyZXNzLS1cbiAgICAgICAgaWYobnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MgPT09IDApeyBvbkNvbXBsZXRlKCkgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMudXBsb2FkZXJzW2lucHV0RWxdID0gdXBsb2FkZXJcbiAgICAgIGxldCBlbnRyaWVzID0gdXBsb2FkZXIuZW50cmllcygpLm1hcChlbnRyeSA9PiBlbnRyeS50b1ByZWZsaWdodFBheWxvYWQoKSlcblxuICAgICAgbGV0IHBheWxvYWQgPSB7XG4gICAgICAgIHJlZjogaW5wdXRFbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpLFxuICAgICAgICBlbnRyaWVzOiBlbnRyaWVzLFxuICAgICAgICBjaWQ6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoaW5wdXRFbC5mb3JtLCB0YXJnZXRDdHgpXG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nKFwidXBsb2FkXCIsICgpID0+IFtcInNlbmRpbmcgcHJlZmxpZ2h0IHJlcXVlc3RcIiwgcGF5bG9hZF0pXG5cbiAgICAgIHRoaXMucHVzaFdpdGhSZXBseShudWxsLCBcImFsbG93X3VwbG9hZFwiLCBwYXlsb2FkLCByZXNwID0+IHtcbiAgICAgICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW1wiZ290IHByZWZsaWdodCByZXNwb25zZVwiLCByZXNwXSlcbiAgICAgICAgaWYocmVzcC5lcnJvcil7XG4gICAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYpXG4gICAgICAgICAgbGV0IFtlbnRyeV9yZWYsIHJlYXNvbl0gPSByZXNwLmVycm9yXG4gICAgICAgICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW2BlcnJvciBmb3IgZW50cnkgJHtlbnRyeV9yZWZ9YCwgcmVhc29uXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgb25FcnJvciA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLm9uRXJyb3IoKCkgPT4ge1xuICAgICAgICAgICAgICBpZih0aGlzLmpvaW5Db3VudCA9PT0gam9pbkNvdW50QXRVcGxvYWQpeyBjYWxsYmFjaygpIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIHVwbG9hZGVyLmluaXRBZGFwdGVyVXBsb2FkKHJlc3AsIG9uRXJyb3IsIHRoaXMubGl2ZVNvY2tldClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgZGlzcGF0Y2hVcGxvYWRzKG5hbWUsIGZpbGVzT3JCbG9icyl7XG4gICAgbGV0IGlucHV0cyA9IERPTS5maW5kVXBsb2FkSW5wdXRzKHRoaXMuZWwpLmZpbHRlcihlbCA9PiBlbC5uYW1lID09PSBuYW1lKVxuICAgIGlmKGlucHV0cy5sZW5ndGggPT09IDApeyBsb2dFcnJvcihgbm8gbGl2ZSBmaWxlIGlucHV0cyBmb3VuZCBtYXRjaGluZyB0aGUgbmFtZSBcIiR7bmFtZX1cImApIH1cbiAgICBlbHNlIGlmKGlucHV0cy5sZW5ndGggPiAxKXsgbG9nRXJyb3IoYGR1cGxpY2F0ZSBsaXZlIGZpbGUgaW5wdXRzIGZvdW5kIG1hdGNoaW5nIHRoZSBuYW1lIFwiJHtuYW1lfVwiYCkgfVxuICAgIGVsc2UgeyBET00uZGlzcGF0Y2hFdmVudChpbnB1dHNbMF0sIFBIWF9UUkFDS19VUExPQURTLCB7ZGV0YWlsOiB7ZmlsZXM6IGZpbGVzT3JCbG9ic319KSB9XG4gIH1cblxuICBwdXNoRm9ybVJlY292ZXJ5KGZvcm0sIG5ld0NpZCwgY2FsbGJhY2spe1xuICAgIHRoaXMubGl2ZVNvY2tldC53aXRoaW5Pd25lcnMoZm9ybSwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgbGV0IGlucHV0ID0gZm9ybS5lbGVtZW50c1swXVxuICAgICAgbGV0IHBoeEV2ZW50ID0gZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSB8fCBmb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpXG5cbiAgICAgIEpTLmV4ZWMoXCJjaGFuZ2VcIiwgcGh4RXZlbnQsIHZpZXcsIGlucHV0LCBbXCJwdXNoXCIsIHtfdGFyZ2V0OiBpbnB1dC5uYW1lLCBuZXdDaWQ6IG5ld0NpZCwgY2FsbGJhY2s6IGNhbGxiYWNrfV0pXG4gICAgfSlcbiAgfVxuXG4gIHB1c2hMaW5rUGF0Y2goaHJlZiwgdGFyZ2V0RWwsIGNhbGxiYWNrKXtcbiAgICBsZXQgbGlua1JlZiA9IHRoaXMubGl2ZVNvY2tldC5zZXRQZW5kaW5nTGluayhocmVmKVxuICAgIGxldCByZWZHZW4gPSB0YXJnZXRFbCA/ICgpID0+IHRoaXMucHV0UmVmKFt0YXJnZXRFbF0sIFwiY2xpY2tcIikgOiBudWxsXG4gICAgbGV0IGZhbGxiYWNrID0gKCkgPT4gdGhpcy5saXZlU29ja2V0LnJlZGlyZWN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuXG4gICAgbGV0IHB1c2ggPSB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuLCBcImxpdmVfcGF0Y2hcIiwge3VybDogaHJlZn0sIHJlc3AgPT4ge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBpZihyZXNwLmxpbmtfcmVkaXJlY3Qpe1xuICAgICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXBsYWNlTWFpbihocmVmLCBudWxsLCBjYWxsYmFjaywgbGlua1JlZilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZih0aGlzLmxpdmVTb2NrZXQuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpe1xuICAgICAgICAgICAgdGhpcy5ocmVmID0gaHJlZlxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFwcGx5UGVuZGluZ1VwZGF0ZXMoKVxuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGxpbmtSZWYpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGlmKHB1c2gpe1xuICAgICAgcHVzaC5yZWNlaXZlKFwidGltZW91dFwiLCBmYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgZmFsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIGZvcm1zRm9yUmVjb3ZlcnkoaHRtbCl7XG4gICAgaWYodGhpcy5qb2luQ291bnQgPT09IDApeyByZXR1cm4gW10gfVxuXG4gICAgbGV0IHBoeENoYW5nZSA9IHRoaXMuYmluZGluZyhcImNoYW5nZVwiKVxuICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWxcblxuICAgIHJldHVybiAoXG4gICAgICBET00uYWxsKHRoaXMuZWwsIGBmb3JtWyR7cGh4Q2hhbmdlfV1gKVxuICAgICAgICAuZmlsdGVyKGZvcm0gPT4gZm9ybS5pZCAmJiB0aGlzLm93bnNFbGVtZW50KGZvcm0pKVxuICAgICAgICAuZmlsdGVyKGZvcm0gPT4gZm9ybS5lbGVtZW50cy5sZW5ndGggPiAwKVxuICAgICAgICAuZmlsdGVyKGZvcm0gPT4gZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSAhPT0gXCJpZ25vcmVcIilcbiAgICAgICAgLm1hcChmb3JtID0+IHtcbiAgICAgICAgICBsZXQgbmV3Rm9ybSA9IHRlbXBsYXRlLmNvbnRlbnQucXVlcnlTZWxlY3RvcihgZm9ybVtpZD1cIiR7Zm9ybS5pZH1cIl1bJHtwaHhDaGFuZ2V9PVwiJHtmb3JtLmdldEF0dHJpYnV0ZShwaHhDaGFuZ2UpfVwiXWApXG4gICAgICAgICAgaWYobmV3Rm9ybSl7XG4gICAgICAgICAgICByZXR1cm4gW2Zvcm0sIG5ld0Zvcm0sIHRoaXMudGFyZ2V0Q29tcG9uZW50SUQobmV3Rm9ybSldXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbZm9ybSwgbnVsbCwgbnVsbF1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoKFtmb3JtLCBuZXdGb3JtLCBuZXdDaWRdKSA9PiBuZXdGb3JtKVxuICAgIClcbiAgfVxuXG4gIG1heWJlUHVzaENvbXBvbmVudHNEZXN0cm95ZWQoZGVzdHJveWVkQ0lEcyl7XG4gICAgbGV0IHdpbGxEZXN0cm95Q0lEcyA9IGRlc3Ryb3llZENJRHMuZmlsdGVyKGNpZCA9PiB7XG4gICAgICByZXR1cm4gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLCBjaWQpLmxlbmd0aCA9PT0gMFxuICAgIH0pXG4gICAgaWYod2lsbERlc3Ryb3lDSURzLmxlbmd0aCA+IDApe1xuICAgICAgdGhpcy5wcnVuaW5nQ0lEcy5wdXNoKC4uLndpbGxEZXN0cm95Q0lEcylcblxuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiY2lkc193aWxsX2Rlc3Ryb3lcIiwge2NpZHM6IHdpbGxEZXN0cm95Q0lEc30sICgpID0+IHtcbiAgICAgICAgLy8gVGhlIGNpZHMgYXJlIGVpdGhlciBiYWNrIG9uIHRoZSBwYWdlIG9yIHRoZXkgd2lsbCBiZSBmdWxseSByZW1vdmVkLFxuICAgICAgICAvLyBzbyB3ZSBjYW4gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgcHJ1bmluZ0NJRHMuXG4gICAgICAgIHRoaXMucHJ1bmluZ0NJRHMgPSB0aGlzLnBydW5pbmdDSURzLmZpbHRlcihjaWQgPT4gd2lsbERlc3Ryb3lDSURzLmluZGV4T2YoY2lkKSAhPT0gLTEpXG5cbiAgICAgICAgLy8gU2VlIGlmIGFueSBvZiB0aGUgY2lkcyB3ZSB3YW50ZWQgdG8gZGVzdHJveSB3ZXJlIGFkZGVkIGJhY2ssXG4gICAgICAgIC8vIGlmIHRoZXkgd2VyZSBhZGRlZCBiYWNrLCB3ZSBkb24ndCBhY3R1YWxseSBkZXN0cm95IHRoZW0uXG4gICAgICAgIGxldCBjb21wbGV0ZWx5RGVzdHJveUNJRHMgPSB3aWxsRGVzdHJveUNJRHMuZmlsdGVyKGNpZCA9PiB7XG4gICAgICAgICAgcmV0dXJuIERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgY2lkKS5sZW5ndGggPT09IDBcbiAgICAgICAgfSlcblxuICAgICAgICBpZihjb21wbGV0ZWx5RGVzdHJveUNJRHMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiY2lkc19kZXN0cm95ZWRcIiwge2NpZHM6IGNvbXBsZXRlbHlEZXN0cm95Q0lEc30sIChyZXNwKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVkLnBydW5lQ0lEcyhyZXNwLmNpZHMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBvd25zRWxlbWVudChlbCl7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShQSFhfUEFSRU5UX0lEKSA9PT0gdGhpcy5pZCB8fFxuICAgICAgbWF5YmUoZWwuY2xvc2VzdChQSFhfVklFV19TRUxFQ1RPUiksIG5vZGUgPT4gbm9kZS5pZCkgPT09IHRoaXMuaWRcbiAgfVxuXG4gIHN1Ym1pdEZvcm0oZm9ybSwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgb3B0cyA9IHt9KXtcbiAgICBET00ucHV0UHJpdmF0ZShmb3JtLCBQSFhfSEFTX1NVQk1JVFRFRCwgdHJ1ZSlcbiAgICBsZXQgcGh4RmVlZGJhY2sgPSB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhQSFhfRkVFREJBQ0tfRk9SKVxuICAgIGxldCBpbnB1dHMgPSBBcnJheS5mcm9tKGZvcm0uZWxlbWVudHMpXG4gICAgdGhpcy5saXZlU29ja2V0LmJsdXJBY3RpdmVFbGVtZW50KHRoaXMpXG4gICAgdGhpcy5wdXNoRm9ybVN1Ym1pdChmb3JtLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzLCAoKSA9PiB7XG4gICAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBET00uc2hvd0Vycm9yKGlucHV0LCBwaHhGZWVkYmFjaykpXG4gICAgICB0aGlzLmxpdmVTb2NrZXQucmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1cygpXG4gICAgfSlcbiAgfVxuXG4gIGJpbmRpbmcoa2luZCl7IHJldHVybiB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhraW5kKSB9XG59XG4iLCAiLyoqIEluaXRpYWxpemVzIHRoZSBMaXZlU29ja2V0XG4gKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRQb2ludCAtIFRoZSBzdHJpbmcgV2ViU29ja2V0IGVuZHBvaW50LCBpZSwgYFwid3NzOi8vZXhhbXBsZS5jb20vbGl2ZVwiYCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXCIvbGl2ZVwiYCAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAqIEBwYXJhbSB7UGhvZW5peC5Tb2NrZXR9IHNvY2tldCAtIHRoZSByZXF1aXJlZCBQaG9lbml4IFNvY2tldCBjbGFzcyBpbXBvcnRlZCBmcm9tIFwicGhvZW5peFwiLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbiAqICAgICBpbXBvcnQge0xpdmVTb2NrZXR9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXG4gKiAgICAgbGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwgey4uLn0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24uIE91dHNpZGUgb2Yga2V5cyBsaXN0ZWQgYmVsb3csIGFsbFxuICogY29uZmlndXJhdGlvbiBpcyBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIFBob2VuaXggU29ja2V0IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmRlZmF1bHRzXSAtIFRoZSBvcHRpb25hbCBkZWZhdWx0cyB0byB1c2UgZm9yIHZhcmlvdXMgYmluZGluZ3MsXG4gKiBzdWNoIGFzIGBwaHgtZGVib3VuY2VgLiBTdXBwb3J0cyB0aGUgZm9sbG93aW5nIGtleXM6XG4gKlxuICogICAtIGRlYm91bmNlIC0gdGhlIG1pbGxpc2Vjb25kIHBoeC1kZWJvdW5jZSB0aW1lLiBEZWZhdWx0cyAzMDBcbiAqICAgLSB0aHJvdHRsZSAtIHRoZSBtaWxsaXNlY29uZCBwaHgtdGhyb3R0bGUgdGltZS4gRGVmYXVsdHMgMzAwXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMucGFyYW1zXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3IgcGFzc2luZyBjb25uZWN0IHBhcmFtcy5cbiAqIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBMaXZlVmlldy4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIChlbCkgPT4ge3ZpZXc6IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtbXktdmlldy1uYW1lXCIsIHRva2VuOiB3aW5kb3cubXlUb2tlbn1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmluZGluZ1ByZWZpeF0gLSBUaGUgb3B0aW9uYWwgcHJlZml4IHRvIHVzZSBmb3IgYWxsIHBoeCBET00gYW5ub3RhdGlvbnMuXG4gKiBEZWZhdWx0cyB0byBcInBoeC1cIi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5ob29rc10gLSBUaGUgb3B0aW9uYWwgb2JqZWN0IGZvciByZWZlcmVuY2luZyBMaXZlVmlldyBob29rIGNhbGxiYWNrcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy51cGxvYWRlcnNdIC0gVGhlIG9wdGlvbmFsIG9iamVjdCBmb3IgcmVmZXJlbmNpbmcgTGl2ZVZpZXcgdXBsb2FkZXIgY2FsbGJhY2tzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5sb2FkZXJUaW1lb3V0XSAtIFRoZSBvcHRpb25hbCBkZWxheSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgYXBwbHlcbiAqIGxvYWRpbmcgc3RhdGVzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5tYXhSZWxvYWRzXSAtIFRoZSBtYXhpbXVtIHJlbG9hZHMgYmVmb3JlIGVudGVyaW5nIGZhaWxzYWZlIG1vZGUuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLnJlbG9hZEppdHRlck1pbl0gLSBUaGUgbWluaW11bSB0aW1lIGJldHdlZW4gbm9ybWFsIHJlbG9hZCBhdHRlbXB0cy5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMucmVsb2FkSml0dGVyTWF4XSAtIFRoZSBtYXhpbXVtIHRpbWUgYmV0d2VlbiBub3JtYWwgcmVsb2FkIGF0dGVtcHRzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5mYWlsc2FmZUppdHRlcl0gLSBUaGUgdGltZSBiZXR3ZWVuIHJlbG9hZCBhdHRlbXB0cyBpbiBmYWlsc2FmZSBtb2RlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMudmlld0xvZ2dlcl0gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9nIGRlYnVnIGluZm9ybWF0aW9uLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgKHZpZXcsIGtpbmQsIG1zZywgb2JqKSA9PiBjb25zb2xlLmxvZyhgJHt2aWV3LmlkfSAke2tpbmR9OiAke21zZ30gLSBgLCBvYmopXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLm1ldGFkYXRhXSAtIFRoZSBvcHRpb25hbCBvYmplY3QgbWFwcGluZyBldmVudCBuYW1lcyB0byBmdW5jdGlvbnMgZm9yXG4gKiBwb3B1bGF0aW5nIGV2ZW50IG1ldGFkYXRhLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgbWV0YWRhdGE6IHtcbiAqICAgICAgIGNsaWNrOiAoZSwgZWwpID0+IHtcbiAqICAgICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gKiAgICAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxuICogICAgICAgICAgIGRldGFpbDogZS5kZXRhaWwgfHwgMSxcbiAqICAgICAgICAgfVxuICogICAgICAgfSxcbiAqICAgICAgIGtleWRvd246IChlLCBlbCkgPT4ge1xuICogICAgICAgICByZXR1cm4ge1xuICogICAgICAgICAgIGtleTogZS5rZXksXG4gKiAgICAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICogICAgICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcbiAqICAgICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleVxuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnNlc3Npb25TdG9yYWdlXSAtIEFuIG9wdGlvbmFsIFN0b3JhZ2UgY29tcGF0aWJsZSBvYmplY3RcbiAqIFVzZWZ1bCB3aGVuIExpdmVWaWV3IHdvbid0IGhhdmUgYWNjZXNzIHRvIGBzZXNzaW9uU3RvcmFnZWAuICBGb3IgZXhhbXBsZSwgVGhpcyBjb3VsZFxuICogaGFwcGVuIGlmIGEgc2l0ZSBsb2FkcyBhIGNyb3NzLWRvbWFpbiBMaXZlVmlldyBpbiBhbiBpZnJhbWUuICBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgICBjbGFzcyBJbk1lbW9yeVN0b3JhZ2Uge1xuICogICAgICAgY29uc3RydWN0b3IoKSB7IHRoaXMuc3RvcmFnZSA9IHt9IH1cbiAqICAgICAgIGdldEl0ZW0oa2V5TmFtZSkgeyByZXR1cm4gdGhpcy5zdG9yYWdlW2tleU5hbWVdIH1cbiAqICAgICAgIHJlbW92ZUl0ZW0oa2V5TmFtZSkgeyBkZWxldGUgdGhpcy5zdG9yYWdlW2tleU5hbWVdIH1cbiAqICAgICAgIHNldEl0ZW0oa2V5TmFtZSwga2V5VmFsdWUpIHsgdGhpcy5zdG9yYWdlW2tleU5hbWVdID0ga2V5VmFsdWUgfVxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMubG9jYWxTdG9yYWdlXSAtIEFuIG9wdGlvbmFsIFN0b3JhZ2UgY29tcGF0aWJsZSBvYmplY3RcbiAqIFVzZWZ1bCBmb3Igd2hlbiBMaXZlVmlldyB3b24ndCBoYXZlIGFjY2VzcyB0byBgbG9jYWxTdG9yYWdlYC5cbiAqIFNlZSBgb3B0cy5zZXNzaW9uU3RvcmFnZWAgZm9yIGV4YW1wbGVzLlxuKi9cblxuaW1wb3J0IHtcbiAgQklORElOR19QUkVGSVgsXG4gIENPTlNFQ1VUSVZFX1JFTE9BRFMsXG4gIERFRkFVTFRTLFxuICBGQUlMU0FGRV9KSVRURVIsXG4gIExPQURFUl9USU1FT1VULFxuICBNQVhfUkVMT0FEUyxcbiAgUEhYX0RFQk9VTkNFLFxuICBQSFhfRFJPUF9UQVJHRVQsXG4gIFBIWF9IQVNfRk9DVVNFRCxcbiAgUEhYX0tFWSxcbiAgUEhYX0xJTktfU1RBVEUsXG4gIFBIWF9MSVZFX0xJTkssXG4gIFBIWF9MVl9ERUJVRyxcbiAgUEhYX0xWX0xBVEVOQ1lfU0lNLFxuICBQSFhfTFZfUFJPRklMRSxcbiAgUEhYX01BSU4sXG4gIFBIWF9QQVJFTlRfSUQsXG4gIFBIWF9WSUVXX1NFTEVDVE9SLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1RIUk9UVExFLFxuICBQSFhfVFJBQ0tfVVBMT0FEUyxcbiAgUEhYX1NFU1NJT04sXG4gIFJFTE9BRF9KSVRURVJfTUlOLFxuICBSRUxPQURfSklUVEVSX01BWCxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgY2xvbmUsXG4gIGNsb3Nlc3RQaHhCaW5kaW5nLFxuICBjbG9zdXJlLFxuICBkZWJ1ZyxcbiAgaXNPYmplY3QsXG4gIG1heWJlXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IEJyb3dzZXIgZnJvbSBcIi4vYnJvd3NlclwiXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgSG9va3MgZnJvbSBcIi4vaG9va3NcIlxuaW1wb3J0IExpdmVVcGxvYWRlciBmcm9tIFwiLi9saXZlX3VwbG9hZGVyXCJcbmltcG9ydCBWaWV3IGZyb20gXCIuL3ZpZXdcIlxuaW1wb3J0IEpTIGZyb20gXCIuL2pzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl2ZVNvY2tldCB7XG4gIGNvbnN0cnVjdG9yKHVybCwgcGh4U29ja2V0LCBvcHRzID0ge30pe1xuICAgIHRoaXMudW5sb2FkZWQgPSBmYWxzZVxuICAgIGlmKCFwaHhTb2NrZXQgfHwgcGh4U29ja2V0LmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiT2JqZWN0XCIpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgIGEgcGhvZW5peCBTb2NrZXQgbXVzdCBiZSBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBMaXZlU29ja2V0IGNvbnN0cnVjdG9yLiBGb3IgZXhhbXBsZTpcblxuICAgICAgICAgIGltcG9ydCB7U29ja2V0fSBmcm9tIFwicGhvZW5peFwiXG4gICAgICAgICAgaW1wb3J0IHtMaXZlU29ja2V0fSBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIlxuICAgICAgICAgIGxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHsuLi59KVxuICAgICAgYClcbiAgICB9XG4gICAgdGhpcy5zb2NrZXQgPSBuZXcgcGh4U29ja2V0KHVybCwgb3B0cylcbiAgICB0aGlzLmJpbmRpbmdQcmVmaXggPSBvcHRzLmJpbmRpbmdQcmVmaXggfHwgQklORElOR19QUkVGSVhcbiAgICB0aGlzLm9wdHMgPSBvcHRzXG4gICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKG9wdHMucGFyYW1zIHx8IHt9KVxuICAgIHRoaXMudmlld0xvZ2dlciA9IG9wdHMudmlld0xvZ2dlclxuICAgIHRoaXMubWV0YWRhdGFDYWxsYmFja3MgPSBvcHRzLm1ldGFkYXRhIHx8IHt9XG4gICAgdGhpcy5kZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oY2xvbmUoREVGQVVMVFMpLCBvcHRzLmRlZmF1bHRzIHx8IHt9KVxuICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IG51bGxcbiAgICB0aGlzLnByZXZBY3RpdmUgPSBudWxsXG4gICAgdGhpcy5zaWxlbmNlZCA9IGZhbHNlXG4gICAgdGhpcy5tYWluID0gbnVsbFxuICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSBudWxsXG4gICAgdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCA9IG51bGxcbiAgICB0aGlzLmxpbmtSZWYgPSAxXG4gICAgdGhpcy5yb290cyA9IHt9XG4gICAgdGhpcy5ocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICB0aGlzLnBlbmRpbmdMaW5rID0gbnVsbFxuICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gY2xvbmUod2luZG93LmxvY2F0aW9uKVxuICAgIHRoaXMuaG9va3MgPSBvcHRzLmhvb2tzIHx8IHt9XG4gICAgdGhpcy51cGxvYWRlcnMgPSBvcHRzLnVwbG9hZGVycyB8fCB7fVxuICAgIHRoaXMubG9hZGVyVGltZW91dCA9IG9wdHMubG9hZGVyVGltZW91dCB8fCBMT0FERVJfVElNRU9VVFxuICAgIHRoaXMucmVsb2FkV2l0aEppdHRlclRpbWVyID0gbnVsbFxuICAgIHRoaXMubWF4UmVsb2FkcyA9IG9wdHMubWF4UmVsb2FkcyB8fCBNQVhfUkVMT0FEU1xuICAgIHRoaXMucmVsb2FkSml0dGVyTWluID0gb3B0cy5yZWxvYWRKaXR0ZXJNaW4gfHwgUkVMT0FEX0pJVFRFUl9NSU5cbiAgICB0aGlzLnJlbG9hZEppdHRlck1heCA9IG9wdHMucmVsb2FkSml0dGVyTWF4IHx8IFJFTE9BRF9KSVRURVJfTUFYXG4gICAgdGhpcy5mYWlsc2FmZUppdHRlciA9IG9wdHMuZmFpbHNhZmVKaXR0ZXIgfHwgRkFJTFNBRkVfSklUVEVSXG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSBvcHRzLmxvY2FsU3RvcmFnZSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlXG4gICAgdGhpcy5zZXNzaW9uU3RvcmFnZSA9IG9wdHMuc2Vzc2lvblN0b3JhZ2UgfHwgd2luZG93LnNlc3Npb25TdG9yYWdlXG4gICAgdGhpcy5ib3VuZFRvcExldmVsRXZlbnRzID0gZmFsc2VcbiAgICB0aGlzLmRvbUNhbGxiYWNrcyA9IE9iamVjdC5hc3NpZ24oe29uTm9kZUFkZGVkOiBjbG9zdXJlKCksIG9uQmVmb3JlRWxVcGRhdGVkOiBjbG9zdXJlKCl9LCBvcHRzLmRvbSB8fCB7fSlcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gbmV3IFRyYW5zaXRpb25TZXQoKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX2UgPT4ge1xuICAgICAgdGhpcy51bmxvYWRlZCA9IHRydWVcbiAgICB9KVxuICAgIHRoaXMuc29ja2V0Lm9uT3BlbigoKSA9PiB7XG4gICAgICBpZih0aGlzLmlzVW5sb2FkZWQoKSl7XG4gICAgICAgIC8vIHJlbG9hZCBwYWdlIGlmIGJlaW5nIHJlc3RvcmVkIGZyb20gYmFjay9mb3J3YXJkIGNhY2hlIGFuZCBicm93c2VyIGRvZXMgbm90IGVtaXQgXCJwYWdlc2hvd1wiXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBwdWJsaWNcblxuICBpc1Byb2ZpbGVFbmFibGVkKCl7IHJldHVybiB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX1BST0ZJTEUpID09PSBcInRydWVcIiB9XG5cbiAgaXNEZWJ1Z0VuYWJsZWQoKXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfREVCVUcpID09PSBcInRydWVcIiB9XG5cbiAgaXNEZWJ1Z0Rpc2FibGVkKCl7IHJldHVybiB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX0RFQlVHKSA9PT0gXCJmYWxzZVwiIH1cblxuICBlbmFibGVEZWJ1ZygpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX0RFQlVHLCBcInRydWVcIikgfVxuXG4gIGVuYWJsZVByb2ZpbGluZygpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX1BST0ZJTEUsIFwidHJ1ZVwiKSB9XG5cbiAgZGlzYWJsZURlYnVnKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfREVCVUcsIFwiZmFsc2VcIikgfVxuXG4gIGRpc2FibGVQcm9maWxpbmcoKXsgdGhpcy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFBIWF9MVl9QUk9GSUxFKSB9XG5cbiAgZW5hYmxlTGF0ZW5jeVNpbSh1cHBlckJvdW5kTXMpe1xuICAgIHRoaXMuZW5hYmxlRGVidWcoKVxuICAgIGNvbnNvbGUubG9nKFwibGF0ZW5jeSBzaW11bGF0b3IgZW5hYmxlZCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoaXMgYnJvd3NlciBzZXNzaW9uLiBDYWxsIGRpc2FibGVMYXRlbmN5U2ltKCkgdG8gZGlzYWJsZVwiKVxuICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfTEFURU5DWV9TSU0sIHVwcGVyQm91bmRNcylcbiAgfVxuXG4gIGRpc2FibGVMYXRlbmN5U2ltKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShQSFhfTFZfTEFURU5DWV9TSU0pIH1cblxuICBnZXRMYXRlbmN5U2ltKCl7XG4gICAgbGV0IHN0ciA9IHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfTEFURU5DWV9TSU0pXG4gICAgcmV0dXJuIHN0ciA/IHBhcnNlSW50KHN0cikgOiBudWxsXG4gIH1cblxuICBnZXRTb2NrZXQoKXsgcmV0dXJuIHRoaXMuc29ja2V0IH1cblxuICBjb25uZWN0KCl7XG4gICAgLy8gZW5hYmxlIGRlYnVnIGJ5IGRlZmF1bHQgaWYgb24gbG9jYWxob3N0IGFuZCBub3QgZXhwbGljaXRseSBkaXNhYmxlZFxuICAgIGlmKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PT0gXCJsb2NhbGhvc3RcIiAmJiAhdGhpcy5pc0RlYnVnRGlzYWJsZWQoKSl7IHRoaXMuZW5hYmxlRGVidWcoKSB9XG4gICAgbGV0IGRvQ29ubmVjdCA9ICgpID0+IHtcbiAgICAgIGlmKHRoaXMuam9pblJvb3RWaWV3cygpKXtcbiAgICAgICAgdGhpcy5iaW5kVG9wTGV2ZWxFdmVudHMoKVxuICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KClcbiAgICAgIH0gZWxzZSBpZih0aGlzLm1haW4pe1xuICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoW1wiY29tcGxldGVcIiwgXCJsb2FkZWRcIiwgXCJpbnRlcmFjdGl2ZVwiXS5pbmRleE9mKGRvY3VtZW50LnJlYWR5U3RhdGUpID49IDApe1xuICAgICAgZG9Db25uZWN0KClcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4gZG9Db25uZWN0KCkpXG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdChjYWxsYmFjayl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVsb2FkV2l0aEppdHRlclRpbWVyKVxuICAgIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoY2FsbGJhY2spXG4gIH1cblxuICByZXBsYWNlVHJhbnNwb3J0KHRyYW5zcG9ydCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVsb2FkV2l0aEppdHRlclRpbWVyKVxuICAgIHRoaXMuc29ja2V0LnJlcGxhY2VUcmFuc3BvcnQodHJhbnNwb3J0KVxuICAgIHRoaXMuY29ubmVjdCgpXG4gIH1cblxuICBleGVjSlMoZWwsIGVuY29kZWRKUywgZXZlbnRUeXBlID0gbnVsbCl7XG4gICAgdGhpcy5vd25lcihlbCwgdmlldyA9PiBKUy5leGVjKGV2ZW50VHlwZSwgZW5jb2RlZEpTLCB2aWV3LCBlbCkpXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgdHJpZ2dlckRPTShraW5kLCBhcmdzKXsgdGhpcy5kb21DYWxsYmFja3Nba2luZF0oLi4uYXJncykgfVxuXG4gIHRpbWUobmFtZSwgZnVuYyl7XG4gICAgaWYoIXRoaXMuaXNQcm9maWxlRW5hYmxlZCgpIHx8ICFjb25zb2xlLnRpbWUpeyByZXR1cm4gZnVuYygpIH1cbiAgICBjb25zb2xlLnRpbWUobmFtZSlcbiAgICBsZXQgcmVzdWx0ID0gZnVuYygpXG4gICAgY29uc29sZS50aW1lRW5kKG5hbWUpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgbG9nKHZpZXcsIGtpbmQsIG1zZ0NhbGxiYWNrKXtcbiAgICBpZih0aGlzLnZpZXdMb2dnZXIpe1xuICAgICAgbGV0IFttc2csIG9ial0gPSBtc2dDYWxsYmFjaygpXG4gICAgICB0aGlzLnZpZXdMb2dnZXIodmlldywga2luZCwgbXNnLCBvYmopXG4gICAgfSBlbHNlIGlmKHRoaXMuaXNEZWJ1Z0VuYWJsZWQoKSl7XG4gICAgICBsZXQgW21zZywgb2JqXSA9IG1zZ0NhbGxiYWNrKClcbiAgICAgIGRlYnVnKHZpZXcsIGtpbmQsIG1zZywgb2JqKVxuICAgIH1cbiAgfVxuXG4gIHJlcXVlc3RET01VcGRhdGUoY2FsbGJhY2spe1xuICAgIHRoaXMudHJhbnNpdGlvbnMuYWZ0ZXIoY2FsbGJhY2spXG4gIH1cblxuICB0cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSA9IGZ1bmN0aW9uKCl7fSl7XG4gICAgdGhpcy50cmFuc2l0aW9ucy5hZGRUcmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSlcbiAgfVxuXG4gIG9uQ2hhbm5lbChjaGFubmVsLCBldmVudCwgY2Ipe1xuICAgIGNoYW5uZWwub24oZXZlbnQsIGRhdGEgPT4ge1xuICAgICAgbGV0IGxhdGVuY3kgPSB0aGlzLmdldExhdGVuY3lTaW0oKVxuICAgICAgaWYoIWxhdGVuY3kpe1xuICAgICAgICBjYihkYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coYHNpbXVsYXRpbmcgJHtsYXRlbmN5fW1zIG9mIGxhdGVuY3kgZnJvbSBzZXJ2ZXIgdG8gY2xpZW50YClcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBjYihkYXRhKSwgbGF0ZW5jeSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgd3JhcFB1c2godmlldywgb3B0cywgcHVzaCl7XG4gICAgbGV0IGxhdGVuY3kgPSB0aGlzLmdldExhdGVuY3lTaW0oKVxuICAgIGxldCBvbGRKb2luQ291bnQgPSB2aWV3LmpvaW5Db3VudFxuICAgIGlmKCFsYXRlbmN5KXtcbiAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQoKSAmJiBvcHRzLnRpbWVvdXQpe1xuICAgICAgICByZXR1cm4gcHVzaCgpLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IHtcbiAgICAgICAgICBpZih2aWV3LmpvaW5Db3VudCA9PT0gb2xkSm9pbkNvdW50ICYmICF2aWV3LmlzRGVzdHJveWVkKCkpe1xuICAgICAgICAgICAgdGhpcy5yZWxvYWRXaXRoSml0dGVyKHZpZXcsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5sb2codmlldywgXCJ0aW1lb3V0XCIsICgpID0+IFtcInJlY2VpdmVkIHRpbWVvdXQgd2hpbGUgY29tbXVuaWNhdGluZyB3aXRoIHNlcnZlci4gRmFsbGluZyBiYWNrIHRvIGhhcmQgcmVmcmVzaCBmb3IgcmVjb3ZlcnlcIl0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwdXNoKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgc2ltdWxhdGluZyAke2xhdGVuY3l9bXMgb2YgbGF0ZW5jeSBmcm9tIGNsaWVudCB0byBzZXJ2ZXJgKVxuICAgIGxldCBmYWtlUHVzaCA9IHtcbiAgICAgIHJlY2VpdmVzOiBbXSxcbiAgICAgIHJlY2VpdmUoa2luZCwgY2IpeyB0aGlzLnJlY2VpdmVzLnB1c2goW2tpbmQsIGNiXSkgfVxuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmKHZpZXcuaXNEZXN0cm95ZWQoKSl7IHJldHVybiB9XG4gICAgICBmYWtlUHVzaC5yZWNlaXZlcy5yZWR1Y2UoKGFjYywgW2tpbmQsIGNiXSkgPT4gYWNjLnJlY2VpdmUoa2luZCwgY2IpLCBwdXNoKCkpXG4gICAgfSwgbGF0ZW5jeSlcbiAgICByZXR1cm4gZmFrZVB1c2hcbiAgfVxuXG4gIHJlbG9hZFdpdGhKaXR0ZXIodmlldywgbG9nKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIpXG4gICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICBsZXQgbWluTXMgPSB0aGlzLnJlbG9hZEppdHRlck1pblxuICAgIGxldCBtYXhNcyA9IHRoaXMucmVsb2FkSml0dGVyTWF4XG4gICAgbGV0IGFmdGVyTXMgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4TXMgLSBtaW5NcyArIDEpKSArIG1pbk1zXG4gICAgbGV0IHRyaWVzID0gQnJvd3Nlci51cGRhdGVMb2NhbCh0aGlzLmxvY2FsU3RvcmFnZSwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLCBDT05TRUNVVElWRV9SRUxPQURTLCAwLCBjb3VudCA9PiBjb3VudCArIDEpXG4gICAgaWYodHJpZXMgPiB0aGlzLm1heFJlbG9hZHMpe1xuICAgICAgYWZ0ZXJNcyA9IHRoaXMuZmFpbHNhZmVKaXR0ZXJcbiAgICB9XG4gICAgdGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIGlmIHZpZXcgaGFzIHJlY292ZXJlZCwgc3VjaCBhcyB0cmFuc3BvcnQgcmVwbGFjZWQsIHRoZW4gY2FuY2VsXG4gICAgICBpZih2aWV3LmlzRGVzdHJveWVkKCkgfHwgdmlldy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIH1cbiAgICAgIHZpZXcuZGVzdHJveSgpXG4gICAgICBsb2cgPyBsb2coKSA6IHRoaXMubG9nKHZpZXcsIFwiam9pblwiLCAoKSA9PiBbYGVuY291bnRlcmVkICR7dHJpZXN9IGNvbnNlY3V0aXZlIHJlbG9hZHNgXSlcbiAgICAgIGlmKHRyaWVzID4gdGhpcy5tYXhSZWxvYWRzKXtcbiAgICAgICAgdGhpcy5sb2codmlldywgXCJqb2luXCIsICgpID0+IFtgZXhjZWVkZWQgJHt0aGlzLm1heFJlbG9hZHN9IGNvbnNlY3V0aXZlIHJlbG9hZHMuIEVudGVyaW5nIGZhaWxzYWZlIG1vZGVgXSlcbiAgICAgIH1cbiAgICAgIGlmKHRoaXMuaGFzUGVuZGluZ0xpbmsoKSl7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHRoaXMucGVuZGluZ0xpbmtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuICAgIH0sIGFmdGVyTXMpXG4gIH1cblxuICBnZXRIb29rQ2FsbGJhY2tzKG5hbWUpe1xuICAgIHJldHVybiBuYW1lICYmIG5hbWUuc3RhcnRzV2l0aChcIlBob2VuaXguXCIpID8gSG9va3NbbmFtZS5zcGxpdChcIi5cIilbMV1dIDogdGhpcy5ob29rc1tuYW1lXVxuICB9XG5cbiAgaXNVbmxvYWRlZCgpeyByZXR1cm4gdGhpcy51bmxvYWRlZCB9XG5cbiAgaXNDb25uZWN0ZWQoKXsgcmV0dXJuIHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkgfVxuXG4gIGdldEJpbmRpbmdQcmVmaXgoKXsgcmV0dXJuIHRoaXMuYmluZGluZ1ByZWZpeCB9XG5cbiAgYmluZGluZyhraW5kKXsgcmV0dXJuIGAke3RoaXMuZ2V0QmluZGluZ1ByZWZpeCgpfSR7a2luZH1gIH1cblxuICBjaGFubmVsKHRvcGljLCBwYXJhbXMpeyByZXR1cm4gdGhpcy5zb2NrZXQuY2hhbm5lbCh0b3BpYywgcGFyYW1zKSB9XG5cbiAgam9pblJvb3RWaWV3cygpe1xuICAgIGxldCByb290c0ZvdW5kID0gZmFsc2VcbiAgICBET00uYWxsKGRvY3VtZW50LCBgJHtQSFhfVklFV19TRUxFQ1RPUn06bm90KFske1BIWF9QQVJFTlRfSUR9XSlgLCByb290RWwgPT4ge1xuICAgICAgaWYoIXRoaXMuZ2V0Um9vdEJ5SWQocm9vdEVsLmlkKSl7XG4gICAgICAgIGxldCB2aWV3ID0gdGhpcy5uZXdSb290Vmlldyhyb290RWwpXG4gICAgICAgIHZpZXcuc2V0SHJlZih0aGlzLmdldEhyZWYoKSlcbiAgICAgICAgdmlldy5qb2luKClcbiAgICAgICAgaWYocm9vdEVsLmdldEF0dHJpYnV0ZShQSFhfTUFJTikpeyB0aGlzLm1haW4gPSB2aWV3IH1cbiAgICAgIH1cbiAgICAgIHJvb3RzRm91bmQgPSB0cnVlXG4gICAgfSlcbiAgICByZXR1cm4gcm9vdHNGb3VuZFxuICB9XG5cbiAgcmVkaXJlY3QodG8sIGZsYXNoKXtcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIEJyb3dzZXIucmVkaXJlY3QodG8sIGZsYXNoKVxuICB9XG5cbiAgcmVwbGFjZU1haW4oaHJlZiwgZmxhc2gsIGNhbGxiYWNrID0gbnVsbCwgbGlua1JlZiA9IHRoaXMuc2V0UGVuZGluZ0xpbmsoaHJlZikpe1xuICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSB0aGlzLm91dGdvaW5nTWFpbkVsIHx8IHRoaXMubWFpbi5lbFxuICAgIGxldCBuZXdNYWluRWwgPSBET00uY2xvbmVOb2RlKHRoaXMub3V0Z29pbmdNYWluRWwsIFwiXCIpXG4gICAgdGhpcy5tYWluLnNob3dMb2FkZXIodGhpcy5sb2FkZXJUaW1lb3V0KVxuICAgIHRoaXMubWFpbi5kZXN0cm95KClcblxuICAgIHRoaXMubWFpbiA9IHRoaXMubmV3Um9vdFZpZXcobmV3TWFpbkVsLCBmbGFzaClcbiAgICB0aGlzLm1haW4uc2V0UmVkaXJlY3QoaHJlZilcbiAgICB0aGlzLnRyYW5zaXRpb25SZW1vdmVzKClcbiAgICB0aGlzLm1haW4uam9pbigoam9pbkNvdW50LCBvbkRvbmUpID0+IHtcbiAgICAgIGlmKGpvaW5Db3VudCA9PT0gMSAmJiB0aGlzLmNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpKXtcbiAgICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICBET00uZmluZFBoeFN0aWNreShkb2N1bWVudCkuZm9yRWFjaChlbCA9PiBuZXdNYWluRWwuYXBwZW5kQ2hpbGQoZWwpKVxuICAgICAgICAgIHRoaXMub3V0Z29pbmdNYWluRWwucmVwbGFjZVdpdGgobmV3TWFpbkVsKVxuICAgICAgICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSBudWxsXG4gICAgICAgICAgY2FsbGJhY2sgJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKVxuICAgICAgICAgIG9uRG9uZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHRyYW5zaXRpb25SZW1vdmVzKGVsZW1lbnRzKXtcbiAgICBsZXQgcmVtb3ZlQXR0ciA9IHRoaXMuYmluZGluZyhcInJlbW92ZVwiKVxuICAgIGVsZW1lbnRzID0gZWxlbWVudHMgfHwgRE9NLmFsbChkb2N1bWVudCwgYFske3JlbW92ZUF0dHJ9XWApXG4gICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBpZihkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsKSl7IC8vIHNraXAgY2hpbGRyZW4gYWxyZWFkeSByZW1vdmVkXG4gICAgICAgIHRoaXMuZXhlY0pTKGVsLCBlbC5nZXRBdHRyaWJ1dGUocmVtb3ZlQXR0ciksIFwicmVtb3ZlXCIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGlzUGh4VmlldyhlbCl7IHJldHVybiBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKSAhPT0gbnVsbCB9XG5cbiAgbmV3Um9vdFZpZXcoZWwsIGZsYXNoKXtcbiAgICBsZXQgdmlldyA9IG5ldyBWaWV3KGVsLCB0aGlzLCBudWxsLCBmbGFzaClcbiAgICB0aGlzLnJvb3RzW3ZpZXcuaWRdID0gdmlld1xuICAgIHJldHVybiB2aWV3XG4gIH1cblxuICBvd25lcihjaGlsZEVsLCBjYWxsYmFjayl7XG4gICAgbGV0IHZpZXcgPSBtYXliZShjaGlsZEVsLmNsb3Nlc3QoUEhYX1ZJRVdfU0VMRUNUT1IpLCBlbCA9PiB0aGlzLmdldFZpZXdCeUVsKGVsKSkgfHwgdGhpcy5tYWluXG4gICAgaWYodmlldyl7IGNhbGxiYWNrKHZpZXcpIH1cbiAgfVxuXG4gIHdpdGhpbk93bmVycyhjaGlsZEVsLCBjYWxsYmFjayl7XG4gICAgdGhpcy5vd25lcihjaGlsZEVsLCB2aWV3ID0+IGNhbGxiYWNrKHZpZXcsIGNoaWxkRWwpKVxuICB9XG5cbiAgZ2V0Vmlld0J5RWwoZWwpe1xuICAgIGxldCByb290SWQgPSBlbC5nZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQpXG4gICAgcmV0dXJuIG1heWJlKHRoaXMuZ2V0Um9vdEJ5SWQocm9vdElkKSwgcm9vdCA9PiByb290LmdldERlc2NlbmRlbnRCeUVsKGVsKSlcbiAgfVxuXG4gIGdldFJvb3RCeUlkKGlkKXsgcmV0dXJuIHRoaXMucm9vdHNbaWRdIH1cblxuICBkZXN0cm95QWxsVmlld3MoKXtcbiAgICBmb3IobGV0IGlkIGluIHRoaXMucm9vdHMpe1xuICAgICAgdGhpcy5yb290c1tpZF0uZGVzdHJveSgpXG4gICAgICBkZWxldGUgdGhpcy5yb290c1tpZF1cbiAgICB9XG4gICAgdGhpcy5tYWluID0gbnVsbFxuICB9XG5cbiAgZGVzdHJveVZpZXdCeUVsKGVsKXtcbiAgICBsZXQgcm9vdCA9IHRoaXMuZ2V0Um9vdEJ5SWQoZWwuZ2V0QXR0cmlidXRlKFBIWF9ST09UX0lEKSlcbiAgICBpZihyb290ICYmIHJvb3QuaWQgPT09IGVsLmlkKXtcbiAgICAgIHJvb3QuZGVzdHJveSgpXG4gICAgICBkZWxldGUgdGhpcy5yb290c1tyb290LmlkXVxuICAgIH0gZWxzZSBpZihyb290KXtcbiAgICAgIHJvb3QuZGVzdHJveURlc2NlbmRlbnQoZWwuaWQpXG4gICAgfVxuICB9XG5cbiAgc2V0QWN0aXZlRWxlbWVudCh0YXJnZXQpe1xuICAgIGlmKHRoaXMuYWN0aXZlRWxlbWVudCA9PT0gdGFyZ2V0KXsgcmV0dXJuIH1cbiAgICB0aGlzLmFjdGl2ZUVsZW1lbnQgPSB0YXJnZXRcbiAgICBsZXQgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgaWYodGFyZ2V0ID09PSB0aGlzLmFjdGl2ZUVsZW1lbnQpeyB0aGlzLmFjdGl2ZUVsZW1lbnQgPSBudWxsIH1cbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzKVxuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzKVxuICAgIH1cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgY2FuY2VsKVxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgY2FuY2VsKVxuICB9XG5cbiAgZ2V0QWN0aXZlRWxlbWVudCgpe1xuICAgIGlmKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpe1xuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIGJlIG51bGwgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTFcbiAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmJvZHlcbiAgICB9XG4gIH1cblxuICBkcm9wQWN0aXZlRWxlbWVudCh2aWV3KXtcbiAgICBpZih0aGlzLnByZXZBY3RpdmUgJiYgdmlldy5vd25zRWxlbWVudCh0aGlzLnByZXZBY3RpdmUpKXtcbiAgICAgIHRoaXMucHJldkFjdGl2ZSA9IG51bGxcbiAgICB9XG4gIH1cblxuICByZXN0b3JlUHJldmlvdXNseUFjdGl2ZUZvY3VzKCl7XG4gICAgaWYodGhpcy5wcmV2QWN0aXZlICYmIHRoaXMucHJldkFjdGl2ZSAhPT0gZG9jdW1lbnQuYm9keSl7XG4gICAgICB0aGlzLnByZXZBY3RpdmUuZm9jdXMoKVxuICAgIH1cbiAgfVxuXG4gIGJsdXJBY3RpdmVFbGVtZW50KCl7XG4gICAgdGhpcy5wcmV2QWN0aXZlID0gdGhpcy5nZXRBY3RpdmVFbGVtZW50KClcbiAgICBpZih0aGlzLnByZXZBY3RpdmUgIT09IGRvY3VtZW50LmJvZHkpeyB0aGlzLnByZXZBY3RpdmUuYmx1cigpIH1cbiAgfVxuXG4gIGJpbmRUb3BMZXZlbEV2ZW50cygpe1xuICAgIGlmKHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cyl7IHJldHVybiB9XG5cbiAgICB0aGlzLmJvdW5kVG9wTGV2ZWxFdmVudHMgPSB0cnVlXG4gICAgLy8gZW50ZXIgZmFpbHNhZmUgcmVsb2FkIGlmIHNlcnZlciBoYXMgZ29uZSBhd2F5IGludGVudGlvbmFsbHksIHN1Y2ggYXMgXCJkaXNjb25uZWN0XCIgYnJvYWRjYXN0XG4gICAgdGhpcy5zb2NrZXQub25DbG9zZShldmVudCA9PiB7XG4gICAgICBpZihldmVudCAmJiBldmVudC5jb2RlID09PSAxMDAwICYmIHRoaXMubWFpbil7XG4gICAgICAgIHRoaXMucmVsb2FkV2l0aEppdHRlcih0aGlzLm1haW4pXG4gICAgICB9XG4gICAgfSlcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKXsgfSkgLy8gZW5zdXJlIGFsbCBjbGljayBldmVudHMgYnViYmxlIGZvciBtb2JpbGUgU2FmYXJpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCBlID0+IHtcbiAgICAgIGlmKGUucGVyc2lzdGVkKXsgLy8gcmVsb2FkIHBhZ2UgaWYgYmVpbmcgcmVzdG9yZWQgZnJvbSBiYWNrL2ZvcndhcmQgY2FjaGVcbiAgICAgICAgdGhpcy5nZXRTb2NrZXQoKS5kaXNjb25uZWN0KClcbiAgICAgICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoe3RvOiB3aW5kb3cubG9jYXRpb24uaHJlZiwga2luZDogXCJyZWRpcmVjdFwifSlcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICB9XG4gICAgfSwgdHJ1ZSlcbiAgICB0aGlzLmJpbmROYXYoKVxuICAgIHRoaXMuYmluZENsaWNrcygpXG4gICAgdGhpcy5iaW5kRm9ybXMoKVxuICAgIHRoaXMuYmluZCh7a2V5dXA6IFwia2V5dXBcIiwga2V5ZG93bjogXCJrZXlkb3duXCJ9LCAoZSwgdHlwZSwgdmlldywgdGFyZ2V0RWwsIHBoeEV2ZW50LCBldmVudFRhcmdldCkgPT4ge1xuICAgICAgbGV0IG1hdGNoS2V5ID0gdGFyZ2V0RWwuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfS0VZKSlcbiAgICAgIGxldCBwcmVzc2VkS2V5ID0gZS5rZXkgJiYgZS5rZXkudG9Mb3dlckNhc2UoKSAvLyBjaHJvbWUgY2xpY2tlZCBhdXRvY29tcGxldGVzIHNlbmQgYSBrZXlkb3duIHdpdGhvdXQga2V5XG4gICAgICBpZihtYXRjaEtleSAmJiBtYXRjaEtleS50b0xvd2VyQ2FzZSgpICE9PSBwcmVzc2VkS2V5KXsgcmV0dXJuIH1cblxuICAgICAgbGV0IGRhdGEgPSB7a2V5OiBlLmtleSwgLi4udGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpfVxuICAgICAgSlMuZXhlYyh0eXBlLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0RWwsIFtcInB1c2hcIiwge2RhdGF9XSlcbiAgICB9KVxuICAgIHRoaXMuYmluZCh7Ymx1cjogXCJmb2N1c291dFwiLCBmb2N1czogXCJmb2N1c2luXCJ9LCAoZSwgdHlwZSwgdmlldywgdGFyZ2V0RWwsIHBoeEV2ZW50LCBldmVudFRhcmdldCkgPT4ge1xuICAgICAgaWYoIWV2ZW50VGFyZ2V0KXtcbiAgICAgICAgbGV0IGRhdGEgPSB7a2V5OiBlLmtleSwgLi4udGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpfVxuICAgICAgICBKUy5leGVjKHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7ZGF0YX1dKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5iaW5kKHtibHVyOiBcImJsdXJcIiwgZm9jdXM6IFwiZm9jdXNcIn0sIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgcGh4VGFyZ2V0KSA9PiB7XG4gICAgICAvLyBibHVyIGFuZCBmb2N1cyBhcmUgdHJpZ2dlcmVkIG9uIGRvY3VtZW50IGFuZCB3aW5kb3cuIERpc2NhcmQgb25lIHRvIGF2b2lkIGR1cHNcbiAgICAgIGlmKHBoeFRhcmdldCA9PT0gXCJ3aW5kb3dcIil7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpXG4gICAgICAgIEpTLmV4ZWModHlwZSwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldEVsLCBbXCJwdXNoXCIsIHtkYXRhfV0pXG4gICAgICB9XG4gICAgfSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCBlID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgbGV0IGRyb3BUYXJnZXRJZCA9IG1heWJlKGNsb3Nlc3RQaHhCaW5kaW5nKGUudGFyZ2V0LCB0aGlzLmJpbmRpbmcoUEhYX0RST1BfVEFSR0VUKSksIHRydWVUYXJnZXQgPT4ge1xuICAgICAgICByZXR1cm4gdHJ1ZVRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9EUk9QX1RBUkdFVCkpXG4gICAgICB9KVxuICAgICAgbGV0IGRyb3BUYXJnZXQgPSBkcm9wVGFyZ2V0SWQgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZHJvcFRhcmdldElkKVxuICAgICAgbGV0IGZpbGVzID0gQXJyYXkuZnJvbShlLmRhdGFUcmFuc2Zlci5maWxlcyB8fCBbXSlcbiAgICAgIGlmKCFkcm9wVGFyZ2V0IHx8IGRyb3BUYXJnZXQuZGlzYWJsZWQgfHwgZmlsZXMubGVuZ3RoID09PSAwIHx8ICEoZHJvcFRhcmdldC5maWxlcyBpbnN0YW5jZW9mIEZpbGVMaXN0KSl7IHJldHVybiB9XG5cbiAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKGRyb3BUYXJnZXQsIGZpbGVzKVxuICAgICAgZHJvcFRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIsIHtidWJibGVzOiB0cnVlfSkpXG4gICAgfSlcbiAgICB0aGlzLm9uKFBIWF9UUkFDS19VUExPQURTLCBlID0+IHtcbiAgICAgIGxldCB1cGxvYWRUYXJnZXQgPSBlLnRhcmdldFxuICAgICAgaWYoIURPTS5pc1VwbG9hZElucHV0KHVwbG9hZFRhcmdldCkpeyByZXR1cm4gfVxuICAgICAgbGV0IGZpbGVzID0gQXJyYXkuZnJvbShlLmRldGFpbC5maWxlcyB8fCBbXSkuZmlsdGVyKGYgPT4gZiBpbnN0YW5jZW9mIEZpbGUgfHwgZiBpbnN0YW5jZW9mIEJsb2IpXG4gICAgICBMaXZlVXBsb2FkZXIudHJhY2tGaWxlcyh1cGxvYWRUYXJnZXQsIGZpbGVzKVxuICAgICAgdXBsb2FkVGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIiwge2J1YmJsZXM6IHRydWV9KSlcbiAgICB9KVxuICB9XG5cbiAgZXZlbnRNZXRhKGV2ZW50TmFtZSwgZSwgdGFyZ2V0RWwpe1xuICAgIGxldCBjYWxsYmFjayA9IHRoaXMubWV0YWRhdGFDYWxsYmFja3NbZXZlbnROYW1lXVxuICAgIHJldHVybiBjYWxsYmFjayA/IGNhbGxiYWNrKGUsIHRhcmdldEVsKSA6IHt9XG4gIH1cblxuICBzZXRQZW5kaW5nTGluayhocmVmKXtcbiAgICB0aGlzLmxpbmtSZWYrK1xuICAgIHRoaXMucGVuZGluZ0xpbmsgPSBocmVmXG4gICAgcmV0dXJuIHRoaXMubGlua1JlZlxuICB9XG5cbiAgY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZil7XG4gICAgaWYodGhpcy5saW5rUmVmICE9PSBsaW5rUmVmKXtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhyZWYgPSB0aGlzLnBlbmRpbmdMaW5rXG4gICAgICB0aGlzLnBlbmRpbmdMaW5rID0gbnVsbFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBnZXRIcmVmKCl7IHJldHVybiB0aGlzLmhyZWYgfVxuXG4gIGhhc1BlbmRpbmdMaW5rKCl7IHJldHVybiAhIXRoaXMucGVuZGluZ0xpbmsgfVxuXG4gIGJpbmQoZXZlbnRzLCBjYWxsYmFjayl7XG4gICAgZm9yKGxldCBldmVudCBpbiBldmVudHMpe1xuICAgICAgbGV0IGJyb3dzZXJFdmVudE5hbWUgPSBldmVudHNbZXZlbnRdXG5cbiAgICAgIHRoaXMub24oYnJvd3NlckV2ZW50TmFtZSwgZSA9PiB7XG4gICAgICAgIGxldCBiaW5kaW5nID0gdGhpcy5iaW5kaW5nKGV2ZW50KVxuICAgICAgICBsZXQgd2luZG93QmluZGluZyA9IHRoaXMuYmluZGluZyhgd2luZG93LSR7ZXZlbnR9YClcbiAgICAgICAgbGV0IHRhcmdldFBoeEV2ZW50ID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlICYmIGUudGFyZ2V0LmdldEF0dHJpYnV0ZShiaW5kaW5nKVxuICAgICAgICBpZih0YXJnZXRQaHhFdmVudCl7XG4gICAgICAgICAgdGhpcy5kZWJvdW5jZShlLnRhcmdldCwgZSwgYnJvd3NlckV2ZW50TmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZS50YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICAgICAgICBjYWxsYmFjayhlLCBldmVudCwgdmlldywgZS50YXJnZXQsIHRhcmdldFBoeEV2ZW50LCBudWxsKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIERPTS5hbGwoZG9jdW1lbnQsIGBbJHt3aW5kb3dCaW5kaW5nfV1gLCBlbCA9PiB7XG4gICAgICAgICAgICBsZXQgcGh4RXZlbnQgPSBlbC5nZXRBdHRyaWJ1dGUod2luZG93QmluZGluZylcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2UoZWwsIGUsIGJyb3dzZXJFdmVudE5hbWUsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZWwsIHZpZXcgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGV2ZW50LCB2aWV3LCBlbCwgcGh4RXZlbnQsIFwid2luZG93XCIpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgYmluZENsaWNrcygpe1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGUgPT4gdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCA9IGUudGFyZ2V0KVxuICAgIHRoaXMuYmluZENsaWNrKFwiY2xpY2tcIiwgXCJjbGlja1wiLCBmYWxzZSlcbiAgICB0aGlzLmJpbmRDbGljayhcIm1vdXNlZG93blwiLCBcImNhcHR1cmUtY2xpY2tcIiwgdHJ1ZSlcbiAgfVxuXG4gIGJpbmRDbGljayhldmVudE5hbWUsIGJpbmRpbmdOYW1lLCBjYXB0dXJlKXtcbiAgICBsZXQgY2xpY2sgPSB0aGlzLmJpbmRpbmcoYmluZGluZ05hbWUpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBlID0+IHtcbiAgICAgIGxldCB0YXJnZXQgPSBudWxsXG4gICAgICBpZihjYXB0dXJlKXtcbiAgICAgICAgdGFyZ2V0ID0gZS50YXJnZXQubWF0Y2hlcyhgWyR7Y2xpY2t9XWApID8gZS50YXJnZXQgOiBlLnRhcmdldC5xdWVyeVNlbGVjdG9yKGBbJHtjbGlja31dYClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjbGlja1N0YXJ0ZWRBdFRhcmdldCA9IHRoaXMuY2xpY2tTdGFydGVkQXRUYXJnZXQgfHwgZS50YXJnZXRcbiAgICAgICAgdGFyZ2V0ID0gY2xvc2VzdFBoeEJpbmRpbmcoY2xpY2tTdGFydGVkQXRUYXJnZXQsIGNsaWNrKVxuICAgICAgICB0aGlzLmRpc3BhdGNoQ2xpY2tBd2F5KGUsIGNsaWNrU3RhcnRlZEF0VGFyZ2V0KVxuICAgICAgICB0aGlzLmNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gbnVsbFxuICAgICAgfVxuICAgICAgbGV0IHBoeEV2ZW50ID0gdGFyZ2V0ICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoY2xpY2spXG4gICAgICBpZighcGh4RXZlbnQpeyByZXR1cm4gfVxuICAgICAgaWYodGFyZ2V0LmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiKXsgZS5wcmV2ZW50RGVmYXVsdCgpIH1cblxuICAgICAgdGhpcy5kZWJvdW5jZSh0YXJnZXQsIGUsIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLndpdGhpbk93bmVycyh0YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICAgIEpTLmV4ZWMoXCJjbGlja1wiLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0LCBbXCJwdXNoXCIsIHtkYXRhOiB0aGlzLmV2ZW50TWV0YShcImNsaWNrXCIsIGUsIHRhcmdldCl9XSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSwgY2FwdHVyZSlcbiAgfVxuXG4gIGRpc3BhdGNoQ2xpY2tBd2F5KGUsIGNsaWNrU3RhcnRlZEF0KXtcbiAgICBsZXQgcGh4Q2xpY2tBd2F5ID0gdGhpcy5iaW5kaW5nKFwiY2xpY2stYXdheVwiKVxuICAgIERPTS5hbGwoZG9jdW1lbnQsIGBbJHtwaHhDbGlja0F3YXl9XWAsIGVsID0+IHtcbiAgICAgIGlmKCEoZWwuaXNTYW1lTm9kZShjbGlja1N0YXJ0ZWRBdCkgfHwgZWwuY29udGFpbnMoY2xpY2tTdGFydGVkQXQpKSl7XG4gICAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCB2aWV3ID0+IHtcbiAgICAgICAgICBsZXQgcGh4RXZlbnQgPSBlbC5nZXRBdHRyaWJ1dGUocGh4Q2xpY2tBd2F5KVxuICAgICAgICAgIGlmKEpTLmlzVmlzaWJsZShlbCkpe1xuICAgICAgICAgICAgSlMuZXhlYyhcImNsaWNrXCIsIHBoeEV2ZW50LCB2aWV3LCBlbCwgW1wicHVzaFwiLCB7ZGF0YTogdGhpcy5ldmVudE1ldGEoXCJjbGlja1wiLCBlLCBlLnRhcmdldCl9XSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGJpbmROYXYoKXtcbiAgICBpZighQnJvd3Nlci5jYW5QdXNoU3RhdGUoKSl7IHJldHVybiB9XG4gICAgaWYoaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbil7IGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiIH1cbiAgICBsZXQgc2Nyb2xsVGltZXIgPSBudWxsXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgX2UgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFRpbWVyKVxuICAgICAgc2Nyb2xsVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgQnJvd3Nlci51cGRhdGVDdXJyZW50U3RhdGUoc3RhdGUgPT4gT2JqZWN0LmFzc2lnbihzdGF0ZSwge3Njcm9sbDogd2luZG93LnNjcm9sbFl9KSlcbiAgICAgIH0sIDEwMClcbiAgICB9KVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgZXZlbnQgPT4ge1xuICAgICAgaWYoIXRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pKXsgcmV0dXJuIH1cbiAgICAgIGxldCB7dHlwZSwgaWQsIHJvb3QsIHNjcm9sbH0gPSBldmVudC5zdGF0ZSB8fCB7fVxuICAgICAgbGV0IGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuXG4gICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBpZih0aGlzLm1haW4uaXNDb25uZWN0ZWQoKSAmJiAodHlwZSA9PT0gXCJwYXRjaFwiICYmIGlkID09PSB0aGlzLm1haW4uaWQpKXtcbiAgICAgICAgICB0aGlzLm1haW4ucHVzaExpbmtQYXRjaChocmVmLCBudWxsKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVwbGFjZU1haW4oaHJlZiwgbnVsbCwgKCkgPT4ge1xuICAgICAgICAgICAgaWYocm9vdCl7IHRoaXMucmVwbGFjZVJvb3RIaXN0b3J5KCkgfVxuICAgICAgICAgICAgaWYodHlwZW9mKHNjcm9sbCkgPT09IFwibnVtYmVyXCIpe1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgc2Nyb2xsKVxuICAgICAgICAgICAgICB9LCAwKSAvLyB0aGUgYm9keSBuZWVkcyB0byByZW5kZXIgYmVmb3JlIHdlIHNjcm9sbC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sIGZhbHNlKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XG4gICAgICBsZXQgdGFyZ2V0ID0gY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIFBIWF9MSVZFX0xJTkspXG4gICAgICBsZXQgdHlwZSA9IHRhcmdldCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFBIWF9MSVZFX0xJTkspXG4gICAgICBsZXQgd2FudHNOZXdUYWIgPSBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuYnV0dG9uID09PSAxXG4gICAgICBpZighdHlwZSB8fCAhdGhpcy5pc0Nvbm5lY3RlZCgpIHx8ICF0aGlzLm1haW4gfHwgd2FudHNOZXdUYWIpeyByZXR1cm4gfVxuXG4gICAgICBsZXQgaHJlZiA9IHRhcmdldC5ocmVmXG4gICAgICBsZXQgbGlua1N0YXRlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShQSFhfTElOS19TVEFURSlcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSAvLyBkbyBub3QgYnViYmxlIGNsaWNrIHRvIHJlZ3VsYXIgcGh4LWNsaWNrIGJpbmRpbmdzXG4gICAgICBpZih0aGlzLnBlbmRpbmdMaW5rID09PSBocmVmKXsgcmV0dXJuIH1cblxuICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgaWYodHlwZSA9PT0gXCJwYXRjaFwiKXtcbiAgICAgICAgICB0aGlzLnB1c2hIaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCB0YXJnZXQpXG4gICAgICAgIH0gZWxzZSBpZih0eXBlID09PSBcInJlZGlyZWN0XCIpe1xuICAgICAgICAgIHRoaXMuaGlzdG9yeVJlZGlyZWN0KGhyZWYsIGxpbmtTdGF0ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7UEhYX0xJVkVfTElOS30gdG8gYmUgXCJwYXRjaFwiIG9yIFwicmVkaXJlY3RcIiwgZ290OiAke3R5cGV9YClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LCBmYWxzZSlcbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQsIHBheWxvYWQgPSB7fSl7XG4gICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBgcGh4OiR7ZXZlbnR9YCwge2RldGFpbDogcGF5bG9hZH0pXG4gIH1cblxuICBkaXNwYXRjaEV2ZW50cyhldmVudHMpe1xuICAgIGV2ZW50cy5mb3JFYWNoKChbZXZlbnQsIHBheWxvYWRdKSA9PiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQsIHBheWxvYWQpKVxuICB9XG5cbiAgd2l0aFBhZ2VMb2FkaW5nKGluZm8sIGNhbGxiYWNrKXtcbiAgICBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCB7ZGV0YWlsOiBpbmZvfSlcbiAgICBsZXQgZG9uZSA9ICgpID0+IERPTS5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0b3BcIiwge2RldGFpbDogaW5mb30pXG4gICAgcmV0dXJuIGNhbGxiYWNrID8gY2FsbGJhY2soZG9uZSkgOiBkb25lXG4gIH1cblxuICBwdXNoSGlzdG9yeVBhdGNoKGhyZWYsIGxpbmtTdGF0ZSwgdGFyZ2V0RWwpe1xuICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzogaHJlZiwga2luZDogXCJwYXRjaFwifSwgZG9uZSA9PiB7XG4gICAgICB0aGlzLm1haW4ucHVzaExpbmtQYXRjaChocmVmLCB0YXJnZXRFbCwgbGlua1JlZiA9PiB7XG4gICAgICAgIHRoaXMuaGlzdG9yeVBhdGNoKGhyZWYsIGxpbmtTdGF0ZSwgbGlua1JlZilcbiAgICAgICAgZG9uZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBoaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSl7XG4gICAgaWYoIXRoaXMuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpeyByZXR1cm4gfVxuXG4gICAgQnJvd3Nlci5wdXNoU3RhdGUobGlua1N0YXRlLCB7dHlwZTogXCJwYXRjaFwiLCBpZDogdGhpcy5tYWluLmlkfSwgaHJlZilcbiAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKVxuICB9XG5cbiAgaGlzdG9yeVJlZGlyZWN0KGhyZWYsIGxpbmtTdGF0ZSwgZmxhc2gpe1xuICAgIGxldCBzY3JvbGwgPSB3aW5kb3cuc2Nyb2xsWVxuICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzogaHJlZiwga2luZDogXCJyZWRpcmVjdFwifSwgZG9uZSA9PiB7XG4gICAgICB0aGlzLnJlcGxhY2VNYWluKGhyZWYsIGZsYXNoLCAoKSA9PiB7XG4gICAgICAgIEJyb3dzZXIucHVzaFN0YXRlKGxpbmtTdGF0ZSwge3R5cGU6IFwicmVkaXJlY3RcIiwgaWQ6IHRoaXMubWFpbi5pZCwgc2Nyb2xsOiBzY3JvbGx9LCBocmVmKVxuICAgICAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKVxuICAgICAgICBkb25lKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHJlcGxhY2VSb290SGlzdG9yeSgpe1xuICAgIEJyb3dzZXIucHVzaFN0YXRlKFwicmVwbGFjZVwiLCB7cm9vdDogdHJ1ZSwgdHlwZTogXCJwYXRjaFwiLCBpZDogdGhpcy5tYWluLmlkfSlcbiAgfVxuXG4gIHJlZ2lzdGVyTmV3TG9jYXRpb24obmV3TG9jYXRpb24pe1xuICAgIGxldCB7cGF0aG5hbWUsIHNlYXJjaH0gPSB0aGlzLmN1cnJlbnRMb2NhdGlvblxuICAgIGlmKHBhdGhuYW1lICsgc2VhcmNoID09PSBuZXdMb2NhdGlvbi5wYXRobmFtZSArIG5ld0xvY2F0aW9uLnNlYXJjaCl7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBjbG9uZShuZXdMb2NhdGlvbilcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgYmluZEZvcm1zKCl7XG4gICAgbGV0IGl0ZXJhdGlvbnMgPSAwXG4gICAgdGhpcy5vbihcInN1Ym1pdFwiLCBlID0+IHtcbiAgICAgIGxldCBwaHhFdmVudCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJzdWJtaXRcIikpXG4gICAgICBpZighcGh4RXZlbnQpeyByZXR1cm4gfVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBlLnRhcmdldC5kaXNhYmxlZCA9IHRydWVcbiAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCB2aWV3ID0+IHtcbiAgICAgICAgSlMuZXhlYyhcInN1Ym1pdFwiLCBwaHhFdmVudCwgdmlldywgZS50YXJnZXQsIFtcInB1c2hcIiwge31dKVxuICAgICAgfSlcbiAgICB9LCBmYWxzZSlcblxuICAgIGZvcihsZXQgdHlwZSBvZiBbXCJjaGFuZ2VcIiwgXCJpbnB1dFwiXSl7XG4gICAgICB0aGlzLm9uKHR5cGUsIGUgPT4ge1xuICAgICAgICBsZXQgcGh4Q2hhbmdlID0gdGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpXG4gICAgICAgIGxldCBpbnB1dCA9IGUudGFyZ2V0XG4gICAgICAgIGxldCBpbnB1dEV2ZW50ID0gaW5wdXQuZ2V0QXR0cmlidXRlKHBoeENoYW5nZSlcbiAgICAgICAgbGV0IGZvcm1FdmVudCA9IGlucHV0LmZvcm0gJiYgaW5wdXQuZm9ybS5nZXRBdHRyaWJ1dGUocGh4Q2hhbmdlKVxuICAgICAgICBsZXQgcGh4RXZlbnQgPSBpbnB1dEV2ZW50IHx8IGZvcm1FdmVudFxuICAgICAgICBpZighcGh4RXZlbnQpeyByZXR1cm4gfVxuICAgICAgICBpZihpbnB1dC50eXBlID09PSBcIm51bWJlclwiICYmIGlucHV0LnZhbGlkaXR5ICYmIGlucHV0LnZhbGlkaXR5LmJhZElucHV0KXsgcmV0dXJuIH1cblxuICAgICAgICBsZXQgZGlzcGF0Y2hlciA9IGlucHV0RXZlbnQgPyBpbnB1dCA6IGlucHV0LmZvcm1cbiAgICAgICAgbGV0IGN1cnJlbnRJdGVyYXRpb25zID0gaXRlcmF0aW9uc1xuICAgICAgICBpdGVyYXRpb25zKytcbiAgICAgICAgbGV0IHthdDogYXQsIHR5cGU6IGxhc3RUeXBlfSA9IERPTS5wcml2YXRlKGlucHV0LCBcInByZXYtaXRlcmF0aW9uXCIpIHx8IHt9XG4gICAgICAgIC8vIGRldGVjdCBkdXAgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGRpc3BhdGNoIGJvdGggXCJpbnB1dFwiIGFuZCBcImNoYW5nZVwiXG4gICAgICAgIGlmKGF0ID09PSBjdXJyZW50SXRlcmF0aW9ucyAtIDEgJiYgdHlwZSAhPT0gbGFzdFR5cGUpeyByZXR1cm4gfVxuXG4gICAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0LCBcInByZXYtaXRlcmF0aW9uXCIsIHthdDogY3VycmVudEl0ZXJhdGlvbnMsIHR5cGU6IHR5cGV9KVxuXG4gICAgICAgIHRoaXMuZGVib3VuY2UoaW5wdXQsIGUsIHR5cGUsICgpID0+IHtcbiAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhkaXNwYXRjaGVyLCB2aWV3ID0+IHtcbiAgICAgICAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0LCBQSFhfSEFTX0ZPQ1VTRUQsIHRydWUpXG4gICAgICAgICAgICBpZighRE9NLmlzVGV4dHVhbElucHV0KGlucHV0KSl7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlRWxlbWVudChpbnB1dClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEpTLmV4ZWMoXCJjaGFuZ2VcIiwgcGh4RXZlbnQsIHZpZXcsIGlucHV0LCBbXCJwdXNoXCIsIHtfdGFyZ2V0OiBlLnRhcmdldC5uYW1lLCBkaXNwYXRjaGVyOiBkaXNwYXRjaGVyfV0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0sIGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIGRlYm91bmNlKGVsLCBldmVudCwgZXZlbnRUeXBlLCBjYWxsYmFjayl7XG4gICAgaWYoZXZlbnRUeXBlID09PSBcImJsdXJcIiB8fCBldmVudFR5cGUgPT09IFwiZm9jdXNvdXRcIil7IHJldHVybiBjYWxsYmFjaygpIH1cblxuICAgIGxldCBwaHhEZWJvdW5jZSA9IHRoaXMuYmluZGluZyhQSFhfREVCT1VOQ0UpXG4gICAgbGV0IHBoeFRocm90dGxlID0gdGhpcy5iaW5kaW5nKFBIWF9USFJPVFRMRSlcbiAgICBsZXQgZGVmYXVsdERlYm91bmNlID0gdGhpcy5kZWZhdWx0cy5kZWJvdW5jZS50b1N0cmluZygpXG4gICAgbGV0IGRlZmF1bHRUaHJvdHRsZSA9IHRoaXMuZGVmYXVsdHMudGhyb3R0bGUudG9TdHJpbmcoKVxuXG4gICAgdGhpcy53aXRoaW5Pd25lcnMoZWwsIHZpZXcgPT4ge1xuICAgICAgbGV0IGFzeW5jRmlsdGVyID0gKCkgPT4gIXZpZXcuaXNEZXN0cm95ZWQoKSAmJiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsKVxuICAgICAgRE9NLmRlYm91bmNlKGVsLCBldmVudCwgcGh4RGVib3VuY2UsIGRlZmF1bHREZWJvdW5jZSwgcGh4VGhyb3R0bGUsIGRlZmF1bHRUaHJvdHRsZSwgYXN5bmNGaWx0ZXIsICgpID0+IHtcbiAgICAgICAgY2FsbGJhY2soKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgc2lsZW5jZUV2ZW50cyhjYWxsYmFjayl7XG4gICAgdGhpcy5zaWxlbmNlZCA9IHRydWVcbiAgICBjYWxsYmFjaygpXG4gICAgdGhpcy5zaWxlbmNlZCA9IGZhbHNlXG4gIH1cblxuICBvbihldmVudCwgY2FsbGJhY2spe1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBlID0+IHtcbiAgICAgIGlmKCF0aGlzLnNpbGVuY2VkKXsgY2FsbGJhY2soZSkgfVxuICAgIH0pXG4gIH1cbn1cblxuY2xhc3MgVHJhbnNpdGlvblNldCB7XG4gIGNvbnN0cnVjdG9yKCl7XG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IG5ldyBTZXQoKVxuICAgIHRoaXMucGVuZGluZ09wcyA9IFtdXG4gICAgdGhpcy5yZXNldCgpXG4gIH1cblxuICByZXNldCgpe1xuICAgIHRoaXMudHJhbnNpdGlvbnMuZm9yRWFjaCh0aW1lciA9PiB7XG4gICAgICBjYW5jZWxUaW1lb3V0KHRpbWVyKVxuICAgICAgdGhpcy50cmFuc2l0aW9ucy5kZWxldGUodGltZXIpXG4gICAgfSlcbiAgICB0aGlzLmZsdXNoUGVuZGluZ09wcygpXG4gIH1cblxuICBhZnRlcihjYWxsYmFjayl7XG4gICAgaWYodGhpcy5zaXplKCkgPT09IDApe1xuICAgICAgY2FsbGJhY2soKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hQZW5kaW5nT3AoY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgYWRkVHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpe1xuICAgIG9uU3RhcnQoKVxuICAgIGxldCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2l0aW9ucy5kZWxldGUodGltZXIpXG4gICAgICBvbkRvbmUoKVxuICAgICAgaWYodGhpcy5zaXplKCkgPT09IDApeyB0aGlzLmZsdXNoUGVuZGluZ09wcygpIH1cbiAgICB9LCB0aW1lKVxuICAgIHRoaXMudHJhbnNpdGlvbnMuYWRkKHRpbWVyKVxuICB9XG5cbiAgcHVzaFBlbmRpbmdPcChvcCl7IHRoaXMucGVuZGluZ09wcy5wdXNoKG9wKSB9XG5cbiAgc2l6ZSgpeyByZXR1cm4gdGhpcy50cmFuc2l0aW9ucy5zaXplIH1cblxuICBmbHVzaFBlbmRpbmdPcHMoKXtcbiAgICB0aGlzLnBlbmRpbmdPcHMuZm9yRWFjaChvcCA9PiBvcCgpKVxuICAgIHRoaXMucGVuZGluZ09wcyA9IFtdXG4gIH1cbn1cbiIsICIvLyBXZSBpbXBvcnQgdGhlIENTUyB3aGljaCBpcyBleHRyYWN0ZWQgdG8gaXRzIG93biBmaWxlIGJ5IGVzYnVpbGQuXG4vLyBSZW1vdmUgdGhpcyBsaW5lIGlmIHlvdSBhZGQgYSB5b3VyIG93biBDU1MgYnVpbGQgcGlwZWxpbmUgKGUuZyBwb3N0Y3NzKS5cbmltcG9ydCBcIi4uL2Nzcy9hcHAuY3NzXCJcblxuLy8gSWYgeW91IHdhbnQgdG8gdXNlIFBob2VuaXggY2hhbm5lbHMsIHJ1biBgbWl4IGhlbHAgcGh4Lmdlbi5jaGFubmVsYFxuLy8gdG8gZ2V0IHN0YXJ0ZWQgYW5kIHRoZW4gdW5jb21tZW50IHRoZSBsaW5lIGJlbG93LlxuLy8gaW1wb3J0IFwiLi91c2VyX3NvY2tldC5qc1wiXG5cbi8vIFlvdSBjYW4gaW5jbHVkZSBkZXBlbmRlbmNpZXMgaW4gdHdvIHdheXMuXG4vL1xuLy8gVGhlIHNpbXBsZXN0IG9wdGlvbiBpcyB0byBwdXQgdGhlbSBpbiBhc3NldHMvdmVuZG9yIGFuZFxuLy8gaW1wb3J0IHRoZW0gdXNpbmcgcmVsYXRpdmUgcGF0aHM6XG4vL1xuLy8gICAgIGltcG9ydCBcIi4uL3ZlbmRvci9zb21lLXBhY2thZ2UuanNcIlxuLy9cbi8vIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gYG5wbSBpbnN0YWxsIHNvbWUtcGFja2FnZSAtLXByZWZpeCBhc3NldHNgIGFuZCBpbXBvcnRcbi8vIHRoZW0gdXNpbmcgYSBwYXRoIHN0YXJ0aW5nIHdpdGggdGhlIHBhY2thZ2UgbmFtZTpcbi8vXG4vLyAgICAgaW1wb3J0IFwic29tZS1wYWNrYWdlXCJcbi8vXG5cbi8vIEluY2x1ZGUgcGhvZW5peF9odG1sIHRvIGhhbmRsZSBtZXRob2Q9UFVUL0RFTEVURSBpbiBmb3JtcyBhbmQgYnV0dG9ucy5cbmltcG9ydCBcInBob2VuaXhfaHRtbFwiXG4vLyBFc3RhYmxpc2ggUGhvZW5peCBTb2NrZXQgYW5kIExpdmVWaWV3IGNvbmZpZ3VyYXRpb24uXG5pbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxuaW1wb3J0IHtMaXZlU29ja2V0fSBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIlxuaW1wb3J0IHRvcGJhciBmcm9tIFwiLi4vdmVuZG9yL3RvcGJhclwiXG5pbXBvcnQge0NoYXJ0SG9va30gZnJvbSBcIi4vY2hhcnRcIlxuXG5sZXQgSG9va3MgPSB7XG4gIENoYXJ0OiBDaGFydEhvb2sgXG4gIC8vIFRoaXMgbmFtZSAoQ2hhcnQpIG11c3QgYmUgdGhlIHNhbWUgbmFtZSBhcyBpbiB0aGUgcGh4IGF0dHJpYnV0ZS4gKGRvbS1lbGVtZW50KVxuICAvLyBXZSBjb3VsZCBhbHNvIHdyaXRlIG91ciBjYWxsYmFja3MgaW4gaGVyZSBuYXR1cmFsbHkgYnV0IHRoaXMgaXMgbXVjaCBjbGVhbmVyLlxufVxubGV0IHRpbWV6b25lID0gSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xubGV0IGNzcmZUb2tlbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJtZXRhW25hbWU9J2NzcmYtdG9rZW4nXVwiKS5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpXG5sZXQgbGl2ZVNvY2tldCA9IG5ldyBMaXZlU29ja2V0KFwiL2xpdmVcIiwgU29ja2V0LCB7aG9va3M6IEhvb2tzLCBwYXJhbXM6IHsgX2NzcmZfdG9rZW46IGNzcmZUb2tlbiwgdGltZXpvbmU6IHRpbWV6b25lfX0pXG5cbi8vIFNob3cgcHJvZ3Jlc3MgYmFyIG9uIGxpdmUgbmF2aWdhdGlvbiBhbmQgZm9ybSBzdWJtaXRzXG50b3BiYXIuY29uZmlnKHtiYXJDb2xvcnM6IHswOiBcIiMyOWRcIn0sIHNoYWRvd0NvbG9yOiBcInJnYmEoMCwgMCwgMCwgLjMpXCJ9KVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIGluZm8gPT4gdG9wYmFyLnNob3coKSlcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OnBhZ2UtbG9hZGluZy1zdG9wXCIsIGluZm8gPT4gdG9wYmFyLmhpZGUoKSlcblxuLy8gY29ubmVjdCBpZiB0aGVyZSBhcmUgYW55IExpdmVWaWV3cyBvbiB0aGUgcGFnZVxubGl2ZVNvY2tldC5jb25uZWN0KClcblxuLy8gZXhwb3NlIGxpdmVTb2NrZXQgb24gd2luZG93IGZvciB3ZWIgY29uc29sZSBkZWJ1ZyBsb2dzIGFuZCBsYXRlbmN5IHNpbXVsYXRpb246XG4vLyA+PiBsaXZlU29ja2V0LmVuYWJsZURlYnVnKClcbi8vID4+IGxpdmVTb2NrZXQuZW5hYmxlTGF0ZW5jeVNpbSgxMDAwKSAgLy8gZW5hYmxlZCBmb3IgZHVyYXRpb24gb2YgYnJvd3NlciBzZXNzaW9uXG4vLyA+PiBsaXZlU29ja2V0LmRpc2FibGVMYXRlbmN5U2ltKClcbndpbmRvdy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldFxuXG4iLCAiLyoqXG4qIENvcHlyaWdodCAoYykgMjAyMiwgTGVvbiBTb3Jva2luXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4qXG4qIHVQbG90LmpzIChcdTAzQkNQbG90KVxuKiBBIHNtYWxsLCBmYXN0IGNoYXJ0IGZvciB0aW1lIHNlcmllcywgbGluZXMsIGFyZWFzLCBvaGxjICYgYmFyc1xuKiBodHRwczovL2dpdGh1Yi5jb20vbGVlb25peWEvdVBsb3QgKHYxLjYuMjIpXG4qL1xuXG5jb25zdCBGRUFUX1RJTUUgICAgICAgICAgPSB0cnVlO1xuXG5jb25zdCBwcmUgPSBcInUtXCI7XG5cbmNvbnN0IFVQTE9UICAgICAgICAgID0gICAgICAgXCJ1cGxvdFwiO1xuY29uc3QgT1JJX0haICAgICAgICAgPSBwcmUgKyBcImh6XCI7XG5jb25zdCBPUklfVlQgICAgICAgICA9IHByZSArIFwidnRcIjtcbmNvbnN0IFRJVExFICAgICAgICAgID0gcHJlICsgXCJ0aXRsZVwiO1xuY29uc3QgV1JBUCAgICAgICAgICAgPSBwcmUgKyBcIndyYXBcIjtcbmNvbnN0IFVOREVSICAgICAgICAgID0gcHJlICsgXCJ1bmRlclwiO1xuY29uc3QgT1ZFUiAgICAgICAgICAgPSBwcmUgKyBcIm92ZXJcIjtcbmNvbnN0IEFYSVMgICAgICAgICAgID0gcHJlICsgXCJheGlzXCI7XG5jb25zdCBPRkYgICAgICAgICAgICA9IHByZSArIFwib2ZmXCI7XG5jb25zdCBTRUxFQ1QgICAgICAgICA9IHByZSArIFwic2VsZWN0XCI7XG5jb25zdCBDVVJTT1JfWCAgICAgICA9IHByZSArIFwiY3Vyc29yLXhcIjtcbmNvbnN0IENVUlNPUl9ZICAgICAgID0gcHJlICsgXCJjdXJzb3IteVwiO1xuY29uc3QgQ1VSU09SX1BUICAgICAgPSBwcmUgKyBcImN1cnNvci1wdFwiO1xuY29uc3QgTEVHRU5EICAgICAgICAgPSBwcmUgKyBcImxlZ2VuZFwiO1xuY29uc3QgTEVHRU5EX0xJVkUgICAgPSBwcmUgKyBcImxpdmVcIjtcbmNvbnN0IExFR0VORF9JTkxJTkUgID0gcHJlICsgXCJpbmxpbmVcIjtcbmNvbnN0IExFR0VORF9USEVBRCAgID0gcHJlICsgXCJ0aGVhZFwiO1xuY29uc3QgTEVHRU5EX1NFUklFUyAgPSBwcmUgKyBcInNlcmllc1wiO1xuY29uc3QgTEVHRU5EX01BUktFUiAgPSBwcmUgKyBcIm1hcmtlclwiO1xuY29uc3QgTEVHRU5EX0xBQkVMICAgPSBwcmUgKyBcImxhYmVsXCI7XG5jb25zdCBMRUdFTkRfVkFMVUUgICA9IHByZSArIFwidmFsdWVcIjtcblxuY29uc3QgV0lEVEggICAgICAgPSBcIndpZHRoXCI7XG5jb25zdCBIRUlHSFQgICAgICA9IFwiaGVpZ2h0XCI7XG5jb25zdCBUT1AgICAgICAgICA9IFwidG9wXCI7XG5jb25zdCBCT1RUT00gICAgICA9IFwiYm90dG9tXCI7XG5jb25zdCBMRUZUICAgICAgICA9IFwibGVmdFwiO1xuY29uc3QgUklHSFQgICAgICAgPSBcInJpZ2h0XCI7XG5jb25zdCBoZXhCbGFjayAgICA9IFwiIzAwMFwiO1xuY29uc3QgdHJhbnNwYXJlbnQgPSBoZXhCbGFjayArIFwiMFwiO1xuXG5jb25zdCBtb3VzZW1vdmUgICA9IFwibW91c2Vtb3ZlXCI7XG5jb25zdCBtb3VzZWRvd24gICA9IFwibW91c2Vkb3duXCI7XG5jb25zdCBtb3VzZXVwICAgICA9IFwibW91c2V1cFwiO1xuY29uc3QgbW91c2VlbnRlciAgPSBcIm1vdXNlZW50ZXJcIjtcbmNvbnN0IG1vdXNlbGVhdmUgID0gXCJtb3VzZWxlYXZlXCI7XG5jb25zdCBkYmxjbGljayAgICA9IFwiZGJsY2xpY2tcIjtcbmNvbnN0IHJlc2l6ZSAgICAgID0gXCJyZXNpemVcIjtcbmNvbnN0IHNjcm9sbCAgICAgID0gXCJzY3JvbGxcIjtcblxuY29uc3QgY2hhbmdlICAgICAgPSBcImNoYW5nZVwiO1xuY29uc3QgZHBweGNoYW5nZSAgPSBcImRwcHhjaGFuZ2VcIjtcblxuY29uc3QgZG9tRW52ID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJztcblxuY29uc3QgZG9jID0gZG9tRW52ID8gZG9jdW1lbnQgIDogbnVsbDtcbmNvbnN0IHdpbiA9IGRvbUVudiA/IHdpbmRvdyAgICA6IG51bGw7XG5jb25zdCBuYXYgPSBkb21FbnYgPyBuYXZpZ2F0b3IgOiBudWxsO1xuXG5sZXQgcHhSYXRpbztcblxubGV0IHF1ZXJ5O1xuXG5mdW5jdGlvbiBzZXRQeFJhdGlvKCkge1xuXHRsZXQgX3B4UmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvO1xuXG5cdC8vIGR1cmluZyBwcmludCBwcmV2aWV3LCBDaHJvbWUgZmlyZXMgb2ZmIHRoZXNlIGRwcHggcXVlcmllcyBldmVuIHdpdGhvdXQgY2hhbmdlc1xuXHRpZiAocHhSYXRpbyAhPSBfcHhSYXRpbykge1xuXHRcdHB4UmF0aW8gPSBfcHhSYXRpbztcblxuXHRcdHF1ZXJ5ICYmIG9mZihjaGFuZ2UsIHF1ZXJ5LCBzZXRQeFJhdGlvKTtcblx0XHRxdWVyeSA9IG1hdGNoTWVkaWEoYChtaW4tcmVzb2x1dGlvbjogJHtweFJhdGlvIC0gMC4wMDF9ZHBweCkgYW5kIChtYXgtcmVzb2x1dGlvbjogJHtweFJhdGlvICsgMC4wMDF9ZHBweClgKTtcblx0XHRvbihjaGFuZ2UsIHF1ZXJ5LCBzZXRQeFJhdGlvKTtcblxuXHRcdHdpbi5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChkcHB4Y2hhbmdlKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGMpIHtcblx0aWYgKGMgIT0gbnVsbCkge1xuXHRcdGxldCBjbCA9IGVsLmNsYXNzTGlzdDtcblx0XHQhY2wuY29udGFpbnMoYykgJiYgY2wuYWRkKGMpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbUNsYXNzKGVsLCBjKSB7XG5cdGxldCBjbCA9IGVsLmNsYXNzTGlzdDtcblx0Y2wuY29udGFpbnMoYykgJiYgY2wucmVtb3ZlKGMpO1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZVB4KGVsLCBuYW1lLCB2YWx1ZSkge1xuXHRlbC5zdHlsZVtuYW1lXSA9IHZhbHVlICsgXCJweFwiO1xufVxuXG5mdW5jdGlvbiBwbGFjZVRhZyh0YWcsIGNscywgdGFyZywgcmVmRWwpIHtcblx0bGV0IGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQodGFnKTtcblxuXHRpZiAoY2xzICE9IG51bGwpXG5cdFx0YWRkQ2xhc3MoZWwsIGNscyk7XG5cblx0aWYgKHRhcmcgIT0gbnVsbClcblx0XHR0YXJnLmluc2VydEJlZm9yZShlbCwgcmVmRWwpO1xuXG5cdHJldHVybiBlbDtcbn1cblxuZnVuY3Rpb24gcGxhY2VEaXYoY2xzLCB0YXJnKSB7XG5cdHJldHVybiBwbGFjZVRhZyhcImRpdlwiLCBjbHMsIHRhcmcpO1xufVxuXG5jb25zdCB4Zm9ybUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gZWxUcmFucyhlbCwgeFBvcywgeVBvcywgeE1heCwgeU1heCkge1xuXHRsZXQgeGZvcm0gPSBcInRyYW5zbGF0ZShcIiArIHhQb3MgKyBcInB4LFwiICsgeVBvcyArIFwicHgpXCI7XG5cdGxldCB4Zm9ybU9sZCA9IHhmb3JtQ2FjaGUuZ2V0KGVsKTtcblxuXHRpZiAoeGZvcm0gIT0geGZvcm1PbGQpIHtcblx0XHRlbC5zdHlsZS50cmFuc2Zvcm0gPSB4Zm9ybTtcblx0XHR4Zm9ybUNhY2hlLnNldChlbCwgeGZvcm0pO1xuXG5cdFx0aWYgKHhQb3MgPCAwIHx8IHlQb3MgPCAwIHx8IHhQb3MgPiB4TWF4IHx8IHlQb3MgPiB5TWF4KVxuXHRcdFx0YWRkQ2xhc3MoZWwsIE9GRik7XG5cdFx0ZWxzZVxuXHRcdFx0cmVtQ2xhc3MoZWwsIE9GRik7XG5cdH1cbn1cblxuY29uc3QgY29sb3JDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbmZ1bmN0aW9uIGVsQ29sb3IoZWwsIGJhY2tncm91bmQsIGJvcmRlckNvbG9yKSB7XG5cdGxldCBuZXdDb2xvciA9IGJhY2tncm91bmQgKyBib3JkZXJDb2xvcjtcblx0bGV0IG9sZENvbG9yID0gY29sb3JDYWNoZS5nZXQoZWwpO1xuXG5cdGlmIChuZXdDb2xvciAhPSBvbGRDb2xvcikge1xuXHRcdGNvbG9yQ2FjaGUuc2V0KGVsLCBuZXdDb2xvcik7XG5cdFx0ZWwuc3R5bGUuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG5cdFx0ZWwuc3R5bGUuYm9yZGVyQ29sb3IgPSBib3JkZXJDb2xvcjtcblx0fVxufVxuXG5jb25zdCBzaXplQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG5mdW5jdGlvbiBlbFNpemUoZWwsIG5ld1dpZCwgbmV3SGd0LCBjZW50ZXJlZCkge1xuXHRsZXQgbmV3U2l6ZSA9IG5ld1dpZCArIFwiXCIgKyBuZXdIZ3Q7XG5cdGxldCBvbGRTaXplID0gc2l6ZUNhY2hlLmdldChlbCk7XG5cblx0aWYgKG5ld1NpemUgIT0gb2xkU2l6ZSkge1xuXHRcdHNpemVDYWNoZS5zZXQoZWwsIG5ld1NpemUpO1xuXHRcdGVsLnN0eWxlLmhlaWdodCA9IG5ld0hndCArIFwicHhcIjtcblx0XHRlbC5zdHlsZS53aWR0aCA9IG5ld1dpZCArIFwicHhcIjtcblx0XHRlbC5zdHlsZS5tYXJnaW5MZWZ0ID0gY2VudGVyZWQgPyAtbmV3V2lkLzIgKyBcInB4XCIgOiAwO1xuXHRcdGVsLnN0eWxlLm1hcmdpblRvcCA9IGNlbnRlcmVkID8gLW5ld0hndC8yICsgXCJweFwiIDogMDtcblx0fVxufVxuXG5jb25zdCBldk9wdHMgPSB7cGFzc2l2ZTogdHJ1ZX07XG5jb25zdCBldk9wdHMyID0gey4uLmV2T3B0cywgY2FwdHVyZTogdHJ1ZX07XG5cbmZ1bmN0aW9uIG9uKGV2LCBlbCwgY2IsIGNhcHQpIHtcblx0ZWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgY2IsIGNhcHQgPyBldk9wdHMyIDogZXZPcHRzKTtcbn1cblxuZnVuY3Rpb24gb2ZmKGV2LCBlbCwgY2IsIGNhcHQpIHtcblx0ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgY2IsIGNhcHQgPyBldk9wdHMyIDogZXZPcHRzKTtcbn1cblxuZG9tRW52ICYmIHNldFB4UmF0aW8oKTtcblxuLy8gYmluYXJ5IHNlYXJjaCBmb3IgaW5kZXggb2YgY2xvc2VzdCB2YWx1ZVxuZnVuY3Rpb24gY2xvc2VzdElkeChudW0sIGFyciwgbG8sIGhpKSB7XG5cdGxldCBtaWQ7XG5cdGxvID0gbG8gfHwgMDtcblx0aGkgPSBoaSB8fCBhcnIubGVuZ3RoIC0gMTtcblx0bGV0IGJpdHdpc2UgPSBoaSA8PSAyMTQ3NDgzNjQ3O1xuXG5cdHdoaWxlIChoaSAtIGxvID4gMSkge1xuXHRcdG1pZCA9IGJpdHdpc2UgPyAobG8gKyBoaSkgPj4gMSA6IGZsb29yKChsbyArIGhpKSAvIDIpO1xuXG5cdFx0aWYgKGFyclttaWRdIDwgbnVtKVxuXHRcdFx0bG8gPSBtaWQ7XG5cdFx0ZWxzZVxuXHRcdFx0aGkgPSBtaWQ7XG5cdH1cblxuXHRpZiAobnVtIC0gYXJyW2xvXSA8PSBhcnJbaGldIC0gbnVtKVxuXHRcdHJldHVybiBsbztcblxuXHRyZXR1cm4gaGk7XG59XG5cbmZ1bmN0aW9uIG5vbk51bGxJZHgoZGF0YSwgX2kwLCBfaTEsIGRpcikge1xuXHRmb3IgKGxldCBpID0gZGlyID09IDEgPyBfaTAgOiBfaTE7IGkgPj0gX2kwICYmIGkgPD0gX2kxOyBpICs9IGRpcikge1xuXHRcdGlmIChkYXRhW2ldICE9IG51bGwpXG5cdFx0XHRyZXR1cm4gaTtcblx0fVxuXG5cdHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0TWluTWF4KGRhdGEsIF9pMCwgX2kxLCBzb3J0ZWQpIHtcbi8vXHRjb25zb2xlLmxvZyhcImdldE1pbk1heCgpXCIpO1xuXG5cdGxldCBfbWluID0gaW5mO1xuXHRsZXQgX21heCA9IC1pbmY7XG5cblx0aWYgKHNvcnRlZCA9PSAxKSB7XG5cdFx0X21pbiA9IGRhdGFbX2kwXTtcblx0XHRfbWF4ID0gZGF0YVtfaTFdO1xuXHR9XG5cdGVsc2UgaWYgKHNvcnRlZCA9PSAtMSkge1xuXHRcdF9taW4gPSBkYXRhW19pMV07XG5cdFx0X21heCA9IGRhdGFbX2kwXTtcblx0fVxuXHRlbHNlIHtcblx0XHRmb3IgKGxldCBpID0gX2kwOyBpIDw9IF9pMTsgaSsrKSB7XG5cdFx0XHRpZiAoZGF0YVtpXSAhPSBudWxsKSB7XG5cdFx0XHRcdF9taW4gPSBtaW4oX21pbiwgZGF0YVtpXSk7XG5cdFx0XHRcdF9tYXggPSBtYXgoX21heCwgZGF0YVtpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFtfbWluLCBfbWF4XTtcbn1cblxuZnVuY3Rpb24gZ2V0TWluTWF4TG9nKGRhdGEsIF9pMCwgX2kxKSB7XG4vL1x0Y29uc29sZS5sb2coXCJnZXRNaW5NYXgoKVwiKTtcblxuXHRsZXQgX21pbiA9IGluZjtcblx0bGV0IF9tYXggPSAtaW5mO1xuXG5cdGZvciAobGV0IGkgPSBfaTA7IGkgPD0gX2kxOyBpKyspIHtcblx0XHRpZiAoZGF0YVtpXSA+IDApIHtcblx0XHRcdF9taW4gPSBtaW4oX21pbiwgZGF0YVtpXSk7XG5cdFx0XHRfbWF4ID0gbWF4KF9tYXgsIGRhdGFbaV0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBbXG5cdFx0X21pbiA9PSAgaW5mID8gIDEgOiBfbWluLFxuXHRcdF9tYXggPT0gLWluZiA/IDEwIDogX21heCxcblx0XTtcbn1cblxuY29uc3QgX2ZpeGVkVHVwbGUgPSBbMCwgMF07XG5cbmZ1bmN0aW9uIGZpeEluY3IobWluSW5jciwgbWF4SW5jciwgbWluRXhwLCBtYXhFeHApIHtcblx0X2ZpeGVkVHVwbGVbMF0gPSBtaW5FeHAgPCAwID8gcm91bmREZWMobWluSW5jciwgLW1pbkV4cCkgOiBtaW5JbmNyO1xuXHRfZml4ZWRUdXBsZVsxXSA9IG1heEV4cCA8IDAgPyByb3VuZERlYyhtYXhJbmNyLCAtbWF4RXhwKSA6IG1heEluY3I7XG5cdHJldHVybiBfZml4ZWRUdXBsZTtcbn1cblxuZnVuY3Rpb24gcmFuZ2VMb2cobWluLCBtYXgsIGJhc2UsIGZ1bGxNYWdzKSB7XG5cdGxldCBtaW5TaWduID0gc2lnbihtaW4pO1xuXG5cdGxldCBsb2dGbiA9IGJhc2UgPT0gMTAgPyBsb2cxMCA6IGxvZzI7XG5cblx0aWYgKG1pbiA9PSBtYXgpIHtcblx0XHRpZiAobWluU2lnbiA9PSAtMSkge1xuXHRcdFx0bWluICo9IGJhc2U7XG5cdFx0XHRtYXggLz0gYmFzZTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRtaW4gLz0gYmFzZTtcblx0XHRcdG1heCAqPSBiYXNlO1xuXHRcdH1cblx0fVxuXG5cdGxldCBtaW5FeHAsIG1heEV4cCwgbWluTWF4SW5jcnM7XG5cblx0aWYgKGZ1bGxNYWdzKSB7XG5cdFx0bWluRXhwID0gZmxvb3IobG9nRm4obWluKSk7XG5cdFx0bWF4RXhwID0gIGNlaWwobG9nRm4obWF4KSk7XG5cblx0XHRtaW5NYXhJbmNycyA9IGZpeEluY3IocG93KGJhc2UsIG1pbkV4cCksIHBvdyhiYXNlLCBtYXhFeHApLCBtaW5FeHAsIG1heEV4cCk7XG5cblx0XHRtaW4gPSBtaW5NYXhJbmNyc1swXTtcblx0XHRtYXggPSBtaW5NYXhJbmNyc1sxXTtcblx0fVxuXHRlbHNlIHtcblx0XHRtaW5FeHAgPSBmbG9vcihsb2dGbihhYnMobWluKSkpO1xuXHRcdG1heEV4cCA9IGZsb29yKGxvZ0ZuKGFicyhtYXgpKSk7XG5cblx0XHRtaW5NYXhJbmNycyA9IGZpeEluY3IocG93KGJhc2UsIG1pbkV4cCksIHBvdyhiYXNlLCBtYXhFeHApLCBtaW5FeHAsIG1heEV4cCk7XG5cblx0XHRtaW4gPSBpbmNyUm91bmREbihtaW4sIG1pbk1heEluY3JzWzBdKTtcblx0XHRtYXggPSBpbmNyUm91bmRVcChtYXgsIG1pbk1heEluY3JzWzFdKTtcblx0fVxuXG5cdHJldHVybiBbbWluLCBtYXhdO1xufVxuXG5mdW5jdGlvbiByYW5nZUFzaW5oKG1pbiwgbWF4LCBiYXNlLCBmdWxsTWFncykge1xuXHRsZXQgbWluTWF4ID0gcmFuZ2VMb2cobWluLCBtYXgsIGJhc2UsIGZ1bGxNYWdzKTtcblxuXHRpZiAobWluID09IDApXG5cdFx0bWluTWF4WzBdID0gMDtcblxuXHRpZiAobWF4ID09IDApXG5cdFx0bWluTWF4WzFdID0gMDtcblxuXHRyZXR1cm4gbWluTWF4O1xufVxuXG5jb25zdCByYW5nZVBhZCA9IDAuMTtcblxuY29uc3QgYXV0b1JhbmdlUGFydCA9IHtcblx0bW9kZTogMyxcblx0cGFkOiByYW5nZVBhZCxcbn07XG5cbmNvbnN0IF9lcVJhbmdlUGFydCA9IHtcblx0cGFkOiAgMCxcblx0c29mdDogbnVsbCxcblx0bW9kZTogMCxcbn07XG5cbmNvbnN0IF9lcVJhbmdlID0ge1xuXHRtaW46IF9lcVJhbmdlUGFydCxcblx0bWF4OiBfZXFSYW5nZVBhcnQsXG59O1xuXG4vLyB0aGlzIGVuc3VyZXMgdGhhdCBub24tdGVtcG9yYWwvbnVtZXJpYyB5LWF4ZXMgZ2V0IG11bHRpcGxlLXNuYXBwZWQgcGFkZGluZyBhZGRlZCBhYm92ZS9iZWxvd1xuLy8gVE9ETzogYWxzbyBhY2NvdW50IGZvciBpbmNycyB3aGVuIHNuYXBwaW5nIHRvIGVuc3VyZSB0b3Agb2YgYXhpcyBnZXRzIGEgdGljayAmIHZhbHVlXG5mdW5jdGlvbiByYW5nZU51bShfbWluLCBfbWF4LCBtdWx0LCBleHRyYSkge1xuXHRpZiAoaXNPYmoobXVsdCkpXG5cdFx0cmV0dXJuIF9yYW5nZU51bShfbWluLCBfbWF4LCBtdWx0KTtcblxuXHRfZXFSYW5nZVBhcnQucGFkICA9IG11bHQ7XG5cdF9lcVJhbmdlUGFydC5zb2Z0ID0gZXh0cmEgPyAwIDogbnVsbDtcblx0X2VxUmFuZ2VQYXJ0Lm1vZGUgPSBleHRyYSA/IDMgOiAwO1xuXG5cdHJldHVybiBfcmFuZ2VOdW0oX21pbiwgX21heCwgX2VxUmFuZ2UpO1xufVxuXG4vLyBudWxsaXNoIGNvYWxlc2NlXG5mdW5jdGlvbiBpZk51bGwobGgsIHJoKSB7XG5cdHJldHVybiBsaCA9PSBudWxsID8gcmggOiBsaDtcbn1cblxuLy8gY2hlY2tzIGlmIGdpdmVuIGluZGV4IHJhbmdlIGluIGFuIGFycmF5IGNvbnRhaW5zIGEgbm9uLW51bGwgdmFsdWVcbi8vIGFrYSBhIHJhbmdlLWJvdW5kZWQgQXJyYXkuc29tZSgpXG5mdW5jdGlvbiBoYXNEYXRhKGRhdGEsIGlkeDAsIGlkeDEpIHtcblx0aWR4MCA9IGlmTnVsbChpZHgwLCAwKTtcblx0aWR4MSA9IGlmTnVsbChpZHgxLCBkYXRhLmxlbmd0aCAtIDEpO1xuXG5cdHdoaWxlIChpZHgwIDw9IGlkeDEpIHtcblx0XHRpZiAoZGF0YVtpZHgwXSAhPSBudWxsKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0aWR4MCsrO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfcmFuZ2VOdW0oX21pbiwgX21heCwgY2ZnKSB7XG5cdGxldCBjbWluID0gY2ZnLm1pbjtcblx0bGV0IGNtYXggPSBjZmcubWF4O1xuXG5cdGxldCBwYWRNaW4gPSBpZk51bGwoY21pbi5wYWQsIDApO1xuXHRsZXQgcGFkTWF4ID0gaWZOdWxsKGNtYXgucGFkLCAwKTtcblxuXHRsZXQgaGFyZE1pbiA9IGlmTnVsbChjbWluLmhhcmQsIC1pbmYpO1xuXHRsZXQgaGFyZE1heCA9IGlmTnVsbChjbWF4LmhhcmQsICBpbmYpO1xuXG5cdGxldCBzb2Z0TWluID0gaWZOdWxsKGNtaW4uc29mdCwgIGluZik7XG5cdGxldCBzb2Z0TWF4ID0gaWZOdWxsKGNtYXguc29mdCwgLWluZik7XG5cblx0bGV0IHNvZnRNaW5Nb2RlID0gaWZOdWxsKGNtaW4ubW9kZSwgMCk7XG5cdGxldCBzb2Z0TWF4TW9kZSA9IGlmTnVsbChjbWF4Lm1vZGUsIDApO1xuXG5cdGxldCBkZWx0YSAgICAgICAgPSBfbWF4IC0gX21pbjtcblxuXHQvLyB0aGlzIGhhbmRsZXMgc2l0dWF0aW9ucyBsaWtlIDg5LjcsIDg5LjY5OTk5OTk5OTk5OTk5XG5cdC8vIGJ5IGFzc3VtaW5nIDAuMDAxeCBkZWx0YXMgYXJlIHByZWNpc2lvbiBlcnJvcnNcbi8vXHRpZiAoZGVsdGEgPiAwICYmIGRlbHRhIDwgYWJzKF9tYXgpIC8gMWUzKVxuLy9cdFx0ZGVsdGEgPSAwO1xuXG5cdC8vIHRyZWF0IGRhdGEgYXMgZmxhdCBpZiBkZWx0YSBpcyBsZXNzIHRoYW4gMSBiaWxsaW9udGhcblx0aWYgKGRlbHRhIDwgMWUtOSkge1xuXHRcdGRlbHRhID0gMDtcblxuXHRcdC8vIGlmIHNvZnQgbW9kZSBpcyAyIGFuZCBhbGwgdmFscyBhcmUgZmxhdCBhdCAwLCBhdm9pZCB0aGUgMC4xICogMWUzIGZhbGxiYWNrXG5cdFx0Ly8gdGhpcyBwcmV2ZW50cyAwLDAsMCBmcm9tIHJhbmdpbmcgdG8gLTEwMCwxMDAgd2hlbiBzb2Z0TWluL3NvZnRNYXggYXJlIC0xLDFcblx0XHRpZiAoX21pbiA9PSAwIHx8IF9tYXggPT0gMCkge1xuXHRcdFx0ZGVsdGEgPSAxZS05O1xuXG5cdFx0XHRpZiAoc29mdE1pbk1vZGUgPT0gMiAmJiBzb2Z0TWluICE9IGluZilcblx0XHRcdFx0cGFkTWluID0gMDtcblxuXHRcdFx0aWYgKHNvZnRNYXhNb2RlID09IDIgJiYgc29mdE1heCAhPSAtaW5mKVxuXHRcdFx0XHRwYWRNYXggPSAwO1xuXHRcdH1cblx0fVxuXG5cdGxldCBub25aZXJvRGVsdGEgPSBkZWx0YSB8fCBhYnMoX21heCkgfHwgMWUzO1xuXHRsZXQgbWFnICAgICAgICAgID0gbG9nMTAobm9uWmVyb0RlbHRhKTtcblx0bGV0IGJhc2UgICAgICAgICA9IHBvdygxMCwgZmxvb3IobWFnKSk7XG5cblx0bGV0IF9wYWRNaW4gID0gbm9uWmVyb0RlbHRhICogKGRlbHRhID09IDAgPyAoX21pbiA9PSAwID8gLjEgOiAxKSA6IHBhZE1pbik7XG5cdGxldCBfbmV3TWluICA9IHJvdW5kRGVjKGluY3JSb3VuZERuKF9taW4gLSBfcGFkTWluLCBiYXNlLzEwKSwgOSk7XG5cdGxldCBfc29mdE1pbiA9IF9taW4gPj0gc29mdE1pbiAmJiAoc29mdE1pbk1vZGUgPT0gMSB8fCBzb2Z0TWluTW9kZSA9PSAzICYmIF9uZXdNaW4gPD0gc29mdE1pbiB8fCBzb2Z0TWluTW9kZSA9PSAyICYmIF9uZXdNaW4gPj0gc29mdE1pbikgPyBzb2Z0TWluIDogaW5mO1xuXHRsZXQgbWluTGltICAgPSBtYXgoaGFyZE1pbiwgX25ld01pbiA8IF9zb2Z0TWluICYmIF9taW4gPj0gX3NvZnRNaW4gPyBfc29mdE1pbiA6IG1pbihfc29mdE1pbiwgX25ld01pbikpO1xuXG5cdGxldCBfcGFkTWF4ICA9IG5vblplcm9EZWx0YSAqIChkZWx0YSA9PSAwID8gKF9tYXggPT0gMCA/IC4xIDogMSkgOiBwYWRNYXgpO1xuXHRsZXQgX25ld01heCAgPSByb3VuZERlYyhpbmNyUm91bmRVcChfbWF4ICsgX3BhZE1heCwgYmFzZS8xMCksIDkpO1xuXHRsZXQgX3NvZnRNYXggPSBfbWF4IDw9IHNvZnRNYXggJiYgKHNvZnRNYXhNb2RlID09IDEgfHwgc29mdE1heE1vZGUgPT0gMyAmJiBfbmV3TWF4ID49IHNvZnRNYXggfHwgc29mdE1heE1vZGUgPT0gMiAmJiBfbmV3TWF4IDw9IHNvZnRNYXgpID8gc29mdE1heCA6IC1pbmY7XG5cdGxldCBtYXhMaW0gICA9IG1pbihoYXJkTWF4LCBfbmV3TWF4ID4gX3NvZnRNYXggJiYgX21heCA8PSBfc29mdE1heCA/IF9zb2Z0TWF4IDogbWF4KF9zb2Z0TWF4LCBfbmV3TWF4KSk7XG5cblx0aWYgKG1pbkxpbSA9PSBtYXhMaW0gJiYgbWluTGltID09IDApXG5cdFx0bWF4TGltID0gMTAwO1xuXG5cdHJldHVybiBbbWluTGltLCBtYXhMaW1dO1xufVxuXG4vLyBhbHRlcm5hdGl2ZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNTQ4OTZcbmNvbnN0IG51bUZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChkb21FbnYgPyBuYXYubGFuZ3VhZ2UgOiAnZW4tVVMnKTtcbmNvbnN0IGZtdE51bSA9IHZhbCA9PiBudW1Gb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG5cbmNvbnN0IE0gPSBNYXRoO1xuXG5jb25zdCBQSSA9IE0uUEk7XG5jb25zdCBhYnMgPSBNLmFicztcbmNvbnN0IGZsb29yID0gTS5mbG9vcjtcbmNvbnN0IHJvdW5kID0gTS5yb3VuZDtcbmNvbnN0IGNlaWwgPSBNLmNlaWw7XG5jb25zdCBtaW4gPSBNLm1pbjtcbmNvbnN0IG1heCA9IE0ubWF4O1xuY29uc3QgcG93ID0gTS5wb3c7XG5jb25zdCBzaWduID0gTS5zaWduO1xuY29uc3QgbG9nMTAgPSBNLmxvZzEwO1xuY29uc3QgbG9nMiA9IE0ubG9nMjtcbi8vIFRPRE86IHNlZW1zIGxpa2UgdGhpcyBuZWVkcyB0byBtYXRjaCBhc2luaCBpbXBsIGlmIHRoZSBwYXNzZWQgdiBpcyB0d2Vha2VkP1xuY29uc3Qgc2luaCA9ICAodiwgbGludGhyZXNoID0gMSkgPT4gTS5zaW5oKHYpICogbGludGhyZXNoO1xuY29uc3QgYXNpbmggPSAodiwgbGludGhyZXNoID0gMSkgPT4gTS5hc2luaCh2IC8gbGludGhyZXNoKTtcblxuY29uc3QgaW5mID0gSW5maW5pdHk7XG5cbmZ1bmN0aW9uIG51bUludERpZ2l0cyh4KSB7XG5cdHJldHVybiAobG9nMTAoKHggXiAoeCA+PiAzMSkpIC0gKHggPj4gMzEpKSB8IDApICsgMTtcbn1cblxuZnVuY3Rpb24gaW5jclJvdW5kKG51bSwgaW5jcikge1xuXHRyZXR1cm4gcm91bmQobnVtL2luY3IpKmluY3I7XG59XG5cbmZ1bmN0aW9uIGNsYW1wKG51bSwgX21pbiwgX21heCkge1xuXHRyZXR1cm4gbWluKG1heChudW0sIF9taW4pLCBfbWF4KTtcbn1cblxuZnVuY3Rpb24gZm5PclNlbGYodikge1xuXHRyZXR1cm4gdHlwZW9mIHYgPT0gXCJmdW5jdGlvblwiID8gdiA6ICgpID0+IHY7XG59XG5cbmNvbnN0IHJldEFyZzAgPSBfMCA9PiBfMDtcblxuY29uc3QgcmV0QXJnMSA9IChfMCwgXzEpID0+IF8xO1xuXG5jb25zdCByZXROdWxsID0gXyA9PiBudWxsO1xuXG5jb25zdCByZXRUcnVlID0gXyA9PiB0cnVlO1xuXG5jb25zdCByZXRFcSA9IChhLCBiKSA9PiBhID09IGI7XG5cbmZ1bmN0aW9uIGluY3JSb3VuZFVwKG51bSwgaW5jcikge1xuXHRyZXR1cm4gY2VpbChudW0vaW5jcikqaW5jcjtcbn1cblxuZnVuY3Rpb24gaW5jclJvdW5kRG4obnVtLCBpbmNyKSB7XG5cdHJldHVybiBmbG9vcihudW0vaW5jcikqaW5jcjtcbn1cblxuZnVuY3Rpb24gcm91bmREZWModmFsLCBkZWMpIHtcblx0cmV0dXJuIHJvdW5kKHZhbCAqIChkZWMgPSAxMCoqZGVjKSkgLyBkZWM7XG59XG5cbmNvbnN0IGZpeGVkRGVjID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBndWVzc0RlYyhudW0pIHtcblx0cmV0dXJuICgoXCJcIitudW0pLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGdlbkluY3JzKGJhc2UsIG1pbkV4cCwgbWF4RXhwLCBtdWx0cykge1xuXHRsZXQgaW5jcnMgPSBbXTtcblxuXHRsZXQgbXVsdERlYyA9IG11bHRzLm1hcChndWVzc0RlYyk7XG5cblx0Zm9yIChsZXQgZXhwID0gbWluRXhwOyBleHAgPCBtYXhFeHA7IGV4cCsrKSB7XG5cdFx0bGV0IGV4cGEgPSBhYnMoZXhwKTtcblx0XHRsZXQgbWFnID0gcm91bmREZWMocG93KGJhc2UsIGV4cCksIGV4cGEpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBtdWx0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGV0IF9pbmNyID0gbXVsdHNbaV0gKiBtYWc7XG5cdFx0XHRsZXQgZGVjID0gKF9pbmNyID49IDAgJiYgZXhwID49IDAgPyAwIDogZXhwYSkgKyAoZXhwID49IG11bHREZWNbaV0gPyAwIDogbXVsdERlY1tpXSk7XG5cdFx0XHRsZXQgaW5jciA9IHJvdW5kRGVjKF9pbmNyLCBkZWMpO1xuXHRcdFx0aW5jcnMucHVzaChpbmNyKTtcblx0XHRcdGZpeGVkRGVjLnNldChpbmNyLCBkZWMpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBpbmNycztcbn1cblxuLy9leHBvcnQgY29uc3QgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuY29uc3QgRU1QVFlfT0JKID0ge307XG5jb25zdCBFTVBUWV9BUlIgPSBbXTtcblxuY29uc3QgbnVsbE51bGxUdXBsZSA9IFtudWxsLCBudWxsXTtcblxuY29uc3QgaXNBcnIgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiBpc1N0cih2KSB7XG5cdHJldHVybiB0eXBlb2YgdiA9PSAnc3RyaW5nJztcbn1cblxuZnVuY3Rpb24gaXNPYmoodikge1xuXHRsZXQgaXMgPSBmYWxzZTtcblxuXHRpZiAodiAhPSBudWxsKSB7XG5cdFx0bGV0IGMgPSB2LmNvbnN0cnVjdG9yO1xuXHRcdGlzID0gYyA9PSBudWxsIHx8IGMgPT0gT2JqZWN0O1xuXHR9XG5cblx0cmV0dXJuIGlzO1xufVxuXG5mdW5jdGlvbiBmYXN0SXNPYmoodikge1xuXHRyZXR1cm4gdiAhPSBudWxsICYmIHR5cGVvZiB2ID09ICdvYmplY3QnO1xufVxuXG5jb25zdCBUeXBlZEFycmF5ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKFVpbnQ4QXJyYXkpO1xuXG5mdW5jdGlvbiBjb3B5KG8sIF9pc09iaiA9IGlzT2JqKSB7XG5cdGxldCBvdXQ7XG5cblx0aWYgKGlzQXJyKG8pKSB7XG5cdFx0bGV0IHZhbCA9IG8uZmluZCh2ID0+IHYgIT0gbnVsbCk7XG5cblx0XHRpZiAoaXNBcnIodmFsKSB8fCBfaXNPYmoodmFsKSkge1xuXHRcdFx0b3V0ID0gQXJyYXkoby5sZW5ndGgpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBvLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRvdXRbaV0gPSBjb3B5KG9baV0sIF9pc09iaik7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHRcdG91dCA9IG8uc2xpY2UoKTtcblx0fVxuXHRlbHNlIGlmIChvIGluc3RhbmNlb2YgVHlwZWRBcnJheSkgLy8gYWxzbyAoQXJyYXlCdWZmZXIuaXNWaWV3KG8pICYmICEobyBpbnN0YW5jZW9mIERhdGFWaWV3KSlcblx0XHRvdXQgPSBvLnNsaWNlKCk7XG5cdGVsc2UgaWYgKF9pc09iaihvKSkge1xuXHRcdG91dCA9IHt9O1xuXHRcdGZvciAobGV0IGsgaW4gbylcblx0XHRcdG91dFtrXSA9IGNvcHkob1trXSwgX2lzT2JqKTtcblx0fVxuXHRlbHNlXG5cdFx0b3V0ID0gbztcblxuXHRyZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBhc3NpZ24odGFyZykge1xuXHRsZXQgYXJncyA9IGFyZ3VtZW50cztcblxuXHRmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRsZXQgc3JjID0gYXJnc1tpXTtcblxuXHRcdGZvciAobGV0IGtleSBpbiBzcmMpIHtcblx0XHRcdGlmIChpc09iaih0YXJnW2tleV0pKVxuXHRcdFx0XHRhc3NpZ24odGFyZ1trZXldLCBjb3B5KHNyY1trZXldKSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRhcmdba2V5XSA9IGNvcHkoc3JjW2tleV0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0YXJnO1xufVxuXG4vLyBudWxsTW9kZXNcbmNvbnN0IE5VTExfUkVNT1ZFID0gMDsgIC8vIG51bGxzIGFyZSBjb252ZXJ0ZWQgdG8gdW5kZWZpbmVkIChlLmcuIGZvciBzcGFuR2FwczogdHJ1ZSlcbmNvbnN0IE5VTExfUkVUQUlOID0gMTsgIC8vIG51bGxzIGFyZSByZXRhaW5lZCwgd2l0aCBhbGlnbm1lbnQgYXJ0aWZhY3RzIHNldCB0byB1bmRlZmluZWQgKGRlZmF1bHQpXG5jb25zdCBOVUxMX0VYUEFORCA9IDI7ICAvLyBudWxscyBhcmUgZXhwYW5kZWQgdG8gaW5jbHVkZSBhbnkgYWRqYWNlbnQgYWxpZ25tZW50IGFydGlmYWN0c1xuXG4vLyBzZXRzIHVuZGVmaW5lZCB2YWx1ZXMgdG8gbnVsbHMgd2hlbiBhZGphY2VudCB0byBleGlzdGluZyBudWxscyAobWluZXN3ZWVwZXIpXG5mdW5jdGlvbiBudWxsRXhwYW5kKHlWYWxzLCBudWxsSWR4cywgYWxpZ25lZExlbikge1xuXHRmb3IgKGxldCBpID0gMCwgeGksIGxhc3ROdWxsSWR4ID0gLTE7IGkgPCBudWxsSWR4cy5sZW5ndGg7IGkrKykge1xuXHRcdGxldCBudWxsSWR4ID0gbnVsbElkeHNbaV07XG5cblx0XHRpZiAobnVsbElkeCA+IGxhc3ROdWxsSWR4KSB7XG5cdFx0XHR4aSA9IG51bGxJZHggLSAxO1xuXHRcdFx0d2hpbGUgKHhpID49IDAgJiYgeVZhbHNbeGldID09IG51bGwpXG5cdFx0XHRcdHlWYWxzW3hpLS1dID0gbnVsbDtcblxuXHRcdFx0eGkgPSBudWxsSWR4ICsgMTtcblx0XHRcdHdoaWxlICh4aSA8IGFsaWduZWRMZW4gJiYgeVZhbHNbeGldID09IG51bGwpXG5cdFx0XHRcdHlWYWxzW2xhc3ROdWxsSWR4ID0geGkrK10gPSBudWxsO1xuXHRcdH1cblx0fVxufVxuXG4vLyBudWxsTW9kZXMgaXMgYSB0YWJsZXMtbWF0Y2hlZCBhcnJheSBpbmRpY2F0aW5nIGhvdyB0byB0cmVhdCBudWxscyBpbiBlYWNoIHNlcmllc1xuLy8gb3V0cHV0IGlzIHNvcnRlZCBBU0Mgb24gdGhlIGpvaW5lZCBmaWVsZCAodGFibGVbMF0pIGFuZCBkdXBsaWNhdGUgam9pbiB2YWx1ZXMgYXJlIGNvbGxhcHNlZFxuZnVuY3Rpb24gam9pbih0YWJsZXMsIG51bGxNb2Rlcykge1xuXHRsZXQgeFZhbHMgPSBuZXcgU2V0KCk7XG5cblx0Zm9yIChsZXQgdGkgPSAwOyB0aSA8IHRhYmxlcy5sZW5ndGg7IHRpKyspIHtcblx0XHRsZXQgdCA9IHRhYmxlc1t0aV07XG5cdFx0bGV0IHhzID0gdFswXTtcblx0XHRsZXQgbGVuID0geHMubGVuZ3RoO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcblx0XHRcdHhWYWxzLmFkZCh4c1tpXSk7XG5cdH1cblxuXHRsZXQgZGF0YSA9IFtBcnJheS5mcm9tKHhWYWxzKS5zb3J0KChhLCBiKSA9PiBhIC0gYildO1xuXG5cdGxldCBhbGlnbmVkTGVuID0gZGF0YVswXS5sZW5ndGg7XG5cblx0bGV0IHhJZHhzID0gbmV3IE1hcCgpO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgYWxpZ25lZExlbjsgaSsrKVxuXHRcdHhJZHhzLnNldChkYXRhWzBdW2ldLCBpKTtcblxuXHRmb3IgKGxldCB0aSA9IDA7IHRpIDwgdGFibGVzLmxlbmd0aDsgdGkrKykge1xuXHRcdGxldCB0ID0gdGFibGVzW3RpXTtcblx0XHRsZXQgeHMgPSB0WzBdO1xuXG5cdFx0Zm9yIChsZXQgc2kgPSAxOyBzaSA8IHQubGVuZ3RoOyBzaSsrKSB7XG5cdFx0XHRsZXQgeXMgPSB0W3NpXTtcblxuXHRcdFx0bGV0IHlWYWxzID0gQXJyYXkoYWxpZ25lZExlbikuZmlsbCh1bmRlZmluZWQpO1xuXG5cdFx0XHRsZXQgbnVsbE1vZGUgPSBudWxsTW9kZXMgPyBudWxsTW9kZXNbdGldW3NpXSA6IE5VTExfUkVUQUlOO1xuXG5cdFx0XHRsZXQgbnVsbElkeHMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRsZXQgeVZhbCA9IHlzW2ldO1xuXHRcdFx0XHRsZXQgYWxpZ25lZElkeCA9IHhJZHhzLmdldCh4c1tpXSk7XG5cblx0XHRcdFx0aWYgKHlWYWwgPT09IG51bGwpIHtcblx0XHRcdFx0XHRpZiAobnVsbE1vZGUgIT0gTlVMTF9SRU1PVkUpIHtcblx0XHRcdFx0XHRcdHlWYWxzW2FsaWduZWRJZHhdID0geVZhbDtcblxuXHRcdFx0XHRcdFx0aWYgKG51bGxNb2RlID09IE5VTExfRVhQQU5EKVxuXHRcdFx0XHRcdFx0XHRudWxsSWR4cy5wdXNoKGFsaWduZWRJZHgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0eVZhbHNbYWxpZ25lZElkeF0gPSB5VmFsO1xuXHRcdFx0fVxuXG5cdFx0XHRudWxsRXhwYW5kKHlWYWxzLCBudWxsSWR4cywgYWxpZ25lZExlbik7XG5cblx0XHRcdGRhdGEucHVzaCh5VmFscyk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmNvbnN0IG1pY3JvVGFzayA9IHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PSBcInVuZGVmaW5lZFwiID8gZm4gPT4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmbikgOiBxdWV1ZU1pY3JvdGFzaztcblxuY29uc3QgbW9udGhzID0gW1xuXHRcIkphbnVhcnlcIixcblx0XCJGZWJydWFyeVwiLFxuXHRcIk1hcmNoXCIsXG5cdFwiQXByaWxcIixcblx0XCJNYXlcIixcblx0XCJKdW5lXCIsXG5cdFwiSnVseVwiLFxuXHRcIkF1Z3VzdFwiLFxuXHRcIlNlcHRlbWJlclwiLFxuXHRcIk9jdG9iZXJcIixcblx0XCJOb3ZlbWJlclwiLFxuXHRcIkRlY2VtYmVyXCIsXG5dO1xuXG5jb25zdCBkYXlzID0gW1xuXHRcIlN1bmRheVwiLFxuXHRcIk1vbmRheVwiLFxuXHRcIlR1ZXNkYXlcIixcblx0XCJXZWRuZXNkYXlcIixcblx0XCJUaHVyc2RheVwiLFxuXHRcIkZyaWRheVwiLFxuXHRcIlNhdHVyZGF5XCIsXG5dO1xuXG5mdW5jdGlvbiBzbGljZTMoc3RyKSB7XG5cdHJldHVybiBzdHIuc2xpY2UoMCwgMyk7XG59XG5cbmNvbnN0IGRheXMzID0gZGF5cy5tYXAoc2xpY2UzKTtcblxuY29uc3QgbW9udGhzMyA9IG1vbnRocy5tYXAoc2xpY2UzKTtcblxuY29uc3QgZW5nTmFtZXMgPSB7XG5cdE1NTU06IG1vbnRocyxcblx0TU1NOiAgbW9udGhzMyxcblx0V1dXVzogZGF5cyxcblx0V1dXOiAgZGF5czMsXG59O1xuXG5mdW5jdGlvbiB6ZXJvUGFkMihpbnQpIHtcblx0cmV0dXJuIChpbnQgPCAxMCA/ICcwJyA6ICcnKSArIGludDtcbn1cblxuZnVuY3Rpb24gemVyb1BhZDMoaW50KSB7XG5cdHJldHVybiAoaW50IDwgMTAgPyAnMDAnIDogaW50IDwgMTAwID8gJzAnIDogJycpICsgaW50O1xufVxuXG4vKlxuZnVuY3Rpb24gc3VmZml4KGludCkge1xuXHRsZXQgbW9kMTAgPSBpbnQgJSAxMDtcblxuXHRyZXR1cm4gaW50ICsgKFxuXHRcdG1vZDEwID09IDEgJiYgaW50ICE9IDExID8gXCJzdFwiIDpcblx0XHRtb2QxMCA9PSAyICYmIGludCAhPSAxMiA/IFwibmRcIiA6XG5cdFx0bW9kMTAgPT0gMyAmJiBpbnQgIT0gMTMgPyBcInJkXCIgOiBcInRoXCJcblx0KTtcbn1cbiovXG5cbmNvbnN0IHN1YnMgPSB7XG5cdC8vIDIwMTlcblx0WVlZWTpcdGQgPT4gZC5nZXRGdWxsWWVhcigpLFxuXHQvLyAxOVxuXHRZWTpcdFx0ZCA9PiAoZC5nZXRGdWxsWWVhcigpKycnKS5zbGljZSgyKSxcblx0Ly8gSnVseVxuXHRNTU1NOlx0KGQsIG5hbWVzKSA9PiBuYW1lcy5NTU1NW2QuZ2V0TW9udGgoKV0sXG5cdC8vIEp1bFxuXHRNTU06XHQoZCwgbmFtZXMpID0+IG5hbWVzLk1NTVtkLmdldE1vbnRoKCldLFxuXHQvLyAwN1xuXHRNTTpcdFx0ZCA9PiB6ZXJvUGFkMihkLmdldE1vbnRoKCkrMSksXG5cdC8vIDdcblx0TTpcdFx0ZCA9PiBkLmdldE1vbnRoKCkrMSxcblx0Ly8gMDlcblx0REQ6XHRcdGQgPT4gemVyb1BhZDIoZC5nZXREYXRlKCkpLFxuXHQvLyA5XG5cdEQ6XHRcdGQgPT4gZC5nZXREYXRlKCksXG5cdC8vIE1vbmRheVxuXHRXV1dXOlx0KGQsIG5hbWVzKSA9PiBuYW1lcy5XV1dXW2QuZ2V0RGF5KCldLFxuXHQvLyBNb25cblx0V1dXOlx0KGQsIG5hbWVzKSA9PiBuYW1lcy5XV1dbZC5nZXREYXkoKV0sXG5cdC8vIDAzXG5cdEhIOlx0XHRkID0+IHplcm9QYWQyKGQuZ2V0SG91cnMoKSksXG5cdC8vIDNcblx0SDpcdFx0ZCA9PiBkLmdldEhvdXJzKCksXG5cdC8vIDkgKDEyaHIsIHVucGFkZGVkKVxuXHRoOlx0XHRkID0+IHtsZXQgaCA9IGQuZ2V0SG91cnMoKTsgcmV0dXJuIGggPT0gMCA/IDEyIDogaCA+IDEyID8gaCAtIDEyIDogaDt9LFxuXHQvLyBBTVxuXHRBQTpcdFx0ZCA9PiBkLmdldEhvdXJzKCkgPj0gMTIgPyAnUE0nIDogJ0FNJyxcblx0Ly8gYW1cblx0YWE6XHRcdGQgPT4gZC5nZXRIb3VycygpID49IDEyID8gJ3BtJyA6ICdhbScsXG5cdC8vIGFcblx0YTpcdFx0ZCA9PiBkLmdldEhvdXJzKCkgPj0gMTIgPyAncCcgOiAnYScsXG5cdC8vIDA5XG5cdG1tOlx0XHRkID0+IHplcm9QYWQyKGQuZ2V0TWludXRlcygpKSxcblx0Ly8gOVxuXHRtOlx0XHRkID0+IGQuZ2V0TWludXRlcygpLFxuXHQvLyAwOVxuXHRzczpcdFx0ZCA9PiB6ZXJvUGFkMihkLmdldFNlY29uZHMoKSksXG5cdC8vIDlcblx0czpcdFx0ZCA9PiBkLmdldFNlY29uZHMoKSxcblx0Ly8gMzc0XG5cdGZmZjpcdGQgPT4gemVyb1BhZDMoZC5nZXRNaWxsaXNlY29uZHMoKSksXG59O1xuXG5mdW5jdGlvbiBmbXREYXRlKHRwbCwgbmFtZXMpIHtcblx0bmFtZXMgPSBuYW1lcyB8fCBlbmdOYW1lcztcblx0bGV0IHBhcnRzID0gW107XG5cblx0bGV0IFIgPSAvXFx7KFthLXpdKylcXH18W157XSsvZ2ksIG07XG5cblx0d2hpbGUgKG0gPSBSLmV4ZWModHBsKSlcblx0XHRwYXJ0cy5wdXNoKG1bMF1bMF0gPT0gJ3snID8gc3Vic1ttWzFdXSA6IG1bMF0pO1xuXG5cdHJldHVybiBkID0+IHtcblx0XHRsZXQgb3V0ID0gJyc7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKVxuXHRcdFx0b3V0ICs9IHR5cGVvZiBwYXJ0c1tpXSA9PSBcInN0cmluZ1wiID8gcGFydHNbaV0gOiBwYXJ0c1tpXShkLCBuYW1lcyk7XG5cblx0XHRyZXR1cm4gb3V0O1xuXHR9XG59XG5cbmNvbnN0IGxvY2FsVHogPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTE0MTc2Mi9ob3ctdG8taW5pdGlhbGl6ZS1hLWphdmFzY3JpcHQtZGF0ZS10by1hLXBhcnRpY3VsYXItdGltZS16b25lLzUzNjUyMTMxIzUzNjUyMTMxXG5mdW5jdGlvbiB0ekRhdGUoZGF0ZSwgdHopIHtcblx0bGV0IGRhdGUyO1xuXG5cdC8vIHBlcmYgb3B0aW1pemF0aW9uXG5cdGlmICh0eiA9PSAnVVRDJyB8fCB0eiA9PSAnRXRjL1VUQycpXG5cdFx0ZGF0ZTIgPSBuZXcgRGF0ZSgrZGF0ZSArIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDZlNCk7XG5cdGVsc2UgaWYgKHR6ID09IGxvY2FsVHopXG5cdFx0ZGF0ZTIgPSBkYXRlO1xuXHRlbHNlIHtcblx0XHRkYXRlMiA9IG5ldyBEYXRlKGRhdGUudG9Mb2NhbGVTdHJpbmcoJ2VuLVVTJywge3RpbWVab25lOiB0en0pKTtcblx0XHRkYXRlMi5zZXRNaWxsaXNlY29uZHMoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSk7XG5cdH1cblxuXHRyZXR1cm4gZGF0ZTI7XG59XG5cbi8vZXhwb3J0IGNvbnN0IHNlcmllcyA9IFtdO1xuXG4vLyBkZWZhdWx0IGZvcm1hdHRlcnM6XG5cbmNvbnN0IG9ubHlXaG9sZSA9IHYgPT4gdiAlIDEgPT0gMDtcblxuY29uc3QgYWxsTXVsdHMgPSBbMSwyLDIuNSw1XTtcblxuLy8gLi4uMC4wMSwgMC4wMiwgMC4wMjUsIDAuMDUsIDAuMSwgMC4yLCAwLjI1LCAwLjVcbmNvbnN0IGRlY0luY3JzID0gZ2VuSW5jcnMoMTAsIC0xNiwgMCwgYWxsTXVsdHMpO1xuXG4vLyAxLCAyLCAyLjUsIDUsIDEwLCAyMCwgMjUsIDUwLi4uXG5jb25zdCBvbmVJbmNycyA9IGdlbkluY3JzKDEwLCAwLCAxNiwgYWxsTXVsdHMpO1xuXG4vLyAxLCAyLCAgICAgIDUsIDEwLCAyMCwgMjUsIDUwLi4uXG5jb25zdCB3aG9sZUluY3JzID0gb25lSW5jcnMuZmlsdGVyKG9ubHlXaG9sZSk7XG5cbmNvbnN0IG51bUluY3JzID0gZGVjSW5jcnMuY29uY2F0KG9uZUluY3JzKTtcblxuY29uc3QgTkwgPSBcIlxcblwiO1xuXG5jb25zdCB5eXl5ICAgID0gXCJ7WVlZWX1cIjtcbmNvbnN0IE5MeXl5eSAgPSBOTCArIHl5eXk7XG5jb25zdCBtZCAgICAgID0gXCJ7TX0ve0R9XCI7XG5jb25zdCBOTG1kICAgID0gTkwgKyBtZDtcbmNvbnN0IE5MbWR5eSAgPSBOTG1kICsgXCIve1lZfVwiO1xuXG5jb25zdCBhYSAgICAgID0gXCJ7YWF9XCI7XG5jb25zdCBobW0gICAgID0gXCJ7aH06e21tfVwiO1xuY29uc3QgaG1tYWEgICA9IGhtbSArIGFhO1xuY29uc3QgTkxobW1hYSA9IE5MICsgaG1tYWE7XG5jb25zdCBzcyAgICAgID0gXCI6e3NzfVwiO1xuXG5jb25zdCBfID0gbnVsbDtcblxuZnVuY3Rpb24gZ2VuVGltZVN0dWZmcyhtcykge1xuXHRsZXRcdHMgID0gbXMgKiAxZTMsXG5cdFx0bSAgPSBzICAqIDYwLFxuXHRcdGggID0gbSAgKiA2MCxcblx0XHRkICA9IGggICogMjQsXG5cdFx0bW8gPSBkICAqIDMwLFxuXHRcdHkgID0gZCAgKiAzNjU7XG5cblx0Ly8gbWluIG9mIDFlLTMgcHJldmVudHMgc2V0dGluZyBhIHRlbXBvcmFsIHggdGlja3MgdG9vIHNtYWxsIHNpbmNlIERhdGUgb2JqZWN0cyBjYW5ub3QgYWR2YW5jZSB0aWNrcyBzbWFsbGVyIHRoYW4gMW1zXG5cdGxldCBzdWJTZWNJbmNycyA9IG1zID09IDEgPyBnZW5JbmNycygxMCwgMCwgMywgYWxsTXVsdHMpLmZpbHRlcihvbmx5V2hvbGUpIDogZ2VuSW5jcnMoMTAsIC0zLCAwLCBhbGxNdWx0cyk7XG5cblx0bGV0IHRpbWVJbmNycyA9IHN1YlNlY0luY3JzLmNvbmNhdChbXG5cdFx0Ly8gbWludXRlIGRpdmlzb3JzICgjIG9mIHNlY3MpXG5cdFx0cyxcblx0XHRzICogNSxcblx0XHRzICogMTAsXG5cdFx0cyAqIDE1LFxuXHRcdHMgKiAzMCxcblx0XHQvLyBob3VyIGRpdmlzb3JzICgjIG9mIG1pbnMpXG5cdFx0bSxcblx0XHRtICogNSxcblx0XHRtICogMTAsXG5cdFx0bSAqIDE1LFxuXHRcdG0gKiAzMCxcblx0XHQvLyBkYXkgZGl2aXNvcnMgKCMgb2YgaHJzKVxuXHRcdGgsXG5cdFx0aCAqIDIsXG5cdFx0aCAqIDMsXG5cdFx0aCAqIDQsXG5cdFx0aCAqIDYsXG5cdFx0aCAqIDgsXG5cdFx0aCAqIDEyLFxuXHRcdC8vIG1vbnRoIGRpdmlzb3JzIFRPRE86IG5lZWQgbW9yZT9cblx0XHRkLFxuXHRcdGQgKiAyLFxuXHRcdGQgKiAzLFxuXHRcdGQgKiA0LFxuXHRcdGQgKiA1LFxuXHRcdGQgKiA2LFxuXHRcdGQgKiA3LFxuXHRcdGQgKiA4LFxuXHRcdGQgKiA5LFxuXHRcdGQgKiAxMCxcblx0XHRkICogMTUsXG5cdFx0Ly8geWVhciBkaXZpc29ycyAoIyBtb250aHMsIGFwcHJveClcblx0XHRtbyxcblx0XHRtbyAqIDIsXG5cdFx0bW8gKiAzLFxuXHRcdG1vICogNCxcblx0XHRtbyAqIDYsXG5cdFx0Ly8gY2VudHVyeSBkaXZpc29yc1xuXHRcdHksXG5cdFx0eSAqIDIsXG5cdFx0eSAqIDUsXG5cdFx0eSAqIDEwLFxuXHRcdHkgKiAyNSxcblx0XHR5ICogNTAsXG5cdFx0eSAqIDEwMCxcblx0XSk7XG5cblx0Ly8gWzBdOiAgIG1pbmltdW0gbnVtIHNlY3MgaW4gdGhlIHRpY2sgaW5jclxuXHQvLyBbMV06ICAgZGVmYXVsdCB0aWNrIGZvcm1hdFxuXHQvLyBbMi03XTogcm9sbG92ZXIgdGljayBmb3JtYXRzXG5cdC8vIFs4XTogICBtb2RlOiAwOiByZXBsYWNlIFsxXSAtPiBbMi03XSwgMTogY29uY2F0IFsxXSArIFsyLTddXG5cdGNvbnN0IF90aW1lQXhpc1N0YW1wcyA9IFtcblx0Ly8gICB0aWNrIGluY3IgICAgZGVmYXVsdCAgICAgICAgICB5ZWFyICAgICAgICAgICAgICAgICAgICBtb250aCAgIGRheSAgICAgICAgICAgICAgICAgICBob3VyICAgIG1pbiAgICAgICBzZWMgICBtb2RlXG5cdFx0W3ksICAgICAgICAgICB5eXl5LCAgICAgICAgICAgIF8sICAgICAgICAgICAgICAgICAgICAgIF8sICAgICAgXywgICAgICAgICAgICAgICAgICAgIF8sICAgICAgXywgICAgICAgIF8sICAgICAgIDFdLFxuXHRcdFtkICogMjgsICAgICAgXCJ7TU1NfVwiLCAgICAgICAgIE5MeXl5eSwgICAgICAgICAgICAgICAgIF8sICAgICAgXywgICAgICAgICAgICAgICAgICAgIF8sICAgICAgXywgICAgICAgIF8sICAgICAgIDFdLFxuXHRcdFtkLCAgICAgICAgICAgbWQsICAgICAgICAgICAgICBOTHl5eXksICAgICAgICAgICAgICAgICBfLCAgICAgIF8sICAgICAgICAgICAgICAgICAgICBfLCAgICAgIF8sICAgICAgICBfLCAgICAgICAxXSxcblx0XHRbaCwgICAgICAgICAgIFwie2h9XCIgKyBhYSwgICAgICBOTG1keXksICAgICAgICAgICAgICAgICBfLCAgICAgIE5MbWQsICAgICAgICAgICAgICAgICBfLCAgICAgIF8sICAgICAgICBfLCAgICAgICAxXSxcblx0XHRbbSwgICAgICAgICAgIGhtbWFhLCAgICAgICAgICAgTkxtZHl5LCAgICAgICAgICAgICAgICAgXywgICAgICBOTG1kLCAgICAgICAgICAgICAgICAgXywgICAgICBfLCAgICAgICAgXywgICAgICAgMV0sXG5cdFx0W3MsICAgICAgICAgICBzcywgICAgICAgICAgICAgIE5MbWR5eSArIFwiIFwiICsgaG1tYWEsICAgXywgICAgICBOTG1kICsgXCIgXCIgKyBobW1hYSwgICBfLCAgICAgIE5MaG1tYWEsICBfLCAgICAgICAxXSxcblx0XHRbbXMsICAgICAgICAgIHNzICsgXCIue2ZmZn1cIiwgICBOTG1keXkgKyBcIiBcIiArIGhtbWFhLCAgIF8sICAgICAgTkxtZCArIFwiIFwiICsgaG1tYWEsICAgXywgICAgICBOTGhtbWFhLCAgXywgICAgICAgMV0sXG5cdF07XG5cblx0Ly8gdGhlIGVuc3VyZXMgdGhhdCBheGlzIHRpY2tzLCB2YWx1ZXMgJiBncmlkIGFyZSBhbGlnbmVkIHRvIGxvZ2ljYWwgdGVtcG9yYWwgYnJlYWtwb2ludHMgYW5kIG5vdCBhbiBhcmJpdHJhcnkgdGltZXN0YW1wXG5cdC8vIGh0dHBzOi8vd3d3LnRpbWVhbmRkYXRlLmNvbS90aW1lL2RzdC9cblx0Ly8gaHR0cHM6Ly93d3cudGltZWFuZGRhdGUuY29tL3RpbWUvZHN0LzIwMTkuaHRtbFxuXHQvLyBodHRwczovL3d3dy5lcG9jaGNvbnZlcnRlci5jb20vdGltZXpvbmVzXG5cdGZ1bmN0aW9uIHRpbWVBeGlzU3BsaXRzKHR6RGF0ZSkge1xuXHRcdHJldHVybiAoc2VsZiwgYXhpc0lkeCwgc2NhbGVNaW4sIHNjYWxlTWF4LCBmb3VuZEluY3IsIGZvdW5kU3BhY2UpID0+IHtcblx0XHRcdGxldCBzcGxpdHMgPSBbXTtcblx0XHRcdGxldCBpc1lyID0gZm91bmRJbmNyID49IHk7XG5cdFx0XHRsZXQgaXNNbyA9IGZvdW5kSW5jciA+PSBtbyAmJiBmb3VuZEluY3IgPCB5O1xuXG5cdFx0XHQvLyBnZXQgdGhlIHRpbWV6b25lLWFkanVzdGVkIGRhdGVcblx0XHRcdGxldCBtaW5EYXRlID0gdHpEYXRlKHNjYWxlTWluKTtcblx0XHRcdGxldCBtaW5EYXRlVHMgPSByb3VuZERlYyhtaW5EYXRlICogbXMsIDMpO1xuXG5cdFx0XHQvLyBnZXQgdHMgb2YgMTJhbSAodGhpcyBsYW5kcyB1cyBhdCBvciBiZWZvcmUgdGhlIG9yaWdpbmFsIHNjYWxlTWluKVxuXHRcdFx0bGV0IG1pbk1pbiA9IG1rRGF0ZShtaW5EYXRlLmdldEZ1bGxZZWFyKCksIGlzWXIgPyAwIDogbWluRGF0ZS5nZXRNb250aCgpLCBpc01vIHx8IGlzWXIgPyAxIDogbWluRGF0ZS5nZXREYXRlKCkpO1xuXHRcdFx0bGV0IG1pbk1pblRzID0gcm91bmREZWMobWluTWluICogbXMsIDMpO1xuXG5cdFx0XHRpZiAoaXNNbyB8fCBpc1lyKSB7XG5cdFx0XHRcdGxldCBtb0luY3IgPSBpc01vID8gZm91bmRJbmNyIC8gbW8gOiAwO1xuXHRcdFx0XHRsZXQgeXJJbmNyID0gaXNZciA/IGZvdW5kSW5jciAvIHkgIDogMDtcblx0XHRcdC8vXHRsZXQgdHpPZmZzZXQgPSBzY2FsZU1pbiAtIG1pbkRhdGVUcztcdFx0Ly8gbmVlZGVkP1xuXHRcdFx0XHRsZXQgc3BsaXQgPSBtaW5EYXRlVHMgPT0gbWluTWluVHMgPyBtaW5EYXRlVHMgOiByb3VuZERlYyhta0RhdGUobWluTWluLmdldEZ1bGxZZWFyKCkgKyB5ckluY3IsIG1pbk1pbi5nZXRNb250aCgpICsgbW9JbmNyLCAxKSAqIG1zLCAzKTtcblx0XHRcdFx0bGV0IHNwbGl0RGF0ZSA9IG5ldyBEYXRlKHJvdW5kKHNwbGl0IC8gbXMpKTtcblx0XHRcdFx0bGV0IGJhc2VZZWFyID0gc3BsaXREYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdGxldCBiYXNlTW9udGggPSBzcGxpdERhdGUuZ2V0TW9udGgoKTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgc3BsaXQgPD0gc2NhbGVNYXg7IGkrKykge1xuXHRcdFx0XHRcdGxldCBuZXh0ID0gbWtEYXRlKGJhc2VZZWFyICsgeXJJbmNyICogaSwgYmFzZU1vbnRoICsgbW9JbmNyICogaSwgMSk7XG5cdFx0XHRcdFx0bGV0IG9mZnMgPSBuZXh0IC0gdHpEYXRlKHJvdW5kRGVjKG5leHQgKiBtcywgMykpO1xuXG5cdFx0XHRcdFx0c3BsaXQgPSByb3VuZERlYygoK25leHQgKyBvZmZzKSAqIG1zLCAzKTtcblxuXHRcdFx0XHRcdGlmIChzcGxpdCA8PSBzY2FsZU1heClcblx0XHRcdFx0XHRcdHNwbGl0cy5wdXNoKHNwbGl0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBpbmNyMCA9IGZvdW5kSW5jciA+PSBkID8gZCA6IGZvdW5kSW5jcjtcblx0XHRcdFx0bGV0IHR6T2Zmc2V0ID0gZmxvb3Ioc2NhbGVNaW4pIC0gZmxvb3IobWluRGF0ZVRzKTtcblx0XHRcdFx0bGV0IHNwbGl0ID0gbWluTWluVHMgKyB0ek9mZnNldCArIGluY3JSb3VuZFVwKG1pbkRhdGVUcyAtIG1pbk1pblRzLCBpbmNyMCk7XG5cdFx0XHRcdHNwbGl0cy5wdXNoKHNwbGl0KTtcblxuXHRcdFx0XHRsZXQgZGF0ZTAgPSB0ekRhdGUoc3BsaXQpO1xuXG5cdFx0XHRcdGxldCBwcmV2SG91ciA9IGRhdGUwLmdldEhvdXJzKCkgKyAoZGF0ZTAuZ2V0TWludXRlcygpIC8gbSkgKyAoZGF0ZTAuZ2V0U2Vjb25kcygpIC8gaCk7XG5cdFx0XHRcdGxldCBpbmNySG91cnMgPSBmb3VuZEluY3IgLyBoO1xuXG5cdFx0XHRcdGxldCBtaW5TcGFjZSA9IHNlbGYuYXhlc1theGlzSWR4XS5fc3BhY2U7XG5cdFx0XHRcdGxldCBwY3RTcGFjZSA9IGZvdW5kU3BhY2UgLyBtaW5TcGFjZTtcblxuXHRcdFx0XHR3aGlsZSAoMSkge1xuXHRcdFx0XHRcdHNwbGl0ID0gcm91bmREZWMoc3BsaXQgKyBmb3VuZEluY3IsIG1zID09IDEgPyAwIDogMyk7XG5cblx0XHRcdFx0XHRpZiAoc3BsaXQgPiBzY2FsZU1heClcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0aWYgKGluY3JIb3VycyA+IDEpIHtcblx0XHRcdFx0XHRcdGxldCBleHBlY3RlZEhvdXIgPSBmbG9vcihyb3VuZERlYyhwcmV2SG91ciArIGluY3JIb3VycywgNikpICUgMjQ7XG5cdFx0XHRcdFx0XHRsZXQgc3BsaXREYXRlID0gdHpEYXRlKHNwbGl0KTtcblx0XHRcdFx0XHRcdGxldCBhY3R1YWxIb3VyID0gc3BsaXREYXRlLmdldEhvdXJzKCk7XG5cblx0XHRcdFx0XHRcdGxldCBkc3RTaGlmdCA9IGFjdHVhbEhvdXIgLSBleHBlY3RlZEhvdXI7XG5cblx0XHRcdFx0XHRcdGlmIChkc3RTaGlmdCA+IDEpXG5cdFx0XHRcdFx0XHRcdGRzdFNoaWZ0ID0gLTE7XG5cblx0XHRcdFx0XHRcdHNwbGl0IC09IGRzdFNoaWZ0ICogaDtcblxuXHRcdFx0XHRcdFx0cHJldkhvdXIgPSAocHJldkhvdXIgKyBpbmNySG91cnMpICUgMjQ7XG5cblx0XHRcdFx0XHRcdC8vIGFkZCBhIHRpY2sgb25seSBpZiBpdCdzIGZ1cnRoZXIgdGhhbiA3MCUgb2YgdGhlIG1pbiBhbGxvd2VkIGxhYmVsIHNwYWNpbmdcblx0XHRcdFx0XHRcdGxldCBwcmV2U3BsaXQgPSBzcGxpdHNbc3BsaXRzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdFx0bGV0IHBjdEluY3IgPSByb3VuZERlYygoc3BsaXQgLSBwcmV2U3BsaXQpIC8gZm91bmRJbmNyLCAzKTtcblxuXHRcdFx0XHRcdFx0aWYgKHBjdEluY3IgKiBwY3RTcGFjZSA+PSAuNylcblx0XHRcdFx0XHRcdFx0c3BsaXRzLnB1c2goc3BsaXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRzcGxpdHMucHVzaChzcGxpdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNwbGl0cztcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gW1xuXHRcdHRpbWVJbmNycyxcblx0XHRfdGltZUF4aXNTdGFtcHMsXG5cdFx0dGltZUF4aXNTcGxpdHMsXG5cdF07XG59XG5cbmNvbnN0IFsgdGltZUluY3JzTXMsIF90aW1lQXhpc1N0YW1wc01zLCB0aW1lQXhpc1NwbGl0c01zIF0gPSBnZW5UaW1lU3R1ZmZzKDEpO1xuY29uc3QgWyB0aW1lSW5jcnNTLCAgX3RpbWVBeGlzU3RhbXBzUywgIHRpbWVBeGlzU3BsaXRzUyAgXSA9IGdlblRpbWVTdHVmZnMoMWUtMyk7XG5cbi8vIGJhc2UgMlxuZ2VuSW5jcnMoMiwgLTUzLCA1MywgWzFdKTtcblxuLypcbmNvbnNvbGUubG9nKHtcblx0ZGVjSW5jcnMsXG5cdG9uZUluY3JzLFxuXHR3aG9sZUluY3JzLFxuXHRudW1JbmNycyxcblx0dGltZUluY3JzLFxuXHRmaXhlZERlYyxcbn0pO1xuKi9cblxuZnVuY3Rpb24gdGltZUF4aXNTdGFtcHMoc3RhbXBDZmcsIGZtdERhdGUpIHtcblx0cmV0dXJuIHN0YW1wQ2ZnLm1hcChzID0+IHMubWFwKCh2LCBpKSA9PlxuXHRcdGkgPT0gMCB8fCBpID09IDggfHwgdiA9PSBudWxsID8gdiA6IGZtdERhdGUoaSA9PSAxIHx8IHNbOF0gPT0gMCA/IHYgOiBzWzFdICsgdilcblx0KSk7XG59XG5cbi8vIFRPRE86IHdpbGwgbmVlZCB0byBhY2NlcHQgc3BhY2VzW10gYW5kIHB1bGwgaW5jciBpbnRvIHRoZSBsb29wIHdoZW4gZ3JpZCB3aWxsIGJlIG5vbi11bmlmb3JtLCBlZyBmb3IgbG9nIHNjYWxlcy5cbi8vIGN1cnJlbnRseSB3ZSBpZ25vcmUgdGhpcyBmb3IgbW9udGhzIHNpbmNlIHRoZXkncmUgKm5lYXJseSogdW5pZm9ybSBhbmQgdGhlIGFkZGVkIGNvbXBsZXhpdHkgaXMgbm90IHdvcnRoIGl0XG5mdW5jdGlvbiB0aW1lQXhpc1ZhbHModHpEYXRlLCBzdGFtcHMpIHtcblx0cmV0dXJuIChzZWxmLCBzcGxpdHMsIGF4aXNJZHgsIGZvdW5kU3BhY2UsIGZvdW5kSW5jcikgPT4ge1xuXHRcdGxldCBzID0gc3RhbXBzLmZpbmQocyA9PiBmb3VuZEluY3IgPj0gc1swXSkgfHwgc3RhbXBzW3N0YW1wcy5sZW5ndGggLSAxXTtcblxuXHRcdC8vIHRoZXNlIHRyYWNrIGJvdW5kYXJpZXMgd2hlbiBhIGZ1bGwgbGFiZWwgaXMgbmVlZGVkIGFnYWluXG5cdFx0bGV0IHByZXZZZWFyO1xuXHRcdGxldCBwcmV2TW50aDtcblx0XHRsZXQgcHJldkRhdGU7XG5cdFx0bGV0IHByZXZIb3VyO1xuXHRcdGxldCBwcmV2TWlucztcblx0XHRsZXQgcHJldlNlY3M7XG5cblx0XHRyZXR1cm4gc3BsaXRzLm1hcChzcGxpdCA9PiB7XG5cdFx0XHRsZXQgZGF0ZSA9IHR6RGF0ZShzcGxpdCk7XG5cblx0XHRcdGxldCBuZXdZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0bGV0IG5ld01udGggPSBkYXRlLmdldE1vbnRoKCk7XG5cdFx0XHRsZXQgbmV3RGF0ZSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdFx0bGV0IG5ld0hvdXIgPSBkYXRlLmdldEhvdXJzKCk7XG5cdFx0XHRsZXQgbmV3TWlucyA9IGRhdGUuZ2V0TWludXRlcygpO1xuXHRcdFx0bGV0IG5ld1NlY3MgPSBkYXRlLmdldFNlY29uZHMoKTtcblxuXHRcdFx0bGV0IHN0YW1wID0gKFxuXHRcdFx0XHRuZXdZZWFyICE9IHByZXZZZWFyICYmIHNbMl0gfHxcblx0XHRcdFx0bmV3TW50aCAhPSBwcmV2TW50aCAmJiBzWzNdIHx8XG5cdFx0XHRcdG5ld0RhdGUgIT0gcHJldkRhdGUgJiYgc1s0XSB8fFxuXHRcdFx0XHRuZXdIb3VyICE9IHByZXZIb3VyICYmIHNbNV0gfHxcblx0XHRcdFx0bmV3TWlucyAhPSBwcmV2TWlucyAmJiBzWzZdIHx8XG5cdFx0XHRcdG5ld1NlY3MgIT0gcHJldlNlY3MgJiYgc1s3XSB8fFxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIHNbMV1cblx0XHRcdCk7XG5cblx0XHRcdHByZXZZZWFyID0gbmV3WWVhcjtcblx0XHRcdHByZXZNbnRoID0gbmV3TW50aDtcblx0XHRcdHByZXZEYXRlID0gbmV3RGF0ZTtcblx0XHRcdHByZXZIb3VyID0gbmV3SG91cjtcblx0XHRcdHByZXZNaW5zID0gbmV3TWlucztcblx0XHRcdHByZXZTZWNzID0gbmV3U2VjcztcblxuXHRcdFx0cmV0dXJuIHN0YW1wKGRhdGUpO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8vIGZvciB3aGVuIGF4aXMudmFsdWVzIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgZm10RGF0ZSB0ZW1wbGF0ZSBzdHJpbmdcbmZ1bmN0aW9uIHRpbWVBeGlzVmFsKHR6RGF0ZSwgZGF0ZVRwbCkge1xuXHRsZXQgc3RhbXAgPSBmbXREYXRlKGRhdGVUcGwpO1xuXHRyZXR1cm4gKHNlbGYsIHNwbGl0cywgYXhpc0lkeCwgZm91bmRTcGFjZSwgZm91bmRJbmNyKSA9PiBzcGxpdHMubWFwKHNwbGl0ID0+IHN0YW1wKHR6RGF0ZShzcGxpdCkpKTtcbn1cblxuZnVuY3Rpb24gbWtEYXRlKHksIG0sIGQpIHtcblx0cmV0dXJuIG5ldyBEYXRlKHksIG0sIGQpO1xufVxuXG5mdW5jdGlvbiB0aW1lU2VyaWVzU3RhbXAoc3RhbXBDZmcsIGZtdERhdGUpIHtcblx0cmV0dXJuIGZtdERhdGUoc3RhbXBDZmcpO1xufVxuY29uc3QgX3RpbWVTZXJpZXNTdGFtcCA9ICd7WVlZWX0te01NfS17RER9IHtofTp7bW19e2FhfSc7XG5cbmZ1bmN0aW9uIHRpbWVTZXJpZXNWYWwodHpEYXRlLCBzdGFtcCkge1xuXHRyZXR1cm4gKHNlbGYsIHZhbCkgPT4gc3RhbXAodHpEYXRlKHZhbCkpO1xufVxuXG5mdW5jdGlvbiBsZWdlbmRTdHJva2Uoc2VsZiwgc2VyaWVzSWR4KSB7XG5cdGxldCBzID0gc2VsZi5zZXJpZXNbc2VyaWVzSWR4XTtcblx0cmV0dXJuIHMud2lkdGggPyBzLnN0cm9rZShzZWxmLCBzZXJpZXNJZHgpIDogcy5wb2ludHMud2lkdGggPyBzLnBvaW50cy5zdHJva2Uoc2VsZiwgc2VyaWVzSWR4KSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZEZpbGwoc2VsZiwgc2VyaWVzSWR4KSB7XG5cdHJldHVybiBzZWxmLnNlcmllc1tzZXJpZXNJZHhdLmZpbGwoc2VsZiwgc2VyaWVzSWR4KTtcbn1cblxuY29uc3QgbGVnZW5kT3B0cyA9IHtcblx0c2hvdzogdHJ1ZSxcblx0bGl2ZTogdHJ1ZSxcblx0aXNvbGF0ZTogZmFsc2UsXG5cdG1hcmtlcnM6IHtcblx0XHRzaG93OiB0cnVlLFxuXHRcdHdpZHRoOiAyLFxuXHRcdHN0cm9rZTogbGVnZW5kU3Ryb2tlLFxuXHRcdGZpbGw6IGxlZ2VuZEZpbGwsXG5cdFx0ZGFzaDogXCJzb2xpZFwiLFxuXHR9LFxuXHRpZHg6IG51bGwsXG5cdGlkeHM6IG51bGwsXG5cdHZhbHVlczogW10sXG59O1xuXG5mdW5jdGlvbiBjdXJzb3JQb2ludFNob3coc2VsZiwgc2kpIHtcblx0bGV0IG8gPSBzZWxmLmN1cnNvci5wb2ludHM7XG5cblx0bGV0IHB0ID0gcGxhY2VEaXYoKTtcblxuXHRsZXQgc2l6ZSA9IG8uc2l6ZShzZWxmLCBzaSk7XG5cdHNldFN0eWxlUHgocHQsIFdJRFRILCBzaXplKTtcblx0c2V0U3R5bGVQeChwdCwgSEVJR0hULCBzaXplKTtcblxuXHRsZXQgbWFyID0gc2l6ZSAvIC0yO1xuXHRzZXRTdHlsZVB4KHB0LCBcIm1hcmdpbkxlZnRcIiwgbWFyKTtcblx0c2V0U3R5bGVQeChwdCwgXCJtYXJnaW5Ub3BcIiwgbWFyKTtcblxuXHRsZXQgd2lkdGggPSBvLndpZHRoKHNlbGYsIHNpLCBzaXplKTtcblx0d2lkdGggJiYgc2V0U3R5bGVQeChwdCwgXCJib3JkZXJXaWR0aFwiLCB3aWR0aCk7XG5cblx0cmV0dXJuIHB0O1xufVxuXG5mdW5jdGlvbiBjdXJzb3JQb2ludEZpbGwoc2VsZiwgc2kpIHtcblx0bGV0IHNwID0gc2VsZi5zZXJpZXNbc2ldLnBvaW50cztcblx0cmV0dXJuIHNwLl9maWxsIHx8IHNwLl9zdHJva2U7XG59XG5cbmZ1bmN0aW9uIGN1cnNvclBvaW50U3Ryb2tlKHNlbGYsIHNpKSB7XG5cdGxldCBzcCA9IHNlbGYuc2VyaWVzW3NpXS5wb2ludHM7XG5cdHJldHVybiBzcC5fc3Ryb2tlIHx8IHNwLl9maWxsO1xufVxuXG5mdW5jdGlvbiBjdXJzb3JQb2ludFNpemUoc2VsZiwgc2kpIHtcblx0bGV0IHNwID0gc2VsZi5zZXJpZXNbc2ldLnBvaW50cztcblx0cmV0dXJuIHB0RGlhKHNwLndpZHRoLCAxKTtcbn1cblxuZnVuY3Rpb24gZGF0YUlkeChzZWxmLCBzZXJpZXNJZHgsIGN1cnNvcklkeCkge1xuXHRyZXR1cm4gY3Vyc29ySWR4O1xufVxuXG5jb25zdCBtb3ZlVHVwbGUgPSBbMCwwXTtcblxuZnVuY3Rpb24gY3Vyc29yTW92ZShzZWxmLCBtb3VzZUxlZnQxLCBtb3VzZVRvcDEpIHtcblx0bW92ZVR1cGxlWzBdID0gbW91c2VMZWZ0MTtcblx0bW92ZVR1cGxlWzFdID0gbW91c2VUb3AxO1xuXHRyZXR1cm4gbW92ZVR1cGxlO1xufVxuXG5mdW5jdGlvbiBmaWx0QnRuMChzZWxmLCB0YXJnLCBoYW5kbGUpIHtcblx0cmV0dXJuIGUgPT4ge1xuXHRcdGUuYnV0dG9uID09IDAgJiYgaGFuZGxlKGUpO1xuXHR9O1xufVxuXG5mdW5jdGlvbiBwYXNzVGhydShzZWxmLCB0YXJnLCBoYW5kbGUpIHtcblx0cmV0dXJuIGhhbmRsZTtcbn1cblxuY29uc3QgY3Vyc29yT3B0cyA9IHtcblx0c2hvdzogdHJ1ZSxcblx0eDogdHJ1ZSxcblx0eTogdHJ1ZSxcblx0bG9jazogZmFsc2UsXG5cdG1vdmU6IGN1cnNvck1vdmUsXG5cdHBvaW50czoge1xuXHRcdHNob3c6ICAgY3Vyc29yUG9pbnRTaG93LFxuXHRcdHNpemU6ICAgY3Vyc29yUG9pbnRTaXplLFxuXHRcdHdpZHRoOiAgMCxcblx0XHRzdHJva2U6IGN1cnNvclBvaW50U3Ryb2tlLFxuXHRcdGZpbGw6ICAgY3Vyc29yUG9pbnRGaWxsLFxuXHR9LFxuXG5cdGJpbmQ6IHtcblx0XHRtb3VzZWRvd246ICAgZmlsdEJ0bjAsXG5cdFx0bW91c2V1cDogICAgIGZpbHRCdG4wLFxuXHRcdGNsaWNrOiAgICAgICBmaWx0QnRuMCxcblx0XHRkYmxjbGljazogICAgZmlsdEJ0bjAsXG5cblx0XHRtb3VzZW1vdmU6ICAgcGFzc1RocnUsXG5cdFx0bW91c2VsZWF2ZTogIHBhc3NUaHJ1LFxuXHRcdG1vdXNlZW50ZXI6ICBwYXNzVGhydSxcblx0fSxcblxuXHRkcmFnOiB7XG5cdFx0c2V0U2NhbGU6IHRydWUsXG5cdFx0eDogdHJ1ZSxcblx0XHR5OiBmYWxzZSxcblx0XHRkaXN0OiAwLFxuXHRcdHVuaTogbnVsbCxcblx0XHRfeDogZmFsc2UsXG5cdFx0X3k6IGZhbHNlLFxuXHR9LFxuXG5cdGZvY3VzOiB7XG5cdFx0cHJveDogLTEsXG5cdH0sXG5cblx0bGVmdDogLTEwLFxuXHR0b3A6IC0xMCxcblx0aWR4OiBudWxsLFxuXHRkYXRhSWR4LFxuXHRpZHhzOiBudWxsLFxufTtcblxuY29uc3QgYXhpc0xpbmVzID0ge1xuXHRzaG93OiB0cnVlLFxuXHRzdHJva2U6IFwicmdiYSgwLDAsMCwwLjA3KVwiLFxuXHR3aWR0aDogMixcbi8vXHRkYXNoOiBbXSxcbn07XG5cbmNvbnN0IGdyaWQgPSBhc3NpZ24oe30sIGF4aXNMaW5lcywge1xuXHRmaWx0ZXI6IHJldEFyZzEsXG59KTtcblxuY29uc3QgdGlja3MgPSBhc3NpZ24oe30sIGdyaWQsIHtcblx0c2l6ZTogMTAsXG59KTtcblxuY29uc3QgYm9yZGVyID0gYXNzaWduKHt9LCBheGlzTGluZXMsIHtcblx0c2hvdzogZmFsc2UsXG59KTtcblxuY29uc3QgZm9udCAgICAgID0gJzEycHggc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBcIlNlZ29lIFVJXCIsIFJvYm90bywgXCJIZWx2ZXRpY2EgTmV1ZVwiLCBBcmlhbCwgXCJOb3RvIFNhbnNcIiwgc2Fucy1zZXJpZiwgXCJBcHBsZSBDb2xvciBFbW9qaVwiLCBcIlNlZ29lIFVJIEVtb2ppXCIsIFwiU2Vnb2UgVUkgU3ltYm9sXCIsIFwiTm90byBDb2xvciBFbW9qaVwiJztcbmNvbnN0IGxhYmVsRm9udCA9IFwiYm9sZCBcIiArIGZvbnQ7XG5jb25zdCBsaW5lTXVsdCA9IDEuNTtcdFx0Ly8gZm9udC1zaXplIG11bHRpcGxpZXJcblxuY29uc3QgeEF4aXNPcHRzID0ge1xuXHRzaG93OiB0cnVlLFxuXHRzY2FsZTogXCJ4XCIsXG5cdHN0cm9rZTogaGV4QmxhY2ssXG5cdHNwYWNlOiA1MCxcblx0Z2FwOiA1LFxuXHRzaXplOiA1MCxcblx0bGFiZWxHYXA6IDAsXG5cdGxhYmVsU2l6ZTogMzAsXG5cdGxhYmVsRm9udCxcblx0c2lkZTogMixcbi8vXHRjbGFzczogXCJ4LXZhbHNcIixcbi8vXHRpbmNyczogdGltZUluY3JzLFxuLy9cdHZhbHVlczogdGltZVZhbHMsXG4vL1x0ZmlsdGVyOiByZXRBcmcxLFxuXHRncmlkLFxuXHR0aWNrcyxcblx0Ym9yZGVyLFxuXHRmb250LFxuXHRyb3RhdGU6IDAsXG59O1xuXG5jb25zdCBudW1TZXJpZXNMYWJlbCA9IFwiVmFsdWVcIjtcbmNvbnN0IHRpbWVTZXJpZXNMYWJlbCA9IFwiVGltZVwiO1xuXG5jb25zdCB4U2VyaWVzT3B0cyA9IHtcblx0c2hvdzogdHJ1ZSxcblx0c2NhbGU6IFwieFwiLFxuXHRhdXRvOiBmYWxzZSxcblx0c29ydGVkOiAxLFxuLy9cdGxhYmVsOiBcIlRpbWVcIixcbi8vXHR2YWx1ZTogdiA9PiBzdGFtcChuZXcgRGF0ZSh2ICogMWUzKSksXG5cblx0Ly8gaW50ZXJuYWwgY2FjaGVzXG5cdG1pbjogaW5mLFxuXHRtYXg6IC1pbmYsXG5cdGlkeHM6IFtdLFxufTtcblxuZnVuY3Rpb24gbnVtQXhpc1ZhbHMoc2VsZiwgc3BsaXRzLCBheGlzSWR4LCBmb3VuZFNwYWNlLCBmb3VuZEluY3IpIHtcblx0cmV0dXJuIHNwbGl0cy5tYXAodiA9PiB2ID09IG51bGwgPyBcIlwiIDogZm10TnVtKHYpKTtcbn1cblxuZnVuY3Rpb24gbnVtQXhpc1NwbGl0cyhzZWxmLCBheGlzSWR4LCBzY2FsZU1pbiwgc2NhbGVNYXgsIGZvdW5kSW5jciwgZm91bmRTcGFjZSwgZm9yY2VNaW4pIHtcblx0bGV0IHNwbGl0cyA9IFtdO1xuXG5cdGxldCBudW1EZWMgPSBmaXhlZERlYy5nZXQoZm91bmRJbmNyKSB8fCAwO1xuXG5cdHNjYWxlTWluID0gZm9yY2VNaW4gPyBzY2FsZU1pbiA6IHJvdW5kRGVjKGluY3JSb3VuZFVwKHNjYWxlTWluLCBmb3VuZEluY3IpLCBudW1EZWMpO1xuXG5cdGZvciAobGV0IHZhbCA9IHNjYWxlTWluOyB2YWwgPD0gc2NhbGVNYXg7IHZhbCA9IHJvdW5kRGVjKHZhbCArIGZvdW5kSW5jciwgbnVtRGVjKSlcblx0XHRzcGxpdHMucHVzaChPYmplY3QuaXModmFsLCAtMCkgPyAwIDogdmFsKTtcdFx0Ly8gY29hbGVzY2VzIC0wXG5cblx0cmV0dXJuIHNwbGl0cztcbn1cblxuLy8gdGhpcyBkb2VzbnQgd29yayBmb3Igc2luLCB3aGljaCBuZWVkcyB0byBjb21lIG9mZiBmcm9tIDAgaW5kZXBlbmRlbnRseSBpbiBwb3MgYW5kIG5lZyBkaXJzXG5mdW5jdGlvbiBsb2dBeGlzU3BsaXRzKHNlbGYsIGF4aXNJZHgsIHNjYWxlTWluLCBzY2FsZU1heCwgZm91bmRJbmNyLCBmb3VuZFNwYWNlLCBmb3JjZU1pbikge1xuXHRjb25zdCBzcGxpdHMgPSBbXTtcblxuXHRjb25zdCBsb2dCYXNlID0gc2VsZi5zY2FsZXNbc2VsZi5heGVzW2F4aXNJZHhdLnNjYWxlXS5sb2c7XG5cblx0Y29uc3QgbG9nRm4gPSBsb2dCYXNlID09IDEwID8gbG9nMTAgOiBsb2cyO1xuXG5cdGNvbnN0IGV4cCA9IGZsb29yKGxvZ0ZuKHNjYWxlTWluKSk7XG5cblx0Zm91bmRJbmNyID0gcG93KGxvZ0Jhc2UsIGV4cCk7XG5cblx0aWYgKGV4cCA8IDApXG5cdFx0Zm91bmRJbmNyID0gcm91bmREZWMoZm91bmRJbmNyLCAtZXhwKTtcblxuXHRsZXQgc3BsaXQgPSBzY2FsZU1pbjtcblxuXHRkbyB7XG5cdFx0c3BsaXRzLnB1c2goc3BsaXQpO1xuXHRcdHNwbGl0ID0gcm91bmREZWMoc3BsaXQgKyBmb3VuZEluY3IsIGZpeGVkRGVjLmdldChmb3VuZEluY3IpKTtcblxuXHRcdGlmIChzcGxpdCA+PSBmb3VuZEluY3IgKiBsb2dCYXNlKVxuXHRcdFx0Zm91bmRJbmNyID0gc3BsaXQ7XG5cblx0fSB3aGlsZSAoc3BsaXQgPD0gc2NhbGVNYXgpO1xuXG5cdHJldHVybiBzcGxpdHM7XG59XG5cbmZ1bmN0aW9uIGFzaW5oQXhpc1NwbGl0cyhzZWxmLCBheGlzSWR4LCBzY2FsZU1pbiwgc2NhbGVNYXgsIGZvdW5kSW5jciwgZm91bmRTcGFjZSwgZm9yY2VNaW4pIHtcblx0bGV0IHNjID0gc2VsZi5zY2FsZXNbc2VsZi5heGVzW2F4aXNJZHhdLnNjYWxlXTtcblxuXHRsZXQgbGludGhyZXNoID0gc2MuYXNpbmg7XG5cblx0bGV0IHBvc1NwbGl0cyA9IHNjYWxlTWF4ID4gbGludGhyZXNoID8gbG9nQXhpc1NwbGl0cyhzZWxmLCBheGlzSWR4LCBtYXgobGludGhyZXNoLCBzY2FsZU1pbiksIHNjYWxlTWF4LCBmb3VuZEluY3IpIDogW2xpbnRocmVzaF07XG5cdGxldCB6ZXJvID0gc2NhbGVNYXggPj0gMCAmJiBzY2FsZU1pbiA8PSAwID8gWzBdIDogW107XG5cdGxldCBuZWdTcGxpdHMgPSBzY2FsZU1pbiA8IC1saW50aHJlc2ggPyBsb2dBeGlzU3BsaXRzKHNlbGYsIGF4aXNJZHgsIG1heChsaW50aHJlc2gsIC1zY2FsZU1heCksIC1zY2FsZU1pbiwgZm91bmRJbmNyKTogW2xpbnRocmVzaF07XG5cblx0cmV0dXJuIG5lZ1NwbGl0cy5yZXZlcnNlKCkubWFwKHYgPT4gLXYpLmNvbmNhdCh6ZXJvLCBwb3NTcGxpdHMpO1xufVxuXG5jb25zdCBSRV9BTEwgICA9IC8uLztcbmNvbnN0IFJFXzEyMzU3ID0gL1sxMjM1N10vO1xuY29uc3QgUkVfMTI1ICAgPSAvWzEyNV0vO1xuY29uc3QgUkVfMSAgICAgPSAvMS87XG5cbmZ1bmN0aW9uIGxvZ0F4aXNWYWxzRmlsdChzZWxmLCBzcGxpdHMsIGF4aXNJZHgsIGZvdW5kU3BhY2UsIGZvdW5kSW5jcikge1xuXHRsZXQgYXhpcyA9IHNlbGYuYXhlc1theGlzSWR4XTtcblx0bGV0IHNjYWxlS2V5ID0gYXhpcy5zY2FsZTtcblx0bGV0IHNjID0gc2VsZi5zY2FsZXNbc2NhbGVLZXldO1xuXG5cdGlmIChzYy5kaXN0ciA9PSAzICYmIHNjLmxvZyA9PSAyKVxuXHRcdHJldHVybiBzcGxpdHM7XG5cblx0bGV0IHZhbFRvUG9zID0gc2VsZi52YWxUb1BvcztcblxuXHRsZXQgbWluU3BhY2UgPSBheGlzLl9zcGFjZTtcblxuXHRsZXQgXzEwID0gdmFsVG9Qb3MoMTAsIHNjYWxlS2V5KTtcblxuXHRsZXQgcmUgPSAoXG5cdFx0dmFsVG9Qb3MoOSwgc2NhbGVLZXkpIC0gXzEwID49IG1pblNwYWNlID8gUkVfQUxMIDpcblx0XHR2YWxUb1Bvcyg3LCBzY2FsZUtleSkgLSBfMTAgPj0gbWluU3BhY2UgPyBSRV8xMjM1NyA6XG5cdFx0dmFsVG9Qb3MoNSwgc2NhbGVLZXkpIC0gXzEwID49IG1pblNwYWNlID8gUkVfMTI1IDpcblx0XHRSRV8xXG5cdCk7XG5cblx0cmV0dXJuIHNwbGl0cy5tYXAodiA9PiAoKHNjLmRpc3RyID09IDQgJiYgdiA9PSAwKSB8fCByZS50ZXN0KHYpKSA/IHYgOiBudWxsKTtcbn1cblxuZnVuY3Rpb24gbnVtU2VyaWVzVmFsKHNlbGYsIHZhbCkge1xuXHRyZXR1cm4gdmFsID09IG51bGwgPyBcIlwiIDogZm10TnVtKHZhbCk7XG59XG5cbmNvbnN0IHlBeGlzT3B0cyA9IHtcblx0c2hvdzogdHJ1ZSxcblx0c2NhbGU6IFwieVwiLFxuXHRzdHJva2U6IGhleEJsYWNrLFxuXHRzcGFjZTogMzAsXG5cdGdhcDogNSxcblx0c2l6ZTogNTAsXG5cdGxhYmVsR2FwOiAwLFxuXHRsYWJlbFNpemU6IDMwLFxuXHRsYWJlbEZvbnQsXG5cdHNpZGU6IDMsXG4vL1x0Y2xhc3M6IFwieS12YWxzXCIsXG4vL1x0aW5jcnM6IG51bUluY3JzLFxuLy9cdHZhbHVlczogKHZhbHMsIHNwYWNlKSA9PiB2YWxzLFxuLy9cdGZpbHRlcjogcmV0QXJnMSxcblx0Z3JpZCxcblx0dGlja3MsXG5cdGJvcmRlcixcblx0Zm9udCxcblx0cm90YXRlOiAwLFxufTtcblxuLy8gdGFrZXMgc3Ryb2tlIHdpZHRoXG5mdW5jdGlvbiBwdERpYSh3aWR0aCwgbXVsdCkge1xuXHRsZXQgZGlhID0gMyArICh3aWR0aCB8fCAxKSAqIDI7XG5cdHJldHVybiByb3VuZERlYyhkaWEgKiBtdWx0LCAzKTtcbn1cblxuZnVuY3Rpb24gc2VyaWVzUG9pbnRzU2hvdyhzZWxmLCBzaSkge1xuXHRsZXQgeyBzY2FsZSwgaWR4cyB9ID0gc2VsZi5zZXJpZXNbMF07XG5cdGxldCB4RGF0YSA9IHNlbGYuX2RhdGFbMF07XG5cdGxldCBwMCA9IHNlbGYudmFsVG9Qb3MoeERhdGFbaWR4c1swXV0sIHNjYWxlLCB0cnVlKTtcblx0bGV0IHAxID0gc2VsZi52YWxUb1Bvcyh4RGF0YVtpZHhzWzFdXSwgc2NhbGUsIHRydWUpO1xuXHRsZXQgZGltID0gYWJzKHAxIC0gcDApO1xuXG5cdGxldCBzID0gc2VsZi5zZXJpZXNbc2ldO1xuLy9cdGNvbnN0IGRpYSA9IHB0RGlhKHMud2lkdGgsIHB4UmF0aW8pO1xuXHRsZXQgbWF4UHRzID0gZGltIC8gKHMucG9pbnRzLnNwYWNlICogcHhSYXRpbyk7XG5cdHJldHVybiBpZHhzWzFdIC0gaWR4c1swXSA8PSBtYXhQdHM7XG59XG5cbmNvbnN0IGZhY2V0ID0ge1xuXHRzY2FsZTogbnVsbCxcblx0YXV0bzogdHJ1ZSxcblx0c29ydGVkOiAwLFxuXG5cdC8vIGludGVybmFsIGNhY2hlc1xuXHRtaW46IGluZixcblx0bWF4OiAtaW5mLFxufTtcblxuY29uc3QgeHlTZXJpZXNPcHRzID0ge1xuXHRzaG93OiB0cnVlLFxuXHRhdXRvOiB0cnVlLFxuXHRzb3J0ZWQ6IDAsXG5cdGFscGhhOiAxLFxuXHRmYWNldHM6IFtcblx0XHRhc3NpZ24oe30sIGZhY2V0LCB7c2NhbGU6ICd4J30pLFxuXHRcdGFzc2lnbih7fSwgZmFjZXQsIHtzY2FsZTogJ3knfSksXG5cdF0sXG59O1xuXG5jb25zdCB5U2VyaWVzT3B0cyA9IHtcblx0c2NhbGU6IFwieVwiLFxuXHRhdXRvOiB0cnVlLFxuXHRzb3J0ZWQ6IDAsXG5cdHNob3c6IHRydWUsXG5cdHNwYW5HYXBzOiBmYWxzZSxcblx0Z2FwczogKHNlbGYsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSwgbnVsbEdhcHMpID0+IG51bGxHYXBzLFxuXHRhbHBoYTogMSxcblx0cG9pbnRzOiB7XG5cdFx0c2hvdzogc2VyaWVzUG9pbnRzU2hvdyxcblx0XHRmaWx0ZXI6IG51bGwsXG5cdC8vICBwYXRoczpcblx0Ly9cdHN0cm9rZTogXCIjMDAwXCIsXG5cdC8vXHRmaWxsOiBcIiNmZmZcIixcblx0Ly9cdHdpZHRoOiAxLFxuXHQvL1x0c2l6ZTogMTAsXG5cdH0sXG4vL1x0bGFiZWw6IFwiVmFsdWVcIixcbi8vXHR2YWx1ZTogdiA9PiB2LFxuXHR2YWx1ZXM6IG51bGwsXG5cblx0Ly8gaW50ZXJuYWwgY2FjaGVzXG5cdG1pbjogaW5mLFxuXHRtYXg6IC1pbmYsXG5cdGlkeHM6IFtdLFxuXG5cdHBhdGg6IG51bGwsXG5cdGNsaXA6IG51bGwsXG59O1xuXG5mdW5jdGlvbiBjbGFtcFNjYWxlKHNlbGYsIHZhbCwgc2NhbGVNaW4sIHNjYWxlTWF4LCBzY2FsZUtleSkge1xuLypcblx0aWYgKHZhbCA8IDApIHtcblx0XHRsZXQgY3NzSGd0ID0gc2VsZi5iYm94LmhlaWdodCAvIHB4UmF0aW87XG5cdFx0bGV0IGFic1BvcyA9IHNlbGYudmFsVG9Qb3MoYWJzKHZhbCksIHNjYWxlS2V5KTtcblx0XHRsZXQgZnJvbUJ0bSA9IGNzc0hndCAtIGFic1Bvcztcblx0XHRyZXR1cm4gc2VsZi5wb3NUb1ZhbChjc3NIZ3QgKyBmcm9tQnRtLCBzY2FsZUtleSk7XG5cdH1cbiovXG5cdHJldHVybiBzY2FsZU1pbiAvIDEwO1xufVxuXG5jb25zdCB4U2NhbGVPcHRzID0ge1xuXHR0aW1lOiBGRUFUX1RJTUUsXG5cdGF1dG86IHRydWUsXG5cdGRpc3RyOiAxLFxuXHRsb2c6IDEwLFxuXHRhc2luaDogMSxcblx0bWluOiBudWxsLFxuXHRtYXg6IG51bGwsXG5cdGRpcjogMSxcblx0b3JpOiAwLFxufTtcblxuY29uc3QgeVNjYWxlT3B0cyA9IGFzc2lnbih7fSwgeFNjYWxlT3B0cywge1xuXHR0aW1lOiBmYWxzZSxcblx0b3JpOiAxLFxufSk7XG5cbmNvbnN0IHN5bmNzID0ge307XG5cbmZ1bmN0aW9uIF9zeW5jKGtleSwgb3B0cykge1xuXHRsZXQgcyA9IHN5bmNzW2tleV07XG5cblx0aWYgKCFzKSB7XG5cdFx0cyA9IHtcblx0XHRcdGtleSxcblx0XHRcdHBsb3RzOiBbXSxcblx0XHRcdHN1YihwbG90KSB7XG5cdFx0XHRcdHMucGxvdHMucHVzaChwbG90KTtcblx0XHRcdH0sXG5cdFx0XHR1bnN1YihwbG90KSB7XG5cdFx0XHRcdHMucGxvdHMgPSBzLnBsb3RzLmZpbHRlcihjID0+IGMgIT0gcGxvdCk7XG5cdFx0XHR9LFxuXHRcdFx0cHViKHR5cGUsIHNlbGYsIHgsIHksIHcsIGgsIGkpIHtcblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBzLnBsb3RzLmxlbmd0aDsgaisrKVxuXHRcdFx0XHRcdHMucGxvdHNbal0gIT0gc2VsZiAmJiBzLnBsb3RzW2pdLnB1Yih0eXBlLCBzZWxmLCB4LCB5LCB3LCBoLCBpKTtcblx0XHRcdH0sXG5cdFx0fTtcblxuXHRcdGlmIChrZXkgIT0gbnVsbClcblx0XHRcdHN5bmNzW2tleV0gPSBzO1xuXHR9XG5cblx0cmV0dXJuIHM7XG59XG5cbmNvbnN0IEJBTkRfQ0xJUF9GSUxMICAgPSAxIDw8IDA7XG5jb25zdCBCQU5EX0NMSVBfU1RST0tFID0gMSA8PCAxO1xuXG5mdW5jdGlvbiBvcmllbnQodSwgc2VyaWVzSWR4LCBjYikge1xuXHRjb25zdCBzZXJpZXMgPSB1LnNlcmllc1tzZXJpZXNJZHhdO1xuXHRjb25zdCBzY2FsZXMgPSB1LnNjYWxlcztcblx0Y29uc3QgYmJveCAgID0gdS5iYm94O1xuXHRjb25zdCBzY2FsZVggPSB1Lm1vZGUgPT0gMiA/IHNjYWxlc1tzZXJpZXMuZmFjZXRzWzBdLnNjYWxlXSA6IHNjYWxlc1t1LnNlcmllc1swXS5zY2FsZV07XG5cblx0bGV0IGR4ID0gdS5fZGF0YVswXSxcblx0XHRkeSA9IHUuX2RhdGFbc2VyaWVzSWR4XSxcblx0XHRzeCA9IHNjYWxlWCxcblx0XHRzeSA9IHUubW9kZSA9PSAyID8gc2NhbGVzW3Nlcmllcy5mYWNldHNbMV0uc2NhbGVdIDogc2NhbGVzW3Nlcmllcy5zY2FsZV0sXG5cdFx0bCA9IGJib3gubGVmdCxcblx0XHR0ID0gYmJveC50b3AsXG5cdFx0dyA9IGJib3gud2lkdGgsXG5cdFx0aCA9IGJib3guaGVpZ2h0LFxuXHRcdEggPSB1LnZhbFRvUG9zSCxcblx0XHRWID0gdS52YWxUb1Bvc1Y7XG5cblx0cmV0dXJuIChzeC5vcmkgPT0gMFxuXHRcdD8gY2IoXG5cdFx0XHRzZXJpZXMsXG5cdFx0XHRkeCxcblx0XHRcdGR5LFxuXHRcdFx0c3gsXG5cdFx0XHRzeSxcblx0XHRcdEgsXG5cdFx0XHRWLFxuXHRcdFx0bCxcblx0XHRcdHQsXG5cdFx0XHR3LFxuXHRcdFx0aCxcblx0XHRcdG1vdmVUb0gsXG5cdFx0XHRsaW5lVG9ILFxuXHRcdFx0cmVjdEgsXG5cdFx0XHRhcmNILFxuXHRcdFx0YmV6aWVyQ3VydmVUb0gsXG5cdFx0KVxuXHRcdDogY2IoXG5cdFx0XHRzZXJpZXMsXG5cdFx0XHRkeCxcblx0XHRcdGR5LFxuXHRcdFx0c3gsXG5cdFx0XHRzeSxcblx0XHRcdFYsXG5cdFx0XHRILFxuXHRcdFx0dCxcblx0XHRcdGwsXG5cdFx0XHRoLFxuXHRcdFx0dyxcblx0XHRcdG1vdmVUb1YsXG5cdFx0XHRsaW5lVG9WLFxuXHRcdFx0cmVjdFYsXG5cdFx0XHRhcmNWLFxuXHRcdFx0YmV6aWVyQ3VydmVUb1YsXG5cdFx0KVxuXHQpO1xufVxuXG5mdW5jdGlvbiBiYW5kRmlsbENsaXBEaXJzKHNlbGYsIHNlcmllc0lkeCkge1xuXHRsZXQgZmlsbERpciA9IDA7XG5cblx0Ly8gMiBiaXRzLCAtMSB8IDFcblx0bGV0IGNsaXBEaXJzID0gMDtcblxuXHRsZXQgYmFuZHMgPSBpZk51bGwoc2VsZi5iYW5kcywgRU1QVFlfQVJSKTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGJhbmRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0bGV0IGIgPSBiYW5kc1tpXTtcblxuXHRcdC8vIGlzIGEgXCJmcm9tXCIgYmFuZCBlZGdlXG5cdFx0aWYgKGIuc2VyaWVzWzBdID09IHNlcmllc0lkeClcblx0XHRcdGZpbGxEaXIgPSBiLmRpcjtcblx0XHQvLyBpcyBhIFwidG9cIiBiYW5kIGVkZ2Vcblx0XHRlbHNlIGlmIChiLnNlcmllc1sxXSA9PSBzZXJpZXNJZHgpIHtcblx0XHRcdGlmIChiLmRpciA9PSAxKVxuXHRcdFx0XHRjbGlwRGlycyB8PSAxO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRjbGlwRGlycyB8PSAyO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBbXG5cdFx0ZmlsbERpcixcblx0XHQoXG5cdFx0XHRjbGlwRGlycyA9PSAxID8gLTEgOiAvLyBuZWcgb25seVxuXHRcdFx0Y2xpcERpcnMgPT0gMiA/ICAxIDogLy8gcG9zIG9ubHlcblx0XHRcdGNsaXBEaXJzID09IDMgPyAgMiA6IC8vIGJvdGhcblx0XHRcdCAgICAgICAgICAgICAgICAgMCAgIC8vIG5laXRoZXJcblx0XHQpXG5cdF07XG59XG5cbmZ1bmN0aW9uIHNlcmllc0ZpbGxUbyhzZWxmLCBzZXJpZXNJZHgsIGRhdGFNaW4sIGRhdGFNYXgsIGJhbmRGaWxsRGlyKSB7XG5cdGxldCBzY2FsZSA9IHNlbGYuc2NhbGVzW3NlbGYuc2VyaWVzW3Nlcmllc0lkeF0uc2NhbGVdO1xuXG5cdHJldHVybiAoXG5cdFx0YmFuZEZpbGxEaXIgPT0gLTEgPyBzY2FsZS5taW4gOlxuXHRcdGJhbmRGaWxsRGlyID09ICAxID8gc2NhbGUubWF4IDpcblx0XHRzY2FsZS5kaXN0ciA9PSAgMyA/IChcblx0XHRcdHNjYWxlLmRpciA9PSAxID8gc2NhbGUubWluIDpcblx0XHRcdHNjYWxlLm1heFxuXHRcdCkgOiAwXG5cdCk7XG59XG5cbi8vIGNyZWF0ZXMgaW52ZXJ0ZWQgYmFuZCBjbGlwIHBhdGggKGZyb20gc3Ryb2tlIHBhdGggLT4geU1heCB8fCB5TWluKVxuLy8gY2xpcERpciBpcyBhbHdheXMgaW52ZXJzZSBvZiBmaWxsRGlyXG4vLyBkZWZhdWx0IGNsaXAgZGlyIGlzIHVwd2FyZHMgKDEpLCBzaW5jZSBkZWZhdWx0IGJhbmQgZmlsbCBpcyBkb3dud2FyZHMvZmlsbEJlbG93VG8gKC0xKSAoaGlnaElkeCAtPiBsb3dJZHgpXG5mdW5jdGlvbiBjbGlwQmFuZExpbmUoc2VsZiwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBzdHJva2VQYXRoLCBjbGlwRGlyKSB7XG5cdHJldHVybiBvcmllbnQoc2VsZiwgc2VyaWVzSWR4LCAoc2VyaWVzLCBkYXRhWCwgZGF0YVksIHNjYWxlWCwgc2NhbGVZLCB2YWxUb1Bvc1gsIHZhbFRvUG9zWSwgeE9mZiwgeU9mZiwgeERpbSwgeURpbSkgPT4ge1xuXHRcdGxldCBweFJvdW5kID0gc2VyaWVzLnB4Um91bmQ7XG5cblx0XHRjb25zdCBkaXIgPSBzY2FsZVguZGlyICogKHNjYWxlWC5vcmkgPT0gMCA/IDEgOiAtMSk7XG5cdFx0Y29uc3QgbGluZVRvID0gc2NhbGVYLm9yaSA9PSAwID8gbGluZVRvSCA6IGxpbmVUb1Y7XG5cblx0XHRsZXQgZnJJZHgsIHRvSWR4O1xuXG5cdFx0aWYgKGRpciA9PSAxKSB7XG5cdFx0XHRmcklkeCA9IGlkeDA7XG5cdFx0XHR0b0lkeCA9IGlkeDE7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZnJJZHggPSBpZHgxO1xuXHRcdFx0dG9JZHggPSBpZHgwO1xuXHRcdH1cblxuXHRcdC8vIHBhdGggc3RhcnRcblx0XHRsZXQgeDAgPSBweFJvdW5kKHZhbFRvUG9zWChkYXRhWFtmcklkeF0sIHNjYWxlWCwgeERpbSwgeE9mZikpO1xuXHRcdGxldCB5MCA9IHB4Um91bmQodmFsVG9Qb3NZKGRhdGFZW2ZySWR4XSwgc2NhbGVZLCB5RGltLCB5T2ZmKSk7XG5cdFx0Ly8gcGF0aCBlbmQgeFxuXHRcdGxldCB4MSA9IHB4Um91bmQodmFsVG9Qb3NYKGRhdGFYW3RvSWR4XSwgc2NhbGVYLCB4RGltLCB4T2ZmKSk7XG5cdFx0Ly8gdXBwZXIgb3IgbG93ZXIgeSBsaW1pdFxuXHRcdGxldCB5TGltaXQgPSBweFJvdW5kKHZhbFRvUG9zWShjbGlwRGlyID09IDEgPyBzY2FsZVkubWF4IDogc2NhbGVZLm1pbiwgc2NhbGVZLCB5RGltLCB5T2ZmKSk7XG5cblx0XHRsZXQgY2xpcCA9IG5ldyBQYXRoMkQoc3Ryb2tlUGF0aCk7XG5cblx0XHRsaW5lVG8oY2xpcCwgeDEsIHlMaW1pdCk7XG5cdFx0bGluZVRvKGNsaXAsIHgwLCB5TGltaXQpO1xuXHRcdGxpbmVUbyhjbGlwLCB4MCwgeTApO1xuXG5cdFx0cmV0dXJuIGNsaXA7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBjbGlwR2FwcyhnYXBzLCBvcmksIHBsb3RMZnQsIHBsb3RUb3AsIHBsb3RXaWQsIHBsb3RIZ3QpIHtcblx0bGV0IGNsaXAgPSBudWxsO1xuXG5cdC8vIGNyZWF0ZSBjbGlwIHBhdGggKGludmVydCBnYXBzIGFuZCBub24tZ2Fwcylcblx0aWYgKGdhcHMubGVuZ3RoID4gMCkge1xuXHRcdGNsaXAgPSBuZXcgUGF0aDJEKCk7XG5cblx0XHRjb25zdCByZWN0ID0gb3JpID09IDAgPyByZWN0SCA6IHJlY3RWO1xuXG5cdFx0bGV0IHByZXZHYXBFbmQgPSBwbG90TGZ0O1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBnYXBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgZyA9IGdhcHNbaV07XG5cblx0XHRcdGlmIChnWzFdID4gZ1swXSkge1xuXHRcdFx0XHRsZXQgdyA9IGdbMF0gLSBwcmV2R2FwRW5kO1xuXG5cdFx0XHRcdHcgPiAwICYmIHJlY3QoY2xpcCwgcHJldkdhcEVuZCwgcGxvdFRvcCwgdywgcGxvdFRvcCArIHBsb3RIZ3QpO1xuXG5cdFx0XHRcdHByZXZHYXBFbmQgPSBnWzFdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCB3ID0gcGxvdExmdCArIHBsb3RXaWQgLSBwcmV2R2FwRW5kO1xuXG5cdFx0dyA+IDAgJiYgcmVjdChjbGlwLCBwcmV2R2FwRW5kLCBwbG90VG9wLCB3LCBwbG90VG9wICsgcGxvdEhndCk7XG5cdH1cblxuXHRyZXR1cm4gY2xpcDtcbn1cblxuZnVuY3Rpb24gYWRkR2FwKGdhcHMsIGZyb21YLCB0b1gpIHtcblx0bGV0IHByZXZHYXAgPSBnYXBzW2dhcHMubGVuZ3RoIC0gMV07XG5cblx0aWYgKHByZXZHYXAgJiYgcHJldkdhcFswXSA9PSBmcm9tWClcdFx0XHQvLyBUT0RPOiBnYXBzIG11c3QgYmUgZW5jb2RlZCBhdCBzdHJva2Ugd2lkdGhzP1xuXHRcdHByZXZHYXBbMV0gPSB0b1g7XG5cdGVsc2Vcblx0XHRnYXBzLnB1c2goW2Zyb21YLCB0b1hdKTtcbn1cblxuZnVuY3Rpb24gZmluZEdhcHMoeHMsIHlzLCBpZHgwLCBpZHgxLCBkaXIsIHBpeGVsRm9yWCwgYWxpZ24pIHtcblx0bGV0IGdhcHMgPSBbXTtcblxuXHRmb3IgKGxldCBpID0gZGlyID09IDEgPyBpZHgwIDogaWR4MTsgaSA+PSBpZHgwICYmIGkgPD0gaWR4MTsgaSArPSBkaXIpIHtcblx0XHRsZXQgeVZhbCA9IHlzW2ldO1xuXG5cdFx0aWYgKHlWYWwgPT09IG51bGwpIHtcblx0XHRcdGxldCBmciA9IGksIHRvID0gaTtcblxuXHRcdFx0aWYgKGRpciA9PSAxKSB7XG5cdFx0XHRcdHdoaWxlICgrK2kgPD0gaWR4MSAmJiB5c1tpXSA9PT0gbnVsbClcblx0XHRcdFx0XHR0byA9IGk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0d2hpbGUgKC0taSA+PSBpZHgwICYmIHlzW2ldID09PSBudWxsKVxuXHRcdFx0XHRcdHRvID0gaTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGZyUHggPSBwaXhlbEZvclgoeHNbZnJdKTtcblx0XHRcdGxldCB0b1B4ID0gdG8gPT0gZnIgPyBmclB4IDogcGl4ZWxGb3JYKHhzW3RvXSk7XG5cblx0XHRcdC8vIGlmIHZhbHVlIGFkamFjZW50IHRvIGVkZ2UgbnVsbCBpcyBzYW1lIHBpeGVsLCB0aGVuIGl0J3MgcGFydGlhbGx5XG5cdFx0XHQvLyBmaWxsZWQgYW5kIGdhcCBzaG91bGQgc3RhcnQgYXQgbmV4dCBwaXhlbFxuXHRcdFx0bGV0IGZyUHgyID0gYWxpZ24gPD0gMCA/IHBpeGVsRm9yWCh4c1tmci1kaXJdKSA6IGZyUHg7XG5cdFx0Ly9cdGlmIChmclB4MiA9PSBmclB4KVxuXHRcdC8vXHRcdGZyUHgrKztcblx0XHQvL1x0ZWxzZVxuXHRcdFx0XHRmclB4ID0gZnJQeDI7XG5cblx0XHRcdGxldCB0b1B4MiA9IGFsaWduID49IDAgPyBwaXhlbEZvclgoeHNbdG8rZGlyXSkgOiB0b1B4O1xuXHRcdC8vXHRpZiAodG9QeDIgPT0gdG9QeClcblx0XHQvL1x0XHR0b1B4LS07XG5cdFx0Ly9cdGVsc2Vcblx0XHRcdFx0dG9QeCA9IHRvUHgyO1xuXG5cdFx0XHRpZiAodG9QeCA+PSBmclB4KVxuXHRcdFx0XHRnYXBzLnB1c2goW2ZyUHgsIHRvUHhdKTsgLy8gYWRkR2FwXG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGdhcHM7XG59XG5cbmZ1bmN0aW9uIHB4Um91bmRHZW4ocHhBbGlnbikge1xuXHRyZXR1cm4gcHhBbGlnbiA9PSAwID8gcmV0QXJnMCA6IHB4QWxpZ24gPT0gMSA/IHJvdW5kIDogdiA9PiBpbmNyUm91bmQodiwgcHhBbGlnbik7XG59XG5cbmZ1bmN0aW9uIHJlY3Qob3JpKSB7XG5cdGxldCBtb3ZlVG8gPSBvcmkgPT0gMCA/XG5cdFx0bW92ZVRvSCA6XG5cdFx0bW92ZVRvVjtcblxuXHRsZXQgYXJjVG8gPSBvcmkgPT0gMCA/XG5cdFx0KHAsIHgxLCB5MSwgeDIsIHkyLCByKSA9PiB7IHAuYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHIpOyB9IDpcblx0XHQocCwgeTEsIHgxLCB5MiwgeDIsIHIpID0+IHsgcC5hcmNUbyh4MSwgeTEsIHgyLCB5Miwgcik7IH07XG5cblx0bGV0IHJlY3QgPSBvcmkgPT0gMCA/XG5cdFx0KHAsIHgsIHksIHcsIGgpID0+IHsgcC5yZWN0KHgsIHksIHcsIGgpOyB9IDpcblx0XHQocCwgeSwgeCwgaCwgdykgPT4geyBwLnJlY3QoeCwgeSwgdywgaCk7IH07XG5cblx0cmV0dXJuIChwLCB4LCB5LCB3LCBoLCByID0gMCkgPT4ge1xuXHRcdGlmIChyID09IDApXG5cdFx0XHRyZWN0KHAsIHgsIHksIHcsIGgpO1xuXHRcdGVsc2Uge1xuXHRcdFx0ciA9IG1pbihyLCB3IC8gMiwgaCAvIDIpO1xuXG5cdFx0XHQvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI1NTUxMi9ob3ctdG8tZHJhdy1hLXJvdW5kZWQtcmVjdGFuZ2xlLXVzaW5nLWh0bWwtY2FudmFzLzc4Mzg4NzEjNzgzODg3MVxuXHRcdFx0bW92ZVRvKHAsIHggKyByLCB5KTtcblx0XHRcdGFyY1RvKHAsIHggKyB3LCB5LCB4ICsgdywgeSArIGgsIHIpO1xuXHRcdFx0YXJjVG8ocCwgeCArIHcsIHkgKyBoLCB4LCB5ICsgaCwgcik7XG5cdFx0XHRhcmNUbyhwLCB4LCB5ICsgaCwgeCwgeSwgcik7XG5cdFx0XHRhcmNUbyhwLCB4LCB5LCB4ICsgdywgeSwgcik7XG5cdFx0XHRwLmNsb3NlUGF0aCgpO1xuXHRcdH1cblx0fTtcbn1cblxuLy8gb3JpZW50YXRpb24taW52ZXJ0aW5nIGNhbnZhcyBmdW5jdGlvbnNcbmNvbnN0IG1vdmVUb0ggPSAocCwgeCwgeSkgPT4geyBwLm1vdmVUbyh4LCB5KTsgfTtcbmNvbnN0IG1vdmVUb1YgPSAocCwgeSwgeCkgPT4geyBwLm1vdmVUbyh4LCB5KTsgfTtcbmNvbnN0IGxpbmVUb0ggPSAocCwgeCwgeSkgPT4geyBwLmxpbmVUbyh4LCB5KTsgfTtcbmNvbnN0IGxpbmVUb1YgPSAocCwgeSwgeCkgPT4geyBwLmxpbmVUbyh4LCB5KTsgfTtcbmNvbnN0IHJlY3RIID0gcmVjdCgwKTtcbmNvbnN0IHJlY3RWID0gcmVjdCgxKTtcbmNvbnN0IGFyY0ggPSAocCwgeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpID0+IHsgcC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpOyB9O1xuY29uc3QgYXJjViA9IChwLCB5LCB4LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkgPT4geyBwLmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7IH07XG5jb25zdCBiZXppZXJDdXJ2ZVRvSCA9IChwLCBicDF4LCBicDF5LCBicDJ4LCBicDJ5LCBwMngsIHAyeSkgPT4geyBwLmJlemllckN1cnZlVG8oYnAxeCwgYnAxeSwgYnAyeCwgYnAyeSwgcDJ4LCBwMnkpOyB9O1xuY29uc3QgYmV6aWVyQ3VydmVUb1YgPSAocCwgYnAxeSwgYnAxeCwgYnAyeSwgYnAyeCwgcDJ5LCBwMngpID0+IHsgcC5iZXppZXJDdXJ2ZVRvKGJwMXgsIGJwMXksIGJwMngsIGJwMnksIHAyeCwgcDJ5KTsgfTtcblxuLy8gVE9ETzogZHJhd1dyYXAoc2VyaWVzSWR4LCBkcmF3UG9pbnRzKSAoc2F2ZSwgcmVzdG9yZSwgdHJhbnNsYXRlLCBjbGlwKVxuZnVuY3Rpb24gcG9pbnRzKG9wdHMpIHtcblx0cmV0dXJuICh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEsIGZpbHRJZHhzKSA9PiB7XG5cdC8vXHRsb2coXCJkcmF3UG9pbnRzKClcIiwgYXJndW1lbnRzKTtcblxuXHRcdHJldHVybiBvcmllbnQodSwgc2VyaWVzSWR4LCAoc2VyaWVzLCBkYXRhWCwgZGF0YVksIHNjYWxlWCwgc2NhbGVZLCB2YWxUb1Bvc1gsIHZhbFRvUG9zWSwgeE9mZiwgeU9mZiwgeERpbSwgeURpbSkgPT4ge1xuXHRcdFx0bGV0IHsgcHhSb3VuZCwgcG9pbnRzIH0gPSBzZXJpZXM7XG5cblx0XHRcdGxldCBtb3ZlVG8sIGFyYztcblxuXHRcdFx0aWYgKHNjYWxlWC5vcmkgPT0gMCkge1xuXHRcdFx0XHRtb3ZlVG8gPSBtb3ZlVG9IO1xuXHRcdFx0XHRhcmMgPSBhcmNIO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG1vdmVUbyA9IG1vdmVUb1Y7XG5cdFx0XHRcdGFyYyA9IGFyY1Y7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHdpZHRoID0gcm91bmREZWMocG9pbnRzLndpZHRoICogcHhSYXRpbywgMyk7XG5cblx0XHRcdGxldCByYWQgPSAocG9pbnRzLnNpemUgLSBwb2ludHMud2lkdGgpIC8gMiAqIHB4UmF0aW87XG5cdFx0XHRsZXQgZGlhID0gcm91bmREZWMocmFkICogMiwgMyk7XG5cblx0XHRcdGxldCBmaWxsID0gbmV3IFBhdGgyRCgpO1xuXHRcdFx0bGV0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG5cblx0XHRcdGxldCB7IGxlZnQ6IGxmdCwgdG9wOiB0b3AsIHdpZHRoOiB3aWQsIGhlaWdodDogaGd0IH0gPSB1LmJib3g7XG5cblx0XHRcdHJlY3RIKGNsaXAsXG5cdFx0XHRcdGxmdCAtIGRpYSxcblx0XHRcdFx0dG9wIC0gZGlhLFxuXHRcdFx0XHR3aWQgKyBkaWEgKiAyLFxuXHRcdFx0XHRoZ3QgKyBkaWEgKiAyLFxuXHRcdFx0KTtcblxuXHRcdFx0Y29uc3QgZHJhd1BvaW50ID0gcGkgPT4ge1xuXHRcdFx0XHRpZiAoZGF0YVlbcGldICE9IG51bGwpIHtcblx0XHRcdFx0XHRsZXQgeCA9IHB4Um91bmQodmFsVG9Qb3NYKGRhdGFYW3BpXSwgc2NhbGVYLCB4RGltLCB4T2ZmKSk7XG5cdFx0XHRcdFx0bGV0IHkgPSBweFJvdW5kKHZhbFRvUG9zWShkYXRhWVtwaV0sIHNjYWxlWSwgeURpbSwgeU9mZikpO1xuXG5cdFx0XHRcdFx0bW92ZVRvKGZpbGwsIHggKyByYWQsIHkpO1xuXHRcdFx0XHRcdGFyYyhmaWxsLCB4LCB5LCByYWQsIDAsIFBJICogMik7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGlmIChmaWx0SWR4cylcblx0XHRcdFx0ZmlsdElkeHMuZm9yRWFjaChkcmF3UG9pbnQpO1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGZvciAobGV0IHBpID0gaWR4MDsgcGkgPD0gaWR4MTsgcGkrKylcblx0XHRcdFx0XHRkcmF3UG9pbnQocGkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzdHJva2U6IHdpZHRoID4gMCA/IGZpbGwgOiBudWxsLFxuXHRcdFx0XHRmaWxsLFxuXHRcdFx0XHRjbGlwLFxuXHRcdFx0XHRmbGFnczogQkFORF9DTElQX0ZJTEwgfCBCQU5EX0NMSVBfU1RST0tFLFxuXHRcdFx0fTtcblx0XHR9KTtcblx0fTtcbn1cblxuZnVuY3Rpb24gX2RyYXdBY2MobGluZVRvKSB7XG5cdHJldHVybiAoc3Ryb2tlLCBhY2NYLCBtaW5ZLCBtYXhZLCBpblksIG91dFkpID0+IHtcblx0XHRpZiAobWluWSAhPSBtYXhZKSB7XG5cdFx0XHRpZiAoaW5ZICE9IG1pblkgJiYgb3V0WSAhPSBtaW5ZKVxuXHRcdFx0XHRsaW5lVG8oc3Ryb2tlLCBhY2NYLCBtaW5ZKTtcblx0XHRcdGlmIChpblkgIT0gbWF4WSAmJiBvdXRZICE9IG1heFkpXG5cdFx0XHRcdGxpbmVUbyhzdHJva2UsIGFjY1gsIG1heFkpO1xuXG5cdFx0XHRsaW5lVG8oc3Ryb2tlLCBhY2NYLCBvdXRZKTtcblx0XHR9XG5cdH07XG59XG5cbmNvbnN0IGRyYXdBY2NIID0gX2RyYXdBY2MobGluZVRvSCk7XG5jb25zdCBkcmF3QWNjViA9IF9kcmF3QWNjKGxpbmVUb1YpO1xuXG5mdW5jdGlvbiBsaW5lYXIob3B0cykge1xuXHRjb25zdCBhbGlnbkdhcHMgPSBpZk51bGwob3B0cz8uYWxpZ25HYXBzLCAwKTtcblxuXHRyZXR1cm4gKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSkgPT4ge1xuXHRcdHJldHVybiBvcmllbnQodSwgc2VyaWVzSWR4LCAoc2VyaWVzLCBkYXRhWCwgZGF0YVksIHNjYWxlWCwgc2NhbGVZLCB2YWxUb1Bvc1gsIHZhbFRvUG9zWSwgeE9mZiwgeU9mZiwgeERpbSwgeURpbSkgPT4ge1xuXHRcdFx0bGV0IHB4Um91bmQgPSBzZXJpZXMucHhSb3VuZDtcblxuXHRcdFx0bGV0IHBpeGVsRm9yWCA9IHZhbCA9PiBweFJvdW5kKHZhbFRvUG9zWCh2YWwsIHNjYWxlWCwgeERpbSwgeE9mZikpO1xuXHRcdFx0bGV0IHBpeGVsRm9yWSA9IHZhbCA9PiBweFJvdW5kKHZhbFRvUG9zWSh2YWwsIHNjYWxlWSwgeURpbSwgeU9mZikpO1xuXG5cdFx0XHRsZXQgbGluZVRvLCBkcmF3QWNjO1xuXG5cdFx0XHRpZiAoc2NhbGVYLm9yaSA9PSAwKSB7XG5cdFx0XHRcdGxpbmVUbyA9IGxpbmVUb0g7XG5cdFx0XHRcdGRyYXdBY2MgPSBkcmF3QWNjSDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsaW5lVG8gPSBsaW5lVG9WO1xuXHRcdFx0XHRkcmF3QWNjID0gZHJhd0FjY1Y7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRpciA9IHNjYWxlWC5kaXIgKiAoc2NhbGVYLm9yaSA9PSAwID8gMSA6IC0xKTtcblxuXHRcdFx0Y29uc3QgX3BhdGhzID0ge3N0cm9rZTogbmV3IFBhdGgyRCgpLCBmaWxsOiBudWxsLCBjbGlwOiBudWxsLCBiYW5kOiBudWxsLCBnYXBzOiBudWxsLCBmbGFnczogQkFORF9DTElQX0ZJTEx9O1xuXHRcdFx0Y29uc3Qgc3Ryb2tlID0gX3BhdGhzLnN0cm9rZTtcblxuXHRcdFx0bGV0IG1pblkgPSBpbmYsXG5cdFx0XHRcdG1heFkgPSAtaW5mLFxuXHRcdFx0XHRpblksIG91dFksIGRyYXduQXRYO1xuXG5cdFx0XHRsZXQgYWNjWCA9IHBpeGVsRm9yWChkYXRhWFtkaXIgPT0gMSA/IGlkeDAgOiBpZHgxXSk7XG5cblx0XHRcdC8vIGRhdGEgZWRnZXNcblx0XHRcdGxldCBsZnRJZHggPSBub25OdWxsSWR4KGRhdGFZLCBpZHgwLCBpZHgxLCAgMSAqIGRpcik7XG5cdFx0XHRsZXQgcmd0SWR4ID0gbm9uTnVsbElkeChkYXRhWSwgaWR4MCwgaWR4MSwgLTEgKiBkaXIpO1xuXHRcdFx0bGV0IGxmdFggICA9ICBwaXhlbEZvclgoZGF0YVhbbGZ0SWR4XSk7XG5cdFx0XHRsZXQgcmd0WCAgID0gIHBpeGVsRm9yWChkYXRhWFtyZ3RJZHhdKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IGRpciA9PSAxID8gaWR4MCA6IGlkeDE7IGkgPj0gaWR4MCAmJiBpIDw9IGlkeDE7IGkgKz0gZGlyKSB7XG5cdFx0XHRcdGxldCB4ID0gcGl4ZWxGb3JYKGRhdGFYW2ldKTtcblxuXHRcdFx0XHRpZiAoeCA9PSBhY2NYKSB7XG5cdFx0XHRcdFx0aWYgKGRhdGFZW2ldICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdG91dFkgPSBwaXhlbEZvclkoZGF0YVlbaV0pO1xuXG5cdFx0XHRcdFx0XHRpZiAobWluWSA9PSBpbmYpIHtcblx0XHRcdFx0XHRcdFx0bGluZVRvKHN0cm9rZSwgeCwgb3V0WSk7XG5cdFx0XHRcdFx0XHRcdGluWSA9IG91dFk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG1pblkgPSBtaW4ob3V0WSwgbWluWSk7XG5cdFx0XHRcdFx0XHRtYXhZID0gbWF4KG91dFksIG1heFkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAobWluWSAhPSBpbmYpIHtcblx0XHRcdFx0XHRcdGRyYXdBY2Moc3Ryb2tlLCBhY2NYLCBtaW5ZLCBtYXhZLCBpblksIG91dFkpO1xuXHRcdFx0XHRcdFx0ZHJhd25BdFggPSBhY2NYO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChkYXRhWVtpXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRvdXRZID0gcGl4ZWxGb3JZKGRhdGFZW2ldKTtcblx0XHRcdFx0XHRcdGxpbmVUbyhzdHJva2UsIHgsIG91dFkpO1xuXHRcdFx0XHRcdFx0bWluWSA9IG1heFkgPSBpblkgPSBvdXRZO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdG1pblkgPSBpbmY7XG5cdFx0XHRcdFx0XHRtYXhZID0gLWluZjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRhY2NYID0geDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWluWSAhPSBpbmYgJiYgbWluWSAhPSBtYXhZICYmIGRyYXduQXRYICE9IGFjY1gpXG5cdFx0XHRcdGRyYXdBY2Moc3Ryb2tlLCBhY2NYLCBtaW5ZLCBtYXhZLCBpblksIG91dFkpO1xuXG5cdFx0XHRsZXQgWyBiYW5kRmlsbERpciwgYmFuZENsaXBEaXIgXSA9IGJhbmRGaWxsQ2xpcERpcnModSwgc2VyaWVzSWR4KTtcblxuXHRcdFx0aWYgKHNlcmllcy5maWxsICE9IG51bGwgfHwgYmFuZEZpbGxEaXIgIT0gMCkge1xuXHRcdFx0XHRsZXQgZmlsbCA9IF9wYXRocy5maWxsID0gbmV3IFBhdGgyRChzdHJva2UpO1xuXG5cdFx0XHRcdGxldCBmaWxsVG9WYWwgPSBzZXJpZXMuZmlsbFRvKHUsIHNlcmllc0lkeCwgc2VyaWVzLm1pbiwgc2VyaWVzLm1heCwgYmFuZEZpbGxEaXIpO1xuXHRcdFx0XHRsZXQgZmlsbFRvWSA9IHBpeGVsRm9yWShmaWxsVG9WYWwpO1xuXG5cdFx0XHRcdGxpbmVUbyhmaWxsLCByZ3RYLCBmaWxsVG9ZKTtcblx0XHRcdFx0bGluZVRvKGZpbGwsIGxmdFgsIGZpbGxUb1kpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXNlcmllcy5zcGFuR2Fwcykge1xuXHRcdFx0Ly9cdGNvbnNvbGUudGltZSgnZ2FwcycpO1xuXHRcdFx0XHRsZXQgZ2FwcyA9IFtdO1xuXG5cdFx0XHRcdGdhcHMucHVzaCguLi5maW5kR2FwcyhkYXRhWCwgZGF0YVksIGlkeDAsIGlkeDEsIGRpciwgcGl4ZWxGb3JYLCBhbGlnbkdhcHMpKTtcblxuXHRcdFx0Ly9cdGNvbnNvbGUudGltZUVuZCgnZ2FwcycpO1xuXG5cdFx0XHQvL1x0Y29uc29sZS5sb2coJ2dhcHMnLCBKU09OLnN0cmluZ2lmeShnYXBzKSk7XG5cblx0XHRcdFx0X3BhdGhzLmdhcHMgPSBnYXBzID0gc2VyaWVzLmdhcHModSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBnYXBzKTtcblxuXHRcdFx0XHRfcGF0aHMuY2xpcCA9IGNsaXBHYXBzKGdhcHMsIHNjYWxlWC5vcmksIHhPZmYsIHlPZmYsIHhEaW0sIHlEaW0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYmFuZENsaXBEaXIgIT0gMCkge1xuXHRcdFx0XHRfcGF0aHMuYmFuZCA9IGJhbmRDbGlwRGlyID09IDIgPyBbXG5cdFx0XHRcdFx0Y2xpcEJhbmRMaW5lKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSwgc3Ryb2tlLCAtMSksXG5cdFx0XHRcdFx0Y2xpcEJhbmRMaW5lKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSwgc3Ryb2tlLCAgMSksXG5cdFx0XHRcdF0gOiBjbGlwQmFuZExpbmUodSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBzdHJva2UsIGJhbmRDbGlwRGlyKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIF9wYXRocztcblx0XHR9KTtcblx0fTtcbn1cblxuZnVuY3Rpb24gc3RlcHBlZChvcHRzKSB7XG5cdGNvbnN0IGFsaWduID0gaWZOdWxsKG9wdHMuYWxpZ24sIDEpO1xuXHQvLyB3aGV0aGVyIHRvIGRyYXcgYXNjZW5kZXJzL2Rlc2NlbmRlcnMgYXQgbnVsbC9nYXAgYm9uZGFyaWVzXG5cdGNvbnN0IGFzY0Rlc2MgPSBpZk51bGwob3B0cy5hc2NEZXNjLCBmYWxzZSk7XG5cblx0Y29uc3QgYWxpZ25HYXBzID0gaWZOdWxsKG9wdHMuYWxpZ25HYXBzLCAwKTtcblxuXHRyZXR1cm4gKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSkgPT4ge1xuXHRcdHJldHVybiBvcmllbnQodSwgc2VyaWVzSWR4LCAoc2VyaWVzLCBkYXRhWCwgZGF0YVksIHNjYWxlWCwgc2NhbGVZLCB2YWxUb1Bvc1gsIHZhbFRvUG9zWSwgeE9mZiwgeU9mZiwgeERpbSwgeURpbSkgPT4ge1xuXHRcdFx0bGV0IHB4Um91bmQgPSBzZXJpZXMucHhSb3VuZDtcblxuXHRcdFx0bGV0IHBpeGVsRm9yWCA9IHZhbCA9PiBweFJvdW5kKHZhbFRvUG9zWCh2YWwsIHNjYWxlWCwgeERpbSwgeE9mZikpO1xuXHRcdFx0bGV0IHBpeGVsRm9yWSA9IHZhbCA9PiBweFJvdW5kKHZhbFRvUG9zWSh2YWwsIHNjYWxlWSwgeURpbSwgeU9mZikpO1xuXG5cdFx0XHRsZXQgbGluZVRvID0gc2NhbGVYLm9yaSA9PSAwID8gbGluZVRvSCA6IGxpbmVUb1Y7XG5cblx0XHRcdGNvbnN0IF9wYXRocyA9IHtzdHJva2U6IG5ldyBQYXRoMkQoKSwgZmlsbDogbnVsbCwgY2xpcDogbnVsbCwgYmFuZDogbnVsbCwgZ2FwczogbnVsbCwgZmxhZ3M6IEJBTkRfQ0xJUF9GSUxMfTtcblx0XHRcdGNvbnN0IHN0cm9rZSA9IF9wYXRocy5zdHJva2U7XG5cblx0XHRcdGNvbnN0IGRpciA9IHNjYWxlWC5kaXIgKiAoc2NhbGVYLm9yaSA9PSAwID8gMSA6IC0xKTtcblxuXHRcdFx0aWR4MCA9IG5vbk51bGxJZHgoZGF0YVksIGlkeDAsIGlkeDEsICAxKTtcblx0XHRcdGlkeDEgPSBub25OdWxsSWR4KGRhdGFZLCBpZHgwLCBpZHgxLCAtMSk7XG5cblx0XHRcdGxldCBwcmV2WVBvcyAgPSBwaXhlbEZvclkoZGF0YVlbZGlyID09IDEgPyBpZHgwIDogaWR4MV0pO1xuXHRcdFx0bGV0IGZpcnN0WFBvcyA9IHBpeGVsRm9yWChkYXRhWFtkaXIgPT0gMSA/IGlkeDAgOiBpZHgxXSk7XG5cdFx0XHRsZXQgcHJldlhQb3MgPSBmaXJzdFhQb3M7XG5cblx0XHRcdGxpbmVUbyhzdHJva2UsIGZpcnN0WFBvcywgcHJldllQb3MpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gZGlyID09IDEgPyBpZHgwIDogaWR4MTsgaSA+PSBpZHgwICYmIGkgPD0gaWR4MTsgaSArPSBkaXIpIHtcblx0XHRcdFx0bGV0IHlWYWwxID0gZGF0YVlbaV07XG5cblx0XHRcdFx0aWYgKHlWYWwxID09IG51bGwpXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0bGV0IHgxID0gcGl4ZWxGb3JYKGRhdGFYW2ldKTtcblx0XHRcdFx0bGV0IHkxID0gcGl4ZWxGb3JZKHlWYWwxKTtcblxuXHRcdFx0XHRpZiAoYWxpZ24gPT0gMSlcblx0XHRcdFx0XHRsaW5lVG8oc3Ryb2tlLCB4MSwgcHJldllQb3MpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0bGluZVRvKHN0cm9rZSwgcHJldlhQb3MsIHkxKTtcblxuXHRcdFx0XHRsaW5lVG8oc3Ryb2tlLCB4MSwgeTEpO1xuXG5cdFx0XHRcdHByZXZZUG9zID0geTE7XG5cdFx0XHRcdHByZXZYUG9zID0geDE7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBbIGJhbmRGaWxsRGlyLCBiYW5kQ2xpcERpciBdID0gYmFuZEZpbGxDbGlwRGlycyh1LCBzZXJpZXNJZHgpO1xuXG5cdFx0XHRpZiAoc2VyaWVzLmZpbGwgIT0gbnVsbCB8fCBiYW5kRmlsbERpciAhPSAwKSB7XG5cdFx0XHRcdGxldCBmaWxsID0gX3BhdGhzLmZpbGwgPSBuZXcgUGF0aDJEKHN0cm9rZSk7XG5cblx0XHRcdFx0bGV0IGZpbGxUbyA9IHNlcmllcy5maWxsVG8odSwgc2VyaWVzSWR4LCBzZXJpZXMubWluLCBzZXJpZXMubWF4LCBiYW5kRmlsbERpcik7XG5cdFx0XHRcdGxldCBmaWxsVG9ZID0gcGl4ZWxGb3JZKGZpbGxUbyk7XG5cblx0XHRcdFx0bGluZVRvKGZpbGwsIHByZXZYUG9zLCBmaWxsVG9ZKTtcblx0XHRcdFx0bGluZVRvKGZpbGwsIGZpcnN0WFBvcywgZmlsbFRvWSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghc2VyaWVzLnNwYW5HYXBzKSB7XG5cdFx0XHQvL1x0Y29uc29sZS50aW1lKCdnYXBzJyk7XG5cdFx0XHRcdGxldCBnYXBzID0gW107XG5cblx0XHRcdFx0Z2Fwcy5wdXNoKC4uLmZpbmRHYXBzKGRhdGFYLCBkYXRhWSwgaWR4MCwgaWR4MSwgZGlyLCBwaXhlbEZvclgsIGFsaWduR2FwcykpO1xuXG5cdFx0XHQvL1x0Y29uc29sZS50aW1lRW5kKCdnYXBzJyk7XG5cblx0XHRcdC8vXHRjb25zb2xlLmxvZygnZ2FwcycsIEpTT04uc3RyaW5naWZ5KGdhcHMpKTtcblxuXHRcdFx0XHQvLyBleHBhbmQvY29udHJhY3QgY2xpcHMgZm9yIGFzY2VuZGVycy9kZXNjZW5kZXJzXG5cdFx0XHRcdGxldCBoYWxmU3Ryb2tlID0gKHNlcmllcy53aWR0aCAqIHB4UmF0aW8pIC8gMjtcblx0XHRcdFx0bGV0IHN0YXJ0c09mZnNldCA9IChhc2NEZXNjIHx8IGFsaWduID09ICAxKSA/ICBoYWxmU3Ryb2tlIDogLWhhbGZTdHJva2U7XG5cdFx0XHRcdGxldCBlbmRzT2Zmc2V0ICAgPSAoYXNjRGVzYyB8fCBhbGlnbiA9PSAtMSkgPyAtaGFsZlN0cm9rZSA6ICBoYWxmU3Ryb2tlO1xuXG5cdFx0XHRcdGdhcHMuZm9yRWFjaChnID0+IHtcblx0XHRcdFx0XHRnWzBdICs9IHN0YXJ0c09mZnNldDtcblx0XHRcdFx0XHRnWzFdICs9IGVuZHNPZmZzZXQ7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdF9wYXRocy5nYXBzID0gZ2FwcyA9IHNlcmllcy5nYXBzKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSwgZ2Fwcyk7XG5cblx0XHRcdFx0X3BhdGhzLmNsaXAgPSBjbGlwR2FwcyhnYXBzLCBzY2FsZVgub3JpLCB4T2ZmLCB5T2ZmLCB4RGltLCB5RGltKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJhbmRDbGlwRGlyICE9IDApIHtcblx0XHRcdFx0X3BhdGhzLmJhbmQgPSBiYW5kQ2xpcERpciA9PSAyID8gW1xuXHRcdFx0XHRcdGNsaXBCYW5kTGluZSh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEsIHN0cm9rZSwgLTEpLFxuXHRcdFx0XHRcdGNsaXBCYW5kTGluZSh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEsIHN0cm9rZSwgIDEpLFxuXHRcdFx0XHRdIDogY2xpcEJhbmRMaW5lKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSwgc3Ryb2tlLCBiYW5kQ2xpcERpcik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBfcGF0aHM7XG5cdFx0fSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGJhcnMob3B0cykge1xuXHRvcHRzID0gb3B0cyB8fCBFTVBUWV9PQko7XG5cdGNvbnN0IHNpemUgPSBpZk51bGwob3B0cy5zaXplLCBbMC42LCBpbmYsIDFdKTtcblx0Y29uc3QgYWxpZ24gPSBvcHRzLmFsaWduIHx8IDA7XG5cdGNvbnN0IGV4dHJhR2FwID0gKG9wdHMuZ2FwIHx8IDApICogcHhSYXRpbztcblxuXHRjb25zdCByYWRpdXMgPSBpZk51bGwob3B0cy5yYWRpdXMsIDApO1xuXG5cdGNvbnN0IGdhcEZhY3RvciA9IDEgLSBzaXplWzBdO1xuXHRjb25zdCBtYXhXaWR0aCAgPSBpZk51bGwoc2l6ZVsxXSwgaW5mKSAqIHB4UmF0aW87XG5cdGNvbnN0IG1pbldpZHRoICA9IGlmTnVsbChzaXplWzJdLCAxKSAqIHB4UmF0aW87XG5cblx0Y29uc3QgZGlzcCA9IGlmTnVsbChvcHRzLmRpc3AsIEVNUFRZX09CSik7XG5cdGNvbnN0IF9lYWNoID0gaWZOdWxsKG9wdHMuZWFjaCwgXyA9PiB7fSk7XG5cblx0Y29uc3QgeyBmaWxsOiBkaXNwRmlsbHMsIHN0cm9rZTogZGlzcFN0cm9rZXMgfSA9IGRpc3A7XG5cblx0cmV0dXJuICh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEpID0+IHtcblx0XHRyZXR1cm4gb3JpZW50KHUsIHNlcmllc0lkeCwgKHNlcmllcywgZGF0YVgsIGRhdGFZLCBzY2FsZVgsIHNjYWxlWSwgdmFsVG9Qb3NYLCB2YWxUb1Bvc1ksIHhPZmYsIHlPZmYsIHhEaW0sIHlEaW0pID0+IHtcblx0XHRcdGxldCBweFJvdW5kID0gc2VyaWVzLnB4Um91bmQ7XG5cblx0XHRcdGNvbnN0IF9kaXJYID0gc2NhbGVYLmRpciAqIChzY2FsZVgub3JpID09IDAgPyAxIDogLTEpO1xuXHRcdFx0Y29uc3QgX2RpclkgPSBzY2FsZVkuZGlyICogKHNjYWxlWS5vcmkgPT0gMSA/IDEgOiAtMSk7XG5cblx0XHRcdGxldCByZWN0ID0gc2NhbGVYLm9yaSA9PSAwID8gcmVjdEggOiByZWN0VjtcblxuXHRcdFx0bGV0IGVhY2ggPSBzY2FsZVgub3JpID09IDAgPyBfZWFjaCA6ICh1LCBzZXJpZXNJZHgsIGksIHRvcCwgbGZ0LCBoZ3QsIHdpZCkgPT4ge1xuXHRcdFx0XHRfZWFjaCh1LCBzZXJpZXNJZHgsIGksIGxmdCwgdG9wLCB3aWQsIGhndCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRsZXQgWyBiYW5kRmlsbERpciwgYmFuZENsaXBEaXIgXSA9IGJhbmRGaWxsQ2xpcERpcnModSwgc2VyaWVzSWR4KTtcblxuXHRcdC8vXHRsZXQgZmlsbFRvWSA9IHNlcmllcy5maWxsVG8odSwgc2VyaWVzSWR4LCBzZXJpZXMubWluLCBzZXJpZXMubWF4LCBiYW5kRmlsbERpcik7XG5cdFx0XHRsZXQgZmlsbFRvWSA9IHNjYWxlWS5kaXN0ciA9PSAzID8gKGJhbmRGaWxsRGlyID09IDEgPyBzY2FsZVkubWF4IDogc2NhbGVZLm1pbikgOiAwO1xuXG5cdFx0XHRsZXQgeTBQb3MgPSB2YWxUb1Bvc1koZmlsbFRvWSwgc2NhbGVZLCB5RGltLCB5T2ZmKTtcblxuXHRcdFx0Ly8gYmFyV2lkIGlzIHRvIGNlbnRlciBvZiBzdHJva2Vcblx0XHRcdGxldCB4U2hpZnQsIGJhcldpZDtcblxuXHRcdFx0bGV0IHN0cm9rZVdpZHRoID0gcHhSb3VuZChzZXJpZXMud2lkdGggKiBweFJhdGlvKTtcblxuXHRcdFx0bGV0IG11bHRpUGF0aCA9IGZhbHNlO1xuXG5cdFx0XHRsZXQgZmlsbENvbG9ycyA9IG51bGw7XG5cdFx0XHRsZXQgZmlsbFBhdGhzID0gbnVsbDtcblx0XHRcdGxldCBzdHJva2VDb2xvcnMgPSBudWxsO1xuXHRcdFx0bGV0IHN0cm9rZVBhdGhzID0gbnVsbDtcblxuXHRcdFx0aWYgKGRpc3BGaWxscyAhPSBudWxsICYmIChzdHJva2VXaWR0aCA9PSAwIHx8IGRpc3BTdHJva2VzICE9IG51bGwpKSB7XG5cdFx0XHRcdG11bHRpUGF0aCA9IHRydWU7XG5cblx0XHRcdFx0ZmlsbENvbG9ycyA9IGRpc3BGaWxscy52YWx1ZXModSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxKTtcblx0XHRcdFx0ZmlsbFBhdGhzID0gbmV3IE1hcCgpO1xuXHRcdFx0XHQobmV3IFNldChmaWxsQ29sb3JzKSkuZm9yRWFjaChjb2xvciA9PiB7XG5cdFx0XHRcdFx0aWYgKGNvbG9yICE9IG51bGwpXG5cdFx0XHRcdFx0XHRmaWxsUGF0aHMuc2V0KGNvbG9yLCBuZXcgUGF0aDJEKCkpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoc3Ryb2tlV2lkdGggPiAwKSB7XG5cdFx0XHRcdFx0c3Ryb2tlQ29sb3JzID0gZGlzcFN0cm9rZXMudmFsdWVzKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSk7XG5cdFx0XHRcdFx0c3Ryb2tlUGF0aHMgPSBuZXcgTWFwKCk7XG5cdFx0XHRcdFx0KG5ldyBTZXQoc3Ryb2tlQ29sb3JzKSkuZm9yRWFjaChjb2xvciA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoY29sb3IgIT0gbnVsbClcblx0XHRcdFx0XHRcdFx0c3Ryb2tlUGF0aHMuc2V0KGNvbG9yLCBuZXcgUGF0aDJEKCkpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGxldCB7IHgwLCBzaXplIH0gPSBkaXNwO1xuXG5cdFx0XHRpZiAoeDAgIT0gbnVsbCAmJiBzaXplICE9IG51bGwpIHtcblx0XHRcdFx0ZGF0YVggPSB4MC52YWx1ZXModSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxKTtcblxuXHRcdFx0XHRpZiAoeDAudW5pdCA9PSAyKVxuXHRcdFx0XHRcdGRhdGFYID0gZGF0YVgubWFwKHBjdCA9PiB1LnBvc1RvVmFsKHhPZmYgKyBwY3QgKiB4RGltLCBzY2FsZVgua2V5LCB0cnVlKSk7XG5cblx0XHRcdFx0Ly8gYXNzdW1lcyB1bmlmb3JtIHNpemVzLCBmb3Igbm93XG5cdFx0XHRcdGxldCBzaXplcyA9IHNpemUudmFsdWVzKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSk7XG5cblx0XHRcdFx0aWYgKHNpemUudW5pdCA9PSAyKVxuXHRcdFx0XHRcdGJhcldpZCA9IHNpemVzWzBdICogeERpbTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGJhcldpZCA9IHZhbFRvUG9zWChzaXplc1swXSwgc2NhbGVYLCB4RGltLCB4T2ZmKSAtIHZhbFRvUG9zWCgwLCBzY2FsZVgsIHhEaW0sIHhPZmYpOyAvLyBhc3N1bWVzIGxpbmVhciBzY2FsZSAoZGVsdGEgZnJvbSAwKVxuXG5cdFx0XHRcdGJhcldpZCA9IHB4Um91bmQoYmFyV2lkIC0gc3Ryb2tlV2lkdGgpO1xuXG5cdFx0XHRcdHhTaGlmdCA9IChfZGlyWCA9PSAxID8gLXN0cm9rZVdpZHRoIC8gMiA6IGJhcldpZCArIHN0cm9rZVdpZHRoIC8gMik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bGV0IGNvbFdpZCA9IHhEaW07XG5cblx0XHRcdFx0aWYgKGRhdGFYLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHQvLyBwcmlvciBpbmRleCB3aXRoIG5vbi11bmRlZmluZWQgeSBkYXRhXG5cdFx0XHRcdFx0bGV0IHByZXZJZHggPSBudWxsO1xuXG5cdFx0XHRcdFx0Ly8gc2NhbiBmdWxsIGRhdGFzZXQgZm9yIHNtYWxsZXN0IGFkamFjZW50IGRlbHRhXG5cdFx0XHRcdFx0Ly8gd2lsbCBub3Qgd29yayBwcm9wZXJseSBmb3Igbm9uLWxpbmVhciB4IHNjYWxlcywgc2luY2UgZG9lcyBub3QgZG8gZXhwZW5zaXZlIHZhbFRvUG9zWCBjYWxjcyB0aWxsIGVuZFxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBtaW5EZWx0YSA9IEluZmluaXR5OyBpIDwgZGF0YVgubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChkYXRhWVtpXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChwcmV2SWR4ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgZGVsdGEgPSBhYnMoZGF0YVhbaV0gLSBkYXRhWFtwcmV2SWR4XSk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoZGVsdGEgPCBtaW5EZWx0YSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bWluRGVsdGEgPSBkZWx0YTtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbFdpZCA9IGFicyh2YWxUb1Bvc1goZGF0YVhbaV0sIHNjYWxlWCwgeERpbSwgeE9mZikgLSB2YWxUb1Bvc1goZGF0YVhbcHJldklkeF0sIHNjYWxlWCwgeERpbSwgeE9mZikpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHByZXZJZHggPSBpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBnYXBXaWQgPSBjb2xXaWQgKiBnYXBGYWN0b3I7XG5cblx0XHRcdFx0YmFyV2lkID0gcHhSb3VuZChtaW4obWF4V2lkdGgsIG1heChtaW5XaWR0aCwgY29sV2lkIC0gZ2FwV2lkKSkgLSBzdHJva2VXaWR0aCAtIGV4dHJhR2FwKTtcblxuXHRcdFx0XHR4U2hpZnQgPSAoYWxpZ24gPT0gMCA/IGJhcldpZCAvIDIgOiBhbGlnbiA9PSBfZGlyWCA/IDAgOiBiYXJXaWQpIC0gYWxpZ24gKiBfZGlyWCAqIGV4dHJhR2FwIC8gMjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgX3BhdGhzID0ge3N0cm9rZTogbnVsbCwgZmlsbDogbnVsbCwgY2xpcDogbnVsbCwgYmFuZDogbnVsbCwgZ2FwczogbnVsbCwgZmxhZ3M6IEJBTkRfQ0xJUF9GSUxMIHwgQkFORF9DTElQX1NUUk9LRX07ICAvLyBkaXNwLCBnZW9tXG5cblx0XHRcdGxldCB5TGltaXQ7XG5cblx0XHRcdGlmIChiYW5kQ2xpcERpciAhPSAwKSB7XG5cdFx0XHRcdF9wYXRocy5iYW5kID0gbmV3IFBhdGgyRCgpO1xuXHRcdFx0XHR5TGltaXQgPSBweFJvdW5kKHZhbFRvUG9zWShiYW5kQ2xpcERpciA9PSAxID8gc2NhbGVZLm1heCA6IHNjYWxlWS5taW4sIHNjYWxlWSwgeURpbSwgeU9mZikpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzdHJva2UgPSBtdWx0aVBhdGggPyBudWxsIDogbmV3IFBhdGgyRCgpO1xuXHRcdFx0Y29uc3QgYmFuZCA9IF9wYXRocy5iYW5kO1xuXG5cdFx0XHRsZXQgeyB5MCwgeTEgfSA9IGRpc3A7XG5cblx0XHRcdGxldCBkYXRhWTAgPSBudWxsO1xuXG5cdFx0XHRpZiAoeTAgIT0gbnVsbCAmJiB5MSAhPSBudWxsKSB7XG5cdFx0XHRcdGRhdGFZID0geTEudmFsdWVzKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSk7XG5cdFx0XHRcdGRhdGFZMCA9IHkwLnZhbHVlcyh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBpID0gX2RpclggPT0gMSA/IGlkeDAgOiBpZHgxOyBpID49IGlkeDAgJiYgaSA8PSBpZHgxOyBpICs9IF9kaXJYKSB7XG5cdFx0XHRcdGxldCB5VmFsID0gZGF0YVlbaV07XG5cblx0XHRcdFx0Ly8gd2UgY2FuIHNraXAgYm90aCwgZHJhd2luZyBhbmQgYmFuZCBjbGlwcGluZyBmb3IgYWxpZ25tZW50IGFydGlmYWN0c1xuXHRcdFx0XHRpZiAoeVZhbCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHQvKlxuXHRcdFx0XHQvLyBpbnRlcnBvbGF0ZSB1cHdhcmRzIGJhbmQgY2xpcHNcblx0XHRcdFx0aWYgKHlWYWwgPT0gbnVsbCkge1xuXHRcdFx0XHQvL1x0aWYgKGhhc0JhbmRzKVxuXHRcdFx0XHQvL1x0XHR5VmFsID0gY29zdGx5TGVycChpLCBpZHgwLCBpZHgxLCBfZGlyWCwgZGF0YVkpO1xuXHRcdFx0XHQvL1x0ZWxzZVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdCovXG5cblx0XHRcdFx0bGV0IHhWYWwgPSBzY2FsZVguZGlzdHIgIT0gMiB8fCBkaXNwICE9IG51bGwgPyBkYXRhWFtpXSA6IGk7XG5cblx0XHRcdFx0Ly8gVE9ETzogYWxsIHhQb3MgY2FuIGJlIHByZS1jb21wdXRlZCBvbmNlIGZvciBhbGwgc2VyaWVzIGluIGFsaWduZWQgc2V0XG5cdFx0XHRcdGxldCB4UG9zID0gdmFsVG9Qb3NYKHhWYWwsIHNjYWxlWCwgeERpbSwgeE9mZik7XG5cdFx0XHRcdGxldCB5UG9zID0gdmFsVG9Qb3NZKGlmTnVsbCh5VmFsLCBmaWxsVG9ZKSwgc2NhbGVZLCB5RGltLCB5T2ZmKTtcblxuXHRcdFx0XHRpZiAoZGF0YVkwICE9IG51bGwgJiYgeVZhbCAhPSBudWxsKVxuXHRcdFx0XHRcdHkwUG9zID0gdmFsVG9Qb3NZKGRhdGFZMFtpXSwgc2NhbGVZLCB5RGltLCB5T2ZmKTtcblxuXHRcdFx0XHRsZXQgbGZ0ID0gcHhSb3VuZCh4UG9zIC0geFNoaWZ0KTtcblx0XHRcdFx0bGV0IGJ0bSA9IHB4Um91bmQobWF4KHlQb3MsIHkwUG9zKSk7XG5cdFx0XHRcdGxldCB0b3AgPSBweFJvdW5kKG1pbih5UG9zLCB5MFBvcykpO1xuXHRcdFx0XHQvLyB0aGlzIGluY2x1ZGVzIHRoZSBzdHJva2Vcblx0XHRcdFx0bGV0IGJhckhndCA9IGJ0bSAtIHRvcDtcblxuXHRcdFx0XHRsZXQgciA9IHJhZGl1cyAqIGJhcldpZDtcblxuXHRcdFx0XHRpZiAoeVZhbCAhPSBudWxsKSB7ICAvLyAmJiB5VmFsICE9IGZpbGxUb1kgKDAgaGVpZ2h0IGJhcilcblx0XHRcdFx0XHRpZiAobXVsdGlQYXRoKSB7XG5cdFx0XHRcdFx0XHRpZiAoc3Ryb2tlV2lkdGggPiAwICYmIHN0cm9rZUNvbG9yc1tpXSAhPSBudWxsKVxuXHRcdFx0XHRcdFx0XHRyZWN0KHN0cm9rZVBhdGhzLmdldChzdHJva2VDb2xvcnNbaV0pLCBsZnQsIHRvcCArIGZsb29yKHN0cm9rZVdpZHRoIC8gMiksIGJhcldpZCwgbWF4KDAsIGJhckhndCAtIHN0cm9rZVdpZHRoKSwgcik7XG5cblx0XHRcdFx0XHRcdGlmIChmaWxsQ29sb3JzW2ldICE9IG51bGwpXG5cdFx0XHRcdFx0XHRcdHJlY3QoZmlsbFBhdGhzLmdldChmaWxsQ29sb3JzW2ldKSwgbGZ0LCB0b3AgKyBmbG9vcihzdHJva2VXaWR0aCAvIDIpLCBiYXJXaWQsIG1heCgwLCBiYXJIZ3QgLSBzdHJva2VXaWR0aCksIHIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRyZWN0KHN0cm9rZSwgbGZ0LCB0b3AgKyBmbG9vcihzdHJva2VXaWR0aCAvIDIpLCBiYXJXaWQsIG1heCgwLCBiYXJIZ3QgLSBzdHJva2VXaWR0aCksIHIpO1xuXG5cdFx0XHRcdFx0ZWFjaCh1LCBzZXJpZXNJZHgsIGksXG5cdFx0XHRcdFx0XHRsZnQgICAgLSBzdHJva2VXaWR0aCAvIDIsXG5cdFx0XHRcdFx0XHR0b3AsXG5cdFx0XHRcdFx0XHRiYXJXaWQgKyBzdHJva2VXaWR0aCxcblx0XHRcdFx0XHRcdGJhckhndCxcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGJhbmRDbGlwRGlyICE9IDApIHtcblx0XHRcdFx0XHRpZiAoX2RpclkgKiBiYW5kQ2xpcERpciA9PSAxKSB7XG5cdFx0XHRcdFx0XHRidG0gPSB0b3A7XG5cdFx0XHRcdFx0XHR0b3AgPSB5TGltaXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0dG9wID0gYnRtO1xuXHRcdFx0XHRcdFx0YnRtID0geUxpbWl0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJhckhndCA9IGJ0bSAtIHRvcDtcblxuXHRcdFx0XHRcdHJlY3QoYmFuZCwgbGZ0IC0gc3Ryb2tlV2lkdGggLyAyLCB0b3AsIGJhcldpZCArIHN0cm9rZVdpZHRoLCBtYXgoMCwgYmFySGd0KSwgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHN0cm9rZVdpZHRoID4gMClcblx0XHRcdFx0X3BhdGhzLnN0cm9rZSA9IG11bHRpUGF0aCA/IHN0cm9rZVBhdGhzIDogc3Ryb2tlO1xuXG5cdFx0XHRfcGF0aHMuZmlsbCA9IG11bHRpUGF0aCA/IGZpbGxQYXRocyA6IHN0cm9rZTtcblxuXHRcdFx0cmV0dXJuIF9wYXRocztcblx0XHR9KTtcblx0fTtcbn1cblxuZnVuY3Rpb24gc3BsaW5lSW50ZXJwKGludGVycCwgb3B0cykge1xuXHRjb25zdCBhbGlnbkdhcHMgPSBpZk51bGwob3B0cz8uYWxpZ25HYXBzLCAwKTtcblxuXHRyZXR1cm4gKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSkgPT4ge1xuXHRcdHJldHVybiBvcmllbnQodSwgc2VyaWVzSWR4LCAoc2VyaWVzLCBkYXRhWCwgZGF0YVksIHNjYWxlWCwgc2NhbGVZLCB2YWxUb1Bvc1gsIHZhbFRvUG9zWSwgeE9mZiwgeU9mZiwgeERpbSwgeURpbSkgPT4ge1xuXHRcdFx0bGV0IHB4Um91bmQgPSBzZXJpZXMucHhSb3VuZDtcblxuXHRcdFx0bGV0IHBpeGVsRm9yWCA9IHZhbCA9PiBweFJvdW5kKHZhbFRvUG9zWCh2YWwsIHNjYWxlWCwgeERpbSwgeE9mZikpO1xuXHRcdFx0bGV0IHBpeGVsRm9yWSA9IHZhbCA9PiBweFJvdW5kKHZhbFRvUG9zWSh2YWwsIHNjYWxlWSwgeURpbSwgeU9mZikpO1xuXG5cdFx0XHRsZXQgbW92ZVRvLCBiZXppZXJDdXJ2ZVRvLCBsaW5lVG87XG5cblx0XHRcdGlmIChzY2FsZVgub3JpID09IDApIHtcblx0XHRcdFx0bW92ZVRvID0gbW92ZVRvSDtcblx0XHRcdFx0bGluZVRvID0gbGluZVRvSDtcblx0XHRcdFx0YmV6aWVyQ3VydmVUbyA9IGJlemllckN1cnZlVG9IO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG1vdmVUbyA9IG1vdmVUb1Y7XG5cdFx0XHRcdGxpbmVUbyA9IGxpbmVUb1Y7XG5cdFx0XHRcdGJlemllckN1cnZlVG8gPSBiZXppZXJDdXJ2ZVRvVjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZGlyID0gc2NhbGVYLmRpciAqIChzY2FsZVgub3JpID09IDAgPyAxIDogLTEpO1xuXG5cdFx0XHRpZHgwID0gbm9uTnVsbElkeChkYXRhWSwgaWR4MCwgaWR4MSwgIDEpO1xuXHRcdFx0aWR4MSA9IG5vbk51bGxJZHgoZGF0YVksIGlkeDAsIGlkeDEsIC0xKTtcblxuXHRcdFx0bGV0IGZpcnN0WFBvcyA9IHBpeGVsRm9yWChkYXRhWFtkaXIgPT0gMSA/IGlkeDAgOiBpZHgxXSk7XG5cdFx0XHRsZXQgcHJldlhQb3MgPSBmaXJzdFhQb3M7XG5cblx0XHRcdGxldCB4Q29vcmRzID0gW107XG5cdFx0XHRsZXQgeUNvb3JkcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gZGlyID09IDEgPyBpZHgwIDogaWR4MTsgaSA+PSBpZHgwICYmIGkgPD0gaWR4MTsgaSArPSBkaXIpIHtcblx0XHRcdFx0bGV0IHlWYWwgPSBkYXRhWVtpXTtcblxuXHRcdFx0XHRpZiAoeVZhbCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0bGV0IHhWYWwgPSBkYXRhWFtpXTtcblx0XHRcdFx0XHRsZXQgeFBvcyA9IHBpeGVsRm9yWCh4VmFsKTtcblxuXHRcdFx0XHRcdHhDb29yZHMucHVzaChwcmV2WFBvcyA9IHhQb3MpO1xuXHRcdFx0XHRcdHlDb29yZHMucHVzaChwaXhlbEZvclkoZGF0YVlbaV0pKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBfcGF0aHMgPSB7c3Ryb2tlOiBpbnRlcnAoeENvb3JkcywgeUNvb3JkcywgbW92ZVRvLCBsaW5lVG8sIGJlemllckN1cnZlVG8sIHB4Um91bmQpLCBmaWxsOiBudWxsLCBjbGlwOiBudWxsLCBiYW5kOiBudWxsLCBnYXBzOiBudWxsLCBmbGFnczogQkFORF9DTElQX0ZJTEx9O1xuXHRcdFx0Y29uc3Qgc3Ryb2tlID0gX3BhdGhzLnN0cm9rZTtcblxuXHRcdFx0bGV0IFsgYmFuZEZpbGxEaXIsIGJhbmRDbGlwRGlyIF0gPSBiYW5kRmlsbENsaXBEaXJzKHUsIHNlcmllc0lkeCk7XG5cblx0XHRcdGlmIChzZXJpZXMuZmlsbCAhPSBudWxsIHx8IGJhbmRGaWxsRGlyICE9IDApIHtcblx0XHRcdFx0bGV0IGZpbGwgPSBfcGF0aHMuZmlsbCA9IG5ldyBQYXRoMkQoc3Ryb2tlKTtcblxuXHRcdFx0XHRsZXQgZmlsbFRvID0gc2VyaWVzLmZpbGxUbyh1LCBzZXJpZXNJZHgsIHNlcmllcy5taW4sIHNlcmllcy5tYXgsIGJhbmRGaWxsRGlyKTtcblx0XHRcdFx0bGV0IGZpbGxUb1kgPSBwaXhlbEZvclkoZmlsbFRvKTtcblxuXHRcdFx0XHRsaW5lVG8oZmlsbCwgcHJldlhQb3MsIGZpbGxUb1kpO1xuXHRcdFx0XHRsaW5lVG8oZmlsbCwgZmlyc3RYUG9zLCBmaWxsVG9ZKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFzZXJpZXMuc3BhbkdhcHMpIHtcblx0XHRcdC8vXHRjb25zb2xlLnRpbWUoJ2dhcHMnKTtcblx0XHRcdFx0bGV0IGdhcHMgPSBbXTtcblxuXHRcdFx0XHRnYXBzLnB1c2goLi4uZmluZEdhcHMoZGF0YVgsIGRhdGFZLCBpZHgwLCBpZHgxLCBkaXIsIHBpeGVsRm9yWCwgYWxpZ25HYXBzKSk7XG5cblx0XHRcdC8vXHRjb25zb2xlLnRpbWVFbmQoJ2dhcHMnKTtcblxuXHRcdFx0Ly9cdGNvbnNvbGUubG9nKCdnYXBzJywgSlNPTi5zdHJpbmdpZnkoZ2FwcykpO1xuXG5cdFx0XHRcdF9wYXRocy5nYXBzID0gZ2FwcyA9IHNlcmllcy5nYXBzKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSwgZ2Fwcyk7XG5cblx0XHRcdFx0X3BhdGhzLmNsaXAgPSBjbGlwR2FwcyhnYXBzLCBzY2FsZVgub3JpLCB4T2ZmLCB5T2ZmLCB4RGltLCB5RGltKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJhbmRDbGlwRGlyICE9IDApIHtcblx0XHRcdFx0X3BhdGhzLmJhbmQgPSBiYW5kQ2xpcERpciA9PSAyID8gW1xuXHRcdFx0XHRcdGNsaXBCYW5kTGluZSh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEsIHN0cm9rZSwgLTEpLFxuXHRcdFx0XHRcdGNsaXBCYW5kTGluZSh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEsIHN0cm9rZSwgIDEpLFxuXHRcdFx0XHRdIDogY2xpcEJhbmRMaW5lKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSwgc3Ryb2tlLCBiYW5kQ2xpcERpcik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBfcGF0aHM7XG5cblx0XHRcdC8vICBpZiBGRUFUX1BBVEhTOiBmYWxzZSBpbiByb2xsdXAuY29uZmlnLmpzXG5cdFx0XHQvL1x0dS5jdHguc2F2ZSgpO1xuXHRcdFx0Ly9cdHUuY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Ly9cdHUuY3R4LnJlY3QodS5iYm94LmxlZnQsIHUuYmJveC50b3AsIHUuYmJveC53aWR0aCwgdS5iYm94LmhlaWdodCk7XG5cdFx0XHQvL1x0dS5jdHguY2xpcCgpO1xuXHRcdFx0Ly9cdHUuY3R4LnN0cm9rZVN0eWxlID0gdS5zZXJpZXNbc2lkeF0uc3Ryb2tlO1xuXHRcdFx0Ly9cdHUuY3R4LnN0cm9rZShzdHJva2UpO1xuXHRcdFx0Ly9cdHUuY3R4LmZpbGxTdHlsZSA9IHUuc2VyaWVzW3NpZHhdLmZpbGw7XG5cdFx0XHQvL1x0dS5jdHguZmlsbChmaWxsKTtcblx0XHRcdC8vXHR1LmN0eC5yZXN0b3JlKCk7XG5cdFx0XHQvL1x0cmV0dXJuIG51bGw7XG5cdFx0fSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIG1vbm90b25lQ3ViaWMob3B0cykge1xuXHRyZXR1cm4gc3BsaW5lSW50ZXJwKF9tb25vdG9uZUN1YmljLCBvcHRzKTtcbn1cblxuLy8gTW9ub3RvbmUgQ3ViaWMgU3BsaW5lIGludGVycG9sYXRpb24sIGFkYXB0ZWQgZnJvbSB0aGUgQ2hhcnRpc3QuanMgaW1wbGVtZW50YXRpb246XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ2lvbmt1bnovY2hhcnRpc3QtanMvYmxvYi9lN2U3ODIwMWJmZmU5NjA5OTE1ZTVlNTNjZmFmYTI5YTVkNmM0OWY5L3NyYy9zY3JpcHRzL2ludGVycG9sYXRpb24uanMjTDI0MC1MMzY5XG5mdW5jdGlvbiBfbW9ub3RvbmVDdWJpYyh4cywgeXMsIG1vdmVUbywgbGluZVRvLCBiZXppZXJDdXJ2ZVRvLCBweFJvdW5kKSB7XG5cdGNvbnN0IG4gPSB4cy5sZW5ndGg7XG5cblx0aWYgKG4gPCAyKVxuXHRcdHJldHVybiBudWxsO1xuXG5cdGNvbnN0IHBhdGggPSBuZXcgUGF0aDJEKCk7XG5cblx0bW92ZVRvKHBhdGgsIHhzWzBdLCB5c1swXSk7XG5cblx0aWYgKG4gPT0gMilcblx0XHRsaW5lVG8ocGF0aCwgeHNbMV0sIHlzWzFdKTtcblx0ZWxzZSB7XG5cdFx0bGV0IG1zICA9IEFycmF5KG4pLFxuXHRcdFx0ZHMgID0gQXJyYXkobiAtIDEpLFxuXHRcdFx0ZHlzID0gQXJyYXkobiAtIDEpLFxuXHRcdFx0ZHhzID0gQXJyYXkobiAtIDEpO1xuXG5cdFx0Ly8gY2FsYyBkZWx0YXMgYW5kIGRlcml2YXRpdmVcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcblx0XHRcdGR5c1tpXSA9IHlzW2kgKyAxXSAtIHlzW2ldO1xuXHRcdFx0ZHhzW2ldID0geHNbaSArIDFdIC0geHNbaV07XG5cdFx0XHRkc1tpXSAgPSBkeXNbaV0gLyBkeHNbaV07XG5cdFx0fVxuXG5cdFx0Ly8gZGV0ZXJtaW5lIGRlc2lyZWQgc2xvcGUgKG0pIGF0IGVhY2ggcG9pbnQgdXNpbmcgRnJpdHNjaC1DYXJsc29uIG1ldGhvZFxuXHRcdC8vIGh0dHA6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy80NTIxOC9pbXBsZW1lbnRhdGlvbi1vZi1tb25vdG9uZS1jdWJpYy1pbnRlcnBvbGF0aW9uXG5cdFx0bXNbMF0gPSBkc1swXTtcblxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgbiAtIDE7IGkrKykge1xuXHRcdFx0aWYgKGRzW2ldID09PSAwIHx8IGRzW2kgLSAxXSA9PT0gMCB8fCAoZHNbaSAtIDFdID4gMCkgIT09IChkc1tpXSA+IDApKVxuXHRcdFx0XHRtc1tpXSA9IDA7XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bXNbaV0gPSAzICogKGR4c1tpIC0gMV0gKyBkeHNbaV0pIC8gKFxuXHRcdFx0XHRcdCgyICogZHhzW2ldICsgZHhzW2kgLSAxXSkgLyBkc1tpIC0gMV0gK1xuXHRcdFx0XHRcdChkeHNbaV0gKyAyICogZHhzW2kgLSAxXSkgLyBkc1tpXVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICghaXNGaW5pdGUobXNbaV0pKVxuXHRcdFx0XHRcdG1zW2ldID0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtc1tuIC0gMV0gPSBkc1tuIC0gMl07XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcblx0XHRcdGJlemllckN1cnZlVG8oXG5cdFx0XHRcdHBhdGgsXG5cdFx0XHRcdHhzW2ldICsgZHhzW2ldIC8gMyxcblx0XHRcdFx0eXNbaV0gKyBtc1tpXSAqIGR4c1tpXSAvIDMsXG5cdFx0XHRcdHhzW2kgKyAxXSAtIGR4c1tpXSAvIDMsXG5cdFx0XHRcdHlzW2kgKyAxXSAtIG1zW2kgKyAxXSAqIGR4c1tpXSAvIDMsXG5cdFx0XHRcdHhzW2kgKyAxXSxcblx0XHRcdFx0eXNbaSArIDFdLFxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcGF0aDtcbn1cblxuY29uc3QgY3Vyc29yUGxvdHMgPSBuZXcgU2V0KCk7XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVSZWN0cygpIHtcblx0Y3Vyc29yUGxvdHMuZm9yRWFjaCh1ID0+IHtcblx0XHR1LnN5bmNSZWN0KHRydWUpO1xuXHR9KTtcbn1cblxuaWYgKGRvbUVudikge1xuXHRvbihyZXNpemUsIHdpbiwgaW52YWxpZGF0ZVJlY3RzKTtcblx0b24oc2Nyb2xsLCB3aW4sIGludmFsaWRhdGVSZWN0cywgdHJ1ZSk7XG5cdG9uKGRwcHhjaGFuZ2UsIHdpbiwgKCkgPT4geyB1UGxvdC5weFJhdGlvID0gcHhSYXRpbzsgfSk7XG59XG5cbmNvbnN0IGxpbmVhclBhdGggPSBsaW5lYXIoKSA7XG5jb25zdCBwb2ludHNQYXRoID0gcG9pbnRzKCkgO1xuXG5mdW5jdGlvbiBzZXREZWZhdWx0cyhkLCB4bywgeW8sIGluaXRZKSB7XG5cdGxldCBkMiA9IGluaXRZID8gW2RbMF0sIGRbMV1dLmNvbmNhdChkLnNsaWNlKDIpKSA6IFtkWzBdXS5jb25jYXQoZC5zbGljZSgxKSk7XG5cdHJldHVybiBkMi5tYXAoKG8sIGkpID0+IHNldERlZmF1bHQobywgaSwgeG8sIHlvKSk7XG59XG5cbmZ1bmN0aW9uIHNldERlZmF1bHRzMihkLCB4eW8pIHtcblx0cmV0dXJuIGQubWFwKChvLCBpKSA9PiBpID09IDAgPyBudWxsIDogYXNzaWduKHt9LCB4eW8sIG8pKTsgIC8vIHRvZG86IGFzc2lnbigpIHdpbGwgbm90IG1lcmdlIGZhY2V0IGFycmF5c1xufVxuXG5mdW5jdGlvbiBzZXREZWZhdWx0KG8sIGksIHhvLCB5bykge1xuXHRyZXR1cm4gYXNzaWduKHt9LCAoaSA9PSAwID8geG8gOiB5byksIG8pO1xufVxuXG5mdW5jdGlvbiBzbmFwTnVtWChzZWxmLCBkYXRhTWluLCBkYXRhTWF4KSB7XG5cdHJldHVybiBkYXRhTWluID09IG51bGwgPyBudWxsTnVsbFR1cGxlIDogW2RhdGFNaW4sIGRhdGFNYXhdO1xufVxuXG5jb25zdCBzbmFwVGltZVggPSBzbmFwTnVtWDtcblxuLy8gdGhpcyBlbnN1cmVzIHRoYXQgbm9uLXRlbXBvcmFsL251bWVyaWMgeS1heGVzIGdldCBtdWx0aXBsZS1zbmFwcGVkIHBhZGRpbmcgYWRkZWQgYWJvdmUvYmVsb3dcbi8vIFRPRE86IGFsc28gYWNjb3VudCBmb3IgaW5jcnMgd2hlbiBzbmFwcGluZyB0byBlbnN1cmUgdG9wIG9mIGF4aXMgZ2V0cyBhIHRpY2sgJiB2YWx1ZVxuZnVuY3Rpb24gc25hcE51bVkoc2VsZiwgZGF0YU1pbiwgZGF0YU1heCkge1xuXHRyZXR1cm4gZGF0YU1pbiA9PSBudWxsID8gbnVsbE51bGxUdXBsZSA6IHJhbmdlTnVtKGRhdGFNaW4sIGRhdGFNYXgsIHJhbmdlUGFkLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gc25hcExvZ1koc2VsZiwgZGF0YU1pbiwgZGF0YU1heCwgc2NhbGUpIHtcblx0cmV0dXJuIGRhdGFNaW4gPT0gbnVsbCA/IG51bGxOdWxsVHVwbGUgOiByYW5nZUxvZyhkYXRhTWluLCBkYXRhTWF4LCBzZWxmLnNjYWxlc1tzY2FsZV0ubG9nLCBmYWxzZSk7XG59XG5cbmNvbnN0IHNuYXBMb2dYID0gc25hcExvZ1k7XG5cbmZ1bmN0aW9uIHNuYXBBc2luaFkoc2VsZiwgZGF0YU1pbiwgZGF0YU1heCwgc2NhbGUpIHtcblx0cmV0dXJuIGRhdGFNaW4gPT0gbnVsbCA/IG51bGxOdWxsVHVwbGUgOiByYW5nZUFzaW5oKGRhdGFNaW4sIGRhdGFNYXgsIHNlbGYuc2NhbGVzW3NjYWxlXS5sb2csIGZhbHNlKTtcbn1cblxuY29uc3Qgc25hcEFzaW5oWCA9IHNuYXBBc2luaFk7XG5cbi8vIGRpbSBpcyBsb2dpY2FsIChnZXRDbGllbnRCb3VuZGluZ1JlY3QpIHBpeGVscywgbm90IGNhbnZhcyBwaXhlbHNcbmZ1bmN0aW9uIGZpbmRJbmNyKG1pblZhbCwgbWF4VmFsLCBpbmNycywgZGltLCBtaW5TcGFjZSkge1xuXHRsZXQgaW50RGlnaXRzID0gbWF4KG51bUludERpZ2l0cyhtaW5WYWwpLCBudW1JbnREaWdpdHMobWF4VmFsKSk7XG5cblx0bGV0IGRlbHRhID0gbWF4VmFsIC0gbWluVmFsO1xuXG5cdGxldCBpbmNySWR4ID0gY2xvc2VzdElkeCgobWluU3BhY2UgLyBkaW0pICogZGVsdGEsIGluY3JzKTtcblxuXHRkbyB7XG5cdFx0bGV0IGZvdW5kSW5jciA9IGluY3JzW2luY3JJZHhdO1xuXHRcdGxldCBmb3VuZFNwYWNlID0gZGltICogZm91bmRJbmNyIC8gZGVsdGE7XG5cblx0XHRpZiAoZm91bmRTcGFjZSA+PSBtaW5TcGFjZSAmJiBpbnREaWdpdHMgKyAoZm91bmRJbmNyIDwgNSA/IGZpeGVkRGVjLmdldChmb3VuZEluY3IpIDogMCkgPD0gMTcpXG5cdFx0XHRyZXR1cm4gW2ZvdW5kSW5jciwgZm91bmRTcGFjZV07XG5cdH0gd2hpbGUgKCsraW5jcklkeCA8IGluY3JzLmxlbmd0aCk7XG5cblx0cmV0dXJuIFswLCAwXTtcbn1cblxuZnVuY3Rpb24gcHhSYXRpb0ZvbnQoZm9udCkge1xuXHRsZXQgZm9udFNpemUsIGZvbnRTaXplQ3NzO1xuXHRmb250ID0gZm9udC5yZXBsYWNlKC8oXFxkKylweC8sIChtLCBwMSkgPT4gKGZvbnRTaXplID0gcm91bmQoKGZvbnRTaXplQ3NzID0gK3AxKSAqIHB4UmF0aW8pKSArICdweCcpO1xuXHRyZXR1cm4gW2ZvbnQsIGZvbnRTaXplLCBmb250U2l6ZUNzc107XG59XG5cbmZ1bmN0aW9uIHN5bmNGb250U2l6ZShheGlzKSB7XG5cdGlmIChheGlzLnNob3cpIHtcblx0XHRbYXhpcy5mb250LCBheGlzLmxhYmVsRm9udF0uZm9yRWFjaChmID0+IHtcblx0XHRcdGxldCBzaXplID0gcm91bmREZWMoZlsyXSAqIHB4UmF0aW8sIDEpO1xuXHRcdFx0ZlswXSA9IGZbMF0ucmVwbGFjZSgvWzAtOS5dK3B4Lywgc2l6ZSArICdweCcpO1xuXHRcdFx0ZlsxXSA9IHNpemU7XG5cdFx0fSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdVBsb3Qob3B0cywgZGF0YSwgdGhlbikge1xuXHRjb25zdCBzZWxmID0ge1xuXHRcdG1vZGU6IGlmTnVsbChvcHRzLm1vZGUsIDEpLFxuXHR9O1xuXG5cdGNvbnN0IG1vZGUgPSBzZWxmLm1vZGU7XG5cblx0Ly8gVE9ETzogY2FjaGUgZGVub21zICYgbWlucyBzY2FsZS5jYWNoZSA9IHtyLCBtaW4sIH1cblx0ZnVuY3Rpb24gZ2V0VmFsUGN0KHZhbCwgc2NhbGUpIHtcblx0XHRsZXQgX3ZhbCA9IChcblx0XHRcdHNjYWxlLmRpc3RyID09IDMgPyBsb2cxMCh2YWwgPiAwID8gdmFsIDogc2NhbGUuY2xhbXAoc2VsZiwgdmFsLCBzY2FsZS5taW4sIHNjYWxlLm1heCwgc2NhbGUua2V5KSkgOlxuXHRcdFx0c2NhbGUuZGlzdHIgPT0gNCA/IGFzaW5oKHZhbCwgc2NhbGUuYXNpbmgpIDpcblx0XHRcdHZhbFxuXHRcdCk7XG5cblx0XHRyZXR1cm4gKF92YWwgLSBzY2FsZS5fbWluKSAvIChzY2FsZS5fbWF4IC0gc2NhbGUuX21pbik7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRIUG9zKHZhbCwgc2NhbGUsIGRpbSwgb2ZmKSB7XG5cdFx0bGV0IHBjdCA9IGdldFZhbFBjdCh2YWwsIHNjYWxlKTtcblx0XHRyZXR1cm4gb2ZmICsgZGltICogKHNjYWxlLmRpciA9PSAtMSA/ICgxIC0gcGN0KSA6IHBjdCk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRWUG9zKHZhbCwgc2NhbGUsIGRpbSwgb2ZmKSB7XG5cdFx0bGV0IHBjdCA9IGdldFZhbFBjdCh2YWwsIHNjYWxlKTtcblx0XHRyZXR1cm4gb2ZmICsgZGltICogKHNjYWxlLmRpciA9PSAtMSA/IHBjdCA6ICgxIC0gcGN0KSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRQb3ModmFsLCBzY2FsZSwgZGltLCBvZmYpIHtcblx0XHRyZXR1cm4gc2NhbGUub3JpID09IDAgPyBnZXRIUG9zKHZhbCwgc2NhbGUsIGRpbSwgb2ZmKSA6IGdldFZQb3ModmFsLCBzY2FsZSwgZGltLCBvZmYpO1xuXHR9XG5cblx0c2VsZi52YWxUb1Bvc0ggPSBnZXRIUG9zO1xuXHRzZWxmLnZhbFRvUG9zViA9IGdldFZQb3M7XG5cblx0bGV0IHJlYWR5ID0gZmFsc2U7XG5cdHNlbGYuc3RhdHVzID0gMDtcblxuXHRjb25zdCByb290ID0gc2VsZi5yb290ID0gcGxhY2VEaXYoVVBMT1QpO1xuXG5cdGlmIChvcHRzLmlkICE9IG51bGwpXG5cdFx0cm9vdC5pZCA9IG9wdHMuaWQ7XG5cblx0YWRkQ2xhc3Mocm9vdCwgb3B0cy5jbGFzcyk7XG5cblx0aWYgKG9wdHMudGl0bGUpIHtcblx0XHRsZXQgdGl0bGUgPSBwbGFjZURpdihUSVRMRSwgcm9vdCk7XG5cdFx0dGl0bGUudGV4dENvbnRlbnQgPSBvcHRzLnRpdGxlO1xuXHR9XG5cblx0Y29uc3QgY2FuID0gcGxhY2VUYWcoXCJjYW52YXNcIik7XG5cdGNvbnN0IGN0eCA9IHNlbGYuY3R4ID0gY2FuLmdldENvbnRleHQoXCIyZFwiKTtcblxuXHRjb25zdCB3cmFwID0gcGxhY2VEaXYoV1JBUCwgcm9vdCk7XG5cdGNvbnN0IHVuZGVyID0gc2VsZi51bmRlciA9IHBsYWNlRGl2KFVOREVSLCB3cmFwKTtcblx0d3JhcC5hcHBlbmRDaGlsZChjYW4pO1xuXHRjb25zdCBvdmVyID0gc2VsZi5vdmVyID0gcGxhY2VEaXYoT1ZFUiwgd3JhcCk7XG5cblx0b3B0cyA9IGNvcHkob3B0cyk7XG5cblx0Y29uc3QgcHhBbGlnbiA9ICtpZk51bGwob3B0cy5weEFsaWduLCAxKTtcblxuXHRjb25zdCBweFJvdW5kID0gcHhSb3VuZEdlbihweEFsaWduKTtcblxuXHQob3B0cy5wbHVnaW5zIHx8IFtdKS5mb3JFYWNoKHAgPT4ge1xuXHRcdGlmIChwLm9wdHMpXG5cdFx0XHRvcHRzID0gcC5vcHRzKHNlbGYsIG9wdHMpIHx8IG9wdHM7XG5cdH0pO1xuXG5cdGNvbnN0IG1zID0gb3B0cy5tcyB8fCAxZS0zO1xuXG5cdGNvbnN0IHNlcmllcyAgPSBzZWxmLnNlcmllcyA9IG1vZGUgPT0gMSA/XG5cdFx0c2V0RGVmYXVsdHMob3B0cy5zZXJpZXMgfHwgW10sIHhTZXJpZXNPcHRzLCB5U2VyaWVzT3B0cywgZmFsc2UpIDpcblx0XHRzZXREZWZhdWx0czIob3B0cy5zZXJpZXMgfHwgW251bGxdLCB4eVNlcmllc09wdHMpO1xuXHRjb25zdCBheGVzICAgID0gc2VsZi5heGVzICAgPSBzZXREZWZhdWx0cyhvcHRzLmF4ZXMgICB8fCBbXSwgeEF4aXNPcHRzLCAgIHlBeGlzT3B0cywgICAgdHJ1ZSk7XG5cdGNvbnN0IHNjYWxlcyAgPSBzZWxmLnNjYWxlcyA9IHt9O1xuXHRjb25zdCBiYW5kcyAgID0gc2VsZi5iYW5kcyAgPSBvcHRzLmJhbmRzIHx8IFtdO1xuXG5cdGJhbmRzLmZvckVhY2goYiA9PiB7XG5cdFx0Yi5maWxsID0gZm5PclNlbGYoYi5maWxsIHx8IG51bGwpO1xuXHRcdGIuZGlyID0gaWZOdWxsKGIuZGlyLCAtMSk7XG5cdH0pO1xuXG5cdGNvbnN0IHhTY2FsZUtleSA9IG1vZGUgPT0gMiA/IHNlcmllc1sxXS5mYWNldHNbMF0uc2NhbGUgOiBzZXJpZXNbMF0uc2NhbGU7XG5cblx0Y29uc3QgZHJhd09yZGVyTWFwID0ge1xuXHRcdGF4ZXM6IGRyYXdBeGVzR3JpZCxcblx0XHRzZXJpZXM6IGRyYXdTZXJpZXMsXG5cdH07XG5cblx0Y29uc3QgZHJhd09yZGVyID0gKG9wdHMuZHJhd09yZGVyIHx8IFtcImF4ZXNcIiwgXCJzZXJpZXNcIl0pLm1hcChrZXkgPT4gZHJhd09yZGVyTWFwW2tleV0pO1xuXG5cdGZ1bmN0aW9uIGluaXRTY2FsZShzY2FsZUtleSkge1xuXHRcdGxldCBzYyA9IHNjYWxlc1tzY2FsZUtleV07XG5cblx0XHRpZiAoc2MgPT0gbnVsbCkge1xuXHRcdFx0bGV0IHNjYWxlT3B0cyA9IChvcHRzLnNjYWxlcyB8fCBFTVBUWV9PQkopW3NjYWxlS2V5XSB8fCBFTVBUWV9PQko7XG5cblx0XHRcdGlmIChzY2FsZU9wdHMuZnJvbSAhPSBudWxsKSB7XG5cdFx0XHRcdC8vIGVuc3VyZSBwYXJlbnQgaXMgaW5pdGlhbGl6ZWRcblx0XHRcdFx0aW5pdFNjYWxlKHNjYWxlT3B0cy5mcm9tKTtcblx0XHRcdFx0Ly8gZGVwZW5kZW50IHNjYWxlcyBpbmhlcml0XG5cdFx0XHRcdHNjYWxlc1tzY2FsZUtleV0gPSBhc3NpZ24oe30sIHNjYWxlc1tzY2FsZU9wdHMuZnJvbV0sIHNjYWxlT3B0cywge2tleTogc2NhbGVLZXl9KTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzYyA9IHNjYWxlc1tzY2FsZUtleV0gPSBhc3NpZ24oe30sIChzY2FsZUtleSA9PSB4U2NhbGVLZXkgPyB4U2NhbGVPcHRzIDogeVNjYWxlT3B0cyksIHNjYWxlT3B0cyk7XG5cblx0XHRcdFx0c2Mua2V5ID0gc2NhbGVLZXk7XG5cblx0XHRcdFx0bGV0IGlzVGltZSA9IHNjLnRpbWU7XG5cblx0XHRcdFx0bGV0IHJuID0gc2MucmFuZ2U7XG5cblx0XHRcdFx0bGV0IHJhbmdlSXNBcnIgPSBpc0Fycihybik7XG5cblx0XHRcdFx0aWYgKHNjYWxlS2V5ICE9IHhTY2FsZUtleSB8fCAobW9kZSA9PSAyICYmICFpc1RpbWUpKSB7XG5cdFx0XHRcdFx0Ly8gaWYgcmFuZ2UgYXJyYXkgaGFzIG51bGwgbGltaXRzLCBpdCBzaG91bGQgYmUgYXV0b1xuXHRcdFx0XHRcdGlmIChyYW5nZUlzQXJyICYmIChyblswXSA9PSBudWxsIHx8IHJuWzFdID09IG51bGwpKSB7XG5cdFx0XHRcdFx0XHRybiA9IHtcblx0XHRcdFx0XHRcdFx0bWluOiByblswXSA9PSBudWxsID8gYXV0b1JhbmdlUGFydCA6IHtcblx0XHRcdFx0XHRcdFx0XHRtb2RlOiAxLFxuXHRcdFx0XHRcdFx0XHRcdGhhcmQ6IHJuWzBdLFxuXHRcdFx0XHRcdFx0XHRcdHNvZnQ6IHJuWzBdLFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRtYXg6IHJuWzFdID09IG51bGwgPyBhdXRvUmFuZ2VQYXJ0IDoge1xuXHRcdFx0XHRcdFx0XHRcdG1vZGU6IDEsXG5cdFx0XHRcdFx0XHRcdFx0aGFyZDogcm5bMV0sXG5cdFx0XHRcdFx0XHRcdFx0c29mdDogcm5bMV0sXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmFuZ2VJc0FyciA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICghcmFuZ2VJc0FyciAmJiBpc09iaihybikpIHtcblx0XHRcdFx0XHRcdGxldCBjZmcgPSBybjtcblx0XHRcdFx0XHRcdC8vIHRoaXMgaXMgc2ltaWxhciB0byBzbmFwTnVtWVxuXHRcdFx0XHRcdFx0cm4gPSAoc2VsZiwgZGF0YU1pbiwgZGF0YU1heCkgPT4gZGF0YU1pbiA9PSBudWxsID8gbnVsbE51bGxUdXBsZSA6IHJhbmdlTnVtKGRhdGFNaW4sIGRhdGFNYXgsIGNmZyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2MucmFuZ2UgPSBmbk9yU2VsZihybiB8fCAoaXNUaW1lID8gc25hcFRpbWVYIDogc2NhbGVLZXkgPT0geFNjYWxlS2V5ID9cblx0XHRcdFx0XHQoc2MuZGlzdHIgPT0gMyA/IHNuYXBMb2dYIDogc2MuZGlzdHIgPT0gNCA/IHNuYXBBc2luaFggOiBzbmFwTnVtWCkgOlxuXHRcdFx0XHRcdChzYy5kaXN0ciA9PSAzID8gc25hcExvZ1kgOiBzYy5kaXN0ciA9PSA0ID8gc25hcEFzaW5oWSA6IHNuYXBOdW1ZKVxuXHRcdFx0XHQpKTtcblxuXHRcdFx0XHRzYy5hdXRvID0gZm5PclNlbGYocmFuZ2VJc0FyciA/IGZhbHNlIDogc2MuYXV0byk7XG5cblx0XHRcdFx0c2MuY2xhbXAgPSBmbk9yU2VsZihzYy5jbGFtcCB8fCBjbGFtcFNjYWxlKTtcblxuXHRcdFx0XHQvLyBjYWNoZXMgZm9yIGV4cGVuc2l2ZSBvcHMgbGlrZSBhc2luaCgpICYgbG9nKClcblx0XHRcdFx0c2MuX21pbiA9IHNjLl9tYXggPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGluaXRTY2FsZShcInhcIik7XG5cdGluaXRTY2FsZShcInlcIik7XG5cblx0Ly8gVE9ETzogaW5pdCBzY2FsZXMgZnJvbSBmYWNldHMgaW4gbW9kZTogMlxuXHRpZiAobW9kZSA9PSAxKSB7XG5cdFx0c2VyaWVzLmZvckVhY2gocyA9PiB7XG5cdFx0XHRpbml0U2NhbGUocy5zY2FsZSk7XG5cdFx0fSk7XG5cdH1cblxuXHRheGVzLmZvckVhY2goYSA9PiB7XG5cdFx0aW5pdFNjYWxlKGEuc2NhbGUpO1xuXHR9KTtcblxuXHRmb3IgKGxldCBrIGluIG9wdHMuc2NhbGVzKVxuXHRcdGluaXRTY2FsZShrKTtcblxuXHRjb25zdCBzY2FsZVggPSBzY2FsZXNbeFNjYWxlS2V5XTtcblxuXHRjb25zdCB4U2NhbGVEaXN0ciA9IHNjYWxlWC5kaXN0cjtcblxuXHRsZXQgdmFsVG9Qb3NYLCB2YWxUb1Bvc1k7XG5cblx0aWYgKHNjYWxlWC5vcmkgPT0gMCkge1xuXHRcdGFkZENsYXNzKHJvb3QsIE9SSV9IWik7XG5cdFx0dmFsVG9Qb3NYID0gZ2V0SFBvcztcblx0XHR2YWxUb1Bvc1kgPSBnZXRWUG9zO1xuXHRcdC8qXG5cdFx0dXBkT3JpRGltcyA9ICgpID0+IHtcblx0XHRcdHhEaW1DYW4gPSBwbG90V2lkO1xuXHRcdFx0eE9mZkNhbiA9IHBsb3RMZnQ7XG5cdFx0XHR5RGltQ2FuID0gcGxvdEhndDtcblx0XHRcdHlPZmZDYW4gPSBwbG90VG9wO1xuXG5cdFx0XHR4RGltQ3NzID0gcGxvdFdpZENzcztcblx0XHRcdHhPZmZDc3MgPSBwbG90TGZ0Q3NzO1xuXHRcdFx0eURpbUNzcyA9IHBsb3RIZ3RDc3M7XG5cdFx0XHR5T2ZmQ3NzID0gcGxvdFRvcENzcztcblx0XHR9O1xuXHRcdCovXG5cdH1cblx0ZWxzZSB7XG5cdFx0YWRkQ2xhc3Mocm9vdCwgT1JJX1ZUKTtcblx0XHR2YWxUb1Bvc1ggPSBnZXRWUG9zO1xuXHRcdHZhbFRvUG9zWSA9IGdldEhQb3M7XG5cdFx0Lypcblx0XHR1cGRPcmlEaW1zID0gKCkgPT4ge1xuXHRcdFx0eERpbUNhbiA9IHBsb3RIZ3Q7XG5cdFx0XHR4T2ZmQ2FuID0gcGxvdFRvcDtcblx0XHRcdHlEaW1DYW4gPSBwbG90V2lkO1xuXHRcdFx0eU9mZkNhbiA9IHBsb3RMZnQ7XG5cblx0XHRcdHhEaW1Dc3MgPSBwbG90SGd0Q3NzO1xuXHRcdFx0eE9mZkNzcyA9IHBsb3RUb3BDc3M7XG5cdFx0XHR5RGltQ3NzID0gcGxvdFdpZENzcztcblx0XHRcdHlPZmZDc3MgPSBwbG90TGZ0Q3NzO1xuXHRcdH07XG5cdFx0Ki9cblx0fVxuXG5cdGNvbnN0IHBlbmRTY2FsZXMgPSB7fTtcblxuXHQvLyBleHBsaWNpdGx5LXNldCBpbml0aWFsIHNjYWxlc1xuXHRmb3IgKGxldCBrIGluIHNjYWxlcykge1xuXHRcdGxldCBzYyA9IHNjYWxlc1trXTtcblxuXHRcdGlmIChzYy5taW4gIT0gbnVsbCB8fCBzYy5tYXggIT0gbnVsbCkge1xuXHRcdFx0cGVuZFNjYWxlc1trXSA9IHttaW46IHNjLm1pbiwgbWF4OiBzYy5tYXh9O1xuXHRcdFx0c2MubWluID0gc2MubWF4ID0gbnVsbDtcblx0XHR9XG5cdH1cblxuLy9cdHNlbGYudHogPSBvcHRzLnR6IHx8IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZTtcblx0Y29uc3QgX3R6RGF0ZSAgPSAob3B0cy50ekRhdGUgfHwgKHRzID0+IG5ldyBEYXRlKHJvdW5kKHRzIC8gbXMpKSkpO1xuXHRjb25zdCBfZm10RGF0ZSA9IChvcHRzLmZtdERhdGUgfHwgZm10RGF0ZSk7XG5cblx0Y29uc3QgX3RpbWVBeGlzU3BsaXRzID0gKG1zID09IDEgPyB0aW1lQXhpc1NwbGl0c01zKF90ekRhdGUpIDogdGltZUF4aXNTcGxpdHNTKF90ekRhdGUpKTtcblx0Y29uc3QgX3RpbWVBeGlzVmFscyAgID0gdGltZUF4aXNWYWxzKF90ekRhdGUsIHRpbWVBeGlzU3RhbXBzKChtcyA9PSAxID8gX3RpbWVBeGlzU3RhbXBzTXMgOiBfdGltZUF4aXNTdGFtcHNTKSwgX2ZtdERhdGUpKTtcblx0Y29uc3QgX3RpbWVTZXJpZXNWYWwgID0gdGltZVNlcmllc1ZhbChfdHpEYXRlLCB0aW1lU2VyaWVzU3RhbXAoX3RpbWVTZXJpZXNTdGFtcCwgX2ZtdERhdGUpKTtcblxuXHRjb25zdCBhY3RpdmVJZHhzID0gW107XG5cblx0Y29uc3QgbGVnZW5kICAgICA9IChzZWxmLmxlZ2VuZCA9IGFzc2lnbih7fSwgbGVnZW5kT3B0cywgb3B0cy5sZWdlbmQpKTtcblx0Y29uc3Qgc2hvd0xlZ2VuZCA9IGxlZ2VuZC5zaG93O1xuXHRjb25zdCBtYXJrZXJzICAgID0gbGVnZW5kLm1hcmtlcnM7XG5cblx0e1xuXHRcdGxlZ2VuZC5pZHhzID0gYWN0aXZlSWR4cztcblxuXHRcdG1hcmtlcnMud2lkdGggID0gZm5PclNlbGYobWFya2Vycy53aWR0aCk7XG5cdFx0bWFya2Vycy5kYXNoICAgPSBmbk9yU2VsZihtYXJrZXJzLmRhc2gpO1xuXHRcdG1hcmtlcnMuc3Ryb2tlID0gZm5PclNlbGYobWFya2Vycy5zdHJva2UpO1xuXHRcdG1hcmtlcnMuZmlsbCAgID0gZm5PclNlbGYobWFya2Vycy5maWxsKTtcblx0fVxuXG5cdGxldCBsZWdlbmRFbDtcblx0bGV0IGxlZ2VuZFJvd3MgPSBbXTtcblx0bGV0IGxlZ2VuZENlbGxzID0gW107XG5cdGxldCBsZWdlbmRDb2xzO1xuXHRsZXQgbXVsdGlWYWxMZWdlbmQgPSBmYWxzZTtcblx0bGV0IE5VTExfTEVHRU5EX1ZBTFVFUyA9IHt9O1xuXG5cdGlmIChsZWdlbmQubGl2ZSkge1xuXHRcdGNvbnN0IGdldE11bHRpVmFscyA9IHNlcmllc1sxXSA/IHNlcmllc1sxXS52YWx1ZXMgOiBudWxsO1xuXHRcdG11bHRpVmFsTGVnZW5kID0gZ2V0TXVsdGlWYWxzICE9IG51bGw7XG5cdFx0bGVnZW5kQ29scyA9IG11bHRpVmFsTGVnZW5kID8gZ2V0TXVsdGlWYWxzKHNlbGYsIDEsIDApIDoge186IDB9O1xuXG5cdFx0Zm9yIChsZXQgayBpbiBsZWdlbmRDb2xzKVxuXHRcdFx0TlVMTF9MRUdFTkRfVkFMVUVTW2tdID0gXCItLVwiO1xuXHR9XG5cblx0aWYgKHNob3dMZWdlbmQpIHtcblx0XHRsZWdlbmRFbCA9IHBsYWNlVGFnKFwidGFibGVcIiwgTEVHRU5ELCByb290KTtcblxuXHRcdGlmIChtdWx0aVZhbExlZ2VuZCkge1xuXHRcdFx0bGV0IGhlYWQgPSBwbGFjZVRhZyhcInRyXCIsIExFR0VORF9USEVBRCwgbGVnZW5kRWwpO1xuXHRcdFx0cGxhY2VUYWcoXCJ0aFwiLCBudWxsLCBoZWFkKTtcblxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGxlZ2VuZENvbHMpXG5cdFx0XHRcdHBsYWNlVGFnKFwidGhcIiwgTEVHRU5EX0xBQkVMLCBoZWFkKS50ZXh0Q29udGVudCA9IGtleTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRhZGRDbGFzcyhsZWdlbmRFbCwgTEVHRU5EX0lOTElORSk7XG5cdFx0XHRsZWdlbmQubGl2ZSAmJiBhZGRDbGFzcyhsZWdlbmRFbCwgTEVHRU5EX0xJVkUpO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IHNvbiAgPSB7c2hvdzogdHJ1ZX07XG5cdGNvbnN0IHNvZmYgPSB7c2hvdzogZmFsc2V9O1xuXG5cdGZ1bmN0aW9uIGluaXRMZWdlbmRSb3cocywgaSkge1xuXHRcdGlmIChpID09IDAgJiYgKG11bHRpVmFsTGVnZW5kIHx8ICFsZWdlbmQubGl2ZSB8fCBtb2RlID09IDIpKVxuXHRcdFx0cmV0dXJuIG51bGxOdWxsVHVwbGU7XG5cblx0XHRsZXQgY2VsbHMgPSBbXTtcblxuXHRcdGxldCByb3cgPSBwbGFjZVRhZyhcInRyXCIsIExFR0VORF9TRVJJRVMsIGxlZ2VuZEVsLCBsZWdlbmRFbC5jaGlsZE5vZGVzW2ldKTtcblxuXHRcdGFkZENsYXNzKHJvdywgcy5jbGFzcyk7XG5cblx0XHRpZiAoIXMuc2hvdylcblx0XHRcdGFkZENsYXNzKHJvdywgT0ZGKTtcblxuXHRcdGxldCBsYWJlbCA9IHBsYWNlVGFnKFwidGhcIiwgbnVsbCwgcm93KTtcblxuXHRcdGlmIChtYXJrZXJzLnNob3cpIHtcblx0XHRcdGxldCBpbmRpYyA9IHBsYWNlRGl2KExFR0VORF9NQVJLRVIsIGxhYmVsKTtcblxuXHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdGxldCB3aWR0aCAgPSBtYXJrZXJzLndpZHRoKHNlbGYsIGkpO1xuXG5cdFx0XHRcdGlmICh3aWR0aClcblx0XHRcdFx0XHRpbmRpYy5zdHlsZS5ib3JkZXIgPSB3aWR0aCArIFwicHggXCIgKyBtYXJrZXJzLmRhc2goc2VsZiwgaSkgKyBcIiBcIiArIG1hcmtlcnMuc3Ryb2tlKHNlbGYsIGkpO1xuXG5cdFx0XHRcdGluZGljLnN0eWxlLmJhY2tncm91bmQgPSBtYXJrZXJzLmZpbGwoc2VsZiwgaSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHRleHQgPSBwbGFjZURpdihMRUdFTkRfTEFCRUwsIGxhYmVsKTtcblx0XHR0ZXh0LnRleHRDb250ZW50ID0gcy5sYWJlbDtcblxuXHRcdGlmIChpID4gMCkge1xuXHRcdFx0aWYgKCFtYXJrZXJzLnNob3cpXG5cdFx0XHRcdHRleHQuc3R5bGUuY29sb3IgPSBzLndpZHRoID4gMCA/IG1hcmtlcnMuc3Ryb2tlKHNlbGYsIGkpIDogbWFya2Vycy5maWxsKHNlbGYsIGkpO1xuXG5cdFx0XHRvbk1vdXNlKFwiY2xpY2tcIiwgbGFiZWwsIGUgPT4ge1xuXHRcdFx0XHRpZiAoY3Vyc29yLl9sb2NrKVxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRsZXQgc2VyaWVzSWR4ID0gc2VyaWVzLmluZGV4T2Yocyk7XG5cblx0XHRcdFx0aWYgKChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSAhPSBsZWdlbmQuaXNvbGF0ZSkge1xuXHRcdFx0XHRcdC8vIGlmIGFueSBvdGhlciBzZXJpZXMgaXMgc2hvd24sIGlzb2xhdGUgdGhpcyBvbmUuIGVsc2Ugc2hvdyBhbGxcblx0XHRcdFx0XHRsZXQgaXNvbGF0ZSA9IHNlcmllcy5zb21lKChzLCBpKSA9PiBpID4gMCAmJiBpICE9IHNlcmllc0lkeCAmJiBzLnNob3cpO1xuXG5cdFx0XHRcdFx0c2VyaWVzLmZvckVhY2goKHMsIGkpID0+IHtcblx0XHRcdFx0XHRcdGkgPiAwICYmIHNldFNlcmllcyhpLCBpc29sYXRlID8gKGkgPT0gc2VyaWVzSWR4ID8gc29uIDogc29mZikgOiBzb24sIHRydWUsIHN5bmNPcHRzLnNldFNlcmllcyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHNldFNlcmllcyhzZXJpZXNJZHgsIHtzaG93OiAhcy5zaG93fSwgdHJ1ZSwgc3luY09wdHMuc2V0U2VyaWVzKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoY3Vyc29yRm9jdXMpIHtcblx0XHRcdFx0b25Nb3VzZShtb3VzZWVudGVyLCBsYWJlbCwgZSA9PiB7XG5cdFx0XHRcdFx0aWYgKGN1cnNvci5fbG9jaylcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdHNldFNlcmllcyhzZXJpZXMuaW5kZXhPZihzKSwgRk9DVVNfVFJVRSwgdHJ1ZSwgc3luY09wdHMuc2V0U2VyaWVzKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIga2V5IGluIGxlZ2VuZENvbHMpIHtcblx0XHRcdGxldCB2ID0gcGxhY2VUYWcoXCJ0ZFwiLCBMRUdFTkRfVkFMVUUsIHJvdyk7XG5cdFx0XHR2LnRleHRDb250ZW50ID0gXCItLVwiO1xuXHRcdFx0Y2VsbHMucHVzaCh2KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gW3JvdywgY2VsbHNdO1xuXHR9XG5cblx0Y29uc3QgbW91c2VMaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG5cblx0ZnVuY3Rpb24gb25Nb3VzZShldiwgdGFyZywgZm4pIHtcblx0XHRjb25zdCB0YXJnTGlzdGVuZXJzID0gbW91c2VMaXN0ZW5lcnMuZ2V0KHRhcmcpIHx8IHt9O1xuXHRcdGNvbnN0IGxpc3RlbmVyID0gY3Vyc29yLmJpbmRbZXZdKHNlbGYsIHRhcmcsIGZuKTtcblxuXHRcdGlmIChsaXN0ZW5lcikge1xuXHRcdFx0b24oZXYsIHRhcmcsIHRhcmdMaXN0ZW5lcnNbZXZdID0gbGlzdGVuZXIpO1xuXHRcdFx0bW91c2VMaXN0ZW5lcnMuc2V0KHRhcmcsIHRhcmdMaXN0ZW5lcnMpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG9mZk1vdXNlKGV2LCB0YXJnLCBmbikge1xuXHRcdGNvbnN0IHRhcmdMaXN0ZW5lcnMgPSBtb3VzZUxpc3RlbmVycy5nZXQodGFyZykgfHwge307XG5cblx0XHRmb3IgKGxldCBrIGluIHRhcmdMaXN0ZW5lcnMpIHtcblx0XHRcdGlmIChldiA9PSBudWxsIHx8IGsgPT0gZXYpIHtcblx0XHRcdFx0b2ZmKGssIHRhcmcsIHRhcmdMaXN0ZW5lcnNba10pO1xuXHRcdFx0XHRkZWxldGUgdGFyZ0xpc3RlbmVyc1trXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZXYgPT0gbnVsbClcblx0XHRcdG1vdXNlTGlzdGVuZXJzLmRlbGV0ZSh0YXJnKTtcblx0fVxuXG5cdGxldCBmdWxsV2lkQ3NzID0gMDtcblx0bGV0IGZ1bGxIZ3RDc3MgPSAwO1xuXG5cdGxldCBwbG90V2lkQ3NzID0gMDtcblx0bGV0IHBsb3RIZ3RDc3MgPSAwO1xuXG5cdC8vIHBsb3QgbWFyZ2lucyB0byBhY2NvdW50IGZvciBheGVzXG5cdGxldCBwbG90TGZ0Q3NzID0gMDtcblx0bGV0IHBsb3RUb3BDc3MgPSAwO1xuXG5cdGxldCBwbG90TGZ0ID0gMDtcblx0bGV0IHBsb3RUb3AgPSAwO1xuXHRsZXQgcGxvdFdpZCA9IDA7XG5cdGxldCBwbG90SGd0ID0gMDtcblxuXHRzZWxmLmJib3ggPSB7fTtcblxuXHRsZXQgc2hvdWxkU2V0U2NhbGVzID0gZmFsc2U7XG5cdGxldCBzaG91bGRTZXRTaXplID0gZmFsc2U7XG5cdGxldCBzaG91bGRDb252ZXJnZVNpemUgPSBmYWxzZTtcblx0bGV0IHNob3VsZFNldEN1cnNvciA9IGZhbHNlO1xuXHRsZXQgc2hvdWxkU2V0TGVnZW5kID0gZmFsc2U7XG5cblx0ZnVuY3Rpb24gX3NldFNpemUod2lkdGgsIGhlaWdodCwgZm9yY2UpIHtcblx0XHRpZiAoZm9yY2UgfHwgKHdpZHRoICE9IHNlbGYud2lkdGggfHwgaGVpZ2h0ICE9IHNlbGYuaGVpZ2h0KSlcblx0XHRcdGNhbGNTaXplKHdpZHRoLCBoZWlnaHQpO1xuXG5cdFx0cmVzZXRZU2VyaWVzKGZhbHNlKTtcblxuXHRcdHNob3VsZENvbnZlcmdlU2l6ZSA9IHRydWU7XG5cdFx0c2hvdWxkU2V0U2l6ZSA9IHRydWU7XG5cdFx0c2hvdWxkU2V0Q3Vyc29yID0gc2hvdWxkU2V0TGVnZW5kID0gY3Vyc29yLmxlZnQgPj0gMDtcblx0XHRjb21taXQoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNhbGNTaXplKHdpZHRoLCBoZWlnaHQpIHtcblx0Ly9cdGxvZyhcImNhbGNTaXplKClcIiwgYXJndW1lbnRzKTtcblxuXHRcdHNlbGYud2lkdGggID0gZnVsbFdpZENzcyA9IHBsb3RXaWRDc3MgPSB3aWR0aDtcblx0XHRzZWxmLmhlaWdodCA9IGZ1bGxIZ3RDc3MgPSBwbG90SGd0Q3NzID0gaGVpZ2h0O1xuXHRcdHBsb3RMZnRDc3MgID0gcGxvdFRvcENzcyA9IDA7XG5cblx0XHRjYWxjUGxvdFJlY3QoKTtcblx0XHRjYWxjQXhlc1JlY3RzKCk7XG5cblx0XHRsZXQgYmIgPSBzZWxmLmJib3g7XG5cblx0XHRwbG90TGZ0ID0gYmIubGVmdCAgID0gaW5jclJvdW5kKHBsb3RMZnRDc3MgKiBweFJhdGlvLCAwLjUpO1xuXHRcdHBsb3RUb3AgPSBiYi50b3AgICAgPSBpbmNyUm91bmQocGxvdFRvcENzcyAqIHB4UmF0aW8sIDAuNSk7XG5cdFx0cGxvdFdpZCA9IGJiLndpZHRoICA9IGluY3JSb3VuZChwbG90V2lkQ3NzICogcHhSYXRpbywgMC41KTtcblx0XHRwbG90SGd0ID0gYmIuaGVpZ2h0ID0gaW5jclJvdW5kKHBsb3RIZ3RDc3MgKiBweFJhdGlvLCAwLjUpO1xuXG5cdC8vXHR1cGRPcmlEaW1zKCk7XG5cdH1cblxuXHQvLyBlbnN1cmVzIHNpemUgY2FsYyBjb252ZXJnZW5jZVxuXHRjb25zdCBDWUNMRV9MSU1JVCA9IDM7XG5cblx0ZnVuY3Rpb24gY29udmVyZ2VTaXplKCkge1xuXHRcdGxldCBjb252ZXJnZWQgPSBmYWxzZTtcblxuXHRcdGxldCBjeWNsZU51bSA9IDA7XG5cblx0XHR3aGlsZSAoIWNvbnZlcmdlZCkge1xuXHRcdFx0Y3ljbGVOdW0rKztcblxuXHRcdFx0bGV0IGF4ZXNDb252ZXJnZWQgPSBheGVzQ2FsYyhjeWNsZU51bSk7XG5cdFx0XHRsZXQgcGFkZGluZ0NvbnZlcmdlZCA9IHBhZGRpbmdDYWxjKGN5Y2xlTnVtKTtcblxuXHRcdFx0Y29udmVyZ2VkID0gY3ljbGVOdW0gPT0gQ1lDTEVfTElNSVQgfHwgKGF4ZXNDb252ZXJnZWQgJiYgcGFkZGluZ0NvbnZlcmdlZCk7XG5cblx0XHRcdGlmICghY29udmVyZ2VkKSB7XG5cdFx0XHRcdGNhbGNTaXplKHNlbGYud2lkdGgsIHNlbGYuaGVpZ2h0KTtcblx0XHRcdFx0c2hvdWxkU2V0U2l6ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0U2l6ZSh7d2lkdGgsIGhlaWdodH0pIHtcblx0XHRfc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblx0fVxuXG5cdHNlbGYuc2V0U2l6ZSA9IHNldFNpemU7XG5cblx0Ly8gYWNjdW11bGF0ZSBheGlzIG9mZnNldHMsIHJlZHVjZSBjYW52YXMgd2lkdGhcblx0ZnVuY3Rpb24gY2FsY1Bsb3RSZWN0KCkge1xuXHRcdC8vIGVhc2VtZW50cyBmb3IgZWRnZSBsYWJlbHNcblx0XHRsZXQgaGFzVG9wQXhpcyA9IGZhbHNlO1xuXHRcdGxldCBoYXNCdG1BeGlzID0gZmFsc2U7XG5cdFx0bGV0IGhhc1JndEF4aXMgPSBmYWxzZTtcblx0XHRsZXQgaGFzTGZ0QXhpcyA9IGZhbHNlO1xuXG5cdFx0YXhlcy5mb3JFYWNoKChheGlzLCBpKSA9PiB7XG5cdFx0XHRpZiAoYXhpcy5zaG93ICYmIGF4aXMuX3Nob3cpIHtcblx0XHRcdFx0bGV0IHtzaWRlLCBfc2l6ZX0gPSBheGlzO1xuXHRcdFx0XHRsZXQgaXNWdCA9IHNpZGUgJSAyO1xuXHRcdFx0XHRsZXQgbGFiZWxTaXplID0gYXhpcy5sYWJlbCAhPSBudWxsID8gYXhpcy5sYWJlbFNpemUgOiAwO1xuXG5cdFx0XHRcdGxldCBmdWxsU2l6ZSA9IF9zaXplICsgbGFiZWxTaXplO1xuXG5cdFx0XHRcdGlmIChmdWxsU2l6ZSA+IDApIHtcblx0XHRcdFx0XHRpZiAoaXNWdCkge1xuXHRcdFx0XHRcdFx0cGxvdFdpZENzcyAtPSBmdWxsU2l6ZTtcblxuXHRcdFx0XHRcdFx0aWYgKHNpZGUgPT0gMykge1xuXHRcdFx0XHRcdFx0XHRwbG90TGZ0Q3NzICs9IGZ1bGxTaXplO1xuXHRcdFx0XHRcdFx0XHRoYXNMZnRBeGlzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0aGFzUmd0QXhpcyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cGxvdEhndENzcyAtPSBmdWxsU2l6ZTtcblxuXHRcdFx0XHRcdFx0aWYgKHNpZGUgPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRwbG90VG9wQ3NzICs9IGZ1bGxTaXplO1xuXHRcdFx0XHRcdFx0XHRoYXNUb3BBeGlzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0aGFzQnRtQXhpcyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRzaWRlc1dpdGhBeGVzWzBdID0gaGFzVG9wQXhpcztcblx0XHRzaWRlc1dpdGhBeGVzWzFdID0gaGFzUmd0QXhpcztcblx0XHRzaWRlc1dpdGhBeGVzWzJdID0gaGFzQnRtQXhpcztcblx0XHRzaWRlc1dpdGhBeGVzWzNdID0gaGFzTGZ0QXhpcztcblxuXHRcdC8vIGh6IHBhZGRpbmdcblx0XHRwbG90V2lkQ3NzIC09IF9wYWRkaW5nWzFdICsgX3BhZGRpbmdbM107XG5cdFx0cGxvdExmdENzcyArPSBfcGFkZGluZ1szXTtcblxuXHRcdC8vIHZ0IHBhZGRpbmdcblx0XHRwbG90SGd0Q3NzIC09IF9wYWRkaW5nWzJdICsgX3BhZGRpbmdbMF07XG5cdFx0cGxvdFRvcENzcyArPSBfcGFkZGluZ1swXTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNhbGNBeGVzUmVjdHMoKSB7XG5cdFx0Ly8gd2lsbCBhY2N1bSArXG5cdFx0bGV0IG9mZjEgPSBwbG90TGZ0Q3NzICsgcGxvdFdpZENzcztcblx0XHRsZXQgb2ZmMiA9IHBsb3RUb3BDc3MgKyBwbG90SGd0Q3NzO1xuXHRcdC8vIHdpbGwgYWNjdW0gLVxuXHRcdGxldCBvZmYzID0gcGxvdExmdENzcztcblx0XHRsZXQgb2ZmMCA9IHBsb3RUb3BDc3M7XG5cblx0XHRmdW5jdGlvbiBpbmNyT2Zmc2V0KHNpZGUsIHNpemUpIHtcblx0XHRcdHN3aXRjaCAoc2lkZSkge1xuXHRcdFx0XHRjYXNlIDE6IG9mZjEgKz0gc2l6ZTsgcmV0dXJuIG9mZjEgLSBzaXplO1xuXHRcdFx0XHRjYXNlIDI6IG9mZjIgKz0gc2l6ZTsgcmV0dXJuIG9mZjIgLSBzaXplO1xuXHRcdFx0XHRjYXNlIDM6IG9mZjMgLT0gc2l6ZTsgcmV0dXJuIG9mZjMgKyBzaXplO1xuXHRcdFx0XHRjYXNlIDA6IG9mZjAgLT0gc2l6ZTsgcmV0dXJuIG9mZjAgKyBzaXplO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGF4ZXMuZm9yRWFjaCgoYXhpcywgaSkgPT4ge1xuXHRcdFx0aWYgKGF4aXMuc2hvdyAmJiBheGlzLl9zaG93KSB7XG5cdFx0XHRcdGxldCBzaWRlID0gYXhpcy5zaWRlO1xuXG5cdFx0XHRcdGF4aXMuX3BvcyA9IGluY3JPZmZzZXQoc2lkZSwgYXhpcy5fc2l6ZSk7XG5cblx0XHRcdFx0aWYgKGF4aXMubGFiZWwgIT0gbnVsbClcblx0XHRcdFx0XHRheGlzLl9scG9zID0gaW5jck9mZnNldChzaWRlLCBheGlzLmxhYmVsU2l6ZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRjb25zdCBjdXJzb3IgPSAoc2VsZi5jdXJzb3IgPSBhc3NpZ24oe30sIGN1cnNvck9wdHMsIHtkcmFnOiB7eTogbW9kZSA9PSAyfX0sIG9wdHMuY3Vyc29yKSk7XG5cblx0e1xuXHRcdGN1cnNvci5pZHhzID0gYWN0aXZlSWR4cztcblxuXHRcdGN1cnNvci5fbG9jayA9IGZhbHNlO1xuXG5cdFx0bGV0IHBvaW50cyA9IGN1cnNvci5wb2ludHM7XG5cblx0XHRwb2ludHMuc2hvdyAgID0gZm5PclNlbGYocG9pbnRzLnNob3cpO1xuXHRcdHBvaW50cy5zaXplICAgPSBmbk9yU2VsZihwb2ludHMuc2l6ZSk7XG5cdFx0cG9pbnRzLnN0cm9rZSA9IGZuT3JTZWxmKHBvaW50cy5zdHJva2UpO1xuXHRcdHBvaW50cy53aWR0aCAgPSBmbk9yU2VsZihwb2ludHMud2lkdGgpO1xuXHRcdHBvaW50cy5maWxsICAgPSBmbk9yU2VsZihwb2ludHMuZmlsbCk7XG5cdH1cblxuXHRjb25zdCBmb2N1cyA9IHNlbGYuZm9jdXMgPSBhc3NpZ24oe30sIG9wdHMuZm9jdXMgfHwge2FscGhhOiAwLjN9LCBjdXJzb3IuZm9jdXMpO1xuXHRjb25zdCBjdXJzb3JGb2N1cyA9IGZvY3VzLnByb3ggPj0gMDtcblxuXHQvLyBzZXJpZXMtaW50ZXJzZWN0aW9uIG1hcmtlcnNcblx0bGV0IGN1cnNvclB0cyA9IFtudWxsXTtcblxuXHRmdW5jdGlvbiBpbml0Q3Vyc29yUHQocywgc2kpIHtcblx0XHRpZiAoc2kgPiAwKSB7XG5cdFx0XHRsZXQgcHQgPSBjdXJzb3IucG9pbnRzLnNob3coc2VsZiwgc2kpO1xuXG5cdFx0XHRpZiAocHQpIHtcblx0XHRcdFx0YWRkQ2xhc3MocHQsIENVUlNPUl9QVCk7XG5cdFx0XHRcdGFkZENsYXNzKHB0LCBzLmNsYXNzKTtcblx0XHRcdFx0ZWxUcmFucyhwdCwgLTEwLCAtMTAsIHBsb3RXaWRDc3MsIHBsb3RIZ3RDc3MpO1xuXHRcdFx0XHRvdmVyLmluc2VydEJlZm9yZShwdCwgY3Vyc29yUHRzW3NpXSk7XG5cblx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGluaXRTZXJpZXMocywgaSkge1xuXHRcdGlmIChtb2RlID09IDEgfHwgaSA+IDApIHtcblx0XHRcdGxldCBpc1RpbWUgPSBtb2RlID09IDEgJiYgc2NhbGVzW3Muc2NhbGVdLnRpbWU7XG5cblx0XHRcdGxldCBzdiA9IHMudmFsdWU7XG5cdFx0XHRzLnZhbHVlID0gaXNUaW1lID8gKGlzU3RyKHN2KSA/IHRpbWVTZXJpZXNWYWwoX3R6RGF0ZSwgdGltZVNlcmllc1N0YW1wKHN2LCBfZm10RGF0ZSkpIDogc3YgfHwgX3RpbWVTZXJpZXNWYWwpIDogc3YgfHwgbnVtU2VyaWVzVmFsO1xuXHRcdFx0cy5sYWJlbCA9IHMubGFiZWwgfHwgKGlzVGltZSA/IHRpbWVTZXJpZXNMYWJlbCA6IG51bVNlcmllc0xhYmVsKTtcblx0XHR9XG5cblx0XHRpZiAoaSA+IDApIHtcblx0XHRcdHMud2lkdGggID0gcy53aWR0aCA9PSBudWxsID8gMSA6IHMud2lkdGg7XG5cdFx0XHRzLnBhdGhzICA9IHMucGF0aHMgfHwgbGluZWFyUGF0aCB8fCByZXROdWxsO1xuXHRcdFx0cy5maWxsVG8gPSBmbk9yU2VsZihzLmZpbGxUbyB8fCBzZXJpZXNGaWxsVG8pO1xuXHRcdFx0cy5weEFsaWduID0gK2lmTnVsbChzLnB4QWxpZ24sIHB4QWxpZ24pO1xuXHRcdFx0cy5weFJvdW5kID0gcHhSb3VuZEdlbihzLnB4QWxpZ24pO1xuXG5cdFx0XHRzLnN0cm9rZSA9IGZuT3JTZWxmKHMuc3Ryb2tlIHx8IG51bGwpO1xuXHRcdFx0cy5maWxsICAgPSBmbk9yU2VsZihzLmZpbGwgfHwgbnVsbCk7XG5cdFx0XHRzLl9zdHJva2UgPSBzLl9maWxsID0gcy5fcGF0aHMgPSBzLl9mb2N1cyA9IG51bGw7XG5cblx0XHRcdGxldCBfcHREaWEgPSBwdERpYShzLndpZHRoLCAxKTtcblx0XHRcdGxldCBwb2ludHMgPSBzLnBvaW50cyA9IGFzc2lnbih7fSwge1xuXHRcdFx0XHRzaXplOiBfcHREaWEsXG5cdFx0XHRcdHdpZHRoOiBtYXgoMSwgX3B0RGlhICogLjIpLFxuXHRcdFx0XHRzdHJva2U6IHMuc3Ryb2tlLFxuXHRcdFx0XHRzcGFjZTogX3B0RGlhICogMixcblx0XHRcdFx0cGF0aHM6IHBvaW50c1BhdGgsXG5cdFx0XHRcdF9zdHJva2U6IG51bGwsXG5cdFx0XHRcdF9maWxsOiBudWxsLFxuXHRcdFx0fSwgcy5wb2ludHMpO1xuXHRcdFx0cG9pbnRzLnNob3cgICA9IGZuT3JTZWxmKHBvaW50cy5zaG93KTtcblx0XHRcdHBvaW50cy5maWx0ZXIgPSBmbk9yU2VsZihwb2ludHMuZmlsdGVyKTtcblx0XHRcdHBvaW50cy5maWxsICAgPSBmbk9yU2VsZihwb2ludHMuZmlsbCk7XG5cdFx0XHRwb2ludHMuc3Ryb2tlID0gZm5PclNlbGYocG9pbnRzLnN0cm9rZSk7XG5cdFx0XHRwb2ludHMucGF0aHMgID0gZm5PclNlbGYocG9pbnRzLnBhdGhzKTtcblx0XHRcdHBvaW50cy5weEFsaWduID0gcy5weEFsaWduO1xuXHRcdH1cblxuXHRcdGlmIChzaG93TGVnZW5kKSB7XG5cdFx0XHRsZXQgcm93Q2VsbHMgPSBpbml0TGVnZW5kUm93KHMsIGkpO1xuXHRcdFx0bGVnZW5kUm93cy5zcGxpY2UoaSwgMCwgcm93Q2VsbHNbMF0pO1xuXHRcdFx0bGVnZW5kQ2VsbHMuc3BsaWNlKGksIDAsIHJvd0NlbGxzWzFdKTtcblx0XHRcdGxlZ2VuZC52YWx1ZXMucHVzaChudWxsKTtcdC8vIE5VTExfTEVHRU5EX1ZBTFMgbm90IHlldCBhdmlsIGhlcmUgOihcblx0XHR9XG5cblx0XHRpZiAoY3Vyc29yLnNob3cpIHtcblx0XHRcdGFjdGl2ZUlkeHMuc3BsaWNlKGksIDAsIG51bGwpO1xuXG5cdFx0XHRsZXQgcHQgPSBpbml0Q3Vyc29yUHQocywgaSk7XG5cdFx0XHRwdCAmJiBjdXJzb3JQdHMuc3BsaWNlKGksIDAsIHB0KTtcblx0XHR9XG5cblx0XHRmaXJlKFwiYWRkU2VyaWVzXCIsIGkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkU2VyaWVzKG9wdHMsIHNpKSB7XG5cdFx0c2kgPSBzaSA9PSBudWxsID8gc2VyaWVzLmxlbmd0aCA6IHNpO1xuXG5cdFx0b3B0cyA9IHNldERlZmF1bHQob3B0cywgc2ksIHhTZXJpZXNPcHRzLCB5U2VyaWVzT3B0cyk7XG5cdFx0c2VyaWVzLnNwbGljZShzaSwgMCwgb3B0cyk7XG5cdFx0aW5pdFNlcmllcyhzZXJpZXNbc2ldLCBzaSk7XG5cdH1cblxuXHRzZWxmLmFkZFNlcmllcyA9IGFkZFNlcmllcztcblxuXHRmdW5jdGlvbiBkZWxTZXJpZXMoaSkge1xuXHRcdHNlcmllcy5zcGxpY2UoaSwgMSk7XG5cblx0XHRpZiAoc2hvd0xlZ2VuZCkge1xuXHRcdFx0bGVnZW5kLnZhbHVlcy5zcGxpY2UoaSwgMSk7XG5cblx0XHRcdGxlZ2VuZENlbGxzLnNwbGljZShpLCAxKTtcblx0XHRcdGxldCB0ciA9IGxlZ2VuZFJvd3Muc3BsaWNlKGksIDEpWzBdO1xuXHRcdFx0b2ZmTW91c2UobnVsbCwgdHIuZmlyc3RDaGlsZCk7XG5cdFx0XHR0ci5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRpZiAoY3Vyc29yLnNob3cpIHtcblx0XHRcdGFjdGl2ZUlkeHMuc3BsaWNlKGksIDEpO1xuXG5cdFx0XHRjdXJzb3JQdHMubGVuZ3RoID4gMSAmJiBjdXJzb3JQdHMuc3BsaWNlKGksIDEpWzBdLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdC8vIFRPRE86IGRlLWluaXQgbm8tbG9uZ2VyLW5lZWRlZCBzY2FsZXM/XG5cblx0XHRmaXJlKFwiZGVsU2VyaWVzXCIsIGkpO1xuXHR9XG5cblx0c2VsZi5kZWxTZXJpZXMgPSBkZWxTZXJpZXM7XG5cblx0Y29uc3Qgc2lkZXNXaXRoQXhlcyA9IFtmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZV07XG5cblx0ZnVuY3Rpb24gaW5pdEF4aXMoYXhpcywgaSkge1xuXHRcdGF4aXMuX3Nob3cgPSBheGlzLnNob3c7XG5cblx0XHRpZiAoYXhpcy5zaG93KSB7XG5cdFx0XHRsZXQgaXNWdCA9IGF4aXMuc2lkZSAlIDI7XG5cblx0XHRcdGxldCBzYyA9IHNjYWxlc1theGlzLnNjYWxlXTtcblxuXHRcdFx0Ly8gdGhpcyBjYW4gb2NjdXIgaWYgYWxsIHNlcmllcyBzcGVjaWZ5IG5vbi1kZWZhdWx0IHNjYWxlc1xuXHRcdFx0aWYgKHNjID09IG51bGwpIHtcblx0XHRcdFx0YXhpcy5zY2FsZSA9IGlzVnQgPyBzZXJpZXNbMV0uc2NhbGUgOiB4U2NhbGVLZXk7XG5cdFx0XHRcdHNjID0gc2NhbGVzW2F4aXMuc2NhbGVdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhbHNvIHNldCBkZWZhdWx0cyBmb3IgaW5jcnMgJiB2YWx1ZXMgYmFzZWQgb24gYXhpcyBkaXN0clxuXHRcdFx0bGV0IGlzVGltZSA9IHNjLnRpbWU7XG5cblx0XHRcdGF4aXMuc2l6ZSAgID0gZm5PclNlbGYoYXhpcy5zaXplKTtcblx0XHRcdGF4aXMuc3BhY2UgID0gZm5PclNlbGYoYXhpcy5zcGFjZSk7XG5cdFx0XHRheGlzLnJvdGF0ZSA9IGZuT3JTZWxmKGF4aXMucm90YXRlKTtcblx0XHRcdGF4aXMuaW5jcnMgID0gZm5PclNlbGYoYXhpcy5pbmNycyAgfHwgKCAgICAgICAgICBzYy5kaXN0ciA9PSAyID8gd2hvbGVJbmNycyA6IChpc1RpbWUgPyAobXMgPT0gMSA/IHRpbWVJbmNyc01zIDogdGltZUluY3JzUykgOiBudW1JbmNycykpKTtcblx0XHRcdGF4aXMuc3BsaXRzID0gZm5PclNlbGYoYXhpcy5zcGxpdHMgfHwgKGlzVGltZSAmJiBzYy5kaXN0ciA9PSAxID8gX3RpbWVBeGlzU3BsaXRzIDogc2MuZGlzdHIgPT0gMyA/IGxvZ0F4aXNTcGxpdHMgOiBzYy5kaXN0ciA9PSA0ID8gYXNpbmhBeGlzU3BsaXRzIDogbnVtQXhpc1NwbGl0cykpO1xuXG5cdFx0XHRheGlzLnN0cm9rZSAgICAgICAgPSBmbk9yU2VsZihheGlzLnN0cm9rZSk7XG5cdFx0XHRheGlzLmdyaWQuc3Ryb2tlICAgPSBmbk9yU2VsZihheGlzLmdyaWQuc3Ryb2tlKTtcblx0XHRcdGF4aXMudGlja3Muc3Ryb2tlICA9IGZuT3JTZWxmKGF4aXMudGlja3Muc3Ryb2tlKTtcblx0XHRcdGF4aXMuYm9yZGVyLnN0cm9rZSA9IGZuT3JTZWxmKGF4aXMuYm9yZGVyLnN0cm9rZSk7XG5cblx0XHRcdGxldCBhdiA9IGF4aXMudmFsdWVzO1xuXG5cdFx0XHRheGlzLnZhbHVlcyA9IChcblx0XHRcdFx0Ly8gc3RhdGljIGFycmF5IG9mIHRpY2sgdmFsdWVzXG5cdFx0XHRcdGlzQXJyKGF2KSAmJiAhaXNBcnIoYXZbMF0pID8gZm5PclNlbGYoYXYpIDpcblx0XHRcdFx0Ly8gdGVtcG9yYWxcblx0XHRcdFx0aXNUaW1lID8gKFxuXHRcdFx0XHRcdC8vIGNvbmZpZyBhcnJheSBvZiBmbXREYXRlIHN0cmluZyB0cGxzXG5cdFx0XHRcdFx0aXNBcnIoYXYpID9cblx0XHRcdFx0XHRcdHRpbWVBeGlzVmFscyhfdHpEYXRlLCB0aW1lQXhpc1N0YW1wcyhhdiwgX2ZtdERhdGUpKSA6XG5cdFx0XHRcdFx0Ly8gZm10RGF0ZSBzdHJpbmcgdHBsXG5cdFx0XHRcdFx0aXNTdHIoYXYpID9cblx0XHRcdFx0XHRcdHRpbWVBeGlzVmFsKF90ekRhdGUsIGF2KSA6XG5cdFx0XHRcdFx0YXYgfHwgX3RpbWVBeGlzVmFsc1xuXHRcdFx0XHQpIDogYXYgfHwgbnVtQXhpc1ZhbHNcblx0XHRcdCk7XG5cblx0XHRcdGF4aXMuZmlsdGVyID0gZm5PclNlbGYoYXhpcy5maWx0ZXIgfHwgKCAgICAgICAgICBzYy5kaXN0ciA+PSAzID8gbG9nQXhpc1ZhbHNGaWx0IDogcmV0QXJnMSkpO1xuXG5cdFx0XHRheGlzLmZvbnQgICAgICA9IHB4UmF0aW9Gb250KGF4aXMuZm9udCk7XG5cdFx0XHRheGlzLmxhYmVsRm9udCA9IHB4UmF0aW9Gb250KGF4aXMubGFiZWxGb250KTtcblxuXHRcdFx0YXhpcy5fc2l6ZSAgID0gYXhpcy5zaXplKHNlbGYsIG51bGwsIGksIDApO1xuXG5cdFx0XHRheGlzLl9zcGFjZSAgPVxuXHRcdFx0YXhpcy5fcm90YXRlID1cblx0XHRcdGF4aXMuX2luY3JzICA9XG5cdFx0XHRheGlzLl9mb3VuZCAgPVx0Ly8gZm91bmRJbmNyU3BhY2Vcblx0XHRcdGF4aXMuX3NwbGl0cyA9XG5cdFx0XHRheGlzLl92YWx1ZXMgPSBudWxsO1xuXG5cdFx0XHRpZiAoYXhpcy5fc2l6ZSA+IDApIHtcblx0XHRcdFx0c2lkZXNXaXRoQXhlc1tpXSA9IHRydWU7XG5cdFx0XHRcdGF4aXMuX2VsID0gcGxhY2VEaXYoQVhJUywgd3JhcCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRlYnVnXG5cdFx0Ly9cdGF4aXMuX2VsLnN0eWxlLmJhY2tncm91bmQgPSBcIiNcIiAgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMTY3NzcyMTUpLnRvU3RyaW5nKDE2KSArICc4MCc7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYXV0b1BhZFNpZGUoc2VsZiwgc2lkZSwgc2lkZXNXaXRoQXhlcywgY3ljbGVOdW0pIHtcblx0XHRsZXQgW2hhc1RvcEF4aXMsIGhhc1JndEF4aXMsIGhhc0J0bUF4aXMsIGhhc0xmdEF4aXNdID0gc2lkZXNXaXRoQXhlcztcblxuXHRcdGxldCBvcmkgPSBzaWRlICUgMjtcblx0XHRsZXQgc2l6ZSA9IDA7XG5cblx0XHRpZiAob3JpID09IDAgJiYgKGhhc0xmdEF4aXMgfHwgaGFzUmd0QXhpcykpXG5cdFx0XHRzaXplID0gKHNpZGUgPT0gMCAmJiAhaGFzVG9wQXhpcyB8fCBzaWRlID09IDIgJiYgIWhhc0J0bUF4aXMgPyByb3VuZCh4QXhpc09wdHMuc2l6ZSAvIDMpIDogMCk7XG5cdFx0aWYgKG9yaSA9PSAxICYmIChoYXNUb3BBeGlzIHx8IGhhc0J0bUF4aXMpKVxuXHRcdFx0c2l6ZSA9IChzaWRlID09IDEgJiYgIWhhc1JndEF4aXMgfHwgc2lkZSA9PSAzICYmICFoYXNMZnRBeGlzID8gcm91bmQoeUF4aXNPcHRzLnNpemUgLyAyKSA6IDApO1xuXG5cdFx0cmV0dXJuIHNpemU7XG5cdH1cblxuXHRjb25zdCBwYWRkaW5nID0gc2VsZi5wYWRkaW5nID0gKG9wdHMucGFkZGluZyB8fCBbYXV0b1BhZFNpZGUsYXV0b1BhZFNpZGUsYXV0b1BhZFNpZGUsYXV0b1BhZFNpZGVdKS5tYXAocCA9PiBmbk9yU2VsZihpZk51bGwocCwgYXV0b1BhZFNpZGUpKSk7XG5cdGNvbnN0IF9wYWRkaW5nID0gc2VsZi5fcGFkZGluZyA9IHBhZGRpbmcubWFwKChwLCBpKSA9PiBwKHNlbGYsIGksIHNpZGVzV2l0aEF4ZXMsIDApKTtcblxuXHRsZXQgZGF0YUxlbjtcblxuXHQvLyByZW5kZXJlZCBkYXRhIHdpbmRvd1xuXHRsZXQgaTAgPSBudWxsO1xuXHRsZXQgaTEgPSBudWxsO1xuXHRjb25zdCBpZHhzID0gbW9kZSA9PSAxID8gc2VyaWVzWzBdLmlkeHMgOiBudWxsO1xuXG5cdGxldCBkYXRhMCA9IG51bGw7XG5cblx0bGV0IHZpYUF1dG9TY2FsZVggPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBzZXREYXRhKF9kYXRhLCBfcmVzZXRTY2FsZXMpIHtcblx0XHRkYXRhID0gX2RhdGEgPT0gbnVsbCA/IFtdIDogY29weShfZGF0YSwgZmFzdElzT2JqKTtcblxuXHRcdGlmIChtb2RlID09IDIpIHtcblx0XHRcdGRhdGFMZW4gPSAwO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspXG5cdFx0XHRcdGRhdGFMZW4gKz0gZGF0YVtpXVswXS5sZW5ndGg7XG5cdFx0XHRzZWxmLmRhdGEgPSBkYXRhID0gX2RhdGE7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKGRhdGFbMF0gPT0gbnVsbClcblx0XHRcdFx0ZGF0YVswXSA9IFtdO1xuXG5cdFx0XHRzZWxmLmRhdGEgPSBkYXRhLnNsaWNlKCk7XG5cblx0XHRcdGRhdGEwID0gZGF0YVswXTtcblx0XHRcdGRhdGFMZW4gPSBkYXRhMC5sZW5ndGg7XG5cblx0XHRcdGlmICh4U2NhbGVEaXN0ciA9PSAyKSB7XG5cdFx0XHRcdGRhdGFbMF0gPSBBcnJheShkYXRhTGVuKTtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhTGVuOyBpKyspXG5cdFx0XHRcdFx0ZGF0YVswXVtpXSA9IGk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VsZi5fZGF0YSA9IGRhdGE7XG5cblx0XHRyZXNldFlTZXJpZXModHJ1ZSk7XG5cblx0XHRmaXJlKFwic2V0RGF0YVwiKTtcblxuXHRcdC8vIGZvcmNlcyB4IGF4aXMgdGljayB2YWx1ZXMgdG8gcmUtZ2VuZXJhdGUgd2hlbiBuZWl0aGVyIHggc2NhbGUgbm9yIHkgc2NhbGUgY2hhbmdlc1xuXHRcdC8vIGluIG9yZGluYWwgbW9kZSwgc2NhbGUgcmFuZ2UgaXMgYnkgaW5kZXgsIHNvIHdpbGwgbm90IGNoYW5nZSBpZiBuZXcgZGF0YSBoYXMgc2FtZSBsZW5ndGgsIGJ1dCB0aWNrIHZhbHVlcyBhcmUgZnJvbSBkYXRhXG5cdFx0aWYgKHhTY2FsZURpc3RyID09IDIpIHtcblx0XHRcdHNob3VsZENvbnZlcmdlU2l6ZSA9IHRydWU7XG5cblx0XHRcdC8qIG9yIHNvbWV3aGF0IGNoZWFwZXIsIGFuZCB1Z2xpZXI6XG5cdFx0XHRpZiAocmVhZHkpIHtcblx0XHRcdFx0Ly8gbG9naWMgZXh0cmFjdGVkIGZyb20gYXhlc0NhbGMoKVxuXHRcdFx0XHRsZXQgaSA9IDA7XG5cdFx0XHRcdGxldCBheGlzID0gYXhlc1tpXTtcblx0XHRcdFx0bGV0IF9zcGxpdHMgPSBheGlzLl9zcGxpdHMubWFwKGkgPT4gZGF0YTBbaV0pO1xuXHRcdFx0XHRsZXQgW19pbmNyLCBfc3BhY2VdID0gYXhpcy5fZm91bmQ7XG5cdFx0XHRcdGxldCBpbmNyID0gZGF0YTBbX3NwbGl0c1sxXV0gLSBkYXRhMFtfc3BsaXRzWzBdXTtcblx0XHRcdFx0YXhpcy5fdmFsdWVzID0gYXhpcy52YWx1ZXMoc2VsZiwgYXhpcy5maWx0ZXIoc2VsZiwgX3NwbGl0cywgaSwgX3NwYWNlLCBpbmNyKSwgaSwgX3NwYWNlLCBpbmNyKTtcblx0XHRcdH1cblx0XHRcdCovXG5cdFx0fVxuXG5cdFx0aWYgKF9yZXNldFNjYWxlcyAhPT0gZmFsc2UpIHtcblx0XHRcdGxldCB4c2MgPSBzY2FsZVg7XG5cblx0XHRcdGlmICh4c2MuYXV0byhzZWxmLCB2aWFBdXRvU2NhbGVYKSlcblx0XHRcdFx0YXV0b1NjYWxlWCgpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRfc2V0U2NhbGUoeFNjYWxlS2V5LCB4c2MubWluLCB4c2MubWF4KTtcblxuXHRcdFx0c2hvdWxkU2V0Q3Vyc29yID0gY3Vyc29yLmxlZnQgPj0gMDtcblx0XHRcdHNob3VsZFNldExlZ2VuZCA9IHRydWU7XG5cdFx0XHRjb21taXQoKTtcblx0XHR9XG5cdH1cblxuXHRzZWxmLnNldERhdGEgPSBzZXREYXRhO1xuXG5cdGZ1bmN0aW9uIGF1dG9TY2FsZVgoKSB7XG5cdFx0dmlhQXV0b1NjYWxlWCA9IHRydWU7XG5cblx0XHRsZXQgX21pbiwgX21heDtcblxuXHRcdGlmIChtb2RlID09IDEpIHtcblx0XHRcdGlmIChkYXRhTGVuID4gMCkge1xuXHRcdFx0XHRpMCA9IGlkeHNbMF0gPSAwO1xuXHRcdFx0XHRpMSA9IGlkeHNbMV0gPSBkYXRhTGVuIC0gMTtcblxuXHRcdFx0XHRfbWluID0gZGF0YVswXVtpMF07XG5cdFx0XHRcdF9tYXggPSBkYXRhWzBdW2kxXTtcblxuXHRcdFx0XHRpZiAoeFNjYWxlRGlzdHIgPT0gMikge1xuXHRcdFx0XHRcdF9taW4gPSBpMDtcblx0XHRcdFx0XHRfbWF4ID0gaTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoZGF0YUxlbiA9PSAxKSB7XG5cdFx0XHRcdFx0aWYgKHhTY2FsZURpc3RyID09IDMpXG5cdFx0XHRcdFx0XHRbX21pbiwgX21heF0gPSByYW5nZUxvZyhfbWluLCBfbWluLCBzY2FsZVgubG9nLCBmYWxzZSk7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoeFNjYWxlRGlzdHIgPT0gNClcblx0XHRcdFx0XHRcdFtfbWluLCBfbWF4XSA9IHJhbmdlQXNpbmgoX21pbiwgX21pbiwgc2NhbGVYLmxvZywgZmFsc2UpO1xuXHRcdFx0XHRcdGVsc2UgaWYgKHNjYWxlWC50aW1lKVxuXHRcdFx0XHRcdFx0X21heCA9IF9taW4gKyByb3VuZCg4NjQwMCAvIG1zKTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRbX21pbiwgX21heF0gPSByYW5nZU51bShfbWluLCBfbWF4LCByYW5nZVBhZCwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpMCA9IGlkeHNbMF0gPSBfbWluID0gbnVsbDtcblx0XHRcdFx0aTEgPSBpZHhzWzFdID0gX21heCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X3NldFNjYWxlKHhTY2FsZUtleSwgX21pbiwgX21heCk7XG5cdH1cblxuXHRsZXQgY3R4U3Ryb2tlLCBjdHhGaWxsLCBjdHhXaWR0aCwgY3R4RGFzaCwgY3R4Sm9pbiwgY3R4Q2FwLCBjdHhGb250LCBjdHhBbGlnbiwgY3R4QmFzZWxpbmU7XG5cdGxldCBjdHhBbHBoYTtcblxuXHRmdW5jdGlvbiBzZXRDdHhTdHlsZShzdHJva2UgPSB0cmFuc3BhcmVudCwgd2lkdGgsIGRhc2ggPSBFTVBUWV9BUlIsIGNhcCA9IFwiYnV0dFwiLCBmaWxsID0gdHJhbnNwYXJlbnQsIGpvaW4gPSBcInJvdW5kXCIpIHtcblx0XHRpZiAoc3Ryb2tlICE9IGN0eFN0cm9rZSlcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGN0eFN0cm9rZSA9IHN0cm9rZTtcblx0XHRpZiAoZmlsbCAhPSBjdHhGaWxsKVxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGN0eEZpbGwgPSBmaWxsO1xuXHRcdGlmICh3aWR0aCAhPSBjdHhXaWR0aClcblx0XHRcdGN0eC5saW5lV2lkdGggPSBjdHhXaWR0aCA9IHdpZHRoO1xuXHRcdGlmIChqb2luICE9IGN0eEpvaW4pXG5cdFx0XHRjdHgubGluZUpvaW4gPSBjdHhKb2luID0gam9pbjtcblx0XHRpZiAoY2FwICE9IGN0eENhcClcblx0XHRcdGN0eC5saW5lQ2FwID0gY3R4Q2FwID0gY2FwOyAvLyAoXHUyMDNGfFx1MjAzRilcblx0XHRpZiAoZGFzaCAhPSBjdHhEYXNoKVxuXHRcdFx0Y3R4LnNldExpbmVEYXNoKGN0eERhc2ggPSBkYXNoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldEZvbnRTdHlsZShmb250LCBmaWxsLCBhbGlnbiwgYmFzZWxpbmUpIHtcblx0XHRpZiAoZmlsbCAhPSBjdHhGaWxsKVxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGN0eEZpbGwgPSBmaWxsO1xuXHRcdGlmIChmb250ICE9IGN0eEZvbnQpXG5cdFx0XHRjdHguZm9udCA9IGN0eEZvbnQgPSBmb250O1xuXHRcdGlmIChhbGlnbiAhPSBjdHhBbGlnbilcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSBjdHhBbGlnbiA9IGFsaWduO1xuXHRcdGlmIChiYXNlbGluZSAhPSBjdHhCYXNlbGluZSlcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBjdHhCYXNlbGluZSA9IGJhc2VsaW5lO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWNjU2NhbGUod3NjLCBwc2MsIGZhY2V0LCBkYXRhLCBzb3J0ZWQgPSAwKSB7XG5cdFx0aWYgKGRhdGEubGVuZ3RoID4gMCAmJiB3c2MuYXV0byhzZWxmLCB2aWFBdXRvU2NhbGVYKSAmJiAocHNjID09IG51bGwgfHwgcHNjLm1pbiA9PSBudWxsKSkge1xuXHRcdFx0bGV0IF9pMCA9IGlmTnVsbChpMCwgMCk7XG5cdFx0XHRsZXQgX2kxID0gaWZOdWxsKGkxLCBkYXRhLmxlbmd0aCAtIDEpO1xuXG5cdFx0XHQvLyBvbmx5IHJ1biBnZXRNaW5NYXgoKSBmb3IgaW52YWxpZGF0ZWQgc2VyaWVzIGRhdGEsIGVsc2UgcmV1c2Vcblx0XHRcdGxldCBtaW5NYXggPSBmYWNldC5taW4gPT0gbnVsbCA/ICh3c2MuZGlzdHIgPT0gMyA/IGdldE1pbk1heExvZyhkYXRhLCBfaTAsIF9pMSkgOiBnZXRNaW5NYXgoZGF0YSwgX2kwLCBfaTEsIHNvcnRlZCkpIDogW2ZhY2V0Lm1pbiwgZmFjZXQubWF4XTtcblxuXHRcdFx0Ly8gaW5pdGlhbCBtaW4vbWF4XG5cdFx0XHR3c2MubWluID0gbWluKHdzYy5taW4sIGZhY2V0Lm1pbiA9IG1pbk1heFswXSk7XG5cdFx0XHR3c2MubWF4ID0gbWF4KHdzYy5tYXgsIGZhY2V0Lm1heCA9IG1pbk1heFsxXSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0U2NhbGVzKCkge1xuXHQvL1x0bG9nKFwic2V0U2NhbGVzKClcIiwgYXJndW1lbnRzKTtcblxuXHRcdC8vIHdpcCBzY2FsZXNcblx0XHRsZXQgd2lwU2NhbGVzID0gY29weShzY2FsZXMsIGZhc3RJc09iaik7XG5cblx0XHRmb3IgKGxldCBrIGluIHdpcFNjYWxlcykge1xuXHRcdFx0bGV0IHdzYyA9IHdpcFNjYWxlc1trXTtcblx0XHRcdGxldCBwc2MgPSBwZW5kU2NhbGVzW2tdO1xuXG5cdFx0XHRpZiAocHNjICE9IG51bGwgJiYgcHNjLm1pbiAhPSBudWxsKSB7XG5cdFx0XHRcdGFzc2lnbih3c2MsIHBzYyk7XG5cblx0XHRcdFx0Ly8gZXhwbGljaXRseSBzZXR0aW5nIHRoZSB4LXNjYWxlIGludmFsaWRhdGVzIGV2ZXJ5dGhpbmcgKGFjdHMgYXMgcmVkcmF3KVxuXHRcdFx0XHRpZiAoayA9PSB4U2NhbGVLZXkpXG5cdFx0XHRcdFx0cmVzZXRZU2VyaWVzKHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoayAhPSB4U2NhbGVLZXkgfHwgbW9kZSA9PSAyKSB7XG5cdFx0XHRcdGlmIChkYXRhTGVuID09IDAgJiYgd3NjLmZyb20gPT0gbnVsbCkge1xuXHRcdFx0XHRcdGxldCBtaW5NYXggPSB3c2MucmFuZ2Uoc2VsZiwgbnVsbCwgbnVsbCwgayk7XG5cdFx0XHRcdFx0d3NjLm1pbiA9IG1pbk1heFswXTtcblx0XHRcdFx0XHR3c2MubWF4ID0gbWluTWF4WzFdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHdzYy5taW4gPSBpbmY7XG5cdFx0XHRcdFx0d3NjLm1heCA9IC1pbmY7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZGF0YUxlbiA+IDApIHtcblx0XHRcdC8vIHByZS1yYW5nZSB5LXNjYWxlcyBmcm9tIHkgc2VyaWVzJyBkYXRhIHZhbHVlc1xuXHRcdFx0c2VyaWVzLmZvckVhY2goKHMsIGkpID0+IHtcblx0XHRcdFx0aWYgKG1vZGUgPT0gMSkge1xuXHRcdFx0XHRcdGxldCBrID0gcy5zY2FsZTtcblx0XHRcdFx0XHRsZXQgd3NjID0gd2lwU2NhbGVzW2tdO1xuXHRcdFx0XHRcdGxldCBwc2MgPSBwZW5kU2NhbGVzW2tdO1xuXG5cdFx0XHRcdFx0aWYgKGkgPT0gMCkge1xuXHRcdFx0XHRcdFx0bGV0IG1pbk1heCA9IHdzYy5yYW5nZShzZWxmLCB3c2MubWluLCB3c2MubWF4LCBrKTtcblxuXHRcdFx0XHRcdFx0d3NjLm1pbiA9IG1pbk1heFswXTtcblx0XHRcdFx0XHRcdHdzYy5tYXggPSBtaW5NYXhbMV07XG5cblx0XHRcdFx0XHRcdGkwID0gY2xvc2VzdElkeCh3c2MubWluLCBkYXRhWzBdKTtcblx0XHRcdFx0XHRcdGkxID0gY2xvc2VzdElkeCh3c2MubWF4LCBkYXRhWzBdKTtcblxuXHRcdFx0XHRcdFx0Ly8gY2xvc2VzdCBpbmRpY2VzIGNhbiBiZSBvdXRzaWRlIG9mIHZpZXdcblx0XHRcdFx0XHRcdGlmIChkYXRhWzBdW2kwXSA8IHdzYy5taW4pXG5cdFx0XHRcdFx0XHRcdGkwKys7XG5cdFx0XHRcdFx0XHRpZiAoZGF0YVswXVtpMV0gPiB3c2MubWF4KVxuXHRcdFx0XHRcdFx0XHRpMS0tO1xuXG5cdFx0XHRcdFx0XHRzLm1pbiA9IGRhdGEwW2kwXTtcblx0XHRcdFx0XHRcdHMubWF4ID0gZGF0YTBbaTFdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChzLnNob3cgJiYgcy5hdXRvKVxuXHRcdFx0XHRcdFx0YWNjU2NhbGUod3NjLCBwc2MsIHMsIGRhdGFbaV0sIHMuc29ydGVkKTtcblxuXHRcdFx0XHRcdHMuaWR4c1swXSA9IGkwO1xuXHRcdFx0XHRcdHMuaWR4c1sxXSA9IGkxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmIChpID4gMCkge1xuXHRcdFx0XHRcdFx0aWYgKHMuc2hvdyAmJiBzLmF1dG8pIHtcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogb25seSBoYW5kbGVzLCBhc3N1bWVzIGFuZCByZXF1aXJlcyBmYWNldHNbMF0gLyAneCcgc2NhbGUsIGFuZCBmYWNldHNbMV0gLyAneScgc2NhbGVcblx0XHRcdFx0XHRcdFx0bGV0IFsgeEZhY2V0LCB5RmFjZXQgXSA9IHMuZmFjZXRzO1xuXHRcdFx0XHRcdFx0XHRsZXQgeFNjYWxlS2V5ID0geEZhY2V0LnNjYWxlO1xuXHRcdFx0XHRcdFx0XHRsZXQgeVNjYWxlS2V5ID0geUZhY2V0LnNjYWxlO1xuXHRcdFx0XHRcdFx0XHRsZXQgWyB4RGF0YSwgeURhdGEgXSA9IGRhdGFbaV07XG5cblx0XHRcdFx0XHRcdFx0YWNjU2NhbGUod2lwU2NhbGVzW3hTY2FsZUtleV0sIHBlbmRTY2FsZXNbeFNjYWxlS2V5XSwgeEZhY2V0LCB4RGF0YSwgeEZhY2V0LnNvcnRlZCk7XG5cdFx0XHRcdFx0XHRcdGFjY1NjYWxlKHdpcFNjYWxlc1t5U2NhbGVLZXldLCBwZW5kU2NhbGVzW3lTY2FsZUtleV0sIHlGYWNldCwgeURhdGEsIHlGYWNldC5zb3J0ZWQpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIHRlbXBcblx0XHRcdFx0XHRcdFx0cy5taW4gPSB5RmFjZXQubWluO1xuXHRcdFx0XHRcdFx0XHRzLm1heCA9IHlGYWNldC5tYXg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmFuZ2UgaW5kZXBlbmRlbnQgc2NhbGVzXG5cdFx0XHRmb3IgKGxldCBrIGluIHdpcFNjYWxlcykge1xuXHRcdFx0XHRsZXQgd3NjID0gd2lwU2NhbGVzW2tdO1xuXHRcdFx0XHRsZXQgcHNjID0gcGVuZFNjYWxlc1trXTtcblxuXHRcdFx0XHRpZiAod3NjLmZyb20gPT0gbnVsbCAmJiAocHNjID09IG51bGwgfHwgcHNjLm1pbiA9PSBudWxsKSkge1xuXHRcdFx0XHRcdGxldCBtaW5NYXggPSB3c2MucmFuZ2UoXG5cdFx0XHRcdFx0XHRzZWxmLFxuXHRcdFx0XHRcdFx0d3NjLm1pbiA9PSAgaW5mID8gbnVsbCA6IHdzYy5taW4sXG5cdFx0XHRcdFx0XHR3c2MubWF4ID09IC1pbmYgPyBudWxsIDogd3NjLm1heCxcblx0XHRcdFx0XHRcdGtcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHdzYy5taW4gPSBtaW5NYXhbMF07XG5cdFx0XHRcdFx0d3NjLm1heCA9IG1pbk1heFsxXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHJhbmdlIGRlcGVuZGVudCBzY2FsZXNcblx0XHRmb3IgKGxldCBrIGluIHdpcFNjYWxlcykge1xuXHRcdFx0bGV0IHdzYyA9IHdpcFNjYWxlc1trXTtcblxuXHRcdFx0aWYgKHdzYy5mcm9tICE9IG51bGwpIHtcblx0XHRcdFx0bGV0IGJhc2UgPSB3aXBTY2FsZXNbd3NjLmZyb21dO1xuXG5cdFx0XHRcdGlmIChiYXNlLm1pbiA9PSBudWxsKVxuXHRcdFx0XHRcdHdzYy5taW4gPSB3c2MubWF4ID0gbnVsbDtcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0bGV0IG1pbk1heCA9IHdzYy5yYW5nZShzZWxmLCBiYXNlLm1pbiwgYmFzZS5tYXgsIGspO1xuXHRcdFx0XHRcdHdzYy5taW4gPSBtaW5NYXhbMF07XG5cdFx0XHRcdFx0d3NjLm1heCA9IG1pbk1heFsxXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCBjaGFuZ2VkID0ge307XG5cdFx0bGV0IGFueUNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdGZvciAobGV0IGsgaW4gd2lwU2NhbGVzKSB7XG5cdFx0XHRsZXQgd3NjID0gd2lwU2NhbGVzW2tdO1xuXHRcdFx0bGV0IHNjID0gc2NhbGVzW2tdO1xuXG5cdFx0XHRpZiAoc2MubWluICE9IHdzYy5taW4gfHwgc2MubWF4ICE9IHdzYy5tYXgpIHtcblx0XHRcdFx0c2MubWluID0gd3NjLm1pbjtcblx0XHRcdFx0c2MubWF4ID0gd3NjLm1heDtcblxuXHRcdFx0XHRsZXQgZGlzdHIgPSBzYy5kaXN0cjtcblxuXHRcdFx0XHRzYy5fbWluID0gZGlzdHIgPT0gMyA/IGxvZzEwKHNjLm1pbikgOiBkaXN0ciA9PSA0ID8gYXNpbmgoc2MubWluLCBzYy5hc2luaCkgOiBzYy5taW47XG5cdFx0XHRcdHNjLl9tYXggPSBkaXN0ciA9PSAzID8gbG9nMTAoc2MubWF4KSA6IGRpc3RyID09IDQgPyBhc2luaChzYy5tYXgsIHNjLmFzaW5oKSA6IHNjLm1heDtcblxuXHRcdFx0XHRjaGFuZ2VkW2tdID0gYW55Q2hhbmdlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGFueUNoYW5nZWQpIHtcblx0XHRcdC8vIGludmFsaWRhdGUgcGF0aHMgb2YgYWxsIHNlcmllcyBvbiBjaGFuZ2VkIHNjYWxlc1xuXHRcdFx0c2VyaWVzLmZvckVhY2goKHMsIGkpID0+IHtcblx0XHRcdFx0aWYgKG1vZGUgPT0gMikge1xuXHRcdFx0XHRcdGlmIChpID4gMCAmJiBjaGFuZ2VkLnkpXG5cdFx0XHRcdFx0XHRzLl9wYXRocyA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGNoYW5nZWRbcy5zY2FsZV0pXG5cdFx0XHRcdFx0XHRzLl9wYXRocyA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRmb3IgKGxldCBrIGluIGNoYW5nZWQpIHtcblx0XHRcdFx0c2hvdWxkQ29udmVyZ2VTaXplID0gdHJ1ZTtcblx0XHRcdFx0ZmlyZShcInNldFNjYWxlXCIsIGspO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY3Vyc29yLnNob3cpXG5cdFx0XHRcdHNob3VsZFNldEN1cnNvciA9IHNob3VsZFNldExlZ2VuZCA9IGN1cnNvci5sZWZ0ID49IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgayBpbiBwZW5kU2NhbGVzKVxuXHRcdFx0cGVuZFNjYWxlc1trXSA9IG51bGw7XG5cdH1cblxuXHQvLyBncmFicyB0aGUgbmVhcmVzdCBpbmRpY2VzIHdpdGggeSBkYXRhIG91dHNpZGUgb2YgeC1zY2FsZSBsaW1pdHNcblx0ZnVuY3Rpb24gZ2V0T3V0ZXJJZHhzKHlkYXRhKSB7XG5cdFx0bGV0IF9pMCA9IGNsYW1wKGkwIC0gMSwgMCwgZGF0YUxlbiAtIDEpO1xuXHRcdGxldCBfaTEgPSBjbGFtcChpMSArIDEsIDAsIGRhdGFMZW4gLSAxKTtcblxuXHRcdHdoaWxlICh5ZGF0YVtfaTBdID09IG51bGwgJiYgX2kwID4gMClcblx0XHRcdF9pMC0tO1xuXG5cdFx0d2hpbGUgKHlkYXRhW19pMV0gPT0gbnVsbCAmJiBfaTEgPCBkYXRhTGVuIC0gMSlcblx0XHRcdF9pMSsrO1xuXG5cdFx0cmV0dXJuIFtfaTAsIF9pMV07XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3U2VyaWVzKCkge1xuXHRcdGlmIChkYXRhTGVuID4gMCkge1xuXHRcdFx0c2VyaWVzLmZvckVhY2goKHMsIGkpID0+IHtcblx0XHRcdFx0aWYgKGkgPiAwICYmIHMuc2hvdyAmJiBzLl9wYXRocyA9PSBudWxsKSB7XG5cdFx0XHRcdFx0bGV0IF9pZHhzID0gZ2V0T3V0ZXJJZHhzKGRhdGFbaV0pO1xuXHRcdFx0XHRcdHMuX3BhdGhzID0gcy5wYXRocyhzZWxmLCBpLCBfaWR4c1swXSwgX2lkeHNbMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0c2VyaWVzLmZvckVhY2goKHMsIGkpID0+IHtcblx0XHRcdFx0aWYgKGkgPiAwICYmIHMuc2hvdykge1xuXHRcdFx0XHRcdGlmIChjdHhBbHBoYSAhPSBzLmFscGhhKVxuXHRcdFx0XHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gY3R4QWxwaGEgPSBzLmFscGhhO1xuXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y2FjaGVTdHJva2VGaWxsKGksIGZhbHNlKTtcblx0XHRcdFx0XHRcdHMuX3BhdGhzICYmIGRyYXdQYXRoKGksIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjYWNoZVN0cm9rZUZpbGwoaSwgdHJ1ZSk7XG5cblx0XHRcdFx0XHRcdGxldCBzaG93ID0gcy5wb2ludHMuc2hvdyhzZWxmLCBpLCBpMCwgaTEpO1xuXHRcdFx0XHRcdFx0bGV0IGlkeHMgPSBzLnBvaW50cy5maWx0ZXIoc2VsZiwgaSwgc2hvdywgcy5fcGF0aHMgPyBzLl9wYXRocy5nYXBzIDogbnVsbCk7XG5cblx0XHRcdFx0XHRcdGlmIChzaG93IHx8IGlkeHMpIHtcblx0XHRcdFx0XHRcdFx0cy5wb2ludHMuX3BhdGhzID0gcy5wb2ludHMucGF0aHMoc2VsZiwgaSwgaTAsIGkxLCBpZHhzKTtcblx0XHRcdFx0XHRcdFx0ZHJhd1BhdGgoaSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGN0eEFscGhhICE9IDEpXG5cdFx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBjdHhBbHBoYSA9IDE7XG5cblx0XHRcdFx0XHRmaXJlKFwiZHJhd1Nlcmllc1wiLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY2FjaGVTdHJva2VGaWxsKHNpLCBfcG9pbnRzKSB7XG5cdFx0bGV0IHMgPSBfcG9pbnRzID8gc2VyaWVzW3NpXS5wb2ludHMgOiBzZXJpZXNbc2ldO1xuXG5cdFx0cy5fc3Ryb2tlID0gcy5zdHJva2Uoc2VsZiwgc2kpO1xuXHRcdHMuX2ZpbGwgICA9IHMuZmlsbChzZWxmLCBzaSk7XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3UGF0aChzaSwgX3BvaW50cykge1xuXHRcdGxldCBzID0gX3BvaW50cyA/IHNlcmllc1tzaV0ucG9pbnRzIDogc2VyaWVzW3NpXTtcblxuXHRcdGxldCBzdHJva2VTdHlsZSA9IHMuX3N0cm9rZTtcblx0XHRsZXQgZmlsbFN0eWxlICAgPSBzLl9maWxsO1xuXG5cdFx0bGV0IHsgc3Ryb2tlLCBmaWxsLCBjbGlwOiBnYXBzQ2xpcCwgZmxhZ3MgfSA9IHMuX3BhdGhzO1xuXHRcdGxldCBib3VuZHNDbGlwID0gbnVsbDtcblx0XHRsZXQgd2lkdGggPSByb3VuZERlYyhzLndpZHRoICogcHhSYXRpbywgMyk7XG5cdFx0bGV0IG9mZnNldCA9ICh3aWR0aCAlIDIpIC8gMjtcblxuXHRcdGlmIChfcG9pbnRzICYmIGZpbGxTdHlsZSA9PSBudWxsKVxuXHRcdFx0ZmlsbFN0eWxlID0gd2lkdGggPiAwID8gXCIjZmZmXCIgOiBzdHJva2VTdHlsZTtcblxuXHRcdGxldCBfcHhBbGlnbiA9IHMucHhBbGlnbiA9PSAxO1xuXG5cdFx0X3B4QWxpZ24gJiYgY3R4LnRyYW5zbGF0ZShvZmZzZXQsIG9mZnNldCk7XG5cblx0XHRpZiAoIV9wb2ludHMpIHtcblx0XHRcdGxldCBsZnQgPSBwbG90TGZ0LFxuXHRcdFx0XHR0b3AgPSBwbG90VG9wLFxuXHRcdFx0XHR3aWQgPSBwbG90V2lkLFxuXHRcdFx0XHRoZ3QgPSBwbG90SGd0O1xuXG5cdFx0XHRsZXQgaGFsZldpZCA9IHdpZHRoICogcHhSYXRpbyAvIDI7XG5cblx0XHRcdGlmIChzLm1pbiA9PSAwKVxuXHRcdFx0XHRoZ3QgKz0gaGFsZldpZDtcblxuXHRcdFx0aWYgKHMubWF4ID09IDApIHtcblx0XHRcdFx0dG9wIC09IGhhbGZXaWQ7XG5cdFx0XHRcdGhndCArPSBoYWxmV2lkO1xuXHRcdFx0fVxuXG5cdFx0XHRib3VuZHNDbGlwID0gbmV3IFBhdGgyRCgpO1xuXHRcdFx0Ym91bmRzQ2xpcC5yZWN0KGxmdCwgdG9wLCB3aWQsIGhndCk7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIHBvaW50cyBwYXRoYnVpbGRlcidzIGdhcHNDbGlwIGlzIGl0cyBib3VuZHNDbGlwLCBzaW5jZSBwb2ludHMgZG9udCBuZWVkIGdhcHMgY2xpcHBpbmcsIGFuZCBib3VuZHMgZGVwZW5kIG9uIHBvaW50IHNpemVcblx0XHRpZiAoX3BvaW50cylcblx0XHRcdHN0cm9rZUZpbGwoc3Ryb2tlU3R5bGUsIHdpZHRoLCBzLmRhc2gsIHMuY2FwLCBmaWxsU3R5bGUsIHN0cm9rZSwgZmlsbCwgZmxhZ3MsIGdhcHNDbGlwKTtcblx0XHRlbHNlXG5cdFx0XHRmaWxsU3Ryb2tlKHNpLCBzdHJva2VTdHlsZSwgd2lkdGgsIHMuZGFzaCwgcy5jYXAsIGZpbGxTdHlsZSwgc3Ryb2tlLCBmaWxsLCBmbGFncywgYm91bmRzQ2xpcCwgZ2Fwc0NsaXApO1xuXG5cdFx0X3B4QWxpZ24gJiYgY3R4LnRyYW5zbGF0ZSgtb2Zmc2V0LCAtb2Zmc2V0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGZpbGxTdHJva2Uoc2ksIHN0cm9rZVN0eWxlLCBsaW5lV2lkdGgsIGxpbmVEYXNoLCBsaW5lQ2FwLCBmaWxsU3R5bGUsIHN0cm9rZVBhdGgsIGZpbGxQYXRoLCBmbGFncywgYm91bmRzQ2xpcCwgZ2Fwc0NsaXApIHtcblx0XHRsZXQgZGlkU3Ryb2tlRmlsbCA9IGZhbHNlO1xuXG5cdFx0Ly8gZm9yIGFsbCBiYW5kcyB3aGVyZSB0aGlzIHNlcmllcyBpcyB0aGUgdG9wIGVkZ2UsIGNyZWF0ZSB1cHdhcmRzIGNsaXBzIHVzaW5nIHRoZSBib3R0b20gZWRnZXNcblx0XHQvLyBhbmQgYXBwbHkgY2xpcHMgKyBmaWxsIHdpdGggYmFuZCBmaWxsIG9yIGRmbHRGaWxsXG5cdFx0YmFuZHMuZm9yRWFjaCgoYiwgYmkpID0+IHtcblx0XHRcdC8vIGlzVXBwZXJFZGdlP1xuXHRcdFx0aWYgKGIuc2VyaWVzWzBdID09IHNpKSB7XG5cdFx0XHRcdGxldCBsb3dlckVkZ2UgPSBzZXJpZXNbYi5zZXJpZXNbMV1dO1xuXHRcdFx0XHRsZXQgbG93ZXJEYXRhID0gZGF0YVtiLnNlcmllc1sxXV07XG5cblx0XHRcdFx0bGV0IGJhbmRDbGlwID0gKGxvd2VyRWRnZS5fcGF0aHMgfHwgRU1QVFlfT0JKKS5iYW5kO1xuXG5cdFx0XHRcdGlmIChpc0FycihiYW5kQ2xpcCkpXG5cdFx0XHRcdFx0YmFuZENsaXAgPSBiLmRpciA9PSAxID8gYmFuZENsaXBbMF0gOiBiYW5kQ2xpcFsxXTtcblxuXHRcdFx0XHRsZXQgZ2Fwc0NsaXAyO1xuXG5cdFx0XHRcdGxldCBfZmlsbFN0eWxlID0gbnVsbDtcblxuXHRcdFx0XHQvLyBoYXNMb3dlckVkZ2U/XG5cdFx0XHRcdGlmIChsb3dlckVkZ2Uuc2hvdyAmJiBiYW5kQ2xpcCAmJiBoYXNEYXRhKGxvd2VyRGF0YSwgaTAsIGkxKSkge1xuXHRcdFx0XHRcdF9maWxsU3R5bGUgPSBiLmZpbGwoc2VsZiwgYmkpIHx8IGZpbGxTdHlsZTtcblx0XHRcdFx0XHRnYXBzQ2xpcDIgPSBsb3dlckVkZ2UuX3BhdGhzLmNsaXA7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGJhbmRDbGlwID0gbnVsbDtcblxuXHRcdFx0XHRzdHJva2VGaWxsKHN0cm9rZVN0eWxlLCBsaW5lV2lkdGgsIGxpbmVEYXNoLCBsaW5lQ2FwLCBfZmlsbFN0eWxlLCBzdHJva2VQYXRoLCBmaWxsUGF0aCwgZmxhZ3MsIGJvdW5kc0NsaXAsIGdhcHNDbGlwLCBnYXBzQ2xpcDIsIGJhbmRDbGlwKTtcblxuXHRcdFx0XHRkaWRTdHJva2VGaWxsID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmICghZGlkU3Ryb2tlRmlsbClcblx0XHRcdHN0cm9rZUZpbGwoc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCwgbGluZURhc2gsIGxpbmVDYXAsIGZpbGxTdHlsZSwgc3Ryb2tlUGF0aCwgZmlsbFBhdGgsIGZsYWdzLCBib3VuZHNDbGlwLCBnYXBzQ2xpcCk7XG5cdH1cblxuXHRjb25zdCBDTElQX0ZJTExfU1RST0tFID0gQkFORF9DTElQX0ZJTEwgfCBCQU5EX0NMSVBfU1RST0tFO1xuXG5cdGZ1bmN0aW9uIHN0cm9rZUZpbGwoc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCwgbGluZURhc2gsIGxpbmVDYXAsIGZpbGxTdHlsZSwgc3Ryb2tlUGF0aCwgZmlsbFBhdGgsIGZsYWdzLCBib3VuZHNDbGlwLCBnYXBzQ2xpcCwgZ2Fwc0NsaXAyLCBiYW5kQ2xpcCkge1xuXHRcdHNldEN0eFN0eWxlKHN0cm9rZVN0eWxlLCBsaW5lV2lkdGgsIGxpbmVEYXNoLCBsaW5lQ2FwLCBmaWxsU3R5bGUpO1xuXG5cdFx0aWYgKGJvdW5kc0NsaXAgfHwgZ2Fwc0NsaXAgfHwgYmFuZENsaXApIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRib3VuZHNDbGlwICYmIGN0eC5jbGlwKGJvdW5kc0NsaXApO1xuXHRcdFx0Z2Fwc0NsaXAgJiYgY3R4LmNsaXAoZ2Fwc0NsaXApO1xuXHRcdH1cblxuXHRcdGlmIChiYW5kQ2xpcCkge1xuXHRcdFx0aWYgKChmbGFncyAmIENMSVBfRklMTF9TVFJPS0UpID09IENMSVBfRklMTF9TVFJPS0UpIHtcblx0XHRcdFx0Y3R4LmNsaXAoYmFuZENsaXApO1xuXHRcdFx0XHRnYXBzQ2xpcDIgJiYgY3R4LmNsaXAoZ2Fwc0NsaXAyKTtcblx0XHRcdFx0ZG9GaWxsKGZpbGxTdHlsZSwgZmlsbFBhdGgpO1xuXHRcdFx0XHRkb1N0cm9rZShzdHJva2VTdHlsZSwgc3Ryb2tlUGF0aCwgbGluZVdpZHRoKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGZsYWdzICYgQkFORF9DTElQX1NUUk9LRSkge1xuXHRcdFx0XHRkb0ZpbGwoZmlsbFN0eWxlLCBmaWxsUGF0aCk7XG5cdFx0XHRcdGN0eC5jbGlwKGJhbmRDbGlwKTtcblx0XHRcdFx0ZG9TdHJva2Uoc3Ryb2tlU3R5bGUsIHN0cm9rZVBhdGgsIGxpbmVXaWR0aCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChmbGFncyAmIEJBTkRfQ0xJUF9GSUxMKSB7XG5cdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdGN0eC5jbGlwKGJhbmRDbGlwKTtcblx0XHRcdFx0Z2Fwc0NsaXAyICYmIGN0eC5jbGlwKGdhcHNDbGlwMik7XG5cdFx0XHRcdGRvRmlsbChmaWxsU3R5bGUsIGZpbGxQYXRoKTtcblx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdFx0ZG9TdHJva2Uoc3Ryb2tlU3R5bGUsIHN0cm9rZVBhdGgsIGxpbmVXaWR0aCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZG9GaWxsKGZpbGxTdHlsZSwgZmlsbFBhdGgpO1xuXHRcdFx0ZG9TdHJva2Uoc3Ryb2tlU3R5bGUsIHN0cm9rZVBhdGgsIGxpbmVXaWR0aCk7XG5cdFx0fVxuXG5cdFx0aWYgKGJvdW5kc0NsaXAgfHwgZ2Fwc0NsaXAgfHwgYmFuZENsaXApXG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZG9TdHJva2Uoc3Ryb2tlU3R5bGUsIHN0cm9rZVBhdGgsIGxpbmVXaWR0aCkge1xuXHRcdGlmIChsaW5lV2lkdGggPiAwKSB7XG5cdFx0XHRpZiAoc3Ryb2tlUGF0aCBpbnN0YW5jZW9mIE1hcCkge1xuXHRcdFx0XHRzdHJva2VQYXRoLmZvckVhY2goKHN0cm9rZVBhdGgsIHN0cm9rZVN0eWxlKSA9PiB7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY3R4U3Ryb2tlID0gc3Ryb2tlU3R5bGU7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZShzdHJva2VQYXRoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHN0cm9rZVBhdGggIT0gbnVsbCAmJiBzdHJva2VTdHlsZSAmJiBjdHguc3Ryb2tlKHN0cm9rZVBhdGgpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRvRmlsbChmaWxsU3R5bGUsIGZpbGxQYXRoKSB7XG5cdFx0aWYgKGZpbGxQYXRoIGluc3RhbmNlb2YgTWFwKSB7XG5cdFx0XHRmaWxsUGF0aC5mb3JFYWNoKChmaWxsUGF0aCwgZmlsbFN0eWxlKSA9PiB7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBjdHhGaWxsID0gZmlsbFN0eWxlO1xuXHRcdFx0XHRjdHguZmlsbChmaWxsUGF0aCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdFx0ZmlsbFBhdGggIT0gbnVsbCAmJiBmaWxsU3R5bGUgJiYgY3R4LmZpbGwoZmlsbFBhdGgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SW5jclNwYWNlKGF4aXNJZHgsIG1pbiwgbWF4LCBmdWxsRGltKSB7XG5cdFx0bGV0IGF4aXMgPSBheGVzW2F4aXNJZHhdO1xuXG5cdFx0bGV0IGluY3JTcGFjZTtcblxuXHRcdGlmIChmdWxsRGltIDw9IDApXG5cdFx0XHRpbmNyU3BhY2UgPSBbMCwgMF07XG5cdFx0ZWxzZSB7XG5cdFx0XHRsZXQgbWluU3BhY2UgPSBheGlzLl9zcGFjZSA9IGF4aXMuc3BhY2Uoc2VsZiwgYXhpc0lkeCwgbWluLCBtYXgsIGZ1bGxEaW0pO1xuXHRcdFx0bGV0IGluY3JzICAgID0gYXhpcy5faW5jcnMgPSBheGlzLmluY3JzKHNlbGYsIGF4aXNJZHgsIG1pbiwgbWF4LCBmdWxsRGltLCBtaW5TcGFjZSk7XG5cdFx0XHRpbmNyU3BhY2UgICAgPSBmaW5kSW5jcihtaW4sIG1heCwgaW5jcnMsIGZ1bGxEaW0sIG1pblNwYWNlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKGF4aXMuX2ZvdW5kID0gaW5jclNwYWNlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRyYXdPcnRob0xpbmVzKG9mZnMsIGZpbHRzLCBvcmksIHNpZGUsIHBvczAsIGxlbiwgd2lkdGgsIHN0cm9rZSwgZGFzaCwgY2FwKSB7XG5cdFx0bGV0IG9mZnNldCA9ICh3aWR0aCAlIDIpIC8gMjtcblxuXHRcdHB4QWxpZ24gPT0gMSAmJiBjdHgudHJhbnNsYXRlKG9mZnNldCwgb2Zmc2V0KTtcblxuXHRcdHNldEN0eFN0eWxlKHN0cm9rZSwgd2lkdGgsIGRhc2gsIGNhcCwgc3Ryb2tlKTtcblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdGxldCB4MCwgeTAsIHgxLCB5MSwgcG9zMSA9IHBvczAgKyAoc2lkZSA9PSAwIHx8IHNpZGUgPT0gMyA/IC1sZW4gOiBsZW4pO1xuXG5cdFx0aWYgKG9yaSA9PSAwKSB7XG5cdFx0XHR5MCA9IHBvczA7XG5cdFx0XHR5MSA9IHBvczE7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0eDAgPSBwb3MwO1xuXHRcdFx0eDEgPSBwb3MxO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgb2Zmcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGZpbHRzW2ldICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKG9yaSA9PSAwKVxuXHRcdFx0XHRcdHgwID0geDEgPSBvZmZzW2ldO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0eTAgPSB5MSA9IG9mZnNbaV07XG5cblx0XHRcdFx0Y3R4Lm1vdmVUbyh4MCwgeTApO1xuXHRcdFx0XHRjdHgubGluZVRvKHgxLCB5MSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y3R4LnN0cm9rZSgpO1xuXG5cdFx0cHhBbGlnbiA9PSAxICYmIGN0eC50cmFuc2xhdGUoLW9mZnNldCwgLW9mZnNldCk7XG5cdH1cblxuXHRmdW5jdGlvbiBheGVzQ2FsYyhjeWNsZU51bSkge1xuXHQvL1x0bG9nKFwiYXhlc0NhbGMoKVwiLCBhcmd1bWVudHMpO1xuXG5cdFx0bGV0IGNvbnZlcmdlZCA9IHRydWU7XG5cblx0XHRheGVzLmZvckVhY2goKGF4aXMsIGkpID0+IHtcblx0XHRcdGlmICghYXhpcy5zaG93KVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGxldCBzY2FsZSA9IHNjYWxlc1theGlzLnNjYWxlXTtcblxuXHRcdFx0aWYgKHNjYWxlLm1pbiA9PSBudWxsKSB7XG5cdFx0XHRcdGlmIChheGlzLl9zaG93KSB7XG5cdFx0XHRcdFx0Y29udmVyZ2VkID0gZmFsc2U7XG5cdFx0XHRcdFx0YXhpcy5fc2hvdyA9IGZhbHNlO1xuXHRcdFx0XHRcdHJlc2V0WVNlcmllcyhmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmICghYXhpcy5fc2hvdykge1xuXHRcdFx0XHRcdGNvbnZlcmdlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdGF4aXMuX3Nob3cgPSB0cnVlO1xuXHRcdFx0XHRcdHJlc2V0WVNlcmllcyhmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bGV0IHNpZGUgPSBheGlzLnNpZGU7XG5cdFx0XHRsZXQgb3JpID0gc2lkZSAlIDI7XG5cblx0XHRcdGxldCB7bWluLCBtYXh9ID0gc2NhbGU7XHRcdC8vIFx0XHQvLyBzaG91bGQgdGhpcyB0b2dnbGUgdGhlbSAuX3Nob3cgPSBmYWxzZVxuXG5cdFx0XHRsZXQgW19pbmNyLCBfc3BhY2VdID0gZ2V0SW5jclNwYWNlKGksIG1pbiwgbWF4LCBvcmkgPT0gMCA/IHBsb3RXaWRDc3MgOiBwbG90SGd0Q3NzKTtcblxuXHRcdFx0aWYgKF9zcGFjZSA9PSAwKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdC8vIGlmIHdlJ3JlIHVzaW5nIGluZGV4IHBvc2l0aW9ucywgZm9yY2UgZmlyc3QgdGljayB0byBtYXRjaCBwYXNzZWQgaW5kZXhcblx0XHRcdGxldCBmb3JjZU1pbiA9IHNjYWxlLmRpc3RyID09IDI7XG5cblx0XHRcdGxldCBfc3BsaXRzID0gYXhpcy5fc3BsaXRzID0gYXhpcy5zcGxpdHMoc2VsZiwgaSwgbWluLCBtYXgsIF9pbmNyLCBfc3BhY2UsIGZvcmNlTWluKTtcblxuXHRcdFx0Ly8gdGljayBsYWJlbHNcblx0XHRcdC8vIEJPTyB0aGlzIGFzc3VtZXMgYSBzcGVjaWZpYyBkYXRhL3Nlcmllc1xuXHRcdFx0bGV0IHNwbGl0cyA9IHNjYWxlLmRpc3RyID09IDIgPyBfc3BsaXRzLm1hcChpID0+IGRhdGEwW2ldKSA6IF9zcGxpdHM7XG5cdFx0XHRsZXQgaW5jciAgID0gc2NhbGUuZGlzdHIgPT0gMiA/IGRhdGEwW19zcGxpdHNbMV1dIC0gZGF0YTBbX3NwbGl0c1swXV0gOiBfaW5jcjtcblxuXHRcdFx0bGV0IHZhbHVlcyA9IGF4aXMuX3ZhbHVlcyA9IGF4aXMudmFsdWVzKHNlbGYsIGF4aXMuZmlsdGVyKHNlbGYsIHNwbGl0cywgaSwgX3NwYWNlLCBpbmNyKSwgaSwgX3NwYWNlLCBpbmNyKTtcblxuXHRcdFx0Ly8gcm90YXRpbmcgb2YgbGFiZWxzIG9ubHkgc3VwcG9ydGVkIG9uIGJvdHRvbSB4IGF4aXNcblx0XHRcdGF4aXMuX3JvdGF0ZSA9IHNpZGUgPT0gMiA/IGF4aXMucm90YXRlKHNlbGYsIHZhbHVlcywgaSwgX3NwYWNlKSA6IDA7XG5cblx0XHRcdGxldCBvbGRTaXplID0gYXhpcy5fc2l6ZTtcblxuXHRcdFx0YXhpcy5fc2l6ZSA9IGNlaWwoYXhpcy5zaXplKHNlbGYsIHZhbHVlcywgaSwgY3ljbGVOdW0pKTtcblxuXHRcdFx0aWYgKG9sZFNpemUgIT0gbnVsbCAmJiBheGlzLl9zaXplICE9IG9sZFNpemUpXHRcdFx0Ly8gcmVhZHkgJiYgP1xuXHRcdFx0XHRjb252ZXJnZWQgPSBmYWxzZTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBjb252ZXJnZWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBwYWRkaW5nQ2FsYyhjeWNsZU51bSkge1xuXHRcdGxldCBjb252ZXJnZWQgPSB0cnVlO1xuXG5cdFx0cGFkZGluZy5mb3JFYWNoKChwLCBpKSA9PiB7XG5cdFx0XHRsZXQgX3AgPSBwKHNlbGYsIGksIHNpZGVzV2l0aEF4ZXMsIGN5Y2xlTnVtKTtcblxuXHRcdFx0aWYgKF9wICE9IF9wYWRkaW5nW2ldKVxuXHRcdFx0XHRjb252ZXJnZWQgPSBmYWxzZTtcblxuXHRcdFx0X3BhZGRpbmdbaV0gPSBfcDtcblx0XHR9KTtcblxuXHRcdHJldHVybiBjb252ZXJnZWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3QXhlc0dyaWQoKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgYXhpcyA9IGF4ZXNbaV07XG5cblx0XHRcdGlmICghYXhpcy5zaG93IHx8ICFheGlzLl9zaG93KVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0bGV0IHNpZGUgPSBheGlzLnNpZGU7XG5cdFx0XHRsZXQgb3JpID0gc2lkZSAlIDI7XG5cblx0XHRcdGxldCB4LCB5O1xuXG5cdFx0XHRsZXQgZmlsbFN0eWxlID0gYXhpcy5zdHJva2Uoc2VsZiwgaSk7XG5cblx0XHRcdGxldCBzaGlmdERpciA9IHNpZGUgPT0gMCB8fCBzaWRlID09IDMgPyAtMSA6IDE7XG5cblx0XHRcdC8vIGF4aXMgbGFiZWxcblx0XHRcdGlmIChheGlzLmxhYmVsKSB7XG5cdFx0XHRcdGxldCBzaGlmdEFtdCA9IGF4aXMubGFiZWxHYXAgKiBzaGlmdERpcjtcblx0XHRcdFx0bGV0IGJhc2VMcG9zID0gcm91bmQoKGF4aXMuX2xwb3MgKyBzaGlmdEFtdCkgKiBweFJhdGlvKTtcblxuXHRcdFx0XHRzZXRGb250U3R5bGUoYXhpcy5sYWJlbEZvbnRbMF0sIGZpbGxTdHlsZSwgXCJjZW50ZXJcIiwgc2lkZSA9PSAyID8gVE9QIDogQk9UVE9NKTtcblxuXHRcdFx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0XHRcdGlmIChvcmkgPT0gMSkge1xuXHRcdFx0XHRcdHggPSB5ID0gMDtcblxuXHRcdFx0XHRcdGN0eC50cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRiYXNlTHBvcyxcblx0XHRcdFx0XHRcdHJvdW5kKHBsb3RUb3AgKyBwbG90SGd0IC8gMiksXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRjdHgucm90YXRlKChzaWRlID09IDMgPyAtUEkgOiBQSSkgLyAyKTtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHggPSByb3VuZChwbG90TGZ0ICsgcGxvdFdpZCAvIDIpO1xuXHRcdFx0XHRcdHkgPSBiYXNlTHBvcztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN0eC5maWxsVGV4dChheGlzLmxhYmVsLCB4LCB5KTtcblxuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgW19pbmNyLCBfc3BhY2VdID0gYXhpcy5fZm91bmQ7XG5cblx0XHRcdGlmIChfc3BhY2UgPT0gMClcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdGxldCBzY2FsZSA9IHNjYWxlc1theGlzLnNjYWxlXTtcblxuXHRcdFx0bGV0IHBsb3REaW0gPSBvcmkgPT0gMCA/IHBsb3RXaWQgOiBwbG90SGd0O1xuXHRcdFx0bGV0IHBsb3RPZmYgPSBvcmkgPT0gMCA/IHBsb3RMZnQgOiBwbG90VG9wO1xuXG5cdFx0XHRsZXQgYXhpc0dhcCA9IHJvdW5kKGF4aXMuZ2FwICogcHhSYXRpbyk7XG5cblx0XHRcdGxldCBfc3BsaXRzID0gYXhpcy5fc3BsaXRzO1xuXG5cdFx0XHQvLyB0aWNrIGxhYmVsc1xuXHRcdFx0Ly8gQk9PIHRoaXMgYXNzdW1lcyBhIHNwZWNpZmljIGRhdGEvc2VyaWVzXG5cdFx0XHRsZXQgc3BsaXRzID0gc2NhbGUuZGlzdHIgPT0gMiA/IF9zcGxpdHMubWFwKGkgPT4gZGF0YTBbaV0pIDogX3NwbGl0cztcblx0XHRcdGxldCBpbmNyICAgPSBzY2FsZS5kaXN0ciA9PSAyID8gZGF0YTBbX3NwbGl0c1sxXV0gLSBkYXRhMFtfc3BsaXRzWzBdXSA6IF9pbmNyO1xuXG5cdFx0XHRsZXQgdGlja3MgPSBheGlzLnRpY2tzO1xuXHRcdFx0bGV0IGJvcmRlciA9IGF4aXMuYm9yZGVyO1xuXHRcdFx0bGV0IHRpY2tTaXplID0gdGlja3Muc2hvdyA/IHJvdW5kKHRpY2tzLnNpemUgKiBweFJhdGlvKSA6IDA7XG5cblx0XHRcdC8vIHJvdGF0aW5nIG9mIGxhYmVscyBvbmx5IHN1cHBvcnRlZCBvbiBib3R0b20geCBheGlzXG5cdFx0XHRsZXQgYW5nbGUgPSBheGlzLl9yb3RhdGUgKiAtUEkvMTgwO1xuXG5cdFx0XHRsZXQgYmFzZVBvcyAgPSBweFJvdW5kKGF4aXMuX3BvcyAqIHB4UmF0aW8pO1xuXHRcdFx0bGV0IHNoaWZ0QW10ID0gKHRpY2tTaXplICsgYXhpc0dhcCkgKiBzaGlmdERpcjtcblx0XHRcdGxldCBmaW5hbFBvcyA9IGJhc2VQb3MgKyBzaGlmdEFtdDtcblx0XHRcdCAgICB5ICAgICAgICA9IG9yaSA9PSAwID8gZmluYWxQb3MgOiAwO1xuXHRcdFx0ICAgIHggICAgICAgID0gb3JpID09IDEgPyBmaW5hbFBvcyA6IDA7XG5cblx0XHRcdGxldCBmb250ICAgICAgICAgPSBheGlzLmZvbnRbMF07XG5cdFx0XHRsZXQgdGV4dEFsaWduICAgID0gYXhpcy5hbGlnbiA9PSAxID8gTEVGVCA6XG5cdFx0XHQgICAgICAgICAgICAgICAgICAgYXhpcy5hbGlnbiA9PSAyID8gUklHSFQgOlxuXHRcdFx0ICAgICAgICAgICAgICAgICAgIGFuZ2xlID4gMCA/IExFRlQgOlxuXHRcdFx0ICAgICAgICAgICAgICAgICAgIGFuZ2xlIDwgMCA/IFJJR0hUIDpcblx0XHRcdCAgICAgICAgICAgICAgICAgICBvcmkgPT0gMCA/IFwiY2VudGVyXCIgOiBzaWRlID09IDMgPyBSSUdIVCA6IExFRlQ7XG5cdFx0XHRsZXQgdGV4dEJhc2VsaW5lID0gYW5nbGUgfHxcblx0XHRcdCAgICAgICAgICAgICAgICAgICBvcmkgPT0gMSA/IFwibWlkZGxlXCIgOiBzaWRlID09IDIgPyBUT1AgICA6IEJPVFRPTTtcblxuXHRcdFx0c2V0Rm9udFN0eWxlKGZvbnQsIGZpbGxTdHlsZSwgdGV4dEFsaWduLCB0ZXh0QmFzZWxpbmUpO1xuXG5cdFx0XHRsZXQgbGluZUhlaWdodCA9IGF4aXMuZm9udFsxXSAqIGxpbmVNdWx0O1xuXG5cdFx0XHRsZXQgY2FuT2ZmcyA9IF9zcGxpdHMubWFwKHZhbCA9PiBweFJvdW5kKGdldFBvcyh2YWwsIHNjYWxlLCBwbG90RGltLCBwbG90T2ZmKSkpO1xuXG5cdFx0XHRsZXQgX3ZhbHVlcyA9IGF4aXMuX3ZhbHVlcztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBfdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGxldCB2YWwgPSBfdmFsdWVzW2ldO1xuXG5cdFx0XHRcdGlmICh2YWwgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChvcmkgPT0gMClcblx0XHRcdFx0XHRcdHggPSBjYW5PZmZzW2ldO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHkgPSBjYW5PZmZzW2ldO1xuXG5cdFx0XHRcdFx0dmFsID0gXCJcIiArIHZhbDtcblxuXHRcdFx0XHRcdGxldCBfcGFydHMgPSB2YWwuaW5kZXhPZihcIlxcblwiKSA9PSAtMSA/IFt2YWxdIDogdmFsLnNwbGl0KC9cXG4vZ20pO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBfcGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdGxldCB0ZXh0ID0gX3BhcnRzW2pdO1xuXG5cdFx0XHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSh4LCB5ICsgaiAqIGxpbmVIZWlnaHQpOyAvLyBjYW4gdGhpcyBiZSByZXBsYWNlZCB3aXRoIHBvc2l0aW9uIG1hdGg/XG5cdFx0XHRcdFx0XHRcdGN0eC5yb3RhdGUoYW5nbGUpOyAvLyBjYW4gdGhpcyBiZSBkb25lIG9uY2U/XG5cdFx0XHRcdFx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0LCAwLCAwKTtcblx0XHRcdFx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRleHQsIHgsIHkgKyBqICogbGluZUhlaWdodCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRpY2tzXG5cdFx0XHRpZiAodGlja3Muc2hvdykge1xuXHRcdFx0XHRkcmF3T3J0aG9MaW5lcyhcblx0XHRcdFx0XHRjYW5PZmZzLFxuXHRcdFx0XHRcdHRpY2tzLmZpbHRlcihzZWxmLCBzcGxpdHMsIGksIF9zcGFjZSwgaW5jciksXG5cdFx0XHRcdFx0b3JpLFxuXHRcdFx0XHRcdHNpZGUsXG5cdFx0XHRcdFx0YmFzZVBvcyxcblx0XHRcdFx0XHR0aWNrU2l6ZSxcblx0XHRcdFx0XHRyb3VuZERlYyh0aWNrcy53aWR0aCAqIHB4UmF0aW8sIDMpLFxuXHRcdFx0XHRcdHRpY2tzLnN0cm9rZShzZWxmLCBpKSxcblx0XHRcdFx0XHR0aWNrcy5kYXNoLFxuXHRcdFx0XHRcdHRpY2tzLmNhcCxcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZ3JpZFxuXHRcdFx0bGV0IGdyaWQgPSBheGlzLmdyaWQ7XG5cblx0XHRcdGlmIChncmlkLnNob3cpIHtcblx0XHRcdFx0ZHJhd09ydGhvTGluZXMoXG5cdFx0XHRcdFx0Y2FuT2Zmcyxcblx0XHRcdFx0XHRncmlkLmZpbHRlcihzZWxmLCBzcGxpdHMsIGksIF9zcGFjZSwgaW5jciksXG5cdFx0XHRcdFx0b3JpLFxuXHRcdFx0XHRcdG9yaSA9PSAwID8gMiA6IDEsXG5cdFx0XHRcdFx0b3JpID09IDAgPyBwbG90VG9wIDogcGxvdExmdCxcblx0XHRcdFx0XHRvcmkgPT0gMCA/IHBsb3RIZ3QgOiBwbG90V2lkLFxuXHRcdFx0XHRcdHJvdW5kRGVjKGdyaWQud2lkdGggKiBweFJhdGlvLCAzKSxcblx0XHRcdFx0XHRncmlkLnN0cm9rZShzZWxmLCBpKSxcblx0XHRcdFx0XHRncmlkLmRhc2gsXG5cdFx0XHRcdFx0Z3JpZC5jYXAsXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChib3JkZXIuc2hvdykge1xuXHRcdFx0XHRkcmF3T3J0aG9MaW5lcyhcblx0XHRcdFx0XHRbYmFzZVBvc10sXG5cdFx0XHRcdFx0WzFdLFxuXHRcdFx0XHRcdG9yaSA9PSAwID8gMSA6IDAsXG5cdFx0XHRcdFx0b3JpID09IDAgPyAxIDogMixcblx0XHRcdFx0XHRvcmkgPT0gMSA/IHBsb3RUb3AgOiBwbG90TGZ0LFxuXHRcdFx0XHRcdG9yaSA9PSAxID8gcGxvdEhndCA6IHBsb3RXaWQsXG5cdFx0XHRcdFx0cm91bmREZWMoYm9yZGVyLndpZHRoICogcHhSYXRpbywgMyksXG5cdFx0XHRcdFx0Ym9yZGVyLnN0cm9rZShzZWxmLCBpKSxcblx0XHRcdFx0XHRib3JkZXIuZGFzaCxcblx0XHRcdFx0XHRib3JkZXIuY2FwLFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZpcmUoXCJkcmF3QXhlc1wiKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlc2V0WVNlcmllcyhtaW5NYXgpIHtcblx0Ly9cdGxvZyhcInJlc2V0WVNlcmllcygpXCIsIGFyZ3VtZW50cyk7XG5cblx0XHRzZXJpZXMuZm9yRWFjaCgocywgaSkgPT4ge1xuXHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdHMuX3BhdGhzID0gbnVsbDtcblxuXHRcdFx0XHRpZiAobWluTWF4KSB7XG5cdFx0XHRcdFx0aWYgKG1vZGUgPT0gMSkge1xuXHRcdFx0XHRcdFx0cy5taW4gPSBudWxsO1xuXHRcdFx0XHRcdFx0cy5tYXggPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHMuZmFjZXRzLmZvckVhY2goZiA9PiB7XG5cdFx0XHRcdFx0XHRcdGYubWluID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0Zi5tYXggPSBudWxsO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRsZXQgcXVldWVkQ29tbWl0ID0gZmFsc2U7XG5cblx0ZnVuY3Rpb24gY29tbWl0KCkge1xuXHRcdGlmICghcXVldWVkQ29tbWl0KSB7XG5cdFx0XHRtaWNyb1Rhc2soX2NvbW1pdCk7XG5cdFx0XHRxdWV1ZWRDb21taXQgPSB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIF9jb21taXQoKSB7XG5cdC8vXHRsb2coXCJfY29tbWl0KClcIiwgYXJndW1lbnRzKTtcblxuXHRcdGlmIChzaG91bGRTZXRTY2FsZXMpIHtcblx0XHRcdHNldFNjYWxlcygpO1xuXHRcdFx0c2hvdWxkU2V0U2NhbGVzID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKHNob3VsZENvbnZlcmdlU2l6ZSkge1xuXHRcdFx0Y29udmVyZ2VTaXplKCk7XG5cdFx0XHRzaG91bGRDb252ZXJnZVNpemUgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoc2hvdWxkU2V0U2l6ZSkge1xuXHRcdFx0c2V0U3R5bGVQeCh1bmRlciwgTEVGVCwgICBwbG90TGZ0Q3NzKTtcblx0XHRcdHNldFN0eWxlUHgodW5kZXIsIFRPUCwgICAgcGxvdFRvcENzcyk7XG5cdFx0XHRzZXRTdHlsZVB4KHVuZGVyLCBXSURUSCwgIHBsb3RXaWRDc3MpO1xuXHRcdFx0c2V0U3R5bGVQeCh1bmRlciwgSEVJR0hULCBwbG90SGd0Q3NzKTtcblxuXHRcdFx0c2V0U3R5bGVQeChvdmVyLCBMRUZULCAgICBwbG90TGZ0Q3NzKTtcblx0XHRcdHNldFN0eWxlUHgob3ZlciwgVE9QLCAgICAgcGxvdFRvcENzcyk7XG5cdFx0XHRzZXRTdHlsZVB4KG92ZXIsIFdJRFRILCAgIHBsb3RXaWRDc3MpO1xuXHRcdFx0c2V0U3R5bGVQeChvdmVyLCBIRUlHSFQsICBwbG90SGd0Q3NzKTtcblxuXHRcdFx0c2V0U3R5bGVQeCh3cmFwLCBXSURUSCwgICBmdWxsV2lkQ3NzKTtcblx0XHRcdHNldFN0eWxlUHgod3JhcCwgSEVJR0hULCAgZnVsbEhndENzcyk7XG5cblx0XHRcdC8vIE5PVEU6IG11dGF0aW5nIHRoaXMgZHVyaW5nIHByaW50IHByZXZpZXcgaW4gQ2hyb21lIGZvcmNlcyB0cmFuc3BhcmVudFxuXHRcdFx0Ly8gY2FudmFzIHBpeGVscyB0byB3aGl0ZSwgZXZlbiB3aGVuIGZvbGxvd2VkIHVwIHdpdGggY2xlYXJSZWN0KCkgYmVsb3dcblx0XHRcdGNhbi53aWR0aCAgPSByb3VuZChmdWxsV2lkQ3NzICogcHhSYXRpbyk7XG5cdFx0XHRjYW4uaGVpZ2h0ID0gcm91bmQoZnVsbEhndENzcyAqIHB4UmF0aW8pO1xuXG5cdFx0XHRheGVzLmZvckVhY2goKHsgX2VsLCBfc2hvdywgX3NpemUsIF9wb3MsIHNpZGUgfSkgPT4ge1xuXHRcdFx0XHRpZiAoX2VsICE9IG51bGwpIHtcblx0XHRcdFx0XHRpZiAoX3Nob3cpIHtcblx0XHRcdFx0XHRcdGxldCBwb3NPZmZzZXQgPSAoc2lkZSA9PT0gMyB8fCBzaWRlID09PSAwID8gX3NpemUgOiAwKTtcblx0XHRcdFx0XHRcdGxldCBpc1Z0ID0gc2lkZSAlIDIgPT0gMTtcblxuXHRcdFx0XHRcdFx0c2V0U3R5bGVQeChfZWwsIGlzVnQgPyBcImxlZnRcIiAgIDogXCJ0b3BcIiwgICAgX3BvcyAtIHBvc09mZnNldCk7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZVB4KF9lbCwgaXNWdCA/IFwid2lkdGhcIiAgOiBcImhlaWdodFwiLCBfc2l6ZSk7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZVB4KF9lbCwgaXNWdCA/IFwidG9wXCIgICAgOiBcImxlZnRcIiwgICBpc1Z0ID8gcGxvdFRvcENzcyA6IHBsb3RMZnRDc3MpO1xuXHRcdFx0XHRcdFx0c2V0U3R5bGVQeChfZWwsIGlzVnQgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLCAgaXNWdCA/IHBsb3RIZ3RDc3MgOiBwbG90V2lkQ3NzKTtcblxuXHRcdFx0XHRcdFx0cmVtQ2xhc3MoX2VsLCBPRkYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRhZGRDbGFzcyhfZWwsIE9GRik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBpbnZhbGlkYXRlIGN0eCBzdHlsZSBjYWNoZVxuXHRcdFx0Y3R4U3Ryb2tlID0gY3R4RmlsbCA9IGN0eFdpZHRoID0gY3R4Sm9pbiA9IGN0eENhcCA9IGN0eEZvbnQgPSBjdHhBbGlnbiA9IGN0eEJhc2VsaW5lID0gY3R4RGFzaCA9IG51bGw7XG5cdFx0XHRjdHhBbHBoYSA9IDE7XG5cblx0XHRcdHN5bmNSZWN0KHRydWUpO1xuXG5cdFx0XHRmaXJlKFwic2V0U2l6ZVwiKTtcblxuXHRcdFx0c2hvdWxkU2V0U2l6ZSA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChmdWxsV2lkQ3NzID4gMCAmJiBmdWxsSGd0Q3NzID4gMCkge1xuXHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCBjYW4ud2lkdGgsIGNhbi5oZWlnaHQpO1xuXHRcdFx0ZmlyZShcImRyYXdDbGVhclwiKTtcblx0XHRcdGRyYXdPcmRlci5mb3JFYWNoKGZuID0+IGZuKCkpO1xuXHRcdFx0ZmlyZShcImRyYXdcIik7XG5cdFx0fVxuXG5cdC8vXHRpZiAoc2hvdWxkU2V0U2VsZWN0KSB7XG5cdFx0Ly8gVE9ETzogdXBkYXRlIC51LXNlbGVjdCBtZXRyaWNzIChpZiB2aXNpYmxlKVxuXHRcdC8vXHRzZXRTdHlsZVB4KHNlbGVjdERpdiwgVE9QLCBzZWxlY3QudG9wID0gMCk7XG5cdFx0Ly9cdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBMRUZULCBzZWxlY3QubGVmdCA9IDApO1xuXHRcdC8vXHRzZXRTdHlsZVB4KHNlbGVjdERpdiwgV0lEVEgsIHNlbGVjdC53aWR0aCA9IDApO1xuXHRcdC8vXHRzZXRTdHlsZVB4KHNlbGVjdERpdiwgSEVJR0hULCBzZWxlY3QuaGVpZ2h0ID0gMCk7XG5cdFx0Ly9cdHNob3VsZFNldFNlbGVjdCA9IGZhbHNlO1xuXHQvL1x0fVxuXG5cdFx0aWYgKGN1cnNvci5zaG93ICYmIHNob3VsZFNldEN1cnNvcikge1xuXHRcdFx0dXBkYXRlQ3Vyc29yKG51bGwsIHRydWUsIGZhbHNlKTtcblx0XHRcdHNob3VsZFNldEN1cnNvciA9IGZhbHNlO1xuXHRcdH1cblxuXHQvL1x0aWYgKEZFQVRfTEVHRU5EICYmIGxlZ2VuZC5zaG93ICYmIGxlZ2VuZC5saXZlICYmIHNob3VsZFNldExlZ2VuZCkge31cblxuXHRcdGlmICghcmVhZHkpIHtcblx0XHRcdHJlYWR5ID0gdHJ1ZTtcblx0XHRcdHNlbGYuc3RhdHVzID0gMTtcblxuXHRcdFx0ZmlyZShcInJlYWR5XCIpO1xuXHRcdH1cblxuXHRcdHZpYUF1dG9TY2FsZVggPSBmYWxzZTtcblxuXHRcdHF1ZXVlZENvbW1pdCA9IGZhbHNlO1xuXHR9XG5cblx0c2VsZi5yZWRyYXcgPSAocmVidWlsZFBhdGhzLCByZWNhbGNBeGVzKSA9PiB7XG5cdFx0c2hvdWxkQ29udmVyZ2VTaXplID0gcmVjYWxjQXhlcyB8fCBmYWxzZTtcblxuXHRcdGlmIChyZWJ1aWxkUGF0aHMgIT09IGZhbHNlKVxuXHRcdFx0X3NldFNjYWxlKHhTY2FsZUtleSwgc2NhbGVYLm1pbiwgc2NhbGVYLm1heCk7XG5cdFx0ZWxzZVxuXHRcdFx0Y29tbWl0KCk7XG5cdH07XG5cblx0Ly8gcmVkcmF3KCkgPT4gc2V0U2NhbGUoJ3gnLCBzY2FsZXMueC5taW4sIHNjYWxlcy54Lm1heCk7XG5cblx0Ly8gZXhwbGljaXQsIG5ldmVyIHJlLXJhbmdlZCAoaXMgdGhpcyBhY3R1YWxseSB0cnVlPyBmb3IgeCBhbmQgeSlcblx0ZnVuY3Rpb24gc2V0U2NhbGUoa2V5LCBvcHRzKSB7XG5cdFx0bGV0IHNjID0gc2NhbGVzW2tleV07XG5cblx0XHRpZiAoc2MuZnJvbSA9PSBudWxsKSB7XG5cdFx0XHRpZiAoZGF0YUxlbiA9PSAwKSB7XG5cdFx0XHRcdGxldCBtaW5NYXggPSBzYy5yYW5nZShzZWxmLCBvcHRzLm1pbiwgb3B0cy5tYXgsIGtleSk7XG5cdFx0XHRcdG9wdHMubWluID0gbWluTWF4WzBdO1xuXHRcdFx0XHRvcHRzLm1heCA9IG1pbk1heFsxXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdHMubWluID4gb3B0cy5tYXgpIHtcblx0XHRcdFx0bGV0IF9taW4gPSBvcHRzLm1pbjtcblx0XHRcdFx0b3B0cy5taW4gPSBvcHRzLm1heDtcblx0XHRcdFx0b3B0cy5tYXggPSBfbWluO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGF0YUxlbiA+IDEgJiYgb3B0cy5taW4gIT0gbnVsbCAmJiBvcHRzLm1heCAhPSBudWxsICYmIG9wdHMubWF4IC0gb3B0cy5taW4gPCAxZS0xNilcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRpZiAoa2V5ID09IHhTY2FsZUtleSkge1xuXHRcdFx0XHRpZiAoc2MuZGlzdHIgPT0gMiAmJiBkYXRhTGVuID4gMCkge1xuXHRcdFx0XHRcdG9wdHMubWluID0gY2xvc2VzdElkeChvcHRzLm1pbiwgZGF0YVswXSk7XG5cdFx0XHRcdFx0b3B0cy5tYXggPSBjbG9zZXN0SWR4KG9wdHMubWF4LCBkYXRhWzBdKTtcblxuXHRcdFx0XHRcdGlmIChvcHRzLm1pbiA9PSBvcHRzLm1heClcblx0XHRcdFx0XHRcdG9wdHMubWF4Kys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vXHRsb2coXCJzZXRTY2FsZSgpXCIsIGFyZ3VtZW50cyk7XG5cblx0XHRcdHBlbmRTY2FsZXNba2V5XSA9IG9wdHM7XG5cblx0XHRcdHNob3VsZFNldFNjYWxlcyA9IHRydWU7XG5cdFx0XHRjb21taXQoKTtcblx0XHR9XG5cdH1cblxuXHRzZWxmLnNldFNjYWxlID0gc2V0U2NhbGU7XG5cbi8vXHRJTlRFUkFDVElPTlxuXG5cdGxldCB4Q3Vyc29yO1xuXHRsZXQgeUN1cnNvcjtcblx0bGV0IHZDdXJzb3I7XG5cdGxldCBoQ3Vyc29yO1xuXG5cdC8vIHN0YXJ0aW5nIHBvc2l0aW9uIGJlZm9yZSBjdXJzb3IubW92ZVxuXHRsZXQgcmF3TW91c2VMZWZ0MDtcblx0bGV0IHJhd01vdXNlVG9wMDtcblxuXHQvLyBzdGFydGluZyBwb3NpdGlvblxuXHRsZXQgbW91c2VMZWZ0MDtcblx0bGV0IG1vdXNlVG9wMDtcblxuXHQvLyBjdXJyZW50IHBvc2l0aW9uIGJlZm9yZSBjdXJzb3IubW92ZVxuXHRsZXQgcmF3TW91c2VMZWZ0MTtcblx0bGV0IHJhd01vdXNlVG9wMTtcblxuXHQvLyBjdXJyZW50IHBvc2l0aW9uXG5cdGxldCBtb3VzZUxlZnQxO1xuXHRsZXQgbW91c2VUb3AxO1xuXG5cdGxldCBkcmFnZ2luZyA9IGZhbHNlO1xuXG5cdGNvbnN0IGRyYWcgPSBjdXJzb3IuZHJhZztcblxuXHRsZXQgZHJhZ1ggPSBkcmFnLng7XG5cdGxldCBkcmFnWSA9IGRyYWcueTtcblxuXHRpZiAoY3Vyc29yLnNob3cpIHtcblx0XHRpZiAoY3Vyc29yLngpXG5cdFx0XHR4Q3Vyc29yID0gcGxhY2VEaXYoQ1VSU09SX1gsIG92ZXIpO1xuXHRcdGlmIChjdXJzb3IueSlcblx0XHRcdHlDdXJzb3IgPSBwbGFjZURpdihDVVJTT1JfWSwgb3Zlcik7XG5cblx0XHRpZiAoc2NhbGVYLm9yaSA9PSAwKSB7XG5cdFx0XHR2Q3Vyc29yID0geEN1cnNvcjtcblx0XHRcdGhDdXJzb3IgPSB5Q3Vyc29yO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZDdXJzb3IgPSB5Q3Vyc29yO1xuXHRcdFx0aEN1cnNvciA9IHhDdXJzb3I7XG5cdFx0fVxuXG5cdFx0bW91c2VMZWZ0MSA9IGN1cnNvci5sZWZ0O1xuXHRcdG1vdXNlVG9wMSA9IGN1cnNvci50b3A7XG5cdH1cblxuXHRjb25zdCBzZWxlY3QgPSBzZWxmLnNlbGVjdCA9IGFzc2lnbih7XG5cdFx0c2hvdzogICB0cnVlLFxuXHRcdG92ZXI6ICAgdHJ1ZSxcblx0XHRsZWZ0OiAgIDAsXG5cdFx0d2lkdGg6ICAwLFxuXHRcdHRvcDogICAgMCxcblx0XHRoZWlnaHQ6IDAsXG5cdH0sIG9wdHMuc2VsZWN0KTtcblxuXHRjb25zdCBzZWxlY3REaXYgPSBzZWxlY3Quc2hvdyA/IHBsYWNlRGl2KFNFTEVDVCwgc2VsZWN0Lm92ZXIgPyBvdmVyIDogdW5kZXIpIDogbnVsbDtcblxuXHRmdW5jdGlvbiBzZXRTZWxlY3Qob3B0cywgX2ZpcmUpIHtcblx0XHRpZiAoc2VsZWN0LnNob3cpIHtcblx0XHRcdGZvciAobGV0IHByb3AgaW4gb3B0cylcblx0XHRcdFx0c2V0U3R5bGVQeChzZWxlY3REaXYsIHByb3AsIHNlbGVjdFtwcm9wXSA9IG9wdHNbcHJvcF0pO1xuXG5cdFx0XHRfZmlyZSAhPT0gZmFsc2UgJiYgZmlyZShcInNldFNlbGVjdFwiKTtcblx0XHR9XG5cdH1cblxuXHRzZWxmLnNldFNlbGVjdCA9IHNldFNlbGVjdDtcblxuXHRmdW5jdGlvbiB0b2dnbGVET00oaSwgb25PZmYpIHtcblx0XHRsZXQgcyA9IHNlcmllc1tpXTtcblx0XHRsZXQgbGFiZWwgPSBzaG93TGVnZW5kID8gbGVnZW5kUm93c1tpXSA6IG51bGw7XG5cblx0XHRpZiAocy5zaG93KVxuXHRcdFx0bGFiZWwgJiYgcmVtQ2xhc3MobGFiZWwsIE9GRik7XG5cdFx0ZWxzZSB7XG5cdFx0XHRsYWJlbCAmJiBhZGRDbGFzcyhsYWJlbCwgT0ZGKTtcblx0XHRcdGN1cnNvclB0cy5sZW5ndGggPiAxICYmIGVsVHJhbnMoY3Vyc29yUHRzW2ldLCAtMTAsIC0xMCwgcGxvdFdpZENzcywgcGxvdEhndENzcyk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gX3NldFNjYWxlKGtleSwgbWluLCBtYXgpIHtcblx0XHRzZXRTY2FsZShrZXksIHttaW4sIG1heH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0U2VyaWVzKGksIG9wdHMsIF9maXJlLCBfcHViKSB7XG5cdC8vXHRsb2coXCJzZXRTZXJpZXMoKVwiLCBhcmd1bWVudHMpO1xuXG5cdFx0aWYgKG9wdHMuZm9jdXMgIT0gbnVsbClcblx0XHRcdHNldEZvY3VzKGkpO1xuXG5cdFx0aWYgKG9wdHMuc2hvdyAhPSBudWxsKSB7XG5cdFx0XHRzZXJpZXMuZm9yRWFjaCgocywgc2kpID0+IHtcblx0XHRcdFx0aWYgKHNpID4gMCAmJiAoaSA9PSBzaSB8fCBpID09IG51bGwpKSB7XG5cdFx0XHRcdFx0cy5zaG93ID0gb3B0cy5zaG93O1xuXHRcdFx0XHRcdHRvZ2dsZURPTShzaSwgb3B0cy5zaG93KTtcblxuXHRcdFx0XHRcdF9zZXRTY2FsZShtb2RlID09IDIgPyBzLmZhY2V0c1sxXS5zY2FsZSA6IHMuc2NhbGUsIG51bGwsIG51bGwpO1xuXHRcdFx0XHRcdGNvbW1pdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRfZmlyZSAhPT0gZmFsc2UgJiYgZmlyZShcInNldFNlcmllc1wiLCBpLCBvcHRzKTtcblxuXHRcdF9wdWIgJiYgcHViU3luYyhcInNldFNlcmllc1wiLCBzZWxmLCBpLCBvcHRzKTtcblx0fVxuXG5cdHNlbGYuc2V0U2VyaWVzID0gc2V0U2VyaWVzO1xuXG5cdGZ1bmN0aW9uIHNldEJhbmQoYmksIG9wdHMpIHtcblx0XHRhc3NpZ24oYmFuZHNbYmldLCBvcHRzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZEJhbmQob3B0cywgYmkpIHtcblx0XHRvcHRzLmZpbGwgPSBmbk9yU2VsZihvcHRzLmZpbGwgfHwgbnVsbCk7XG5cdFx0b3B0cy5kaXIgPSBpZk51bGwob3B0cy5kaXIsIC0xKTtcblx0XHRiaSA9IGJpID09IG51bGwgPyBiYW5kcy5sZW5ndGggOiBiaTtcblx0XHRiYW5kcy5zcGxpY2UoYmksIDAsIG9wdHMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVsQmFuZChiaSkge1xuXHRcdGlmIChiaSA9PSBudWxsKVxuXHRcdFx0YmFuZHMubGVuZ3RoID0gMDtcblx0XHRlbHNlXG5cdFx0XHRiYW5kcy5zcGxpY2UoYmksIDEpO1xuXHR9XG5cblx0c2VsZi5hZGRCYW5kID0gYWRkQmFuZDtcblx0c2VsZi5zZXRCYW5kID0gc2V0QmFuZDtcblx0c2VsZi5kZWxCYW5kID0gZGVsQmFuZDtcblxuXHRmdW5jdGlvbiBzZXRBbHBoYShpLCB2YWx1ZSkge1xuXHRcdHNlcmllc1tpXS5hbHBoYSA9IHZhbHVlO1xuXG5cdFx0aWYgKGN1cnNvci5zaG93ICYmIGN1cnNvclB0c1tpXSlcblx0XHRcdGN1cnNvclB0c1tpXS5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XG5cblx0XHRpZiAoc2hvd0xlZ2VuZCAmJiBsZWdlbmRSb3dzW2ldKVxuXHRcdFx0bGVnZW5kUm93c1tpXS5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XG5cdH1cblxuXHQvLyB5LWRpc3RhbmNlXG5cdGxldCBjbG9zZXN0RGlzdDtcblx0bGV0IGNsb3Nlc3RTZXJpZXM7XG5cdGxldCBmb2N1c2VkU2VyaWVzO1xuXHRjb25zdCBGT0NVU19UUlVFICA9IHtmb2N1czogdHJ1ZX07XG5cblx0ZnVuY3Rpb24gc2V0Rm9jdXMoaSkge1xuXHRcdGlmIChpICE9IGZvY3VzZWRTZXJpZXMpIHtcblx0XHQvL1x0bG9nKFwic2V0Rm9jdXMoKVwiLCBhcmd1bWVudHMpO1xuXG5cdFx0XHRsZXQgYWxsRm9jdXNlZCA9IGkgPT0gbnVsbDtcblxuXHRcdFx0bGV0IF9zZXRBbHBoYSA9IGZvY3VzLmFscGhhICE9IDE7XG5cblx0XHRcdHNlcmllcy5mb3JFYWNoKChzLCBpMikgPT4ge1xuXHRcdFx0XHRsZXQgaXNGb2N1c2VkID0gYWxsRm9jdXNlZCB8fCBpMiA9PSAwIHx8IGkyID09IGk7XG5cdFx0XHRcdHMuX2ZvY3VzID0gYWxsRm9jdXNlZCA/IG51bGwgOiBpc0ZvY3VzZWQ7XG5cdFx0XHRcdF9zZXRBbHBoYSAmJiBzZXRBbHBoYShpMiwgaXNGb2N1c2VkID8gMSA6IGZvY3VzLmFscGhhKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRmb2N1c2VkU2VyaWVzID0gaTtcblx0XHRcdF9zZXRBbHBoYSAmJiBjb21taXQoKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoc2hvd0xlZ2VuZCAmJiBjdXJzb3JGb2N1cykge1xuXHRcdG9uKG1vdXNlbGVhdmUsIGxlZ2VuZEVsLCBlID0+IHtcblx0XHRcdGlmIChjdXJzb3IuX2xvY2spXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0aWYgKGZvY3VzZWRTZXJpZXMgIT0gbnVsbClcblx0XHRcdFx0c2V0U2VyaWVzKG51bGwsIEZPQ1VTX1RSVUUsIHRydWUsIHN5bmNPcHRzLnNldFNlcmllcyk7XG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBwb3NUb1ZhbChwb3MsIHNjYWxlLCBjYW4pIHtcblx0XHRsZXQgc2MgPSBzY2FsZXNbc2NhbGVdO1xuXG5cdFx0aWYgKGNhbilcblx0XHRcdHBvcyA9IHBvcyAvIHB4UmF0aW8gLSAoc2Mub3JpID09IDEgPyBwbG90VG9wQ3NzIDogcGxvdExmdENzcyk7XG5cblx0XHRsZXQgZGltID0gcGxvdFdpZENzcztcblxuXHRcdGlmIChzYy5vcmkgPT0gMSkge1xuXHRcdFx0ZGltID0gcGxvdEhndENzcztcblx0XHRcdHBvcyA9IGRpbSAtIHBvcztcblx0XHR9XG5cblx0XHRpZiAoc2MuZGlyID09IC0xKVxuXHRcdFx0cG9zID0gZGltIC0gcG9zO1xuXG5cdFx0bGV0IF9taW4gPSBzYy5fbWluLFxuXHRcdFx0X21heCA9IHNjLl9tYXgsXG5cdFx0XHRwY3QgPSBwb3MgLyBkaW07XG5cblx0XHRsZXQgc3YgPSBfbWluICsgKF9tYXggLSBfbWluKSAqIHBjdDtcblxuXHRcdGxldCBkaXN0ciA9IHNjLmRpc3RyO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdGRpc3RyID09IDMgPyBwb3coMTAsIHN2KSA6XG5cdFx0XHRkaXN0ciA9PSA0ID8gc2luaChzdiwgc2MuYXNpbmgpIDpcblx0XHRcdHN2XG5cdFx0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNsb3Nlc3RJZHhGcm9tWHBvcyhwb3MsIGNhbikge1xuXHRcdGxldCB2ID0gcG9zVG9WYWwocG9zLCB4U2NhbGVLZXksIGNhbik7XG5cdFx0cmV0dXJuIGNsb3Nlc3RJZHgodiwgZGF0YVswXSwgaTAsIGkxKTtcblx0fVxuXG5cdHNlbGYudmFsVG9JZHggPSB2YWwgPT4gY2xvc2VzdElkeCh2YWwsIGRhdGFbMF0pO1xuXHRzZWxmLnBvc1RvSWR4ID0gY2xvc2VzdElkeEZyb21YcG9zO1xuXHRzZWxmLnBvc1RvVmFsID0gcG9zVG9WYWw7XG5cdHNlbGYudmFsVG9Qb3MgPSAodmFsLCBzY2FsZSwgY2FuKSA9PiAoXG5cdFx0c2NhbGVzW3NjYWxlXS5vcmkgPT0gMCA/XG5cdFx0Z2V0SFBvcyh2YWwsIHNjYWxlc1tzY2FsZV0sXG5cdFx0XHRjYW4gPyBwbG90V2lkIDogcGxvdFdpZENzcyxcblx0XHRcdGNhbiA/IHBsb3RMZnQgOiAwLFxuXHRcdCkgOlxuXHRcdGdldFZQb3ModmFsLCBzY2FsZXNbc2NhbGVdLFxuXHRcdFx0Y2FuID8gcGxvdEhndCA6IHBsb3RIZ3RDc3MsXG5cdFx0XHRjYW4gPyBwbG90VG9wIDogMCxcblx0XHQpXG5cdCk7XG5cblx0Ly8gZGVmZXJzIGNhbGxpbmcgZXhwZW5zaXZlIGZ1bmN0aW9uc1xuXHRmdW5jdGlvbiBiYXRjaChmbikge1xuXHRcdGZuKHNlbGYpO1xuXHRcdGNvbW1pdCgpO1xuXHR9XG5cblx0c2VsZi5iYXRjaCA9IGJhdGNoO1xuXG5cdChzZWxmLnNldEN1cnNvciA9IChvcHRzLCBfZmlyZSwgX3B1YikgPT4ge1xuXHRcdG1vdXNlTGVmdDEgPSBvcHRzLmxlZnQ7XG5cdFx0bW91c2VUb3AxID0gb3B0cy50b3A7XG5cdC8vXHRhc3NpZ24oY3Vyc29yLCBvcHRzKTtcblx0XHR1cGRhdGVDdXJzb3IobnVsbCwgX2ZpcmUsIF9wdWIpO1xuXHR9KTtcblxuXHRmdW5jdGlvbiBzZXRTZWxIKG9mZiwgZGltKSB7XG5cdFx0c2V0U3R5bGVQeChzZWxlY3REaXYsIExFRlQsICBzZWxlY3QubGVmdCA9IG9mZik7XG5cdFx0c2V0U3R5bGVQeChzZWxlY3REaXYsIFdJRFRILCBzZWxlY3Qud2lkdGggPSBkaW0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0U2VsVihvZmYsIGRpbSkge1xuXHRcdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBUT1AsICAgIHNlbGVjdC50b3AgPSBvZmYpO1xuXHRcdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBIRUlHSFQsIHNlbGVjdC5oZWlnaHQgPSBkaW0pO1xuXHR9XG5cblx0bGV0IHNldFNlbFggPSBzY2FsZVgub3JpID09IDAgPyBzZXRTZWxIIDogc2V0U2VsVjtcblx0bGV0IHNldFNlbFkgPSBzY2FsZVgub3JpID09IDEgPyBzZXRTZWxIIDogc2V0U2VsVjtcblxuXHRmdW5jdGlvbiBzeW5jTGVnZW5kKCkge1xuXHRcdGlmIChzaG93TGVnZW5kICYmIGxlZ2VuZC5saXZlKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gbW9kZSA9PSAyID8gMSA6IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGkgPT0gMCAmJiBtdWx0aVZhbExlZ2VuZClcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRsZXQgdmFscyA9IGxlZ2VuZC52YWx1ZXNbaV07XG5cblx0XHRcdFx0bGV0IGogPSAwO1xuXG5cdFx0XHRcdGZvciAobGV0IGsgaW4gdmFscylcblx0XHRcdFx0XHRsZWdlbmRDZWxsc1tpXVtqKytdLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdmFsc1trXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRMZWdlbmQob3B0cywgX2ZpcmUpIHtcblx0XHRpZiAob3B0cyAhPSBudWxsKSB7XG5cdFx0XHRsZXQgaWR4ID0gb3B0cy5pZHg7XG5cblx0XHRcdGxlZ2VuZC5pZHggPSBpZHg7XG5cdFx0XHRzZXJpZXMuZm9yRWFjaCgocywgc2lkeCkgPT4ge1xuXHRcdFx0XHQoc2lkeCA+IDAgfHwgIW11bHRpVmFsTGVnZW5kKSAmJiBzZXRMZWdlbmRWYWx1ZXMoc2lkeCwgaWR4KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChzaG93TGVnZW5kICYmIGxlZ2VuZC5saXZlKVxuXHRcdFx0c3luY0xlZ2VuZCgpO1xuXG5cdFx0c2hvdWxkU2V0TGVnZW5kID0gZmFsc2U7XG5cblx0XHRfZmlyZSAhPT0gZmFsc2UgJiYgZmlyZShcInNldExlZ2VuZFwiKTtcblx0fVxuXG5cdHNlbGYuc2V0TGVnZW5kID0gc2V0TGVnZW5kO1xuXG5cdGZ1bmN0aW9uIHNldExlZ2VuZFZhbHVlcyhzaWR4LCBpZHgpIHtcblx0XHRsZXQgdmFsO1xuXG5cdFx0aWYgKGlkeCA9PSBudWxsKVxuXHRcdFx0dmFsID0gTlVMTF9MRUdFTkRfVkFMVUVTO1xuXHRcdGVsc2Uge1xuXHRcdFx0bGV0IHMgPSBzZXJpZXNbc2lkeF07XG5cdFx0XHRsZXQgc3JjID0gc2lkeCA9PSAwICYmIHhTY2FsZURpc3RyID09IDIgPyBkYXRhMCA6IGRhdGFbc2lkeF07XG5cdFx0XHR2YWwgPSBtdWx0aVZhbExlZ2VuZCA/IHMudmFsdWVzKHNlbGYsIHNpZHgsIGlkeCkgOiB7Xzogcy52YWx1ZShzZWxmLCBzcmNbaWR4XSwgc2lkeCwgaWR4KX07XG5cdFx0fVxuXG5cdFx0bGVnZW5kLnZhbHVlc1tzaWR4XSA9IHZhbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUN1cnNvcihzcmMsIF9maXJlLCBfcHViKSB7XG5cdC8vXHR0cyA9PSBudWxsICYmIGxvZyhcInVwZGF0ZUN1cnNvcigpXCIsIGFyZ3VtZW50cyk7XG5cblx0XHRyYXdNb3VzZUxlZnQxID0gbW91c2VMZWZ0MTtcblx0XHRyYXdNb3VzZVRvcDEgPSBtb3VzZVRvcDE7XG5cblx0XHRbbW91c2VMZWZ0MSwgbW91c2VUb3AxXSA9IGN1cnNvci5tb3ZlKHNlbGYsIG1vdXNlTGVmdDEsIG1vdXNlVG9wMSk7XG5cblx0XHRpZiAoY3Vyc29yLnNob3cpIHtcblx0XHRcdHZDdXJzb3IgJiYgZWxUcmFucyh2Q3Vyc29yLCByb3VuZChtb3VzZUxlZnQxKSwgMCwgcGxvdFdpZENzcywgcGxvdEhndENzcyk7XG5cdFx0XHRoQ3Vyc29yICYmIGVsVHJhbnMoaEN1cnNvciwgMCwgcm91bmQobW91c2VUb3AxKSwgcGxvdFdpZENzcywgcGxvdEhndENzcyk7XG5cdFx0fVxuXG5cdFx0bGV0IGlkeDtcblxuXHRcdC8vIHdoZW4gem9vbWluZyB0byBhbiB4IHNjYWxlIHJhbmdlIGJldHdlZW4gZGF0YXBvaW50cyB0aGUgYmluYXJ5IHNlYXJjaFxuXHRcdC8vIGZvciBuZWFyZXN0IG1pbi9tYXggaW5kaWNlcyByZXN1bHRzIGluIHRoaXMgY29uZGl0aW9uLiBjaGVhcCBoYWNrIDpEXG5cdFx0bGV0IG5vRGF0YUluUmFuZ2UgPSBpMCA+IGkxOyAvLyB3b3JrcyBmb3IgbW9kZSAxIG9ubHlcblxuXHRcdGNsb3Nlc3REaXN0ID0gaW5mO1xuXG5cdFx0Ly8gVE9ETzogZXh0cmFjdFxuXHRcdGxldCB4RGltID0gc2NhbGVYLm9yaSA9PSAwID8gcGxvdFdpZENzcyA6IHBsb3RIZ3RDc3M7XG5cdFx0bGV0IHlEaW0gPSBzY2FsZVgub3JpID09IDEgPyBwbG90V2lkQ3NzIDogcGxvdEhndENzcztcblxuXHRcdC8vIGlmIGN1cnNvciBoaWRkZW4sIGhpZGUgcG9pbnRzICYgY2xlYXIgbGVnZW5kIHZhbHNcblx0XHRpZiAobW91c2VMZWZ0MSA8IDAgfHwgZGF0YUxlbiA9PSAwIHx8IG5vRGF0YUluUmFuZ2UpIHtcblx0XHRcdGlkeCA9IG51bGw7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChpID4gMCkge1xuXHRcdFx0XHRcdGN1cnNvclB0cy5sZW5ndGggPiAxICYmIGVsVHJhbnMoY3Vyc29yUHRzW2ldLCAtMTAsIC0xMCwgcGxvdFdpZENzcywgcGxvdEhndENzcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGN1cnNvckZvY3VzKVxuXHRcdFx0XHRzZXRTZXJpZXMobnVsbCwgRk9DVVNfVFJVRSwgdHJ1ZSwgc3JjID09IG51bGwgJiYgc3luY09wdHMuc2V0U2VyaWVzKTtcblxuXHRcdFx0aWYgKGxlZ2VuZC5saXZlKSB7XG5cdFx0XHRcdGFjdGl2ZUlkeHMuZmlsbChudWxsKTtcblx0XHRcdFx0c2hvdWxkU2V0TGVnZW5kID0gdHJ1ZTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKylcblx0XHRcdFx0XHRsZWdlbmQudmFsdWVzW2ldID0gTlVMTF9MRUdFTkRfVkFMVUVTO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHQvL1x0bGV0IHBjdFkgPSAxIC0gKHkgLyByZWN0LmhlaWdodCk7XG5cblx0XHRcdGxldCBtb3VzZVhQb3MsIHZhbEF0UG9zWCwgeFBvcztcblxuXHRcdFx0aWYgKG1vZGUgPT0gMSkge1xuXHRcdFx0XHRtb3VzZVhQb3MgPSBzY2FsZVgub3JpID09IDAgPyBtb3VzZUxlZnQxIDogbW91c2VUb3AxO1xuXHRcdFx0XHR2YWxBdFBvc1ggPSBwb3NUb1ZhbChtb3VzZVhQb3MsIHhTY2FsZUtleSk7XG5cdFx0XHRcdGlkeCA9IGNsb3Nlc3RJZHgodmFsQXRQb3NYLCBkYXRhWzBdLCBpMCwgaTEpO1xuXHRcdFx0XHR4UG9zID0gaW5jclJvdW5kVXAodmFsVG9Qb3NYKGRhdGFbMF1baWR4XSwgc2NhbGVYLCB4RGltLCAwKSwgMC41KTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChsZXQgaSA9IG1vZGUgPT0gMiA/IDEgOiAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGxldCBzID0gc2VyaWVzW2ldO1xuXG5cdFx0XHRcdGxldCBpZHgxICA9IGFjdGl2ZUlkeHNbaV07XG5cdFx0XHRcdGxldCB5VmFsMSA9IG1vZGUgPT0gMSA/IGRhdGFbaV1baWR4MV0gOiBkYXRhW2ldWzFdW2lkeDFdO1xuXG5cdFx0XHRcdGxldCBpZHgyICA9IGN1cnNvci5kYXRhSWR4KHNlbGYsIGksIGlkeCwgdmFsQXRQb3NYKTtcblx0XHRcdFx0bGV0IHlWYWwyID0gbW9kZSA9PSAxID8gZGF0YVtpXVtpZHgyXSA6IGRhdGFbaV1bMV1baWR4Ml07XG5cblx0XHRcdFx0c2hvdWxkU2V0TGVnZW5kID0gc2hvdWxkU2V0TGVnZW5kIHx8IHlWYWwyICE9IHlWYWwxIHx8IGlkeDIgIT0gaWR4MTtcblxuXHRcdFx0XHRhY3RpdmVJZHhzW2ldID0gaWR4MjtcblxuXHRcdFx0XHRsZXQgeFBvczIgPSBpZHgyID09IGlkeCA/IHhQb3MgOiBpbmNyUm91bmRVcCh2YWxUb1Bvc1gobW9kZSA9PSAxID8gZGF0YVswXVtpZHgyXSA6IGRhdGFbaV1bMF1baWR4Ml0sIHNjYWxlWCwgeERpbSwgMCksIDAuNSk7XG5cblx0XHRcdFx0aWYgKGkgPiAwICYmIHMuc2hvdykge1xuXHRcdFx0XHRcdGxldCB5UG9zID0geVZhbDIgPT0gbnVsbCA/IC0xMCA6IGluY3JSb3VuZFVwKHZhbFRvUG9zWSh5VmFsMiwgbW9kZSA9PSAxID8gc2NhbGVzW3Muc2NhbGVdIDogc2NhbGVzW3MuZmFjZXRzWzFdLnNjYWxlXSwgeURpbSwgMCksIDAuNSk7XG5cblx0XHRcdFx0XHRpZiAoeVBvcyA+IDAgJiYgbW9kZSA9PSAxKSB7XG5cdFx0XHRcdFx0XHRsZXQgZGlzdCA9IGFicyh5UG9zIC0gbW91c2VUb3AxKTtcblxuXHRcdFx0XHRcdFx0aWYgKGRpc3QgPD0gY2xvc2VzdERpc3QpIHtcblx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3QgPSBkaXN0O1xuXHRcdFx0XHRcdFx0XHRjbG9zZXN0U2VyaWVzID0gaTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsZXQgaFBvcywgdlBvcztcblxuXHRcdFx0XHRcdGlmIChzY2FsZVgub3JpID09IDApIHtcblx0XHRcdFx0XHRcdGhQb3MgPSB4UG9zMjtcblx0XHRcdFx0XHRcdHZQb3MgPSB5UG9zO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGhQb3MgPSB5UG9zO1xuXHRcdFx0XHRcdFx0dlBvcyA9IHhQb3MyO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChzaG91bGRTZXRMZWdlbmQgJiYgY3Vyc29yUHRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRcdGVsQ29sb3IoY3Vyc29yUHRzW2ldLCBjdXJzb3IucG9pbnRzLmZpbGwoc2VsZiwgaSksIGN1cnNvci5wb2ludHMuc3Ryb2tlKHNlbGYsIGkpKTtcblxuXHRcdFx0XHRcdFx0bGV0IHB0V2lkLCBwdEhndCwgcHRMZnQsIHB0VG9wLFxuXHRcdFx0XHRcdFx0XHRjZW50ZXJlZCA9IHRydWUsXG5cdFx0XHRcdFx0XHRcdGdldEJCb3ggPSBjdXJzb3IucG9pbnRzLmJib3g7XG5cblx0XHRcdFx0XHRcdGlmIChnZXRCQm94ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0Y2VudGVyZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0XHRsZXQgYmJveCA9IGdldEJCb3goc2VsZiwgaSk7XG5cblx0XHRcdFx0XHRcdFx0cHRMZnQgPSBiYm94LmxlZnQ7XG5cdFx0XHRcdFx0XHRcdHB0VG9wID0gYmJveC50b3A7XG5cdFx0XHRcdFx0XHRcdHB0V2lkID0gYmJveC53aWR0aDtcblx0XHRcdFx0XHRcdFx0cHRIZ3QgPSBiYm94LmhlaWdodDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwdExmdCA9IGhQb3M7XG5cdFx0XHRcdFx0XHRcdHB0VG9wID0gdlBvcztcblx0XHRcdFx0XHRcdFx0cHRXaWQgPSBwdEhndCA9IGN1cnNvci5wb2ludHMuc2l6ZShzZWxmLCBpKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZWxTaXplKGN1cnNvclB0c1tpXSwgcHRXaWQsIHB0SGd0LCBjZW50ZXJlZCk7XG5cdFx0XHRcdFx0XHRlbFRyYW5zKGN1cnNvclB0c1tpXSwgcHRMZnQsIHB0VG9wLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobGVnZW5kLmxpdmUpIHtcblx0XHRcdFx0XHRpZiAoIXNob3VsZFNldExlZ2VuZCB8fCBpID09IDAgJiYgbXVsdGlWYWxMZWdlbmQpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdHNldExlZ2VuZFZhbHVlcyhpLCBpZHgyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGN1cnNvci5pZHggPSBpZHg7XG5cdFx0Y3Vyc29yLmxlZnQgPSBtb3VzZUxlZnQxO1xuXHRcdGN1cnNvci50b3AgPSBtb3VzZVRvcDE7XG5cblx0XHRpZiAoc2hvdWxkU2V0TGVnZW5kKSB7XG5cdFx0XHRsZWdlbmQuaWR4ID0gaWR4O1xuXHRcdFx0c2V0TGVnZW5kKCk7XG5cdFx0fVxuXG5cdFx0Ly8gbml0OiBjdXJzb3IuZHJhZy5zZXRTZWxlY3QgaXMgYXNzdW1lZCBhbHdheXMgdHJ1ZVxuXHRcdGlmIChzZWxlY3Quc2hvdyAmJiBkcmFnZ2luZykge1xuXHRcdFx0aWYgKHNyYyAhPSBudWxsKSB7XG5cdFx0XHRcdGxldCBbeEtleSwgeUtleV0gPSBzeW5jT3B0cy5zY2FsZXM7XG5cdFx0XHRcdGxldCBbbWF0Y2hYS2V5cywgbWF0Y2hZS2V5c10gPSBzeW5jT3B0cy5tYXRjaDtcblx0XHRcdFx0bGV0IFt4S2V5U3JjLCB5S2V5U3JjXSA9IHNyYy5jdXJzb3Iuc3luYy5zY2FsZXM7XG5cblx0XHRcdFx0Ly8gbWF0Y2ggdGhlIGRyYWdYL2RyYWdZIGltcGxpY2l0bmVzcy9leHBsaWNpdG5lc3Mgb2Ygc3JjXG5cdFx0XHRcdGxldCBzZHJhZyA9IHNyYy5jdXJzb3IuZHJhZztcblx0XHRcdFx0ZHJhZ1ggPSBzZHJhZy5feDtcblx0XHRcdFx0ZHJhZ1kgPSBzZHJhZy5feTtcblxuXHRcdFx0XHRpZiAoZHJhZ1ggfHwgZHJhZ1kpIHtcblx0XHRcdFx0XHRsZXQgeyBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgfSA9IHNyYy5zZWxlY3Q7XG5cblx0XHRcdFx0XHRsZXQgc29yaSA9IHNyYy5zY2FsZXNbeEtleV0ub3JpO1xuXHRcdFx0XHRcdGxldCBzUG9zVG9WYWwgPSBzcmMucG9zVG9WYWw7XG5cblx0XHRcdFx0XHRsZXQgc09mZiwgc0RpbSwgc2MsIGEsIGI7XG5cblx0XHRcdFx0XHRsZXQgbWF0Y2hpbmdYID0geEtleSAhPSBudWxsICYmIG1hdGNoWEtleXMoeEtleSwgeEtleVNyYyk7XG5cdFx0XHRcdFx0bGV0IG1hdGNoaW5nWSA9IHlLZXkgIT0gbnVsbCAmJiBtYXRjaFlLZXlzKHlLZXksIHlLZXlTcmMpO1xuXG5cdFx0XHRcdFx0aWYgKG1hdGNoaW5nWCAmJiBkcmFnWCkge1xuXHRcdFx0XHRcdFx0aWYgKHNvcmkgPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRzT2ZmID0gbGVmdDtcblx0XHRcdFx0XHRcdFx0c0RpbSA9IHdpZHRoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNPZmYgPSB0b3A7XG5cdFx0XHRcdFx0XHRcdHNEaW0gPSBoZWlnaHQ7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHNjID0gc2NhbGVzW3hLZXldO1xuXG5cdFx0XHRcdFx0XHRhID0gdmFsVG9Qb3NYKHNQb3NUb1ZhbChzT2ZmLCB4S2V5U3JjKSwgICAgICAgIHNjLCB4RGltLCAwKTtcblx0XHRcdFx0XHRcdGIgPSB2YWxUb1Bvc1goc1Bvc1RvVmFsKHNPZmYgKyBzRGltLCB4S2V5U3JjKSwgc2MsIHhEaW0sIDApO1xuXG5cdFx0XHRcdFx0XHRzZXRTZWxYKG1pbihhLGIpLCBhYnMoYi1hKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHNldFNlbFgoMCwgeERpbSk7XG5cblx0XHRcdFx0XHRpZiAobWF0Y2hpbmdZICYmIGRyYWdZKSB7XG5cdFx0XHRcdFx0XHRpZiAoc29yaSA9PSAxKSB7XG5cdFx0XHRcdFx0XHRcdHNPZmYgPSBsZWZ0O1xuXHRcdFx0XHRcdFx0XHRzRGltID0gd2lkdGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0c09mZiA9IHRvcDtcblx0XHRcdFx0XHRcdFx0c0RpbSA9IGhlaWdodDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c2MgPSBzY2FsZXNbeUtleV07XG5cblx0XHRcdFx0XHRcdGEgPSB2YWxUb1Bvc1koc1Bvc1RvVmFsKHNPZmYsIHlLZXlTcmMpLCAgICAgICAgc2MsIHlEaW0sIDApO1xuXHRcdFx0XHRcdFx0YiA9IHZhbFRvUG9zWShzUG9zVG9WYWwoc09mZiArIHNEaW0sIHlLZXlTcmMpLCBzYywgeURpbSwgMCk7XG5cblx0XHRcdFx0XHRcdHNldFNlbFkobWluKGEsYiksIGFicyhiLWEpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0c2V0U2VsWSgwLCB5RGltKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0aGlkZVNlbGVjdCgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCByYXdEWCA9IGFicyhyYXdNb3VzZUxlZnQxIC0gcmF3TW91c2VMZWZ0MCk7XG5cdFx0XHRcdGxldCByYXdEWSA9IGFicyhyYXdNb3VzZVRvcDEgLSByYXdNb3VzZVRvcDApO1xuXG5cdFx0XHRcdGlmIChzY2FsZVgub3JpID09IDEpIHtcblx0XHRcdFx0XHRsZXQgX3Jhd0RYID0gcmF3RFg7XG5cdFx0XHRcdFx0cmF3RFggPSByYXdEWTtcblx0XHRcdFx0XHRyYXdEWSA9IF9yYXdEWDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRyYWdYID0gZHJhZy54ICYmIHJhd0RYID49IGRyYWcuZGlzdDtcblx0XHRcdFx0ZHJhZ1kgPSBkcmFnLnkgJiYgcmF3RFkgPj0gZHJhZy5kaXN0O1xuXG5cdFx0XHRcdGxldCB1bmkgPSBkcmFnLnVuaTtcblxuXHRcdFx0XHRpZiAodW5pICE9IG51bGwpIHtcblx0XHRcdFx0XHQvLyBvbmx5IGNhbGMgZHJhZyBzdGF0dXMgaWYgdGhleSBwYXNzIHRoZSBkaXN0IHRocmVzaFxuXHRcdFx0XHRcdGlmIChkcmFnWCAmJiBkcmFnWSkge1xuXHRcdFx0XHRcdFx0ZHJhZ1ggPSByYXdEWCA+PSB1bmk7XG5cdFx0XHRcdFx0XHRkcmFnWSA9IHJhd0RZID49IHVuaTtcblxuXHRcdFx0XHRcdFx0Ly8gZm9yY2UgdW5pZGlyZWN0aW9uYWxpdHkgd2hlbiBib3RoIGFyZSB1bmRlciB1bmkgbGltaXRcblx0XHRcdFx0XHRcdGlmICghZHJhZ1ggJiYgIWRyYWdZKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChyYXdEWSA+IHJhd0RYKVxuXHRcdFx0XHRcdFx0XHRcdGRyYWdZID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdGRyYWdYID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoZHJhZy54ICYmIGRyYWcueSAmJiAoZHJhZ1ggfHwgZHJhZ1kpKVxuXHRcdFx0XHRcdC8vIGlmIG9tbmkgd2l0aCBubyB1bmkgdGhlbiBib3RoIGRyYWdYIC8gZHJhZ1kgc2hvdWxkIGJlIHRydWUgaWYgZWl0aGVyIGlzIHRydWVcblx0XHRcdFx0XHRkcmFnWCA9IGRyYWdZID0gdHJ1ZTtcblxuXHRcdFx0XHRsZXQgcDAsIHAxO1xuXG5cdFx0XHRcdGlmIChkcmFnWCkge1xuXHRcdFx0XHRcdGlmIChzY2FsZVgub3JpID09IDApIHtcblx0XHRcdFx0XHRcdHAwID0gbW91c2VMZWZ0MDtcblx0XHRcdFx0XHRcdHAxID0gbW91c2VMZWZ0MTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRwMCA9IG1vdXNlVG9wMDtcblx0XHRcdFx0XHRcdHAxID0gbW91c2VUb3AxO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNldFNlbFgobWluKHAwLCBwMSksIGFicyhwMSAtIHAwKSk7XG5cblx0XHRcdFx0XHRpZiAoIWRyYWdZKVxuXHRcdFx0XHRcdFx0c2V0U2VsWSgwLCB5RGltKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkcmFnWSkge1xuXHRcdFx0XHRcdGlmIChzY2FsZVgub3JpID09IDEpIHtcblx0XHRcdFx0XHRcdHAwID0gbW91c2VMZWZ0MDtcblx0XHRcdFx0XHRcdHAxID0gbW91c2VMZWZ0MTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRwMCA9IG1vdXNlVG9wMDtcblx0XHRcdFx0XHRcdHAxID0gbW91c2VUb3AxO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNldFNlbFkobWluKHAwLCBwMSksIGFicyhwMSAtIHAwKSk7XG5cblx0XHRcdFx0XHRpZiAoIWRyYWdYKVxuXHRcdFx0XHRcdFx0c2V0U2VsWCgwLCB4RGltKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHRoZSBkcmFnIGRpZG4ndCBwYXNzIHRoZSBkaXN0IHJlcXVpcmVtZW50XG5cdFx0XHRcdGlmICghZHJhZ1ggJiYgIWRyYWdZKSB7XG5cdFx0XHRcdFx0c2V0U2VsWCgwLCAwKTtcblx0XHRcdFx0XHRzZXRTZWxZKDAsIDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZHJhZy5feCA9IGRyYWdYO1xuXHRcdGRyYWcuX3kgPSBkcmFnWTtcblxuXHRcdGlmIChzcmMgPT0gbnVsbCkge1xuXHRcdFx0aWYgKF9wdWIpIHtcblx0XHRcdFx0aWYgKHN5bmNLZXkgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGxldCBbeFN5bmNLZXksIHlTeW5jS2V5XSA9IHN5bmNPcHRzLnNjYWxlcztcblxuXHRcdFx0XHRcdHN5bmNPcHRzLnZhbHVlc1swXSA9IHhTeW5jS2V5ICE9IG51bGwgPyBwb3NUb1ZhbChzY2FsZVgub3JpID09IDAgPyBtb3VzZUxlZnQxIDogbW91c2VUb3AxLCB4U3luY0tleSkgOiBudWxsO1xuXHRcdFx0XHRcdHN5bmNPcHRzLnZhbHVlc1sxXSA9IHlTeW5jS2V5ICE9IG51bGwgPyBwb3NUb1ZhbChzY2FsZVgub3JpID09IDEgPyBtb3VzZUxlZnQxIDogbW91c2VUb3AxLCB5U3luY0tleSkgOiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cHViU3luYyhtb3VzZW1vdmUsIHNlbGYsIG1vdXNlTGVmdDEsIG1vdXNlVG9wMSwgcGxvdFdpZENzcywgcGxvdEhndENzcywgaWR4KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGN1cnNvckZvY3VzKSB7XG5cdFx0XHRcdGxldCBzaG91bGRQdWIgPSBfcHViICYmIHN5bmNPcHRzLnNldFNlcmllcztcblx0XHRcdFx0bGV0IHAgPSBmb2N1cy5wcm94O1xuXG5cdFx0XHRcdGlmIChmb2N1c2VkU2VyaWVzID09IG51bGwpIHtcblx0XHRcdFx0XHRpZiAoY2xvc2VzdERpc3QgPD0gcClcblx0XHRcdFx0XHRcdHNldFNlcmllcyhjbG9zZXN0U2VyaWVzLCBGT0NVU19UUlVFLCB0cnVlLCBzaG91bGRQdWIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmIChjbG9zZXN0RGlzdCA+IHApXG5cdFx0XHRcdFx0XHRzZXRTZXJpZXMobnVsbCwgRk9DVVNfVFJVRSwgdHJ1ZSwgc2hvdWxkUHViKTtcblx0XHRcdFx0XHRlbHNlIGlmIChjbG9zZXN0U2VyaWVzICE9IGZvY3VzZWRTZXJpZXMpXG5cdFx0XHRcdFx0XHRzZXRTZXJpZXMoY2xvc2VzdFNlcmllcywgRk9DVVNfVFJVRSwgdHJ1ZSwgc2hvdWxkUHViKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJlYWR5ICYmIF9maXJlICE9PSBmYWxzZSAmJiBmaXJlKFwic2V0Q3Vyc29yXCIpO1xuXHR9XG5cblx0bGV0IHJlY3QgPSBudWxsO1xuXG5cdGZ1bmN0aW9uIHN5bmNSZWN0KGRlZmVyKSB7XG5cdFx0aWYgKGRlZmVyID09PSB0cnVlKVxuXHRcdFx0cmVjdCA9IG51bGw7XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZWN0ID0gb3Zlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdGZpcmUoXCJzeW5jUmVjdFwiLCByZWN0KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBtb3VzZU1vdmUoZSwgc3JjLCBfbCwgX3QsIF93LCBfaCwgX2kpIHtcblx0XHRpZiAoY3Vyc29yLl9sb2NrKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Y2FjaGVNb3VzZShlLCBzcmMsIF9sLCBfdCwgX3csIF9oLCBfaSwgZmFsc2UsIGUgIT0gbnVsbCk7XG5cblx0XHRpZiAoZSAhPSBudWxsKVxuXHRcdFx0dXBkYXRlQ3Vyc29yKG51bGwsIHRydWUsIHRydWUpO1xuXHRcdGVsc2Vcblx0XHRcdHVwZGF0ZUN1cnNvcihzcmMsIHRydWUsIGZhbHNlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNhY2hlTW91c2UoZSwgc3JjLCBfbCwgX3QsIF93LCBfaCwgX2ksIGluaXRpYWwsIHNuYXApIHtcblx0XHRpZiAocmVjdCA9PSBudWxsKVxuXHRcdFx0c3luY1JlY3QoZmFsc2UpO1xuXG5cdFx0aWYgKGUgIT0gbnVsbCkge1xuXHRcdFx0X2wgPSBlLmNsaWVudFggLSByZWN0LmxlZnQ7XG5cdFx0XHRfdCA9IGUuY2xpZW50WSAtIHJlY3QudG9wO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmIChfbCA8IDAgfHwgX3QgPCAwKSB7XG5cdFx0XHRcdG1vdXNlTGVmdDEgPSAtMTA7XG5cdFx0XHRcdG1vdXNlVG9wMSA9IC0xMDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgW3hLZXksIHlLZXldID0gc3luY09wdHMuc2NhbGVzO1xuXG5cdFx0XHRsZXQgc3luY09wdHNTcmMgPSBzcmMuY3Vyc29yLnN5bmM7XG5cdFx0XHRsZXQgW3hWYWxTcmMsIHlWYWxTcmNdID0gc3luY09wdHNTcmMudmFsdWVzO1xuXHRcdFx0bGV0IFt4S2V5U3JjLCB5S2V5U3JjXSA9IHN5bmNPcHRzU3JjLnNjYWxlcztcblx0XHRcdGxldCBbbWF0Y2hYS2V5cywgbWF0Y2hZS2V5c10gPSBzeW5jT3B0cy5tYXRjaDtcblxuXHRcdFx0bGV0IHJvdFNyYyA9IHNyYy5heGVzWzBdLnNpZGUgJSAyID09IDE7XG5cblx0XHRcdGxldCB4RGltID0gc2NhbGVYLm9yaSA9PSAwID8gcGxvdFdpZENzcyA6IHBsb3RIZ3RDc3MsXG5cdFx0XHRcdHlEaW0gPSBzY2FsZVgub3JpID09IDEgPyBwbG90V2lkQ3NzIDogcGxvdEhndENzcyxcblx0XHRcdFx0X3hEaW0gPSByb3RTcmMgPyBfaCA6IF93LFxuXHRcdFx0XHRfeURpbSA9IHJvdFNyYyA/IF93IDogX2gsXG5cdFx0XHRcdF94UG9zID0gcm90U3JjID8gX3QgOiBfbCxcblx0XHRcdFx0X3lQb3MgPSByb3RTcmMgPyBfbCA6IF90O1xuXG5cdFx0XHRpZiAoeEtleVNyYyAhPSBudWxsKVxuXHRcdFx0XHRfbCA9IG1hdGNoWEtleXMoeEtleSwgeEtleVNyYykgPyBnZXRQb3MoeFZhbFNyYywgc2NhbGVzW3hLZXldLCB4RGltLCAwKSA6IC0xMDtcblx0XHRcdGVsc2Vcblx0XHRcdFx0X2wgPSB4RGltICogKF94UG9zL194RGltKTtcblxuXHRcdFx0aWYgKHlLZXlTcmMgIT0gbnVsbClcblx0XHRcdFx0X3QgPSBtYXRjaFlLZXlzKHlLZXksIHlLZXlTcmMpID8gZ2V0UG9zKHlWYWxTcmMsIHNjYWxlc1t5S2V5XSwgeURpbSwgMCkgOiAtMTA7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdF90ID0geURpbSAqIChfeVBvcy9feURpbSk7XG5cblx0XHRcdGlmIChzY2FsZVgub3JpID09IDEpIHtcblx0XHRcdFx0bGV0IF9fbCA9IF9sO1xuXHRcdFx0XHRfbCA9IF90O1xuXHRcdFx0XHRfdCA9IF9fbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoc25hcCkge1xuXHRcdFx0aWYgKF9sIDw9IDEgfHwgX2wgPj0gcGxvdFdpZENzcyAtIDEpXG5cdFx0XHRcdF9sID0gaW5jclJvdW5kKF9sLCBwbG90V2lkQ3NzKTtcblxuXHRcdFx0aWYgKF90IDw9IDEgfHwgX3QgPj0gcGxvdEhndENzcyAtIDEpXG5cdFx0XHRcdF90ID0gaW5jclJvdW5kKF90LCBwbG90SGd0Q3NzKTtcblx0XHR9XG5cblx0XHRpZiAoaW5pdGlhbCkge1xuXHRcdFx0cmF3TW91c2VMZWZ0MCA9IF9sO1xuXHRcdFx0cmF3TW91c2VUb3AwID0gX3Q7XG5cblx0XHRcdFttb3VzZUxlZnQwLCBtb3VzZVRvcDBdID0gY3Vyc29yLm1vdmUoc2VsZiwgX2wsIF90KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRtb3VzZUxlZnQxID0gX2w7XG5cdFx0XHRtb3VzZVRvcDEgPSBfdDtcblx0XHR9XG5cdH1cblxuXHRjb25zdCBfaGlkZVByb3BzID0ge1xuXHRcdHdpZHRoOiAwLFxuXHRcdGhlaWdodDogMCxcblx0fTtcblxuXHRmdW5jdGlvbiBoaWRlU2VsZWN0KCkge1xuXHRcdHNldFNlbGVjdChfaGlkZVByb3BzLCBmYWxzZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBtb3VzZURvd24oZSwgc3JjLCBfbCwgX3QsIF93LCBfaCwgX2kpIHtcblx0XHRkcmFnZ2luZyA9IHRydWU7XG5cdFx0ZHJhZ1ggPSBkcmFnWSA9IGRyYWcuX3ggPSBkcmFnLl95ID0gZmFsc2U7XG5cblx0XHRjYWNoZU1vdXNlKGUsIHNyYywgX2wsIF90LCBfdywgX2gsIF9pLCB0cnVlLCBmYWxzZSk7XG5cblx0XHRpZiAoZSAhPSBudWxsKSB7XG5cdFx0XHRvbk1vdXNlKG1vdXNldXAsIGRvYywgbW91c2VVcCk7XG5cdFx0XHRwdWJTeW5jKG1vdXNlZG93biwgc2VsZiwgbW91c2VMZWZ0MCwgbW91c2VUb3AwLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzLCBudWxsKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBtb3VzZVVwKGUsIHNyYywgX2wsIF90LCBfdywgX2gsIF9pKSB7XG5cdFx0ZHJhZ2dpbmcgPSBkcmFnLl94ID0gZHJhZy5feSA9IGZhbHNlO1xuXG5cdFx0Y2FjaGVNb3VzZShlLCBzcmMsIF9sLCBfdCwgX3csIF9oLCBfaSwgZmFsc2UsIHRydWUpO1xuXG5cdFx0bGV0IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH0gPSBzZWxlY3Q7XG5cblx0XHRsZXQgaGFzU2VsZWN0ID0gd2lkdGggPiAwIHx8IGhlaWdodCA+IDA7XG5cblx0XHRoYXNTZWxlY3QgJiYgc2V0U2VsZWN0KHNlbGVjdCk7XG5cblx0XHRpZiAoZHJhZy5zZXRTY2FsZSAmJiBoYXNTZWxlY3QpIHtcblx0XHQvL1x0aWYgKHN5bmNLZXkgIT0gbnVsbCkge1xuXHRcdC8vXHRcdGRyYWdYID0gZHJhZy54O1xuXHRcdC8vXHRcdGRyYWdZID0gZHJhZy55O1xuXHRcdC8vXHR9XG5cblx0XHRcdGxldCB4T2ZmID0gbGVmdCxcblx0XHRcdFx0eERpbSA9IHdpZHRoLFxuXHRcdFx0XHR5T2ZmID0gdG9wLFxuXHRcdFx0XHR5RGltID0gaGVpZ2h0O1xuXG5cdFx0XHRpZiAoc2NhbGVYLm9yaSA9PSAxKSB7XG5cdFx0XHRcdHhPZmYgPSB0b3AsXG5cdFx0XHRcdHhEaW0gPSBoZWlnaHQsXG5cdFx0XHRcdHlPZmYgPSBsZWZ0LFxuXHRcdFx0XHR5RGltID0gd2lkdGg7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkcmFnWCkge1xuXHRcdFx0XHRfc2V0U2NhbGUoeFNjYWxlS2V5LFxuXHRcdFx0XHRcdHBvc1RvVmFsKHhPZmYsIHhTY2FsZUtleSksXG5cdFx0XHRcdFx0cG9zVG9WYWwoeE9mZiArIHhEaW0sIHhTY2FsZUtleSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRyYWdZKSB7XG5cdFx0XHRcdGZvciAobGV0IGsgaW4gc2NhbGVzKSB7XG5cdFx0XHRcdFx0bGV0IHNjID0gc2NhbGVzW2tdO1xuXG5cdFx0XHRcdFx0aWYgKGsgIT0geFNjYWxlS2V5ICYmIHNjLmZyb20gPT0gbnVsbCAmJiBzYy5taW4gIT0gaW5mKSB7XG5cdFx0XHRcdFx0XHRfc2V0U2NhbGUoayxcblx0XHRcdFx0XHRcdFx0cG9zVG9WYWwoeU9mZiArIHlEaW0sIGspLFxuXHRcdFx0XHRcdFx0XHRwb3NUb1ZhbCh5T2ZmLCBrKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aGlkZVNlbGVjdCgpO1xuXHRcdH1cblx0XHRlbHNlIGlmIChjdXJzb3IubG9jaykge1xuXHRcdFx0Y3Vyc29yLl9sb2NrID0gIWN1cnNvci5fbG9jaztcblxuXHRcdFx0aWYgKCFjdXJzb3IuX2xvY2spXG5cdFx0XHRcdHVwZGF0ZUN1cnNvcihudWxsLCB0cnVlLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGUgIT0gbnVsbCkge1xuXHRcdFx0b2ZmTW91c2UobW91c2V1cCwgZG9jKTtcblx0XHRcdHB1YlN5bmMobW91c2V1cCwgc2VsZiwgbW91c2VMZWZ0MSwgbW91c2VUb3AxLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzLCBudWxsKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBtb3VzZUxlYXZlKGUsIHNyYywgX2wsIF90LCBfdywgX2gsIF9pKSB7XG5cdFx0aWYgKCFjdXJzb3IuX2xvY2spIHtcblx0XHRcdGxldCBfZHJhZ2dpbmcgPSBkcmFnZ2luZztcblxuXHRcdFx0aWYgKGRyYWdnaW5nKSB7XG5cdFx0XHRcdC8vIGhhbmRsZSBjYXNlIHdoZW4gbW91c2Vtb3ZlIGFyZW4ndCBmaXJlZCBhbGwgdGhlIHdheSB0byBlZGdlcyBieSBicm93c2VyXG5cdFx0XHRcdGxldCBzbmFwSCA9IHRydWU7XG5cdFx0XHRcdGxldCBzbmFwViA9IHRydWU7XG5cdFx0XHRcdGxldCBzbmFwUHJveCA9IDEwO1xuXG5cdFx0XHRcdGxldCBkcmFnSCwgZHJhZ1Y7XG5cblx0XHRcdFx0aWYgKHNjYWxlWC5vcmkgPT0gMCkge1xuXHRcdFx0XHRcdGRyYWdIID0gZHJhZ1g7XG5cdFx0XHRcdFx0ZHJhZ1YgPSBkcmFnWTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRkcmFnSCA9IGRyYWdZO1xuXHRcdFx0XHRcdGRyYWdWID0gZHJhZ1g7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZHJhZ0ggJiYgZHJhZ1YpIHtcblx0XHRcdFx0XHQvLyBtYXliZSBvbW5pIGNvcm5lciBzbmFwXG5cdFx0XHRcdFx0c25hcEggPSBtb3VzZUxlZnQxIDw9IHNuYXBQcm94IHx8IG1vdXNlTGVmdDEgPj0gcGxvdFdpZENzcyAtIHNuYXBQcm94O1xuXHRcdFx0XHRcdHNuYXBWID0gbW91c2VUb3AxICA8PSBzbmFwUHJveCB8fCBtb3VzZVRvcDEgID49IHBsb3RIZ3RDc3MgLSBzbmFwUHJveDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkcmFnSCAmJiBzbmFwSClcblx0XHRcdFx0XHRtb3VzZUxlZnQxID0gbW91c2VMZWZ0MSA8IG1vdXNlTGVmdDAgPyAwIDogcGxvdFdpZENzcztcblxuXHRcdFx0XHRpZiAoZHJhZ1YgJiYgc25hcFYpXG5cdFx0XHRcdFx0bW91c2VUb3AxID0gbW91c2VUb3AxIDwgbW91c2VUb3AwID8gMCA6IHBsb3RIZ3RDc3M7XG5cblx0XHRcdFx0dXBkYXRlQ3Vyc29yKG51bGwsIHRydWUsIHRydWUpO1xuXG5cdFx0XHRcdGRyYWdnaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdG1vdXNlTGVmdDEgPSAtMTA7XG5cdFx0XHRtb3VzZVRvcDEgPSAtMTA7XG5cblx0XHRcdC8vIHBhc3NpbmcgYSBub24tbnVsbCB0aW1lc3RhbXAgdG8gZm9yY2Ugc3luYy9tb3VzZW1vdmUgZXZlbnRcblx0XHRcdHVwZGF0ZUN1cnNvcihudWxsLCB0cnVlLCB0cnVlKTtcblxuXHRcdFx0aWYgKF9kcmFnZ2luZylcblx0XHRcdFx0ZHJhZ2dpbmcgPSBfZHJhZ2dpbmc7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZGJsQ2xpY2soZSwgc3JjLCBfbCwgX3QsIF93LCBfaCwgX2kpIHtcblx0XHRhdXRvU2NhbGVYKCk7XG5cblx0XHRoaWRlU2VsZWN0KCk7XG5cblx0XHRpZiAoZSAhPSBudWxsKVxuXHRcdFx0cHViU3luYyhkYmxjbGljaywgc2VsZiwgbW91c2VMZWZ0MSwgbW91c2VUb3AxLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzLCBudWxsKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHN5bmNQeFJhdGlvKCkge1xuXHRcdGF4ZXMuZm9yRWFjaChzeW5jRm9udFNpemUpO1xuXHRcdF9zZXRTaXplKHNlbGYud2lkdGgsIHNlbGYuaGVpZ2h0LCB0cnVlKTtcblx0fVxuXG5cdG9uKGRwcHhjaGFuZ2UsIHdpbiwgc3luY1B4UmF0aW8pO1xuXG5cdC8vIGludGVybmFsIHB1Yi9zdWJcblx0Y29uc3QgZXZlbnRzID0ge307XG5cblx0ZXZlbnRzLm1vdXNlZG93biA9IG1vdXNlRG93bjtcblx0ZXZlbnRzLm1vdXNlbW92ZSA9IG1vdXNlTW92ZTtcblx0ZXZlbnRzLm1vdXNldXAgPSBtb3VzZVVwO1xuXHRldmVudHMuZGJsY2xpY2sgPSBkYmxDbGljaztcblx0ZXZlbnRzW1wic2V0U2VyaWVzXCJdID0gKGUsIHNyYywgaWR4LCBvcHRzKSA9PiB7XG5cdFx0c2V0U2VyaWVzKGlkeCwgb3B0cywgdHJ1ZSwgZmFsc2UpO1xuXHR9O1xuXG5cdGlmIChjdXJzb3Iuc2hvdykge1xuXHRcdG9uTW91c2UobW91c2Vkb3duLCAgb3ZlciwgbW91c2VEb3duKTtcblx0XHRvbk1vdXNlKG1vdXNlbW92ZSwgIG92ZXIsIG1vdXNlTW92ZSk7XG5cdFx0b25Nb3VzZShtb3VzZWVudGVyLCBvdmVyLCBzeW5jUmVjdCk7XG5cdFx0b25Nb3VzZShtb3VzZWxlYXZlLCBvdmVyLCBtb3VzZUxlYXZlKTtcblxuXHRcdG9uTW91c2UoZGJsY2xpY2ssIG92ZXIsIGRibENsaWNrKTtcblxuXHRcdGN1cnNvclBsb3RzLmFkZChzZWxmKTtcblxuXHRcdHNlbGYuc3luY1JlY3QgPSBzeW5jUmVjdDtcblx0fVxuXG5cdC8vIGV4dGVybmFsIG9uL29mZlxuXHRjb25zdCBob29rcyA9IHNlbGYuaG9va3MgPSBvcHRzLmhvb2tzIHx8IHt9O1xuXG5cdGZ1bmN0aW9uIGZpcmUoZXZOYW1lLCBhMSwgYTIpIHtcblx0XHRpZiAoZXZOYW1lIGluIGhvb2tzKSB7XG5cdFx0XHRob29rc1tldk5hbWVdLmZvckVhY2goZm4gPT4ge1xuXHRcdFx0XHRmbi5jYWxsKG51bGwsIHNlbGYsIGExLCBhMik7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQob3B0cy5wbHVnaW5zIHx8IFtdKS5mb3JFYWNoKHAgPT4ge1xuXHRcdGZvciAobGV0IGV2TmFtZSBpbiBwLmhvb2tzKVxuXHRcdFx0aG9va3NbZXZOYW1lXSA9IChob29rc1tldk5hbWVdIHx8IFtdKS5jb25jYXQocC5ob29rc1tldk5hbWVdKTtcblx0fSk7XG5cblx0Y29uc3Qgc3luY09wdHMgPSBhc3NpZ24oe1xuXHRcdGtleTogbnVsbCxcblx0XHRzZXRTZXJpZXM6IGZhbHNlLFxuXHRcdGZpbHRlcnM6IHtcblx0XHRcdHB1YjogcmV0VHJ1ZSxcblx0XHRcdHN1YjogcmV0VHJ1ZSxcblx0XHR9LFxuXHRcdHNjYWxlczogW3hTY2FsZUtleSwgc2VyaWVzWzFdID8gc2VyaWVzWzFdLnNjYWxlIDogbnVsbF0sXG5cdFx0bWF0Y2g6IFtyZXRFcSwgcmV0RXFdLFxuXHRcdHZhbHVlczogW251bGwsIG51bGxdLFxuXHR9LCBjdXJzb3Iuc3luYyk7XG5cblx0KGN1cnNvci5zeW5jID0gc3luY09wdHMpO1xuXG5cdGNvbnN0IHN5bmNLZXkgPSBzeW5jT3B0cy5rZXk7XG5cblx0Y29uc3Qgc3luYyA9IF9zeW5jKHN5bmNLZXkpO1xuXG5cdGZ1bmN0aW9uIHB1YlN5bmModHlwZSwgc3JjLCB4LCB5LCB3LCBoLCBpKSB7XG5cdFx0aWYgKHN5bmNPcHRzLmZpbHRlcnMucHViKHR5cGUsIHNyYywgeCwgeSwgdywgaCwgaSkpXG5cdFx0XHRzeW5jLnB1Yih0eXBlLCBzcmMsIHgsIHksIHcsIGgsIGkpO1xuXHR9XG5cblx0c3luYy5zdWIoc2VsZik7XG5cblx0ZnVuY3Rpb24gcHViKHR5cGUsIHNyYywgeCwgeSwgdywgaCwgaSkge1xuXHRcdGlmIChzeW5jT3B0cy5maWx0ZXJzLnN1Yih0eXBlLCBzcmMsIHgsIHksIHcsIGgsIGkpKVxuXHRcdFx0ZXZlbnRzW3R5cGVdKG51bGwsIHNyYywgeCwgeSwgdywgaCwgaSk7XG5cdH1cblxuXHQoc2VsZi5wdWIgPSBwdWIpO1xuXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0c3luYy51bnN1YihzZWxmKTtcblx0XHRjdXJzb3JQbG90cy5kZWxldGUoc2VsZik7XG5cdFx0bW91c2VMaXN0ZW5lcnMuY2xlYXIoKTtcblx0XHRvZmYoZHBweGNoYW5nZSwgd2luLCBzeW5jUHhSYXRpbyk7XG5cdFx0cm9vdC5yZW1vdmUoKTtcblx0XHRmaXJlKFwiZGVzdHJveVwiKTtcblx0fVxuXG5cdHNlbGYuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0ZnVuY3Rpb24gX2luaXQoKSB7XG5cdFx0ZmlyZShcImluaXRcIiwgb3B0cywgZGF0YSk7XG5cblx0XHRzZXREYXRhKGRhdGEgfHwgb3B0cy5kYXRhLCBmYWxzZSk7XG5cblx0XHRpZiAocGVuZFNjYWxlc1t4U2NhbGVLZXldKVxuXHRcdFx0c2V0U2NhbGUoeFNjYWxlS2V5LCBwZW5kU2NhbGVzW3hTY2FsZUtleV0pO1xuXHRcdGVsc2Vcblx0XHRcdGF1dG9TY2FsZVgoKTtcblxuXHRcdF9zZXRTaXplKG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcblxuXHRcdHVwZGF0ZUN1cnNvcihudWxsLCB0cnVlLCBmYWxzZSk7XG5cblx0XHRzZXRTZWxlY3Qoc2VsZWN0LCBmYWxzZSk7XG5cdH1cblxuXHRzZXJpZXMuZm9yRWFjaChpbml0U2VyaWVzKTtcblxuXHRheGVzLmZvckVhY2goaW5pdEF4aXMpO1xuXG5cdGlmICh0aGVuKSB7XG5cdFx0aWYgKHRoZW4gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuXHRcdFx0dGhlbi5hcHBlbmRDaGlsZChyb290KTtcblx0XHRcdF9pbml0KCk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHRcdHRoZW4oc2VsZiwgX2luaXQpO1xuXHR9XG5cdGVsc2Vcblx0XHRfaW5pdCgpO1xuXG5cdHJldHVybiBzZWxmO1xufVxuXG51UGxvdC5hc3NpZ24gPSBhc3NpZ247XG51UGxvdC5mbXROdW0gPSBmbXROdW07XG51UGxvdC5yYW5nZU51bSA9IHJhbmdlTnVtO1xudVBsb3QucmFuZ2VMb2cgPSByYW5nZUxvZztcbnVQbG90LnJhbmdlQXNpbmggPSByYW5nZUFzaW5oO1xudVBsb3Qub3JpZW50ICAgPSBvcmllbnQ7XG51UGxvdC5weFJhdGlvID0gcHhSYXRpbztcblxue1xuXHR1UGxvdC5qb2luID0gam9pbjtcbn1cblxue1xuXHR1UGxvdC5mbXREYXRlID0gZm10RGF0ZTtcblx0dVBsb3QudHpEYXRlICA9IHR6RGF0ZTtcbn1cblxue1xuXHR1UGxvdC5zeW5jID0gX3N5bmM7XG59XG5cbntcblx0dVBsb3QuYWRkR2FwID0gYWRkR2FwO1xuXHR1UGxvdC5jbGlwR2FwcyA9IGNsaXBHYXBzO1xuXG5cdGxldCBwYXRocyA9IHVQbG90LnBhdGhzID0ge1xuXHRcdHBvaW50cyxcblx0fTtcblxuXHQocGF0aHMubGluZWFyICA9IGxpbmVhcik7XG5cdChwYXRocy5zdGVwcGVkID0gc3RlcHBlZCk7XG5cdChwYXRocy5iYXJzICAgID0gYmFycyk7XG5cdChwYXRocy5zcGxpbmUgID0gbW9ub3RvbmVDdWJpYyk7XG59XG5cbmV4cG9ydCB7IHVQbG90IGFzIGRlZmF1bHQgfTtcbiIsICIvLyBpbXBvcnQgX2NzcyBmcm9tICd1cGxvdC9kaXN0L3VQbG90Lm1pbi5jc3MnXG5pbXBvcnQgdVBsb3QgZnJvbSBcInVwbG90XCJcblxubGV0IENoYXJ0SG9vayA9IHtcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLnRyYWRlcyA9IFtdO1xuICAgIHRoaXMucGxvdCA9IG5ldyB1UGxvdChwbG90T3B0aW9ucygpLCBbW10sIFtdXSwgdGhpcy5lbCk7XG4gIH0sXG4gIHVwZGF0ZWQoKSB7XG4gICAgbGV0IHByaWNlID0gcGFyc2VGbG9hdCh0aGlzLmVsLmRhdGFzZXQucHJpY2UpLFxuICAgICAgdGltZXN0YW1wID0gcGFyc2VJbnQodGhpcy5lbC5kYXRhc2V0LnRyYWRlZEF0KVxuXG4gICAgdGhpcy50cmFkZXMucHVzaCh7XG4gICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCwgcHJpY2U6IHByaWNlXG4gICAgfSk7XG5cbiAgICBpZih0aGlzLnRyYWRlcy5sZW5ndGggPiAyMCkge1xuICAgICAgdGhpcy50cmFkZXMuc3BsaWNlKDAsIDEpXG4gICAgfVxuICAgIHRoaXMudXBkYXRlQ2hhcnQoKVxuICB9LFxuXG4gIHVwZGF0ZUNoYXJ0KCkge1xuICAgIGxldCB4ID0gdGhpcy50cmFkZXMubWFwKHQgPT4gdC50aW1lc3RhbXApO1xuICAgIGxldCB5ID0gdGhpcy50cmFkZXMubWFwKHQgPT4gdC5wcmljZSk7XG4gICAgdGhpcy5wbG90LnNldERhdGEoW3gsIHldKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwbG90T3B0aW9ucygpIHtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogMjAwLCBoZWlnaHQ6IDgwLCBcbiAgICBjbGFzczogXCJjaGFydC1jb250YWluZXJcIixcbiAgICBjdXJzb3I6IHtzaG93OiBmYWxzZX0sIFxuICAgIHNlbGVjdDoge3Nob3c6IGZhbHNlfSwgXG4gICAgbGVnZW5kOiB7c2hvdzogZmFsc2V9LFxuICAgIHNjYWxlczoge30sXG4gICAgYXhlczogW1xuICAgICAge3Nob3c6IGZhbHNlfSxcbiAgICAgIHtzaG93OiBmYWxzZX1cbiAgICBdLFxuICAgIHNlcmllczogW1xuICAgICAge30sXG4gICAgICB7XG4gICAgICAgIHNpemU6IDAsXG4gICAgICAgIHdpZHRoOiAyLFxuICAgICAgICBzdHJva2U6IFwid2hpdGVcIixcbiAgICAgICAgZmlsbDogXCJyZ2IoNDUsODUsMTUwKVwiLFxuICAgICAgfSxcbiAgICBdLFxuICB9O1xufVxuXG5leHBvcnQgeyBDaGFydEhvb2sgfSJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQU1BLE1BQUMsVUFBVSxTQUFRLFdBQVU7QUFDM0I7QUFHQSxRQUFDLFlBQVk7QUFDWCxjQUFJLFdBQVc7QUFDZixjQUFJLFVBQVUsQ0FBQyxNQUFNLE9BQU8sVUFBVSxHQUFHO0FBQ3pDLG1CQUFTLElBQUksR0FBRyxJQUFJLFFBQVEsVUFBVSxDQUFDLFFBQU8sdUJBQXVCLEVBQUUsR0FBRztBQUN4RSxvQkFBTyx3QkFDTCxRQUFPLFFBQVEsS0FBSztBQUN0QixvQkFBTyx1QkFDTCxRQUFPLFFBQVEsS0FBSywyQkFDcEIsUUFBTyxRQUFRLEtBQUs7QUFBQSxVQUN4QjtBQUNBLGNBQUksQ0FBQyxRQUFPO0FBQ1Ysb0JBQU8sd0JBQXdCLFNBQVUsVUFBVSxTQUFTO0FBQzFELGtCQUFJLFdBQVcsSUFBSSxLQUFLLEVBQUUsUUFBUTtBQUNsQyxrQkFBSSxhQUFhLEtBQUssSUFBSSxHQUFHLEtBQU0sWUFBVyxTQUFTO0FBQ3ZELGtCQUFJLEtBQUssUUFBTyxXQUFXLFdBQVk7QUFDckMseUJBQVMsV0FBVyxVQUFVO0FBQUEsY0FDaEMsR0FBRyxVQUFVO0FBQ2IseUJBQVcsV0FBVztBQUN0QixxQkFBTztBQUFBLFlBQ1Q7QUFDRixjQUFJLENBQUMsUUFBTztBQUNWLG9CQUFPLHVCQUF1QixTQUFVLElBQUk7QUFDMUMsMkJBQWEsRUFBRTtBQUFBLFlBQ2pCO0FBQUEsUUFDSixHQUFHO0FBRUgsWUFBSSxRQUNGLGlCQUNBLGFBQ0EsaUJBQ0EsU0FDQSxXQUFXLFNBQVUs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
